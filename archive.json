{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2021-04-13T19:39:33.456826+00:00",
  "repo": "WICG/webpackage",
  "labels": [
    {
      "name": "bug",
      "description": null,
      "color": "ee0701"
    },
    {
      "name": "duplicate",
      "description": null,
      "color": "cccccc"
    },
    {
      "name": "feature request",
      "description": "",
      "color": "84b6eb"
    },
    {
      "name": "help wanted",
      "description": "Community members should chime in with your opinions.",
      "color": "128A0C"
    },
    {
      "name": "go",
      "description": "",
      "color": "fbca04"
    },
    {
      "name": "bundled-exchanges",
      "description": "",
      "color": "bfdadc"
    },
    {
      "name": "Pending Security + Privacy Review",
      "description": "",
      "color": "ccf280"
    },
    {
      "name": "needs spec",
      "description": "The issue has agreement, but someone needs to add it to the specification.",
      "color": "ce9cf4"
    },
    {
      "name": "discuss",
      "description": "Needs a verbal or face-to-face discussion",
      "color": "bc6c2b"
    },
    {
      "name": "consider closing",
      "description": "",
      "color": "ffe9c9"
    },
    {
      "name": "architecture",
      "description": "Big design questions that need to be figured out.",
      "color": "73d4ef"
    },
    {
      "name": "documentation",
      "description": "Tech writers wanted!",
      "color": "6f35b7"
    },
    {
      "name": "i18n-tracker",
      "description": "Group bringing to attention of Internationalization, or tracked by i18n but not needing response.",
      "color": "F9C9FF"
    },
    {
      "name": "i18n-needs-resolution",
      "description": "Issue the Internationalization Group has raised and looks for a response on.",
      "color": "F9C9FF"
    },
    {
      "name": "privacy-tracker",
      "description": "Group bringing to attention of Privacy, or tracked by the Privacy Group but not needing response.",
      "color": "d4af37"
    },
    {
      "name": "privacy-needs-resolution",
      "description": "Issue the Privacy Group has raised and looks for a response on.",
      "color": "d4af37"
    },
    {
      "name": "security-tracker",
      "description": "Group bringing to attention of security, or tracked by the security Group but not needing response.",
      "color": "ffff00"
    },
    {
      "name": "security-needs-resolution",
      "description": "Issue the security Group has raised and looks for a response on.",
      "color": "ffff00"
    },
    {
      "name": "a11y-tracker",
      "description": "Group bringing to attention of a11y, or tracked by the a11y Group but not needing response.",
      "color": "ea7472"
    },
    {
      "name": "a11y-needs-resolution",
      "description": "Issue the Accessibility Group has raised and looks for a response on.",
      "color": "ea7472"
    },
    {
      "name": "tag-tracker",
      "description": "Group bringing to attention of the TAG, or tracked by the TAG but not needing response.",
      "color": "7fff00"
    },
    {
      "name": "tag-needs-resolution",
      "description": "Issue the Technical Architecture Group has raised and looks for a response on.",
      "color": "7fff00"
    },
    {
      "name": "subresource-loading",
      "description": "",
      "color": "73D6DA"
    }
  ],
  "issues": [
    {
      "number": 2,
      "id": "MDU6SXNzdWUxODk4MjcwNTU=",
      "title": "Interfacing with Resource Hints and link rel=preload.",
      "url": "https://github.com/WICG/webpackage/issues/2",
      "state": "CLOSED",
      "author": "addyosmani",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Something unclear reading through the current proposal is how a developer would hint that some resources in a web package have a higher priority to fetch (e.g via resource hints) than others - the entire package would be fetched with a single priority. If I want to prefetch or preload certain assets, I'm unsure how those systems interface with packages.\r\n\r\nAre there any thoughts about this?",
      "createdAt": "2016-11-16T20:03:18Z",
      "updatedAt": "2017-01-09T16:38:05Z",
      "closedAt": "2017-01-09T16:38:05Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@addyosmani I'm not sure that is possible under current text since it is a single non-multiplexed body for the payload. You might want to put the prioritized resources at the start of the package body. I would be interested more in having multiple streams like http/2 does if you want to interleave resources and/or change priorities dynamically.",
          "createdAt": "2016-12-02T16:37:03Z",
          "updatedAt": "2017-01-09T16:29:29Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@addyosmani after a call, it should be possible to re-order signed content resources as long as a Package-Signature and Content-Index can be recomputed by the server. The server could re-order them into a more optimal order. Might be a good idea to move the discussion to https://github.com/dimich-g/webpackage/issues/11 since that is going to be covering reordering. Is this ok to close?",
          "createdAt": "2016-12-29T19:27:07Z",
          "updatedAt": "2016-12-29T19:27:07Z"
        },
        {
          "author": "addyosmani",
          "authorAssociation": "NONE",
          "body": "Let's close this one up. Thanks for the replies, @bmeck! ",
          "createdAt": "2017-01-09T16:38:04Z",
          "updatedAt": "2017-01-09T16:38:04Z"
        }
      ]
    },
    {
      "number": 3,
      "id": "MDU6SXNzdWUxOTAwNzk5MzY=",
      "title": "relationship to DPUB",
      "url": "https://github.com/WICG/webpackage/issues/3",
      "state": "CLOSED",
      "author": "TzviyaSiegman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Very happy to see Packaging reconsidered. The Digital Publishing IG considered this as well. Please see http://w3c.github.io/dpub-pwp-ucr/index.html for our use cases and requirements. We are also looking at Web App Manifest (https://w3c.github.io/manifest/) as a potential mechanism. Our goals are very similar, so it would be helpful to discuss and find common ground. ",
      "createdAt": "2016-11-17T15:34:29Z",
      "updatedAt": "2017-01-13T19:54:47Z",
      "closedAt": "2017-01-13T19:54:47Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@TzviyaSiegman it seems possible to place a Web App Manifest within a WebPackage since it is just a JSON file referenced by a `<link>` in HTML. On a glance it seems possible that the \"Packaged Web Publication\" standard distribution format could be WebPackage for DPUB, however I don't have the breadth of knowledge to say with 100% certainty that the pagination requirement would be related to WebPackage itself (that may be left up to the contents of individual resources within the package).",
          "createdAt": "2016-12-29T15:51:04Z",
          "updatedAt": "2016-12-29T15:51:04Z"
        },
        {
          "author": "dauwhe",
          "authorAssociation": "NONE",
          "body": "I've been experimenting with using web packages for publications. I put up an example at https://github.com/dauwhe/acme-labs/blob/gh-pages/MobyDick/MobyDick.pod (there's a tradition in the ebook community to use Moby Dick as a sample book). It's just a bunch of HTML files, etc. with a web app manifest. I've attempted a content index but have no idea how to figure out byte offsets, etc.\r\n\r\nOur interest in this is largely due to security concerns. Signing a bundle of web content could help solve the origin problem for portable publications. \r\n\r\nI would expect no dependency on pagination. That's a matter for CSS :)",
          "createdAt": "2017-01-05T14:51:48Z",
          "updatedAt": "2017-01-05T14:51:48Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@dauwhe - cool, thanks!  You will need to write a \"packager\" in order to get all the correct offsets (either that or a hex editor and patience :)).\r\n\r\nSigning the bundle is actually a small part of the solution for two security concerns for portable publications.  It doesn't actually get you an origin - since I could potentially resign your package and therefore \"reorigin\" it, which isn't what a professional publisher would want (and may indeed break the content).  But more importantly, it's actually the verification process (or specifically the establishment of trust) that we need in the publication realm..",
          "createdAt": "2017-01-05T20:38:20Z",
          "updatedAt": "2017-01-05T20:38:20Z"
        },
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm working on a golang packager script (in the \"go/\" directory) that will eventually support content-index and signatures.  Stay tuned!  I think a verifier is also a great tool to keep in this repo as well.",
          "createdAt": "2017-01-05T23:06:13Z",
          "updatedAt": "2017-01-05T23:06:13Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@TzviyaSiegman is this clear / ok to close?",
          "createdAt": "2017-01-13T03:33:36Z",
          "updatedAt": "2017-01-13T03:33:36Z"
        },
        {
          "author": "iherman",
          "authorAssociation": "NONE",
          "body": "@bmeck , @TzviyaSiegman is currently on a maternity leave. I think this issue was raised more as a FYI, and more specific technical problems were discussed on more specific issues. I think it is o.k.  to close this issue.\r\n\r\n@lrosenthol @dauwhe : what do you think?",
          "createdAt": "2017-01-13T03:54:05Z",
          "updatedAt": "2017-01-13T03:54:05Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Yes, fine to close by me.  We will raise other issues as we get to that\npoint in our development of DPUB\n\nOn Thu, Jan 12, 2017 at 10:54 PM, Ivan Herman <notifications@github.com>\nwrote:\n\n> @bmeck <https://github.com/bmeck> , @TzviyaSiegman\n> <https://github.com/TzviyaSiegman> is currently on a maternity leave. I\n> think this issue was raised more as a FYI, and more specific technical\n> problems were discussed on more specific issues. I think it is o.k. to\n> close this issue.\n>\n> @lrosenthol <https://github.com/lrosenthol> @dauwhe\n> <https://github.com/dauwhe> : what do you think?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/3#issuecomment-272354894>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNcUT6vET_BMrgc9-VX4mI2W1CiFuks5rRvVegaJpZM4K1cp1>\n> .\n>\n",
          "createdAt": "2017-01-13T12:56:22Z",
          "updatedAt": "2017-01-13T12:56:22Z"
        }
      ]
    },
    {
      "number": 6,
      "id": "MDU6SXNzdWUxOTAxMzExNzc=",
      "title": "Streaming not supported",
      "url": "https://github.com/WICG/webpackage/issues/6",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "One of the reasons that the [packaging on the web](https://w3ctag.github.io/packaging-on-the-web/) spec chose to avoid ZIP in favor of something new & different was due to the (perceived) lack of streaming support.\r\n\r\nHowever, this proposal suffers from the same problem.  You cannot create it entirely in stream, due to (a) the way that offsets are used and (b) the index file needing to list all other files.\r\n\r\nIf streaming is not a requirement for this format - that's fine.  But then, that should also be called out in the spec.",
      "createdAt": "2016-11-17T18:50:47Z",
      "updatedAt": "2017-03-30T03:05:56Z",
      "closedAt": "2017-03-30T03:05:56Z",
      "comments": [
        {
          "author": "addyosmani",
          "authorAssociation": "NONE",
          "body": "I would also like to get some clarity around how packaging interfaces with streaming (even if it's a non-goal for the first version).\n",
          "createdAt": "2016-11-17T19:43:23Z",
          "updatedAt": "2016-11-17T19:43:23Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Streaming is important and very much the goal, just as for the [packaging on the web](https://w3ctag.github.io/packaging-on-the-web/) effort that  you mention. I should have clarified that more (I will add to the Explainer, with corresponding example).\n\nThe idea is that there are two major use cases - streaming and 'local file'. The former is a regular way resources are used on the web - for example, one can package an SVG image with an SVG markup and PNG image that is used in that markup and refer to that from a regular web page. Or package a JS library. This usage is normally over HTTP or HTTPS and support for incremental streaming is important. The latter type of use cases can happen as result of local sharing, or saving a package for offline use. In that case, the package is on a local device in its entirety, and it is potentially huge (\"wikipedia in a package\" etc). In that case, it is important to be able to quickly access resource in the [huge] package w/o need to unpack it in any form, including things like seeking into a movie that is a part of package, etc. \n\nSo the proposed format is trying to address both! Note the usage of MIME-like parts and boundaries and per-parts headers - that allows streaming use by making it possible to parse the package while it trickles in. The offsets are serving the local case - by allowing use of efficient IO operations on a locally-stored 'file'. Note there is no information in the Content Index which would not be available from a part header, and also Content Index is optional. \n\nThe signature, if the package is signed, would require the Content Index (with hashes for parts). In that case, it makes sense for Content Index  and certificate to be in the beginning of the package to facilitate streaming - so the incoming parts can be validated as they are becoming available. The tools that would build such a package could ensure that, this format doesn't depend on the requirement to keep a 'directory' at the end of the file as ZIP does (which does it mostly for ease of append of possibly duplicating files, which is not a goal for this format).\n",
          "createdAt": "2016-11-18T01:20:23Z",
          "updatedAt": "2016-11-18T01:20:23Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "> Note the usage of MIME-like parts and boundaries and per-parts headers - that allows streaming use by making it possible to parse the package while it trickles in. \r\n\r\nMIME like boundary strings need to ensure they do not exist in any of the content body. This means potential collisions or preprocessing to ensure the boundary string does not exist within the body. From https://www.w3.org/Protocols/rfc1341/7_2_Multipart.html :\r\n\r\n>> The encapsulation boundary MUST NOT appear inside any of the encapsulated parts. Thus, it is crucial that the composing agent be able to choose and specify the unique boundary that will separate the parts.\r\n\r\nThings like chunked encoding do not suffer from the potential collision or preprocessing issue.\r\n\r\n> The signature, if the package is signed, would require the Content Index (with hashes for parts). In that case, it makes sense for Content Index and certificate to be in the beginning of the package to facilitate streaming - so the incoming parts can be validated as they are becoming available.\r\n\r\nThis can be done as a trailer per resource rather than a batch up front. Running the digest cannot finish until all the resource is available. I see no need to receive the signed digest prior to the content since the local digest to verify against cannot be created until the body is finished streaming.\r\n\r\n> this format doesn't depend on the requirement to keep a 'directory' at the end of the file as ZIP does (which does it mostly for ease of append of possibly duplicating files, which is not a goal for this format).\r\n\r\nThere are other reasons to use ZIP, I would just like to make a point of disagreement on this being the prevailing reason to use ZIP like trailing directories.",
          "createdAt": "2016-11-29T06:02:08Z",
          "updatedAt": "2016-11-29T06:02:08Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "> one can package an SVG image with an SVG markup and PNG image that is used in that markup and refer to that from a regular web page\r\n\r\nNow you are introducing a completely new issue which is lack of a standard media type and file extension, which would be required to be supported by any OWP client in order to allow this to handled as the result of a URL.  \r\n\r\n> streaming, MIME parts, and index offsets\r\n>Link: <cid:f47ac10b-58cc-4372-a567-0e02b2c3d479>; rel=index; offset=12014/2048\r\n\r\nAs @bmeck mentioned, MIME boundary strings have issues when used for packaging.  In addition, the use of an offset to the index in the header is impossible to have in a streamed format, since you don't know how large the data itself is, and thus where the index where be when you start.\r\n\r\n> So the proposed format is trying to address both!\r\n\r\nIt can't - at least not in a mixed model.  If you are streaming out and streaming in - where there won't be any index/offsets.  OR if you are creating an \"offline\" package upfront.  Then sure, it works.  *BUT* what won't work is streaming out a package that will work offline - or passing an existing offline package to a streaming recipient.\r\n",
          "createdAt": "2016-11-29T06:35:32Z",
          "updatedAt": "2016-11-29T06:35:32Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "note: my PR does not address not knowing the indexes during streaming, your server must place the Content Index at the end of stream and record offsets for each content resource as it goes. I find this an acceptable compromise since a client is still allowed to re-order content within the package.",
          "createdAt": "2016-12-29T15:43:47Z",
          "updatedAt": "2016-12-29T15:43:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think \"streaming\" means at least 2 things here, and we need to distinguish them. Here are 3 scenarios with signed packages that might help structure the discussion. I'm not treating unsigned packages here because a client can rewrite them arbitrarily to make the boundaries and offsets work.\r\n\r\n3 actors: a server that can sign content with a private key, a client who connects to the server and trusts the key but can't sign with it, and a peer who connects to the client and also trusts the key.\r\n\r\n1. The server needs to dynamically generate at least one of the resources in the package, so it doesn't know all contents and offsets ahead of time. However, the client can benefit from loading resources as they're sent.\r\n  If the package is being transferred without authentication+integrity (e.g. HTTP instead of HTTPS), the client is out of luck and has to wait until the signatures arrive to use any of the package. We get no streaming benefit.\r\n  If the package is being transferred under TLS, the client can use that to infer trust in the content, and the server can send a signed manifest/index after all content is transferred. If there's some way to mark what's going to be in the package so the client knows to save it literally, the server can even transfer the files in multiple separate streams, and the client can assemble the package when the index arrives. Dynamically-generated resources can be transferred with the chunked encoding, but we could have the client rewrite that to MIME boundaries before serializing the package if we want, since the offsets aren't generated and signed until the end of the transfer.\r\n\r\n2) One client wants to send the package to a peer, who will rely on the signature to trust the content, but who also might want to use the initial resources before the whole file has transferred. \r\n  This requires the signature block to be sent *first*, opposite case (1). As @bmeck [mentioned](https://github.com/dimich-g/webpackage/issues/6#issuecomment-263484273), it's also possible to sign each resource independently, at the cost of more public-key operations. Nothing's being dynamically generated here, since the client couldn't sign dynamically generated content anyway, so MIME boundaries and fixed offsets are fine, although other ways of marking file boundaries are fine too. The peer can't use a file until the whole file is transferred, hashed, and verified, but they can use file1 before file2 has transferred.\r\n\r\n3) The client or peer wants to re-use a package that's fully transferred, without needing to parse the whole thing from the beginning. This requires an index with offsets and sizes, and signed hashes. The index can be anywhere in the file as long as the peer can find it.\r\n\r\nWhat have I missed?",
          "createdAt": "2017-01-26T23:29:04Z",
          "updatedAt": "2017-01-26T23:29:04Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin I am not sure those are the only three, but let's work through those.\r\n\r\n1 - I would call this \"streamed generation\", and is a possible use case though I would consider it the least important. But regardless, let's work through it.\r\nYour suggestion to utilize the trust of TLS towards the model is interesting, but not viable - as the type of trust one achieves from TLS is not comparable (or replaceable) by the trust inherent in signed content.  Just because badactor.com has a good TLS cert, doesn't mean that I trust the Javascript code that comes from. So a client that is concerned with trusted content (which hopefully will be more and more as we solve this problem) wouldn't be able to use anything until all the content and the certs are down and can verify the trust of those certs.\r\n\r\n2 - Not sure why this has to be client->peer.  To me, this is server->client, where the content already exists (with or without signature).  I agree that the **certificate** (and any associated trust chain and/or revocation info) has to be sent first - so that trust can be established.  However, it doesn't require that the signed hash be sent until the end.  The client can be validating the trust of the cert while streaming in the rest of the data (and the hash) and then only if it ends up trusting the cert does it even bother checking the hash and then (potentially) using the data.\r\n",
          "createdAt": "2017-01-27T13:54:47Z",
          "updatedAt": "2017-01-27T13:54:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "1. If you're not concerned with \"streamed generation\", then I don't understand your [comment](https://github.com/dimich-g/webpackage/issues/6#issue-190131177) at the top of this thread that \"You cannot create it entirely in stream\". Sorry for being dense.\r\n  I'm also not clear on the difference between TLS's trust and the trust in signed content. The two differences I know of are: A) TLS is repudiable since the signature only covers the shared symmetric key, not the content, and B) the TLS private key must be accessible in real time from the server, while signed content can protect the key better. If those are the only differences, I don't know why you'd trust a package signed by foo.com but wouldn't trust a TLS connection to foo.com. Could you enlighten me?\r\n\r\n2. Agreed: I called it \"client\" because the key difference is that it doesn't have access to the private key. It could easily be a server that serves a pre-signed package. My point about sending signatures early is that you can't use a file before you've received its signature. If you send [certificates, file1, file2, ... fileN, signatures], you've unnecessarily delayed use of file1. You can definitely send [certificates, file1, sig1, file2, sig2, ...] instead of [certificates, signatures, file1, file2, ...], but if the package is pre-built I don't really see the benefit.",
          "createdAt": "2017-01-27T17:37:09Z",
          "updatedAt": "2017-01-27T17:37:09Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "I did make that comment up front, as at the time, I wasn't sure whether that was (or wasn't) a requirement.  I would state that right now - no one has proposed a use case where streaming creation is required.  \r\n\r\nAs you note, you can't use a TLS cert to sign content - so that any trust I have in that cert wouldn't apply to content.  I would have to trust a different cert - and that other cert isn't tied to a domain but instead an organization or individual.  See #16 for previous conversations in this area.\r\n\r\n",
          "createdAt": "2017-01-27T19:02:47Z",
          "updatedAt": "2017-01-27T19:02:47Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Dropping streaming requirement seems fine to me. Only use case that we have is speeding up sending packages to registries when publishing.",
          "createdAt": "2017-01-27T20:14:07Z",
          "updatedAt": "2017-01-27T20:14:07Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin @lrosenthol @dimich-g are we fine to close this?",
          "createdAt": "2017-03-29T14:24:16Z",
          "updatedAt": "2017-03-29T14:24:16Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing. File a new issue if needed.",
          "createdAt": "2017-03-30T03:05:56Z",
          "updatedAt": "2017-03-30T03:05:56Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "MDU6SXNzdWUxOTAxMzIyMTk=",
      "title": "Loading in a secure or insecure context?",
      "url": "https://github.com/WICG/webpackage/issues/7",
      "state": "OPEN",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [
        "jyasskin"
      ],
      "labels": [
        "consider closing"
      ],
      "body": "While there is a good discussion about the need to handle separate (and unique) origins [here](https://github.com/dimich-g/webpackage#use-case-a-web-page-with-a-resources-from-the-other-origin), it's not clear whether such content should be loaded in a secure (https-like) or insecure (http) context - and whether it being signed influences that choice.",
      "createdAt": "2016-11-17T18:55:09Z",
      "updatedAt": "2019-05-13T16:44:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is a symptom of including the transfer protocol in the package content-location.\r\n\r\nThoughts for browser behavior:\r\n\r\n* If a package comes over an insecure context no contents can be treated as secure\r\n   * Even if contents are signed they are not secure due to potential resigning\r\n* If a package comes over a secure context\r\n   * Same origin/`<cid>` locations treated as secure since the transfer cert is providing a secure context\r\n* Differing origin needs cert to create a secure context\r\n   * Required even if loading insecure resource off the differing domain to prevent impersonation\r\n\r\nThis assumes differing origins is only possible via nested packages, the spec text currently does not mandate such.",
          "createdAt": "2017-01-13T04:30:24Z",
          "updatedAt": "2017-01-13T04:30:24Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "The cert and the origin have nothing to do with each other.  Just because\nsomething is signed - and even if that certificate verifies just fine - you\ncan't use that as any type of trust that you should use a different origin.\n\nFor example, what prevents me from creating a package, signing it with my\ncert but setting the origin to \"badactor.com\"? Or worse, taking a known\npackage (say jquery), signing it and remapping the origin.\n\nMixing origins in a single package is even worse, especially when you try\nto combine it with inter-package linking...\n\nWe've been looking at this problem for a while now in the context of other\npackaging models and so far we've found no good solution...\n\nOn Thu, Jan 12, 2017 at 11:30 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> I think this is a symptom of including the transfer protocol in the\n> package content-location.\n>\n> Thoughts for browser behavior:\n>\n>    - If a package comes over an insecure context no contents can be\n>    treated as secure\n>       - Even if contents are signed they are not secure due to potential\n>       resigning\n>    - If a package comes over a secure context\n>       - Same origin/<cid> locations treated as secure since the transfer\n>       cert is providing a secure context\n>    - Differing origin needs cert to create a secure context\n>       - Required even if loading insecure resource off the differing\n>       domain to prevent impersonation\n>\n> This assumes differing origins is only possible via nested packages, the\n> spec text currently does not mandate such.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/7#issuecomment-272358603>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNfMRt79Gq_mtd5783wHP6VveezUZks5rRv3hgaJpZM4K1rFA>\n> .\n>\n",
          "createdAt": "2017-01-13T12:55:22Z",
          "updatedAt": "2017-01-13T12:55:22Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol I'm saying your cert used for signing must have valid a valid chain of trust for `badactor.com` if you state an origin for `badactor.com`. The process to validate that a cert belongs to `badactor.com` is something that exists in the web world. However, this becomes complicated once we talk about offline verification since the full chain of trust needs to be verified and things like OCSP are not possible.\r\n\r\nMixing origins I think should be fine if the mixing is only at package boundaries:\r\n\r\n```\r\nfoo.com.webpackage (signed by foo.com cert, sets origin for contents to foo.com)\r\n\\- index.html\r\n\\- foo.js\r\n\\- bar.com.webpackage (must include Package Signature, sets origin for contents to bar.com)\r\n    \\- bar.js\r\n    \\- Content Index <- ALL SIGNED BY bar.com\r\n       \\- bar.js\r\n       \\- Pub key\r\n    \\- Pub Key\r\n\\- Content Index <- ALL SIGNED BY foo.com\r\n    \\- index.html\r\n    \\- foo.js\r\n    \\- bar.com.webpackage\r\n    \\- Pub Key\r\n\\- Pub Key\r\n```\r\n\r\nI think in particular the passing of pubkeys around is influenced by things such as [Google's attemp for Pub Key transparency](https://security.googleblog.com/2017/01/security-through-transparency.html).\r\n\r\n@lrosenthol Do you have a quick list of the problems you have experienced in the past?\r\n\r\n",
          "createdAt": "2017-01-13T13:54:42Z",
          "updatedAt": "2017-01-13T13:54:42Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck - Yes, SSL certs do indeed work for origins because that's what they\nwere designed to do.  But other types of certs don't have that feature.\nAnd you can't use the email address of the person/organization as the\norigin, because my company could own many domains.  (let's keep offline,\noff the table, for now)\n\nAnd I think we agree that you can't specify an origin unless you have a\ncert that verifies to that origin (once we figure out how that would work).\n\nSo in your example, for the bar.com.webpackage, bar.js would have an\nabsolute URL of https://bar.com/bar.js - since it's origined off bar.com.\nCorrect?  And it refers to a relative URL \"image.jpg\", that would then need\nto resolve to https://bar.com/image.jpg, correct?  I'm conflicted on if\nthat is a good or bad thing.\n\nI wasn't aware of the Key Transparency effort - that's interesting - but\nuntil (or if) it gets any real traction, I dont think its prudent to build\na system around...\n\n\nOn Fri, Jan 13, 2017 at 8:54 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> I'm saying your cert used for\n> signing must have valid a valid chain of trust for badactor.com if you\n> state an origin for badactor.com. The process to validate that a cert\n> belongs to badactor.com is something that exists in the web world.\n> However, this becomes complicated once we talk about offline verification\n> since the full chain of trust needs to be verified and things like OCSP are\n> not possible.\n>\n> Mixing origins I think should be fine if the mixing is only at package\n> boundaries:\n>\n> foo.com.webpackage (signed by foo.com cert, sets origin for contents to foo.com)\n> \\- index.html\n> \\- foo.js\n> \\- bar.com.webpackage (must include Package Signature, sets origin for contents to bar.com)\n>     \\- bar.js\n>     \\- Content Index <- ALL SIGNED BY bar.com\n>        \\- bar.js\n>        \\- Pub key\n>     \\- Pub Key\n> \\- Content Index <- ALL SIGNED BY foo.com\n>     \\- index.html\n>     \\- foo.js\n>     \\- bar.com.webpackage\n>     \\- Pub Key\n> \\- Pub Key\n>\n> I think in particular the passing of pubkeys around is influenced by\n> things such as Google's attemp for Pub Key transparency\n> <https://security.googleblog.com/2017/01/security-through-transparency.html>\n> .\n>\n> @lrosenthol <https://github.com/lrosenthol> Do you have a quick list of\n> the problems you have experienced in the past?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/7#issuecomment-272447900>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNWiTxjneKGnbkKbNteAeLJQV9-Joks5rR4IigaJpZM4K1rFA>\n> .\n>\n",
          "createdAt": "2017-01-13T14:13:30Z",
          "updatedAt": "2017-01-13T14:13:30Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "> I wasn't aware of the Key Transparency effort - that's interesting - but\r\nuntil (or if) it gets any real traction, I dont think its prudent to build\r\na system around...\r\n\r\nAgree other existing efforts like PGP Key Servers have similar lookup mechanisms already. It is something to think about.\r\n\r\n> So in your example, for the bar.com.webpackage, bar.js would have an\r\nabsolute URL of https://bar.com/bar.js - since it's origined off bar.com.\r\nCorrect?  And it refers to a relative URL \"image.jpg\", that would then need\r\nto resolve to https://bar.com/image.jpg, correct?  I'm conflicted on if\r\nthat is a good or bad thing.\r\n\r\nThis I am a bit fuzzy on. Web has a concept of \"base URL\" to change the root of relative lookups fo a resource; I see no reason why it couldn't have something like `base-url = bar.com/wepackages/1/` and then `bar.js` is treated as `bar.com/wepackages/1/bar.js`. It has the same escape properties as a naive `chroot` or a cookie `path` attribute which needs to be taken into consideration.\r\n\r\n> Yes, SSL certs do indeed work for origins because that's what they\r\nwere designed to do.  But other types of certs don't have that feature.\r\nAnd you can't use the email address of the person/organization as the\r\norigin, because my company could own many domains.  (let's keep offline,\r\noff the table, for now)\r\n\r\nIt is exactly non-SSL certs that are my interest here. I don't have a good definition for example of what a `secure context` is for filesystem based things that Node/Electron want. It isn't a www domain. Verifying would require some local keychain at the very minimum.",
          "createdAt": "2017-01-13T14:42:21Z",
          "updatedAt": "2017-01-13T14:42:21Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "> Web has a concept of \"base URL\" to change the root of relative lookups fo a resource; I see no reason why it couldn't have something like base-url = bar.com/wepackages/1/ and then bar.js is treated as bar.com/wepackages/1/bar.js.\r\n\r\nI agree, that would also apply.  But in lieu of that, we have to assume it's right at the root, yes?\r\n\r\n>>Yes, SSL certs do indeed work for origins because that's what they\r\nwere designed to do. But other types of certs don't have that feature.\r\n\r\n>It is exactly non-SSL certs that are my interest here. I don't have a good definition for example of what a secure context is for filesystem based things that Node/Electron want. It isn't a www domain. Verifying would require some local keychain at the very minimum.\r\n\r\nBingo!   That is exactly the problem.  \r\nOr one part of the problem\r\n\r\nActually, establishing a secure context is easy - a caller such as Node/Electron can easily establish that the content they are displaying in their \"web view\" must be in a secure context - regardless of where it comes from.   In fact, I would say that just like the many browsers are moving to https only ([here](https://blog.mozilla.org/security/2015/04/30/deprecating-non-secure-http/) and many other places), web-packages should also only run in secure context.\r\n\r\nBut secure context has nothing to do with the origin.  The question here is whether you need the origin or not.  The only reason you would need one is if you expect the package to reference resources outside of itself, and therefore are concerned about CORS-like considerations.  Otherwise, you could simply consider the package as the origin (and each sub-package is either its own origin or a [sub-origin](https://w3c.github.io/webappsec-suborigins/).)\r\n\r\nIt's exactly this problem (origin vs. context) that has been plaguing us and others as well...",
          "createdAt": "2017-01-13T14:55:11Z",
          "updatedAt": "2017-01-13T14:55:11Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "> I agree, that would also apply. But in lieu of that, we have to assume it's right at the root, yes?\r\n\r\nUp to UA, base URL depends on location of the HTML in web views. Could implicitly do URL resolve on browser side to get `http://foo.com/1.webpackage` => `http://foo.com/1.webpackage/` so `bar.js` would be `http://foo.com/1.webpackage/bar.js`. This behavior is similar to what https://github.com/bmeck/noda-loader did on filesystem locations.\r\n\r\n> Actually, establishing a secure context is easy - a caller such as Node/Electron can easily establish that the content they are displaying in their \"web view\" must be in a secure context - regardless of where it comes from. In fact, I would say that just like the many browsers are moving to https only (here and many other places), web-packages should also only run in secure context.\r\n\r\nNode for example doesn't have any \"view\". It should remain possible to run non-signed applications.\r\n\r\nPolicies on if your secure context is allowed to load insecure contexts is complicated in this sense. If I download some 3rd party package, I need my non-signed application to be able to use it, and maybe vice-versa (for example `webpack` used `.js` files for configuration).\r\n\r\n> But secure context has nothing to do with the origin. The question here is whether you need the origin or not. The only reason you would need one is if you expect the package to reference resources outside of itself, and therefore are concerned about CORS-like considerations. Otherwise, you could simply consider the package as the origin (and each sub-package is either its own origin or a sub-origin.)\r\n\r\nAgree. While I worked on this a few years back we were thinking of a policy where origin is recorded at time of transfer of the package and is up to the host to maintain. The download would be stored in some DB with the origin setup that is not mutable by user code (for `node` this requires OS/FS permissions to be done properly).\r\n\r\nI need to think on this some after these points.",
          "createdAt": "2017-01-13T15:05:27Z",
          "updatedAt": "2017-01-13T15:05:27Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "> Node for example doesn't have any \"view\". It should remain possible to run non-signed applications.\r\n\r\nI don't see why signing of the applications has any impact on whether to force a secure context or not.  I would think that forcing secure context on all applications - regardless of whether they are signed or not - is a good thing.  It prevents non-signed applications from doing things they shouldn't be doing (IMO).  However, I could see needing to be more lenient with apps than with publications.\r\n\r\n > we were thinking of a policy where origin is recorded at time of transfer of the package and is up to the host to maintain\r\n\r\nFor signed packages, you could have the origin as part of the package.  As long as the signature is verified and *trusted(!)*, then there would be no problem using that origin.  It's when it's not signed (which we expect to the normal case for publications) or there is no trust that we are back to square one.",
          "createdAt": "2017-01-16T15:14:17Z",
          "updatedAt": "2017-01-16T15:14:17Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol node has permission to access a shell / the real file system / etc. removing this is not possible at this point. Determining if something is *not-approved* for secure access is possible though.\r\n\r\n> For signed packages, you could have the origin as part of the package. As long as the signature is verified and trusted(!), then there would be no problem using that origin. It's when it's not signed (which we expect to the normal case for publications) or there is no trust that we are back to square one.\r\n\r\nIn `node`'s case that would be the current behavior, which is to allow full access. It would need a keystore to limit this behavior.",
          "createdAt": "2017-01-16T15:54:31Z",
          "updatedAt": "2017-01-16T15:54:31Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck - yes, for Node, I fully understand the problem/situation.  That is\nindeed more complex than for publications, where we would never want to\nallow access to such things.\n\nI assume that any UA that will process webpackages is going to either need\ntheir own personal keystore and/or use the one provided by the OS.  I don't\nsee how you can get away from that, especially when trust needs to be\nestablished.\n\nOn Mon, Jan 16, 2017 at 10:54 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> node has permission to access\n> a shell / the real file system / etc. removing this is not possible at this\n> point. Determining if something is *not-approved* for secure access is\n> possible though.\n>\n> For signed packages, you could have the origin as part of the package. As\n> long as the signature is verified and trusted(!), then there would be no\n> problem using that origin. It's when it's not signed (which we expect to\n> the normal case for publications) or there is no trust that we are back to\n> square one.\n>\n> In node's case that would be the current behavior, which is to allow full\n> access. It would need a keystore to limit this behavior.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/7#issuecomment-272898521>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNTeuZxSGYx_-lcDtZuSxV53zCvtNks5rS5K3gaJpZM4K1rFA>\n> .\n>\n",
          "createdAt": "2017-01-16T17:06:53Z",
          "updatedAt": "2017-01-16T17:06:53Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "MDU6SXNzdWUxOTAxMzMxMTQ=",
      "title": "Index should use a common structured format (eg. JSON)",
      "url": "https://github.com/WICG/webpackage/issues/8",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Having the index file be in a text-like format that (a) doesn't specify or mandate an encoding and  (b) no provisions for proper data typing, (c) requires writing a custom parser and (d) will need a newly defined MIME type (see issue #9 ) - doesn't seem like a good idea.\r\n\r\nI recommend instead that the index be a well defined JSON grammar.  That way standard parsers can be used and there is no question about encodings, data types, etc.\r\n",
      "createdAt": "2016-11-17T18:58:44Z",
      "updatedAt": "2017-06-27T22:42:25Z",
      "closedAt": "2017-06-27T22:42:25Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol are there any use cases you can think of that are not solved by HTTP style header mappings that JSON would be better at. I am hesitant to have custom JSON properties but [SourceMaps](https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit) have precedent of allowing this by `x_*` as a prefix. I also am concerned about deeply nested objects but with any custom header it would be possible to make the value itself an object, so that seems fine.\r\n\r\nIf you want to write up a schema that would be great :).",
          "createdAt": "2016-12-29T19:21:23Z",
          "updatedAt": "2016-12-29T19:21:23Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "The main issues are (1) data typing and (2) containers/lists.  if the data\nisn't typed (eg. always treated as a string), you will introduce numerous\nparsing and potential security risks.  But if I know something is a number\n(or boolean or ...), then the issues go away.   Same with having a list of\nthings - each implementor need not write a parser (that might have security\nflaws).\n\nI'll look at doing a schema.\n\nOn Thu, Dec 29, 2016 at 2:21 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> are there any use cases you\n> can think of that are not solved by HTTP style header mappings that JSON\n> would be better at. I am hesitant to have custom JSON properties but\n> SourceMaps\n> <https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/edit>\n> have precedent of allowing this by x_* as a prefix. I also am concerned\n> about deeply nested objects but with any custom header it would be possible\n> to make the value itself an object, so that seems fine.\n>\n> If you want to write up a schema that would be great :).\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/8#issuecomment-269679450>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNW4eaB8xap8i40pKwIfMR0jiuZ7jks5rNAgzgaJpZM4K1rU5>\n> .\n>\n",
          "createdAt": "2017-01-03T19:38:08Z",
          "updatedAt": "2017-01-03T19:38:08Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#36 uses a CDDL grammar to define the index, so I think this is fixed.",
          "createdAt": "2017-03-30T17:55:31Z",
          "updatedAt": "2017-03-30T17:55:31Z"
        }
      ]
    },
    {
      "number": 9,
      "id": "MDU6SXNzdWUxOTAxMzM2ODQ=",
      "title": "application/index not defined as a valid media type",
      "url": "https://github.com/WICG/webpackage/issues/9",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As defined [in its IANA registration](https://www.iana.org/assignments/media-types/application/index), this is not a valid media type.  Instead, either a new sub-type should be defined and/or the appropriate format extension (eg. +json) should be added.",
      "createdAt": "2016-11-17T19:01:09Z",
      "updatedAt": "2017-01-24T02:07:46Z",
      "closedAt": "2017-01-24T02:07:46Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I would vote for a different sub-type, `index` doesn't really make me think that the content is also included. This also doesn't appear to match up with any of https://tools.ietf.org/html/rfc2652 or the subtree:\r\n\r\n```\r\napplication/index.cmd\r\napplication/index.response\r\napplication/index.obj\r\napplication/index.vnd\r\n```",
          "createdAt": "2016-11-29T22:13:20Z",
          "updatedAt": "2016-11-29T22:13:20Z"
        }
      ]
    },
    {
      "number": 10,
      "id": "MDU6SXNzdWUxOTAxMzQ0MDU=",
      "title": "Inclusion of binary data into a text-based format",
      "url": "https://github.com/WICG/webpackage/issues/10",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "[The section on the index ](https://github.com/dimich-g/webpackage#use-case-optional-content-index) says that compression may be permitted, but that may/will yield binary data.  However, because the header of the is document is text - most sniffers will consider this a text file and treat it accordingly (eg. screwing up line endings).\r\n\r\nEither require that all data be text-encoded (eg. BASE64) or use a binary format.",
      "createdAt": "2016-11-17T19:04:06Z",
      "updatedAt": "2017-08-10T13:48:24Z",
      "closedAt": "2017-08-10T13:48:24Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol I do not view this as a problem. Opening a text editor on the file format and editing is not something I see as a goal.",
          "createdAt": "2016-11-29T22:07:30Z",
          "updatedAt": "2016-11-29T22:07:30Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck The problem isn't manual editing.  The problem is systems that determine whether to automatically convert line endings of injected files based on sniffing the beginning of file's content (eg. git).  ",
          "createdAt": "2016-11-30T20:26:47Z",
          "updatedAt": "2016-11-30T20:26:47Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol would using hpack or something to turn the headers into something a sniffer would not see as ASCII be sufficient? I'm not terribly moved by automatic conversion by git etc. as other files suffer similar problems.",
          "createdAt": "2016-12-02T20:07:18Z",
          "updatedAt": "2016-12-02T20:07:18Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck  - Assuming you mean [this hpack](https://http2.github.io/http2-spec/compression.html), it isn't viable as that only works for headers not arbitrary data.   \r\nAnd just because the other kids are jumping off the bridge doesn't mean we should too :).  We know it's wrong - let's not do it...",
          "createdAt": "2016-12-04T20:51:11Z",
          "updatedAt": "2016-12-04T20:51:11Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol my understanding is that the headers were the cause for concern related to sniffers. I do not wish to use hpack on bodies. So, I was saying something like hpack (maybe not hpack) to compress the headers might be sufficient.",
          "createdAt": "2016-12-05T14:42:45Z",
          "updatedAt": "2016-12-05T14:42:45Z"
        },
        {
          "author": "groundwater",
          "authorAssociation": "NONE",
          "body": "I think binary data will be common place.\r\n\r\n1. webassembly\r\n2. images/audio/video\r\n3. encrypted data\r\n\r\nI don't know how good/bad BASE64 encoding is, but it's never been a great story for JSON. Would a few magic bytes fool the sniffers?",
          "createdAt": "2016-12-30T20:46:03Z",
          "updatedAt": "2016-12-30T20:46:03Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "there is nothing wrong with BASE64 - it's been in widespread use for\ndecades.  However, it has the downside of bloating file size (since it is\nobviously larger than the binary equivalent).\n\nOne way to address this problem is to force a web package to be a binary\nformat, in the same way that PDF did 20+ years ago (and continues to do).\nPut a string of high order ASCII early on in the file (eg. as part of the\nformat header).  That should hopefully fool the sniffer to consider it\nalways a binary file and thus allowing enclosed binaries.\n\nOn Fri, Dec 30, 2016 at 3:46 PM, Jacob Groundwater <notifications@github.com\n> wrote:\n\n> I think binary data will be common place.\n>\n>    1. webassembly\n>    2. images/audio/video\n>    3. encrypted data\n>\n> I don't know how good/bad BASE64 encoding is, but it's never been a great\n> story for JSON. Would a few magic bytes fool the sniffers?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/10#issuecomment-269819994>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNV8UYmHHneJjJbqFJHmT5WGOODjgks5rNW2LgaJpZM4K1rr4>\n> .\n>\n",
          "createdAt": "2017-01-03T19:35:08Z",
          "updatedAt": "2017-01-03T19:35:08Z"
        },
        {
          "author": "groundwater",
          "authorAssociation": "NONE",
          "body": "Thank you @lrosenthol!\r\n\r\n> it has the downside of bloating file size\r\n\r\nThat was honestly the only downsize I could think of. Given that one problem this project aims to solve is packaging for folks with low or limited access, I think file size is important.\r\n\r\n> the same way that PDF did 20+ years ago\r\n\r\nWhat I love about this solution is that we're copying something that already works!\r\n\r\n@bmeck regarding hpack, I don't know much about the format, but it sounds like it has the upside of both reducing file size, and passing the sniff test. It sounds like the downsize is increased complexity of creating and parsing the package. For a moment, assuming the binary sniffing problem was solved, are there still benefits to hpack?",
          "createdAt": "2017-01-03T20:25:51Z",
          "updatedAt": "2017-01-03T20:25:51Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@groundwater file size is a big win, allowing arbitrary extension headers is a possible win. Stateful compression like hpack can have a downside in that you have to preserve state if you want to extract  only one part of the archive and leave the rest intact.",
          "createdAt": "2017-01-03T20:38:30Z",
          "updatedAt": "2017-01-03T20:38:30Z"
        },
        {
          "author": "groundwater",
          "authorAssociation": "NONE",
          "body": "@bmeck \r\n\r\n> file size is a big win\r\n\r\nI agree! Just to ask, is this something that could be seen as a v2.0 optimization? Or would this need to be part of the spec out of the gate.\r\n\r\n> allowing arbitrary extension headers is a possible win\r\n\r\nI am not sure what this means, but it sounds interesting. Can you explain a little more?\r\n\r\n> Stateful compression like hpack can have a downside in that you have to preserve state if you want to extract only one part of the archive and leave the rest intact.\r\n\r\nCorrect me if I'm wrong, but it sounds like this is solvable _with good tooling_. But there is a cost in creating that tooling.",
          "createdAt": "2017-01-03T21:24:53Z",
          "updatedAt": "2017-01-03T21:24:53Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "There are (basically) three different approaches to archival compression\n\n- Compress the entire thing (ala .tar.z)\n- Compress each file/object individually (ala ZIP)\n- Block-based compression\n\nThe latter is the most complex and yields somewhat larger files, but with\nthe advantage of being able to do partial decompression and/or updates.\nIt's also (AFAIK) still under a variety of patents from the 90's when it\nwas first developed.\n\nYou have to make a decision about which up front as it's part of your\nformat design.\n\n\nOn Tue, Jan 3, 2017 at 4:24 PM, Jacob Groundwater <notifications@github.com>\nwrote:\n\n> @bmeck <https://github.com/bmeck>\n>\n> file size is a big win\n>\n> I agree! Just to ask, is this something that could be seen as a v2.0\n> optimization? Or would this need to be part of the spec out of the gate.\n>\n> allowing arbitrary extension headers is a possible win\n>\n> I am not sure what this means, but it sounds interesting. Can you explain\n> a little more?\n>\n> Stateful compression like hpack can have a downside in that you have to\n> preserve state if you want to extract only one part of the archive and\n> leave the rest intact.\n>\n> Correct me if I'm wrong, but it sounds like this is solvable *with good\n> tooling*. But there is a cost in creating that tooling.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/10#issuecomment-270228930>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNRIJHuhau7coJYjCy7W-byRYnq7yks5rOrymgaJpZM4K1rr4>\n> .\n>\n",
          "createdAt": "2017-01-03T21:31:13Z",
          "updatedAt": "2017-01-03T21:31:13Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "> > allowing arbitrary extension headers is a possible win\r\n\r\n> I am not sure what this means, but it sounds interesting. Can you explain a little more?\r\n\r\nThings that are not well known headers a like `X-Special-Header: ...` in HTTP. In the actual HTTP 1.1 RFC extensions are not required to start with `X-` and the use of that prefix is deprecated, I just used it to make a point. \r\n\r\n> Correct me if I'm wrong, but it sounds like this is solvable with good tooling. But there is a cost in creating that tooling.\r\n\r\nThe way hpack works it can index existing field/value pairs https://http2.github.io/http2-spec/compression.html#compression.based.attacks has some more details on various design considerations to take note of due to this.",
          "createdAt": "2017-01-03T21:34:25Z",
          "updatedAt": "2017-01-03T21:34:25Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "What are the technical constraints here? I assume UTF-8 isn't sufficiently non-text to convince sniffers that they've found a binary file. How close to the beginning of the file do non-UTF-8 sequences need to appear in order to convince sniffers that the file's binary?",
          "createdAt": "2017-02-03T19:23:00Z",
          "updatedAt": "2017-02-03T19:23:00Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've finally realized the benefits of @bmeck's suggestion to use [HPACK](http://httpwg.org/specs/rfc7541.html). Even if we forbid parts from adding entries to the [dynamic table](http://httpwg.org/specs/rfc7541.html#dynamic.table), we get the following benefits:\r\n1. The format is obviously binary and will appear right at the beginning of the package, solving #10.\r\n2. The [static table](http://httpwg.org/specs/rfc7541.html#static.table.definition) will reduce the size of many common headers.\r\n3. The [Huffman code](http://httpwg.org/specs/rfc7541.html#huffman.code) will reduce the size of many uncommon headers and values.\r\n\r\nWe could allow the package to explicitly define the dynamic table in a single central place, which would give many of the benefits of HPACK's default online compression, but that seems like an extra feature that we can consider independently.",
          "createdAt": "2017-02-03T22:28:44Z",
          "updatedAt": "2017-02-03T22:30:21Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Correct, UTF8 is still text.   Usually sniffers tend to search the first\n2048 bytes or less.\n\nAs for HPACK - I am not seeing how that will help.  The large sizes for web\npackages aren't going to be the headers but the actual data of each part.\n\nOn Fri, Feb 3, 2017 at 2:23 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> What are the technical constraints here? I assume UTF-8 isn't sufficiently\n> non-text to convince sniffers that they've found a binary file. How close\n> to the beginning of the file do non-UTF-8 sequences need to appear in order\n> to convince sniffers that the file's binary?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/10#issuecomment-277337993>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNQBFKAZEcjJCfouC8G4e0nVooszCks5rY36VgaJpZM4K1rr4>\n> .\n>\n",
          "createdAt": "2017-02-06T13:58:26Z",
          "updatedAt": "2017-02-06T13:58:26Z"
        },
        {
          "author": "inexorabletash",
          "authorAssociation": "NONE",
          "body": "Reading through CBOR, I noticed the bit on [Self-Describe CBOR](https://tools.ietf.org/html/rfc7049#section-2.4.5) which roughly says you can freely prepend 0xd9d9f7 as a CBOR magic number, which is also carefully chosen to not be a valid UTF-8 or UTF-16 sequence. I don't know if mandating a leading \"tag 55799\" for webpackage has been discussed elsewhere (I'm a noob here) but it might be useful for making the very start of the package less sniffable as text?",
          "createdAt": "2017-05-17T22:20:49Z",
          "updatedAt": "2017-05-17T22:20:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The beginning of the current format is \"83 48\", which isn't valid UTF-8, but it is valid UTF-16. Do we need to prevent the format from being valid UTF-16?",
          "createdAt": "2017-05-17T23:14:11Z",
          "updatedAt": "2017-05-17T23:14:11Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol can we move this to https://github.com/WICG/webpackage/issues/47 ?",
          "createdAt": "2017-08-09T14:51:57Z",
          "updatedAt": "2017-08-09T14:51:57Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Yes, that's fine with me.  Thanks!\n\nOn Wed, Aug 9, 2017 at 10:51 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> can we move this to #47\n> <https://github.com/WICG/webpackage/issues/47> ?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/10#issuecomment-321279490>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNUdkWLNUQaBGTNwX6dHmsKlXVl2Lks5sWceOgaJpZM4K1rr4>\n> .\n>\n",
          "createdAt": "2017-08-09T15:42:45Z",
          "updatedAt": "2017-08-09T15:42:45Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "MDU6SXNzdWUxOTAxMzQ3NTA=",
      "title": "Index offset may not survive some processes",
      "url": "https://github.com/WICG/webpackage/issues/11",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "However, because the header of the is document is text - most sniffers will consider this a text file and treat it accordingly (eg. screwing up line endings).  If this happens, then all byte offsets will be incorrect and the file will be unable to load.\r\n\r\nConsider finding a way to fool the sniffer or move to a binary format.\r\n\r\n",
      "createdAt": "2016-11-17T19:05:37Z",
      "updatedAt": "2018-01-22T19:29:08Z",
      "closedAt": "2018-01-22T19:29:08Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "These offsets can also suffer if the package:\r\n\r\n1. is re-ordered (perhaps due to priorities)\r\n\r\n    Signatures are Headers+Body of a content resource currently which means it can be re-ordered fairly simply and maintain the signatures still. This was talked about on a phone call as being possible, particularly since the boundaries allow the Content Index Entities to keep the same hash.\r\n\r\n2. streamed in such a way as chunked encoded where encoding boundaries/headers could change the exact offsets.\r\n\r\n   In order for a Content Index to have these offsets for a streaming resource it would need to be at the end of file and not allow removing the encoding boundaries/headers. This seems a bit wasteful since a stream would need to track these offsets if the size of streamed chunks is not known ahead of time.\r\n\r\nIn any case, both of these have a need to recalculate the Package-Signature if the offsets change. Doing so while streaming would mean that Package-Signature also would need to occur at the end of file, presumably as a trailer.",
          "createdAt": "2016-12-29T19:13:47Z",
          "updatedAt": "2016-12-29T19:13:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#36 takes the index structure out of the signed content, so it can be re-generated by any process that invalidates its offsets. I think this is fixed.",
          "createdAt": "2017-03-30T17:54:38Z",
          "updatedAt": "2017-03-30T17:54:38Z"
        }
      ]
    },
    {
      "number": 12,
      "id": "MDU6SXNzdWUxOTAxMzcwNzk=",
      "title": "Details of exactly what is hashed (both for individual entries and the package itself) are missing",
      "url": "https://github.com/WICG/webpackage/issues/12",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "There is nothing specified for exactly which bytes are hashed - either for an individual file/resource for the header or the index.  \r\n\r\nDo you include the boundary string?  Do you include any closing line endings?  ",
      "createdAt": "2016-11-17T19:15:02Z",
      "updatedAt": "2017-06-27T22:40:15Z",
      "closedAt": "2017-06-27T22:40:15Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "see note about each resource having its HEADER+BODY signed in : https://github.com/dimich-g/webpackage/blame/master/README.md#L308\r\n\r\nMy PR rephrased in a few places to make more explicit in https://github.com/dimich-g/webpackage/pull/23\r\n\r\nIt might be prudent however to change the phrasing of https://github.com/dimich-g/webpackage/blame/master/README.md#L312 to state that nested packages as signed as opaque entities as it sounds currently like nested packages are not something that the root package can verify as being correct currently.",
          "createdAt": "2016-12-29T15:41:13Z",
          "updatedAt": "2016-12-29T15:41:13Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Just noticed, the certificates are not signed in the Content-Index examples; unsure if this is intentional, but seems like just an accident.",
          "createdAt": "2016-12-29T17:13:19Z",
          "updatedAt": "2016-12-29T17:13:19Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol if certificates are signed is the rest covered?",
          "createdAt": "2017-01-13T03:32:39Z",
          "updatedAt": "2017-01-13T03:32:39Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "You can't sign a certificate with itself - but you could sign the\ncertificates from a nested package with the certs from the parent - that\nwould be perfectly fine.\n\nOn Thu, Jan 12, 2017 at 10:32 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> if certificates are signed is\n> the rest covered?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/12#issuecomment-272352581>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNZL62PntQ79dK3bnPVwpddgBWyLFks5rRvBYgaJpZM4K1say>\n> .\n>\n",
          "createdAt": "2017-01-13T12:51:25Z",
          "updatedAt": "2017-01-13T12:51:25Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Arguably, these details can go in the draft specification rather than the explainer, but it's probably time to start that specification and add these details, so we can iterate on them.",
          "createdAt": "2017-01-24T01:15:19Z",
          "updatedAt": "2017-01-24T01:15:19Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#36 now specifies exactly which bytes are hashed and signed, so I believe this is fixed.",
          "createdAt": "2017-03-30T17:53:42Z",
          "updatedAt": "2017-03-30T17:53:42Z"
        }
      ]
    },
    {
      "number": 13,
      "id": "MDU6SXNzdWUxOTAxMzc3NzQ=",
      "title": "Signatures not in compliance with EU law",
      "url": "https://github.com/WICG/webpackage/issues/13",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As described in [Mandate M/460](http://www.e-signatures-standards.eu/activities), only certain signature format and standards can be legally used in the EU - and this proposal does not comply with any.  It would be better to align with at least one of them - most likely CAdES.\r\n",
      "createdAt": "2016-11-17T19:17:45Z",
      "updatedAt": "2019-05-13T16:44:42Z",
      "closedAt": "2019-05-13T16:44:42Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Note various parts of these return 404s like https://docbox.etsi.org/ESI/Open/Latest_Drafts/ts-119172-1_v009-SignaturePolicyFramework-STABLE-DRAFT.pdf currently",
          "createdAt": "2016-12-28T16:07:32Z",
          "updatedAt": "2016-12-28T16:07:32Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I gave it a read through (once is not enough for me to fully understand in depth though). It seems this is more around policy and I see nothing in WebPackage that prevents you from using the proper standards (it also allows you to create signatures outside the standard). What are the exact things that prevent compliance?",
          "createdAt": "2016-12-29T17:43:53Z",
          "updatedAt": "2016-12-29T17:43:53Z"
        }
      ]
    },
    {
      "number": 14,
      "id": "MDU6SXNzdWUxOTAxMzkyMDA=",
      "title": "No need to specify cert algo as that is defined by the cert itself",
      "url": "https://github.com/WICG/webpackage/issues/14",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As asked [here](https://github.com/dimich-g/webpackage#use-case-signed-package-one-origin):\r\n> Should there be '-with-ECDSA' since certificate specifies the key's algorithm?\r\n\r\nNo, not necessary since the certificate specifies the algorithm.",
      "createdAt": "2016-11-17T19:23:09Z",
      "updatedAt": "2017-01-05T02:08:54Z",
      "closedAt": "2017-01-05T02:08:54Z",
      "comments": []
    },
    {
      "number": 15,
      "id": "MDU6SXNzdWUxOTAxNDAwOTE=",
      "title": "Validation cannot necessarily take place offline ",
      "url": "https://github.com/WICG/webpackage/issues/15",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the [discussion on signing](https://github.com/dimich-g/webpackage#use-case-signed-package-one-origin), it says\r\n> The inclusion of certificate makes it possible to validate the package offline (certificate revocation aside, this can be done out-of-band when device is actually online).\r\n\r\nThis is only true in very few cases as you need to build an entire trust chain from that cert up to the root.  Most processors will not have local access to every cert - in which case, it will need to fetch them.",
      "createdAt": "2016-11-17T19:26:33Z",
      "updatedAt": "2019-05-13T16:45:50Z",
      "closedAt": "2019-05-13T16:45:50Z",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "True, the full chain is necessary for validation. Intermediary certificates can be usually fetched automatically, based on info in the Authority Information Access (AIA) extension in a typical certificate. There is a paragraph on that at the end of FAQ in the Explainer.\r\nSince a tool of some sort is required to sign a package, the same tool could make sure to fetch intermediate certificates and package them into the same package. Whether it is a part of the same resource or it has to be multiple 'certificate' parts all representing parts of the certificate chain is still somewhat an open question.",
          "createdAt": "2016-12-07T01:13:25Z",
          "updatedAt": "2016-12-07T01:13:25Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "You could indeed package up (a set of) intermediate certificates - but,\nthat may not be the same set that is used at validation time, depending on\nthe validation policy in place.  Different policies can lead to different\nbranches of the chain.   Also, you'd still (most likely) need to do\nrevocation checks, which require online access for full validation.\nAnd then there is the whole \"where do you get the CA certs from\"\nproblem...(EUTL, OS, other?)\n\nAll solvable - as they are in other instances - but could lead to\ninteroperability issues...\n\nOn Tue, Dec 6, 2016 at 8:13 PM, Dmitry Titov <notifications@github.com>\nwrote:\n\n> True, the full chain is necessary for validation. Intermediary\n> certificates can be usually fetched automatically, based on info in the\n> Authority Information Access (AIA) extension in a typical certificate.\n> There is a paragraph on that at the end of FAQ in the Explainer.\n> Since a tool of some sort is required to sign a package, the same tool\n> could make sure to fetch intermediate certificates and package them into\n> the same package. Whether it is a part of the same resource or it has to be\n> multiple 'certificate' parts all representing parts of the certificate\n> chain is still somewhat an open question.\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/15#issuecomment-265325632>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNZ3qSdJ6LC3v7aHhxXSKDCpHcNmmks5rFgg2gaJpZM4K1tPO>\n> .\n>\n",
          "createdAt": "2016-12-08T14:23:04Z",
          "updatedAt": "2016-12-08T14:23:04Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the point here was that your environment could supply the missing certs and/or your downloader could automatically check/fetch missing certs. \"possible\" does not mean always true in my mind. I am unclear on the specific interoperability issue you allude to except from collision and/or replacement of certs which are true in almost all systems (particularly if non-security based revocation/expiration is allowed to be ignored).",
          "createdAt": "2016-12-28T14:41:52Z",
          "updatedAt": "2016-12-28T14:41:52Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "If you read the relevant standards around signature validation (such as\nthose form the EU's eIDAS regulations, incl EN 319 102-1 v1.1.1 and TS 119\n172-1), you will see that the building of the trust chain for validation is\ncontrolled by a number of factors including signature policies. Those\npolicies have impact on the interoperability, as does the selection of CA\nrepository.\n\nAgain, these are all solved problems in DOCUMENT signature space - which is\nnot the same as web content/TLS signature validation.\n\nOn Wed, Dec 28, 2016 at 9:41 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> I think the point here was that your environment could supply the missing\n> certs and/or your downloader could automatically check/fetch missing certs.\n> \"possible\" does not mean always true in my mind. I am unclear on the\n> specific interoperability issue you allude to except from collision and/or\n> replacement of certs which are true in almost all systems (particularly if\n> non-security based revocation/expiration is allowed to be ignored).\n>\n> \u2014\n> You are receiving this because you authored the thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/15#issuecomment-269485803>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNSkxk_oJLFRFzXiLZWkBD9CZZ9h8ks5rMnUxgaJpZM4K1tPO>\n> .\n>\n",
          "createdAt": "2016-12-28T15:30:45Z",
          "updatedAt": "2016-12-28T15:30:45Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol I was not thinking of looking at those, so if you have other relevant documents it might be good to share those.",
          "createdAt": "2016-12-28T16:06:20Z",
          "updatedAt": "2016-12-28T16:06:20Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol thanks for the references! Need to digest a bit :)",
          "createdAt": "2017-01-05T02:00:10Z",
          "updatedAt": "2017-01-05T02:00:10Z"
        }
      ]
    },
    {
      "number": 16,
      "id": "MDU6SXNzdWUxOTAxNDAzMTI=",
      "title": "What type of certificates can be used to sign? ",
      "url": "https://github.com/WICG/webpackage/issues/16",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "What is the expectation of what types of certificates can be used to sign these packages? \r\n\r\nSSL/TLS?\r\nCode signing?\r\nStandard document/message signing?\r\nOther?\r\n",
      "createdAt": "2016-11-17T19:27:26Z",
      "updatedAt": "2017-01-13T19:19:02Z",
      "closedAt": "2017-01-13T19:19:02Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol do we need to constrain the types of certs or just the certificate container format: x509 vs PGP vs ...?\r\n\r\nedit: should clarify that the proposal contains:\r\n> Certificate is included as one of standard the DER-encoded resource (with proper Content-type).\r\n",
          "createdAt": "2016-11-29T22:14:57Z",
          "updatedAt": "2016-11-29T22:16:34Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck Yes, we would need both.  First the certificate format (eg. X509 vs. PGP) and then second the type of cert - because you can't necessarily intermix SSL/TLS certs with code or document signing certs.  (which is, of course, by design)",
          "createdAt": "2016-11-30T20:24:16Z",
          "updatedAt": "2016-11-30T20:24:16Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "with the conversation in https://github.com/dimich-g/webpackage/pull/22 \r\n\r\nI vote for X509 with a minimum of [Key Usage](https://tools.ietf.org/html/rfc5280#section-4.2.1.3):\r\n\r\n* `digitalSignature` - we could be sending down assets that would not execute\r\n* `id-kp-codeSigning` - we could be sending down JS that would execute\r\n* `id-kp-timeStamping` - we have mentions of expiration/ages\r\n\r\nShould check with certificate vendors around and see if there are any that would have issues easily supplying all 3 to average person wanting to make a package.",
          "createdAt": "2017-01-04T19:42:06Z",
          "updatedAt": "2017-01-04T19:42:15Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck\n\nIt's pretty difficult to get a code signing cert, due to the normal usage\ncases for it.   And timestamping even more so - since that's really only\nfor use in a timestamp server.\n\nBut can't hurt to ask...\n\n\nOn Wed, Jan 4, 2017 at 2:42 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> with the conversation in #22\n> <https://github.com/dimich-g/webpackage/pull/22> \ud83d\udc4d\n>\n> I vote for X509 with a minimum of Key Usage\n> <https://tools.ietf.org/html/rfc5280#section-4.2.1.3>:\n>\n>    - digitalSignature - we could be sending down assets that would not\n>    execute\n>    - id-kp-codeSigning - we could be sending down JS that would execute\n>    - id-kp-timeStamping - we have mentions of expiration/ages\n>\n> Should check with certificate vendors around and see if there are any that\n> would have issues easily supplying all 3 to average person wanting to make\n> a package.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/16#issuecomment-270466521>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNbXm5m7xNw5P-CI6Swb6440cwJZGks5rO_YOgaJpZM4K1tS->\n> .\n>\n",
          "createdAt": "2017-01-05T01:05:15Z",
          "updatedAt": "2017-01-05T01:05:15Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Was id-kp-codeSigning extension introduced to be able to issue those separately from SSL (and even using separate roots?) to reduce associated risks? \r\n\r\nPerhaps the limits on key usage (especially key usage extensions) should be a detail of implementation? For example, a browser would use SSL/TLS keys since the content it will validate is web content and the purpose of validation is to afford it the same privileges that delivering it via SSL provides. It is also likely that the procedure to sign the web content will involve the same certs the web servers use already. \r\n\r\nThe code distribution tools for JS runtimes may have different limits and require different type of keys (if this is practical).",
          "createdAt": "2017-01-05T01:55:33Z",
          "updatedAt": "2017-01-05T01:55:33Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Given that we have identified at least three different use cases for this\nwork (browsers loading scripts/etc, application packagers and\npublications), each of which would logically want/require a different type\nof certificate - perhaps we shouldn't put any restrictions here and leave\nit up to the use case in question to create a \"profile\" for their own\nneeds??\n\nOn Wed, Jan 4, 2017 at 8:55 PM, Dmitry Titov <notifications@github.com>\nwrote:\n\n> Was id-kp-codeSigning extension introduced to be able to issue those\n> separately from SSL (and even using separate roots?) to reduce associated\n> risks?\n>\n> Perhaps the limits on key usage (especially key usage extensions) should\n> be a detail of implementation? For example, a browser would use SSL/TLS\n> keys since the content it will validate is web content and the purpose of\n> validation is to afford it the same privileges that delivering it via SSL\n> provides. It is also likely that the procedure to sign the web content will\n> involve the same certs the web servers use already.\n>\n> The code distribution tools for JS runtimes may have different limits and\n> require different type of keys (if this is practical).\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/16#issuecomment-270543271>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNTK3IUa1eix9SPWex-WgtP6GySgUks5rPE2WgaJpZM4K1tS->\n> .\n>\n",
          "createdAt": "2017-01-05T12:47:14Z",
          "updatedAt": "2017-01-05T12:47:14Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol @dimich-g if we want to leave it up to env that seems fine.",
          "createdAt": "2017-01-05T15:19:10Z",
          "updatedAt": "2017-01-05T15:19:10Z"
        }
      ]
    },
    {
      "number": 17,
      "id": "MDU6SXNzdWUxOTAxNDExODU=",
      "title": "In nested packages, what are the offsets relative to?",
      "url": "https://github.com/WICG/webpackage/issues/17",
      "state": "CLOSED",
      "author": "lrosenthol",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It's not clear from the document whether offsets specified in the header or index of a nested package are to be taken from the start of the containing/primary package data or from the start of the nested package header.  \r\n",
      "createdAt": "2016-11-17T19:30:56Z",
      "updatedAt": "2016-12-07T00:40:56Z",
      "closedAt": "2016-12-07T00:40:56Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "for streaming[/reuse] purposes I would hope it is relative to the nested package and not the outer package.",
          "createdAt": "2016-11-29T22:17:18Z",
          "updatedAt": "2016-11-29T22:17:34Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck I would hope so too - but the spec is silent on the topic...",
          "createdAt": "2016-11-30T20:22:18Z",
          "updatedAt": "2016-11-30T20:22:18Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Commit https://github.com/dimich-g/webpackage/commit/45bf2223ef53764c5b42ae614744267aa7fe90ed\r\nadded the note about relative offsets - the offsets inside the nested package are relative to the nested package. The idea is that the nested packages are full-formed on their own and can be created/signed separately, then included as-is into containing package.",
          "createdAt": "2016-12-07T00:40:55Z",
          "updatedAt": "2016-12-07T00:40:55Z"
        }
      ]
    },
    {
      "number": 20,
      "id": "MDU6SXNzdWUxOTQ3Nzg5NTc=",
      "title": "Self Extracting Binaries",
      "url": "https://github.com/WICG/webpackage/issues/20",
      "state": "CLOSED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For self extracting executables, the common implementation is to produce a file which is a concatenated binary executable head, and an archive tail.\r\n\r\nNode and Electron are looking at reusing webpackage possibly as things progress and need a way:\r\n\r\n* Have a signature for the concatenated binary+archive\r\n* Have a length pointer to let the runtime jump to the start of the archive\r\n\r\nSelf extracting zip files, ASAR from electron, and NODA are examples of this from the past. These all work by having a directory at end of file, but for all use cases I know a pointer to start of archive on the tail would be sufficient. Doing so would most likely just be a series of magic bytes and kength that exists at the end of the file. It could be optional but must be easy to add to an existing webpackage.\r\n\r\nFor a signature of the entire binary + archive this is important so people don't perform a secondary concatenation and load a different archive than expected, it most likely can just be a well known header that optionally exists on the package headers.",
      "createdAt": "2016-12-10T16:55:07Z",
      "updatedAt": "2019-12-12T01:16:14Z",
      "closedAt": "2017-03-30T18:07:48Z",
      "comments": [
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "Seems that the most important incompatibility here is that an archive with an executable at the head won't be readable by archive readers since we use header lines to define the content type, signature, etc.  \r\n\r\nSignature of the binary+archive seems like a less important feature, unless the OS is going to know how to validate the binary signature before it executes it. Is there a use case I'm not seeing?  Can we split the discussion of binary signatures from the more general self-extracting case?",
          "createdAt": "2017-01-03T18:41:38Z",
          "updatedAt": "2017-01-03T18:41:38Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I would not expect to keep the same file extension if it is self extracting. Unsure what workflow:\r\n\r\n> Seems that the most important incompatibility here is that an archive with an executable at the head won't be readable by archive readers since we use header lines to define the content type, signature, etc.\r\n\r\nWould conflict with.\r\n\r\nSigning of a binary+archive is important if the runtime wants to prevent certain types of concatenation attacks. Otherwise:\r\n\r\n```sh\r\n> cat runtime webpackage > extracting_bin\r\n```\r\n\r\ncould have the package replaced by doing\r\n\r\n```sh\r\n> cat extracting_bin other_webpackage\r\n```\r\n\r\nWhich would not be good if you are trying to distribute a binary.\r\n\r\nSigning tools like `codesign` or `toolsign` are currently outside my intents but I don't see any problem with using them ontop in conjunction with a signature method for the combined executable.",
          "createdAt": "2017-01-03T18:57:30Z",
          "updatedAt": "2017-01-03T18:57:30Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Shouldn't signign the binary+archive be something that the self-extracting\nexecutable has to worry about and not something we need to worry about?  If\nthey want to use our packaging format (by cat'ing it to the end of\nthemselves), then they are responsible for their own signing - be it\nstandard/OS code sign or something else.\n\nOn Tue, Jan 3, 2017 at 1:57 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> I would not expect to keep the same file extension if it is self\n> extracting. Unsure what workflow:\n>\n> Seems that the most important incompatibility here is that an archive with\n> an executable at the head won't be readable by archive readers since we use\n> header lines to define the content type, signature, etc.\n>\n> Would conflict with.\n>\n> Signing of a binary+archive is important if the runtime wants to prevent\n> certain types of concatenation attacks. Otherwise:\n>\n> > cat runtime webpackage > extracting_bin\n>\n> could have the package replaced by doing\n>\n> > cat extracting_bin other_webpackage\n>\n> Which would not be good if you are trying to distribute a binary.\n>\n> Signing tools like codesign or toolsign are currently outside my intents\n> but I don't see any problem with using them ontop in conjunction with a\n> signature method for the combined executable.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/20#issuecomment-270193261>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNZZi6Wez9tjVavYLcB3wcnoPCUFXks5rOpobgaJpZM4LJspJ>\n> .\n>\n",
          "createdAt": "2017-01-03T19:31:22Z",
          "updatedAt": "2017-01-03T19:31:22Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol mostly yes, but as was talked about a bit ago on a call, there needs to be a standard so that the differing runtimes can leverage the same process/tooling to generate these. Same reason to have a trailer that could be picked up to find the beginning of the archive.",
          "createdAt": "2017-01-03T19:51:17Z",
          "updatedAt": "2017-01-03T19:51:17Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck I don't actually believe that a standard is needed in this case. And if there is, wouldn't it be better to come from the folks doing the SEA's and tooling for same, rather than us?  Do we have any folks from those communities participating here? ",
          "createdAt": "2017-01-03T20:19:09Z",
          "updatedAt": "2017-01-03T20:19:09Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Runtime people interested in this: Me (Node), @jasnell (Node), and @groundwater (Electron)",
          "createdAt": "2017-01-03T20:36:26Z",
          "updatedAt": "2017-01-03T20:36:26Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#36 added a length to the end of the package: https://github.com/dimich-g/webpackage#overall-format. Is that sufficient?",
          "createdAt": "2017-03-30T17:52:31Z",
          "updatedAt": "2017-03-30T17:52:31Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin yes",
          "createdAt": "2017-03-30T17:58:24Z",
          "updatedAt": "2017-03-30T17:58:24Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "@bmeck adding the length at last **inside cbor format** also works fine for your use case ?\r\n\r\n```\r\n> cat extracting_bin other_webpackage\r\n```\r\n\r\nit seems necessary decoding/re-encoding cbor format when adding other package to current .wbn .",
          "createdAt": "2019-12-11T04:01:19Z",
          "updatedAt": "2019-12-11T04:07:36Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Only works if the position is known, which means it must not be an unordered named field, it would still need to be at the very end of the payload. Is that what you are suggesting? E.g.\r\n\r\n```\r\n{\r\n  size,\r\n  payload\r\n} | {\r\n  payload,\r\n  size\r\n}\r\n```\r\n\r\nwouldn't work\r\n\r\n```\r\n[\r\n  payload,\r\n  size // guaranteed location at tail of the whole bundle\r\n]\r\n```\r\n\r\nis probably ok",
          "createdAt": "2019-12-11T15:03:02Z",
          "updatedAt": "2019-12-11T15:03:02Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "CBOR integers are variable-sized and can't be parsed backwards, so the total size does need to be a byte-string like it's currently specified: https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#name-top-level-structure. They are inside the overall CBOR format, which is easy since an array's last item is also the last bytes of the encoding of the array.",
          "createdAt": "2019-12-11T18:37:08Z",
          "updatedAt": "2019-12-11T18:37:08Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "adding another package to current webbundle should update section and section-length too.\r\nyou can update only length without parsing whole cbor. but updating section/section-length need to parse whole cbor isn't it ?\r\nin that case, move only length to bottom of cbor array will help this case ?\r\n",
          "createdAt": "2019-12-12T01:16:14Z",
          "updatedAt": "2019-12-12T01:16:14Z"
        }
      ]
    },
    {
      "number": 26,
      "id": "MDU6SXNzdWUyMDA0MTE2ODE=",
      "title": "Links to resource within a Package",
      "url": "https://github.com/WICG/webpackage/issues/26",
      "state": "OPEN",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "discuss",
        "feature request"
      ],
      "body": "For some use cases like Source Maps packages may wish to not include the full asset within themselves but have another package containing debugging symbols. Currently fragment URLs are proposed for removal, however I don't see a clear way to have a situation like:\r\n\r\n```\r\nminified.webpackage\r\n\\- index.min.js\r\n```\r\n\r\n```\r\nsource-maps.webpackage\r\n\\- index.min.js.map\r\n```\r\n\r\nAnd have `index.min.js` able to point to `index.min.js.map`.",
      "createdAt": "2017-01-12T16:20:01Z",
      "updatedAt": "2020-10-26T18:36:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Unless we can convince \"the powers that be\" to support fragment URLs or\nsome other method by which paths into packages could be supported as part\nof a URL syntax - you are correct, there is no solution :(.\n\nOn Thu, Jan 12, 2017 at 11:20 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> For some use cases like Source Maps packages may wish to not include the\n> full asset within themselves but have another package containing debugging\n> symbols. Currently fragment URLs are proposed for removal, however I don't\n> see a clear way to have a situation like:\n>\n> minified.webpackage\n> \\- index.min.js\n>\n> source-maps.webpackage\n> \\- index.min.js.map\n>\n> And have index.min.js able to point to index.min.js.map.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNW595WhOgmpM4tsGCHzs31bpGfQlks5rRlKxgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-13T02:45:13Z",
          "updatedAt": "2017-01-13T02:45:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Initially, what if we write the source map's URL, and insist on being online in order to debug?",
          "createdAt": "2017-01-24T01:18:18Z",
          "updatedAt": "2017-01-24T01:18:18Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin I'm not sure I understand. The source maps are generally linked via a URL already ( https://docs.google.com/document/d/1U1RGAehQwRypUTovF1KRlpiOFze0b-_2gc6fAH0KY0k/view#heading=h.lmz475t4mvbx ). Even with an online mandate we don't have a way to refer to contents within different packages so source maps cannot exist within a different package from the generated content.",
          "createdAt": "2017-01-24T05:02:18Z",
          "updatedAt": "2017-01-24T05:02:18Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@bmeck Say https://example.com/index.package contains https://example.com/index.min.js, which says its sourcemap is https://example.com/index.min.js.map. https://example.com/maps.package happens to contain https://example.com/index.min.js.map, but as you said, there's no way to have index.min.js say its sourcemap is https://example.com/index.min.js.map *inside of https://example.com/maps.package*. But that's ok as long as you're online: the browser will just fetch https://example.com/index.min.js.map directly. If you want to pre-cache a bunch of sourcemaps, maybe your devtools will have a way to load a package, and then it won't need to re-download the sourcemap, but that doesn't need to be based on fragments.",
          "createdAt": "2017-01-25T18:43:48Z",
          "updatedAt": "2017-01-25T18:43:48Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin ah, I see the disconnect. I am mostly concerned with Node's ability to use webpackage. So we were looking at something more like a `app.webpackage` and `app_debug_info.webpackage` they would never refer to a sourcemap outside of a `webpackage`. Your assertion is that the sourcemap is available is outside a webpackage always, I was under the assumption that there are debug webpackages that are the source of truth and the sourcemaps contained within are not available outside of those webpackages.",
          "createdAt": "2017-01-25T19:01:36Z",
          "updatedAt": "2017-01-25T19:01:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I see. What if `app.webpackage` included a header:\r\n```\r\nLink: <app_debug_info.webpackage>; rel=debug; type=application/package\r\n```\r\nheader, and Node interpreted that as a request to load the package when trying to debug. When loading `app_debug_info.webpackage`, Node would cache `index.min.js.map` and then use it for requests from `app.webpackage`. This would also work for offline use in a browser.",
          "createdAt": "2017-01-25T20:02:28Z",
          "updatedAt": "2017-01-25T20:02:28Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck but we aren't designing this package format only for Node (or similar). In the context of a web publication, those sourcemaps are a huge security hole since it would allow for reference content across domains - even in signed/trusted content.\r\n\r\nWhile there are some excellent use cases for being able to map relative->absolute URLs, its a major security hole in the general package case.",
          "createdAt": "2017-01-25T23:22:09Z",
          "updatedAt": "2017-01-25T23:22:09Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol if those urls cannot be accessed (does not exist / lack of perms) how is that a security hole?\r\n\r\nI agree that if this allowed cross domain access it would be problematic. I have no desire to allow such, but have a very strong interest in solving packaging debug info. I simply insist it is an important use case. Having a constrained solution is fine to me, but a solution should exist.",
          "createdAt": "2017-01-25T23:47:30Z",
          "updatedAt": "2017-01-25T23:47:30Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@bmeck How do you restrict the URLs that are allowed?  What determines that only \"non-existent/non-resolvable\" URLs could used?  ",
          "createdAt": "2017-01-27T19:09:09Z",
          "updatedAt": "2017-01-27T19:09:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol, given that sourcemaps already exist on the web, and can already refer to cross-origin maps, it doesn't seem that we can or need to restrict them further within packages. The UA can process the `//#` annotation the same as it would if the resource weren't in a package.",
          "createdAt": "2017-01-27T21:50:36Z",
          "updatedAt": "2017-01-27T21:50:36Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't it where the 'scope' attribute of the Link: header provides necessary mapping? Lets say:\r\n\r\nThe package contains 2 subpackages, `app.webpackage` and `app_debug_map.webpackage`.\r\n\r\nThe top-level package would contain 2 Link: headers to list the packages:\r\n\r\n`Link: <https://googleapis.com/packs/jquery.pack>; rel=package; scope=/libs`\r\n`Link: <https://googleapis.com/packs/jquery_debug_map.pack>; rel=package; scope=/libs/maps\r\n....\r\n`\r\nThen the URL `https://googleapis.com/libs/jquery.min.js` will be resolved (scope-matched) to the first webpack, and the map it refers to as h`ttps://googleapis.com/libs/maps/jquery.min.js.map` will be mapped to the second.",
          "createdAt": "2017-01-27T23:57:29Z",
          "updatedAt": "2017-01-27T23:57:29Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin, interesting though AFAICT that only applies to (a) JavaScript\nand (b) when it is used in some form of transpilation.  I don't see any\nusage on the web proper, nor usage outside of JS.   Am I missing something?\n\n\nOn Fri, Jan 27, 2017 at 4:50 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol>, given that sourcemaps\n> already exist on the web, and can already refer to cross-origin maps, it\n> doesn't seem that we can or need to restrict them further within packages.\n> The UA can process the //# annotation the same as it would if the\n> resource weren't in a package.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-275784581>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNd3x9yk5KjyIQIoqUBvz50kW-wTKks5rWmasgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-29T20:03:57Z",
          "updatedAt": "2017-01-29T20:03:57Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol CSS preprocessors and WASM are also affected. I don't know of any HTML/image conventions that use src maps though.",
          "createdAt": "2017-01-29T20:29:32Z",
          "updatedAt": "2017-01-29T20:29:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol Yes, sourcemaps are used for transpilation and little if anything else. When you [said](https://github.com/dimich-g/webpackage/issues/26#issuecomment-275264434) \"sourcemaps are a huge security hole\", what did you mean?",
          "createdAt": "2017-01-30T18:35:32Z",
          "updatedAt": "2017-01-30T18:35:32Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin - thinking about them being used at actual resource load time in\na UA.  The concern being that you could be loading stuff from one domain\nand then remapping it into another one.  That's basically enabling XSS as a\nfeature...\n\nOn Mon, Jan 30, 2017 at 1:35 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> Yes, sourcemaps are used for\n> transpilation and little if anything else. When you said\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-275264434>\n> \"sourcemaps are a huge security hole\", what did you mean?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276149434>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNZXu3geL5iVCoWKvdyw4DwHdKhk7ks5rXi11gaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T20:06:09Z",
          "updatedAt": "2017-01-30T20:06:09Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol can you clarify the `remapping` bit. We aren't loading source maps to alter execution, but they can redefine what source text looks like in dev tools.",
          "createdAt": "2017-01-30T20:10:09Z",
          "updatedAt": "2017-01-30T20:10:09Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Right - I think I understand how they work for dev tools today.  What I am\nstill somewhat unclear on is how that would work in a package that is\ndistributed and then opened on another machine??\n\nOn Mon, Jan 30, 2017 at 3:10 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> can you clarify the remapping\n> bit. We aren't loading source maps to alter execution, but they can\n> redefine what source text looks like in dev tools.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276175820>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNVTXysSv1LPHTAYBcnDP_vvPa8YZks5rXkOigaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T21:36:12Z",
          "updatedAt": "2017-01-30T21:36:12Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, my presumption is that they would contain paths/urls to something potentially off the machine. Though these urls are contained within the resource bodies generally, not in the headers that would be related to webpackage. This is more a question about what to do when such a url is encountered / how to denote that a resource is within a different file. I have no desire to try and lock down what is allowed content within a .js/.css/.wasm file.",
          "createdAt": "2017-01-30T22:03:55Z",
          "updatedAt": "2017-01-30T22:04:04Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": ">Ah, my presumption is that they would contain paths/urls to something potentially off the machine. Though these urls are contained within the resource bodies generally, not in the headers that would be related to webpackage. This is more a question about what to do when such a url is encountered / how to denote that a resource is within a different file. \r\n\r\nAgreed.   To be specific, there are multiple cases here and not sure which you want to support.\r\n\r\nThe normal case is where an absolute URL is mapped to a relative URL (in the package).   For example, you might have a CSS file that refers to an image via absolute URL (eg. background-image: url(\"http://some.domain.com/image.jpg\")).  You want to be able to setup a mapping from that URL to something like \"/images/image.jp\".  However, in that case, the resources must be in the unique origin of the package **not associated with any other domain**!\r\n\r\nThe second case is relative to relative mapping, where the reference is already to \"images/image.jpg\", but as part of packaging, it had to be moved to simply \"image.jpg\", so you need something to map that.  _Same comment about unique origin here as well._\r\n\r\nFinally, we have the really problematic cases, where you are mapping **TO** an absolute URL (either from a relative or another absolute). You don't want to start having a local reference pull something from a remote source, especially if you then try to map it back into the unique domain.\r\n\r\n> I have no desire to try and lock down what is allowed content within a .js/.css/.wasm file.\r\n\r\nMe either.  But we need to do it in a way that is secure.\r\n\r\n\r\n",
          "createdAt": "2017-01-30T22:34:16Z",
          "updatedAt": "2017-01-30T22:34:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Source maps don't alter execution, so even if a malicious sourcemap changes how a string appears while debugging, the original string is still used for all program logic. Sourcemaps can't introduce XSS.",
          "createdAt": "2017-01-30T22:43:02Z",
          "updatedAt": "2017-01-30T22:43:02Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Jeffrey - I understand that is how they work today in the contexts in which\nthey execute.  I am trying to understand how they would be used in the\ncontext of a webpackage, especially as it is loaded by a UA dynamically.\n\nOn Mon, Jan 30, 2017 at 5:43 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Source maps don't alter execution, so even if a malicious sourcemap\n> changes how a string appears while debugging, the original string is still\n> used for all program logic. Sourcemaps can't introduce XSS.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276215877>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNerZP9ZewlwvBH0PLlrF2jZTR108ks5rXmd2gaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T22:57:14Z",
          "updatedAt": "2017-01-30T22:57:14Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "They'd be used in exactly the same way when a webpackage is loaded by a UA dynamically.",
          "createdAt": "2017-01-30T23:02:35Z",
          "updatedAt": "2017-01-30T23:02:35Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "I don't understand how you can do that without using them to remap URLs as\nyou load resources...\n\nOn Mon, Jan 30, 2017 at 6:02 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> They'd be used in exactly the same way when a webpackage is loaded by a UA\n> dynamically.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276220274>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNYQpvZn7DsWNKpP4CM24A1_moiOUks5rXmwMgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T23:04:13Z",
          "updatedAt": "2017-01-30T23:04:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Given a sourcemap, you load and execute resources as if there were no sourcemap. Then, when debugging, you display urls in the devtools as the sourcemap says to remap them. This is the same whether or not there's a package involved.",
          "createdAt": "2017-01-30T23:06:05Z",
          "updatedAt": "2017-01-30T23:06:05Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "So you saying that sourcemaps would **never** be used during normal loading\ntime - but only during debugging?  What use is that for general package\nresource remapping, as I laid out in the previous message?\n\nRemember that a package isn't just scripts - but can/will also be HTML +\nCSS...\n\nOn Mon, Jan 30, 2017 at 6:06 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Given a sourcemap, you load and execute resources as if there were no\n> sourcemap. Then, when debugging, you display urls in the devtools as the\n> sourcemap says to remap them. This is the same whether or not there's a\n> package involved.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276221025>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNQ6JY7HQESHaq1MHh6FAyVmRb4L-ks5rXmzdgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T23:09:21Z",
          "updatedAt": "2017-01-30T23:09:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Sourcemaps aren't much use for resources you haven't transpiled, and folks building packages out of just HTML and non-compiled CSS don't need to use sourcemaps.",
          "createdAt": "2017-01-30T23:12:22Z",
          "updatedAt": "2017-01-30T23:12:22Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "I disagree with you on that point, @jyasskin.  They would be very useful in\nthose cases - as mentioned above...\n\nOn Mon, Jan 30, 2017 at 6:12 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Sourcemaps aren't much use for resources you haven't transpiled, and folks\n> building packages out of just HTML and non-compiled CSS don't need to use\n> sourcemaps.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276222294>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNa9USNH3x37nORJ4r40M5D02gjtpks5rXm5WgaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T23:13:57Z",
          "updatedAt": "2017-01-30T23:13:57Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "That's a different feature than sourcemaps then, and as you pointed out, it comes with significant XSS risks. If possible, I'd like to avoid that sort of distraction in at least the initial version of the packaging format.",
          "createdAt": "2017-01-30T23:23:19Z",
          "updatedAt": "2017-01-30T23:23:19Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Glad that we're now on the same page...\n\nAnd keeping them separate makes perfect sense - however, I then envision\nthat in version > 1, that we now have **two** mapping syntaxes in the same\nformat...and that would seem to yield more confusion for the UA that has to\nimplement.  (or maybe not...)\n\n\nOn Mon, Jan 30, 2017 at 6:23 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> That's a different feature than sourcemaps then, and as you pointed out,\n> it comes with significant XSS risks. If possible, I'd like to avoid that\n> sort of distraction in at least the initial version of the packaging format.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/26#issuecomment-276224531>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNf0ExawYwu4xn1bq1-WpdDJVzH2fks5rXnDogaJpZM4Lh8Sr>\n> .\n>\n",
          "createdAt": "2017-01-30T23:30:03Z",
          "updatedAt": "2017-01-30T23:30:03Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Even if we spend the time to design a new mapping system for version 1, sourcemaps already exist and are in wide use, so we'd still have two mapping syntaxes. The only piece that might be redundant is the `Link:` header I suggested, which @dimich-g pointed out could maybe be subsumed by the `scope` attribute that we want anyway.",
          "createdAt": "2017-01-31T00:09:11Z",
          "updatedAt": "2017-01-31T00:09:11Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md proposes a URL scheme to point directly to package/bundle subresources. It's been discussed some at https://www.ietf.org/proceedings/108/minutes/minutes-108-wpack-00 and https://mailarchive.ietf.org/arch/msg/wpack/8fFVJv0AIksODEha8iyJrVDvOek/, and some difficulties with using it as a top-level URL are in https://github.com/w3ctag/design-reviews/issues/509.",
          "createdAt": "2020-10-20T00:32:05Z",
          "updatedAt": "2020-10-20T00:32:05Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "Can someone paint a picture of what is wrong with the original request in the beginning? Why is there a discussion here at all?\r\n\r\nIf there is `/index.min.js` in one bundle and `/index.min.js.map` in another bundle, what is the issue? Imo as a user on the web, posessing these two bundles, the resources of both should be available to me? No?\r\n\r\nThis question is phrased in terms of linking. That's somewhat nonsensical to me. Bundles are a collection of resources that I the user have. If I have multiple bundles, I would like the content to work across them? There's no \"linking\" to a bundle needed, is there? My expectation and hope as a user is that packages/bundles are available resources to my offline-capable PWA, for example.\r\n\r\nTo suppement the development use case outlined at the start, a user-focused use case might be an ebook reader. I go to guten-bundle.example, an example website for hosting Project Gutenberg books, and I download a bundle for Frankenstein and a bundle for Pride and Prejudice. My desire, what I hope would be possible, with a good, user-serving implementation of web packages/web bundles, is to have both /frankenstein.ebook and /pride-and-prejudice.ebook available to my offline service-worker application. This would also permit me to share either of these bundles with others.\r\n\r\nThe above user needs are heightened the bigger the bundle. If I have a bundle for El Paquet Semanal, this is content that I might want or need to access from a variety of tools & sources. Maybe one day I am in a document editor & want to put a clip art into the document from the EPS bundle. Maybe the next day I am looking for audio samples to mix, and want to pull from the EPS bundle. As a user, my need is a general purpose bundle with assets that I can opt to make use of.\r\n\r\nThe original post here implies this would  not be possible. Why was this issue opened? What impedes `/index.min.js.map` from being available when requested? How can we empower users to be able to use the resources they have available to them?",
          "createdAt": "2020-10-24T01:59:22Z",
          "updatedAt": "2020-10-24T02:14:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@rektide The original issue exists because the user might have loaded the bundle containing `/index.min.js` but *not* yet loaded the bundle containing `/index.min.js.map`. `/index.min.js` needs to give the UA instructions for what to do if the user tries to debug it. Just saying \"load `/index.min.js.map`\" (as [I suggested early in the discussion](https://github.com/WICG/webpackage/issues/26#issuecomment-274671830)) isn't really the right thing to do if the user's likely to want a bunch of different `.map` files: it should instead say which bundle to load to get all of them. But just saying \"use `/page.wbn`\" isn't right either: it doesn't say which subresource inside the bundle corresponds to `/index.min.js`. So two options are to have a global [link to the resources](https://github.com/WICG/webpackage/issues/26#issuecomment-275806362) that are [needed for debugging](https://github.com/WICG/webpackage/issues/26#issuecomment-275217020) or to have each link point to a subresource nested inside a bundle.\r\n\r\nThe debugging case isn't the primary one I care about for the [URL scheme](https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md), but the issue title matches what that does.",
          "createdAt": "2020-10-25T21:38:56Z",
          "updatedAt": "2020-10-25T21:38:56Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "Rather than invent a new URL scheme, I feel like I'd want the server to throw a `Alt-Svc` or some kind of designator that the resource is already on it's way via, being sent. That way links can be into plain-old-regular uniform address space, versus needing to be these deep links? I as a rule tend to prefer giving things that can have URLs a URL, but I'm pretty leery of trying to name things inside bundles; that's an expansive realm of complexity.\r\n\r\nThanks for the good overview @jyasskin. I'm also concerned that there may be storage api \"shelf\" concerns here too that would keep \"just load `/index.min.js.map`\" from working? How & when would storage api shelves obstruct this flow? Or is it 100% an issue of the bundle not being loaded yet (which would be fantastic!)?",
          "createdAt": "2020-10-26T18:36:55Z",
          "updatedAt": "2020-10-26T18:36:55Z"
        }
      ]
    },
    {
      "number": 29,
      "id": "MDU6SXNzdWUyMDMyNzc3MTE=",
      "title": "Subpackage should have index in main package",
      "url": "https://github.com/WICG/webpackage/issues/29",
      "state": "CLOSED",
      "author": "jianli-chromium",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Without index, we will have to scan the whole package to find it out.",
      "createdAt": "2017-01-26T02:18:30Z",
      "updatedAt": "2019-05-13T16:48:21Z",
      "closedAt": "2019-05-13T16:48:21Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think #36 fixes this: https://github.com/dimich-g/webpackage#index",
          "createdAt": "2017-03-30T17:51:54Z",
          "updatedAt": "2017-03-30T17:51:54Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jianli-chromium can this be closed?",
          "createdAt": "2017-08-09T14:52:48Z",
          "updatedAt": "2017-08-09T14:52:48Z"
        }
      ]
    },
    {
      "number": 30,
      "id": "MDU6SXNzdWUyMDMyNzg1MjA=",
      "title": "Generated name should be used to denote a subresource if there is not a corresponding pack file in the server",
      "url": "https://github.com/WICG/webpackage/issues/30",
      "state": "CLOSED",
      "author": "jianli-chromium",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For subpackage that contains pages and resources downloaded from one domain, but not through pack file offered by that domain, we should not use http://foo.com/something.pack since it does not exist in the server. Probably we should use a generated name.",
      "createdAt": "2017-01-26T02:25:15Z",
      "updatedAt": "2019-05-13T16:49:02Z",
      "closedAt": "2019-05-13T16:49:02Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Subpackages aren't in the spec anymore.",
          "createdAt": "2019-05-13T16:49:02Z",
          "updatedAt": "2019-05-13T16:49:02Z"
        }
      ]
    },
    {
      "number": 32,
      "id": "MDU6SXNzdWUyMDM1MTE2MzE=",
      "title": "Document Adobe's use cases",
      "url": "https://github.com/WICG/webpackage/issues/32",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@lrosenthol, could you describe the use cases you're interested in for the packaging format, either in this issue or as a PR against the [`README.md`](https://github.com/dimich-g/webpackage/blob/master/README.md)?",
      "createdAt": "2017-01-26T22:45:10Z",
      "updatedAt": "2019-05-13T16:49:31Z",
      "closedAt": "2019-05-13T16:49:31Z",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin I became involved in this project due to Adobe's involvement in the [Web Publications](https://w3c.github.io/dpub-pwp/) work at the W3C and the filing of issue #3 .  However, we are also interested in the work with Node & Electron, as they are technologies that we use internally.\r\n\r\nPersonally, I have a very long (30+ year) history with archiving and packaging formats having been one of the founders of Aladdin Systems, which was responsible for [StuffIt](https://en.wikipedia.org/wiki/StuffIt).",
          "createdAt": "2017-01-27T14:02:50Z",
          "updatedAt": "2017-01-27T14:02:50Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks, so http://w3c.github.io/dpub-pwp-ucr/index.html covers the use cases? Also thanks for explaining your background.",
          "createdAt": "2017-01-27T16:11:23Z",
          "updatedAt": "2017-01-27T16:11:23Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Yes, that would be the right document to work from.\n\nOn Fri, Jan 27, 2017 at 11:11 AM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Thanks, so http://w3c.github.io/dpub-pwp-ucr/index.html covers the use\n> cases? Also thanks for explaining your background.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/32#issuecomment-275703397>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNaz1az1nrY1Q5NKEw7OHon1KjiBzks5rWhcsgaJpZM4LvPIw>\n> .\n>\n",
          "createdAt": "2017-01-27T18:57:54Z",
          "updatedAt": "2017-01-27T18:57:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Looking at dpub-pwp-ucr, it doesn't mention signing the publication. Given your other comments, I assume Adobe does have requirements around signatures, so could you write them down somewhere?\r\n\r\nI'll also admit that the Chrome folks are going to prioritize letting browsers give a package the [same origin](https://html.spec.whatwg.org/multipage/browsers.html#same-origin) as content loaded over HTTPS, over any Web Publications requirements, if there's a conflict. I don't see any impossible conflicts yet, especially if we allow multiple certificates to sign the same package, but FYI.",
          "createdAt": "2017-01-27T22:07:12Z",
          "updatedAt": "2017-01-27T22:07:12Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin Nothing Adobe-centric here - just me representing the PWP community as one of the editors of the works in progress.  \r\n\r\nSigning a publication is simply one well-established model to establish trust on a set of \"off the web\" resources - just as it is here with web packages.  That's what this entire discussion is about - how to establish that trust so that both the user and the UA feel safe in using some/all of the resources in a package/publication.\r\n\r\nThe entire work on sub-domains is also something interesting to the world of publications, where a single \"physical\" publication may actually be a collection of publications - in which case, sub-domains would serve to help with a variety of potential problems.",
          "createdAt": "2017-01-29T20:11:02Z",
          "updatedAt": "2017-01-29T20:11:02Z"
        }
      ]
    },
    {
      "number": 33,
      "id": "MDU6SXNzdWUyMDM1MTE3NTU=",
      "title": "Document Node's use cases",
      "url": "https://github.com/WICG/webpackage/issues/33",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@bmeck, could you describe the use cases you're interested in for the packaging format, either in this issue or as a PR against the [`README.md`](https://github.com/dimich-g/webpackage/blob/master/README.md)?",
      "createdAt": "2017-01-26T22:45:48Z",
      "updatedAt": "2019-05-13T16:49:49Z",
      "closedAt": "2019-05-13T16:49:49Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "From an older call: https://docs.google.com/document/d/1iPHPLMUVimh8cZgB_vkO-XtmDrnanOMI9v5kfnwiv4U/view",
          "createdAt": "2017-02-01T19:16:12Z",
          "updatedAt": "2017-02-01T19:16:12Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Mandatory:\r\n\r\n- [x] Signing\r\n- [x] Random Access (via manifest)\r\n- [x] Self Extracting capable\r\n\r\nImportant but not absolute requirements (would need some path to mitigate):\r\n\r\n- [ ] Inter-package linking\r\n- [x] Nested packages\r\n- [ ] Deduplication\r\n\r\nNice to have:\r\n\r\n- [ ] Streaming\r\n- [x] Expiration",
          "createdAt": "2017-02-01T19:59:00Z",
          "updatedAt": "2017-03-30T19:22:49Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "mandatory requirements have been reached, feel free to mark closed",
          "createdAt": "2017-03-30T19:23:21Z",
          "updatedAt": "2017-03-30T19:23:21Z"
        }
      ]
    },
    {
      "number": 35,
      "id": "MDU6SXNzdWUyMDU3MzA1NDQ=",
      "title": "Electron user stories",
      "url": "https://github.com/WICG/webpackage/issues/35",
      "state": "CLOSED",
      "author": "groundwater",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi all, I saw some of you at Blink On, and I promised to come up with a few user stories. Rather than trying help shape the implementation, I thought I could just outline why electron is looking at this format. Here's my first pass at some user stories.\r\n\r\n## App Installer Story\r\n\r\nDeveloper Kim builds a new electron app, and wants to host it on her site. She wants to make the install as easy as possible, and a new hot installation tool some people have downloaded knows how to take a web package, and install it like a desktop app. Right now, every electron app comes with its own chromium. A web package format distribution could link out to the required chromium, which may already be installed on the users desktop.\r\n\r\nThe end-user downloads the `.electron` bundle, double-clicks it, and the installer installs a new app.\r\n\r\nBoth the installer, and the operating system should be validating the package and checking code signatures. (Open question if the dynamic installer messes up the signature story)\r\n\r\nA new icon is placed wherever there operating system installs applications, and double-clicking it opens the app.\r\n\r\n## Lifecycle with _shared_ resources\r\n\r\nKim is at it again, but this time her users have demanded an even slimmer after install experience. Kim builds the next web package bundle, but instead of including everything in `node_modules` the web package simply links out to indicate that a requires these and PM modules at specific versions. To complicate matters, some of these modules require compilation.\r\n\r\nKim knows that not all of her users have developer tools installed, but also doesn't want to set up CI on numerous different platforms. That's okay, we have your back. The top 100 electron modules that require compilation have been precompiled on common platforms packaged into a web package format.\r\n\r\nUser Angela downloads Kim's latest web package, which only includes the core app code. The installer understands the outbound links in the web package, and first attempts to satisfy them with a local cache on disk. One of the compiled dependencies is missing however, and the installer has to downloaded fresh. Instead of pulling from npm directly, the installer is able to resolve the location of a precompiled version and use that.\r\n\r\n## BigCorp\r\n\r\nBig Corp once control over every last bit of their installed application. They want to block every last piece down. They want a self-contained packaging format, where everything gets shipped altogether.\r\n\r\nThis is the situation we have now, which is why it's worth putting down.\r\n\r\n## BigCrop Internal\r\n\r\nInternally at big Corp, they have a lot of internal tools developers that wish to distribute quick one-off applications. Because everything is running behind their firewall, they only want vetted code. Developers love the hotlinking that the web package can do, but all links should resolve to an internal npm mirror and an internal blob store for precompiled modules.",
      "createdAt": "2017-02-06T22:43:56Z",
      "updatedAt": "2019-05-13T16:50:43Z",
      "closedAt": "2019-05-13T16:50:43Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think these have been incorporated into the [use cases document](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html).",
          "createdAt": "2019-05-13T16:50:43Z",
          "updatedAt": "2019-05-13T16:50:43Z"
        }
      ]
    },
    {
      "number": 38,
      "id": "MDU6SXNzdWUyMDY5NDc1NDY=",
      "title": "Switch to binary format and more.",
      "url": "https://github.com/WICG/webpackage/issues/38",
      "state": "CLOSED",
      "author": "dimich-g",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Hi,\r\n\r\nCapturing recent conversations with @jyasskin and @mrdewitt:\r\n\r\n1. We think it makes sense to switch to 100% binary format since the header compression and parts body compression makes it mostly binary anyways. It also lets us to replace MIME boundary strings with direct chunk-size kind of encoding.\r\n2. The Explainer and samples in it will be gradually updated to reflect switch to binary encoding. While in update, there can be some inconsistency in the doc.\r\n\r\nAlso discussed:\r\n- Binary alignment at 32 bit boundaries (decided not to)\r\n- Use Self-Delimiting Numeric Values (rfc 6256) (decided not to)\r\n- Split content index and offset table (so the resources may be rearranged)\r\n- Multiple hashes (to support deprecation of old ones)\r\n- Cross-signing\r\n",
      "createdAt": "2017-02-11T01:43:58Z",
      "updatedAt": "2017-06-27T22:41:25Z",
      "closedAt": "2017-06-27T22:41:25Z",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "If you are moving to a binary format - why not use an existing one instead\nof inventing yet another one?\n\nOn Fri, Feb 10, 2017 at 8:43 PM, Dmitry Titov <notifications@github.com>\nwrote:\n\n> Hi,\n>\n> Capturing recent conversations with @jyasskin\n> <https://github.com/jyasskin> and @mrdewitt <https://github.com/mrdewitt>:\n>\n>    1. We think it makes sense to switch to 100% binary format since the\n>    header compression and parts body compression makes it mostly binary\n>    anyways. It also lets us to replace MIME boundary strings with direct\n>    chunk-size kind of encoding.\n>    2. The Explainer and samples in it will be gradually updated to\n>    reflect switch to binary encoding. While in update, there can be some\n>    inconsistency in the doc.\n>\n> Also discussed:\n>\n>    - Binary alignment at 32 bit boundaries (decided not to)\n>    - Use Self-Delimiting Numeric Values (rfc 6256) (decided not to)\n>    - Split content index and offset table (so the resources may be\n>    rearranged)\n>    - Multiple hashes (to support deprecation of old ones)\n>    - Cross-signing\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/38>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNVOpv6nACGgd-JbgukU8oqFXpRHLks5rbRJegaJpZM4L-CAb>\n> .\n>\n",
          "createdAt": "2017-02-14T23:40:26Z",
          "updatedAt": "2017-02-14T23:40:26Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol Which existing one? Note the considerations at https://github.com/w3ctag/packaging-on-the-web#rejected-approaches",
          "createdAt": "2017-02-14T23:45:53Z",
          "updatedAt": "2017-02-14T23:46:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "[CBOR](http://cbor.io/) is an option for the package structure, and it even has a draft schema definition language, [CDDL](https://tools.ietf.org/html/draft-greevenbosch-appsawg-cbor-cddl-09). It won't be quite as compact as something we do custom, but it'll be easier to debug and to extend in the future.",
          "createdAt": "2017-02-15T19:50:05Z",
          "updatedAt": "2017-02-15T19:50:05Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "CBOR looks interesting. It seems to support streaming on receiving end as well.",
          "createdAt": "2017-02-15T21:01:46Z",
          "updatedAt": "2017-02-15T21:01:46Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "CBOR does look interesting, but seems to be more focused on handling a\nsingle file and not a package/collection of files & resources. I think we\nneed a more classic archiving format - something like a ZIP or StuffIt -\nbut with modern sensibilities.  I'll do some research\n\nOn Wed, Feb 15, 2017 at 4:01 PM, Dmitry Titov <notifications@github.com>\nwrote:\n\n> CBOR looks interesting. It seems to support streaming on receiving end as\n> well.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/38#issuecomment-280137551>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNRW1nXyJEUNjLiSLLVF6OohBQ-jEks5rc2e6gaJpZM4L-CAb>\n> .\n>\n",
          "createdAt": "2017-02-16T01:31:25Z",
          "updatedAt": "2017-02-16T01:31:25Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "There are 2 orthogonal things - binary encoding and then an index/manifest/hashing structure.  Formats like CBOR provide the former w/o attempting to provide the latter. So if we want specific structure and content of the package metadata (index, manifest, certificates and hashes), and don't care much about the way to assemble those pieces into a binary file with chunks of certain size is not important.\r\n\r\nThe main issue with Zip and other archiving formats is they mostly were developed without streaming on receiving and with fixed and/or limited set of metadata, and they will have to be 'augmented' in one way or another.\r\n\r\nCBOR seems to be a simple way to assemble length-prefixed and variable-length records, arrays and maps, and supports variable-length numbers, byte blobs and UTF-8 strings. No notion of a directory or hashing, which seems to be a good thing since those are exactly the subject of this proposal.",
          "createdAt": "2017-02-16T17:58:11Z",
          "updatedAt": "2017-02-16T17:58:11Z"
        },
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "It is small potatoes, but CBOR has already got debug tools and pretty\nprinters, so we'd have a head start on tooling as well.\n\nOn Thu, Feb 16, 2017 at 9:58 AM Dmitry Titov <notifications@github.com>\nwrote:\n\n> There are 2 orthogonal things - binary encoding and then an\n> index/manifest/hashing structure. Formats like CBOR provide the former w/o\n> attempting to provide the latter. So if we want specific structure and\n> content of the package metadata (index, manifest, certificates and hashes),\n> and don't care much about the way to assemble those pieces into a binary\n> file with chunks of certain size is not important.\n>\n> The main issue with Zip and other archiving formats is they mostly were\n> developed without streaming on receiving and with fixed and/or limited set\n> of metadata, and they will have to be 'augmented' in one way or another.\n>\n> CBOR seems to be a simple way to assemble length-prefixed and\n> variable-length records, arrays and maps, and supports variable-length\n> numbers, byte blobs and UTF-8 strings. No notion of a directory or hashing,\n> which seems to be a good thing since those are exactly the subject of this\n> proposal.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/38#issuecomment-280407885>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABQXzu8O_nbEWIOoQ7krTnKr6ERfmEWMks5rdI4zgaJpZM4L-CAb>\n> .\n>\n",
          "createdAt": "2017-02-16T18:06:19Z",
          "updatedAt": "2017-02-16T18:06:19Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #36.",
          "createdAt": "2017-03-30T17:50:53Z",
          "updatedAt": "2017-03-30T17:50:53Z"
        }
      ]
    },
    {
      "number": 39,
      "id": "MDU6SXNzdWUyMTg5NDI3ODM=",
      "title": "Figure out unsigned sub-packages",
      "url": "https://github.com/WICG/webpackage/issues/39",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From @dimich-g's https://github.com/dimich-g/webpackage/pull/36#issuecomment-290316360:\r\n\r\nWithout a signed manifest, there's no structure to identify sub-packages.\r\n\r\nHowever, it might just work to lump all the resources together at the top level. Do we need to identify the sub-package structure?",
      "createdAt": "2017-04-03T13:59:48Z",
      "updatedAt": "2019-05-13T16:51:39Z",
      "closedAt": "2019-05-13T16:51:39Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Can you clarify\r\n\r\n> lump all the resources together at the top level\r\n\r\nSub-packages are certainly distinct, even if unsigned.",
          "createdAt": "2017-04-03T15:00:10Z",
          "updatedAt": "2017-04-03T15:00:10Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Sorry for my delay in replying. If a package consists of a bunch of resources, and a sub-package consists of a bunch of resources with distinct URLs, do we need to have the packaging format distinguish the sub-package's resources from the main package's resources? How would a package consumer use that information?",
          "createdAt": "2017-04-12T03:56:48Z",
          "updatedAt": "2017-04-12T03:56:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We don't have subpackages anymore.",
          "createdAt": "2019-05-13T16:51:39Z",
          "updatedAt": "2019-05-13T16:51:39Z"
        }
      ]
    },
    {
      "number": 40,
      "id": "MDU6SXNzdWUyMTg5OTcwMzE=",
      "title": "Allow linking to sub-packages instead of just including them",
      "url": "https://github.com/WICG/webpackage/issues/40",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "architecture",
        "feature request"
      ],
      "body": "From @dimich-g's https://github.com/dimich-g/webpackage/pull/36#issuecomment-290316360:\r\n\r\nHaving external sub-packages could be useful to tell the UA that it's likely to need some files, without incurring an extra download cost when the UA happens to already have that package.",
      "createdAt": "2017-04-03T16:56:18Z",
      "updatedAt": "2019-05-13T16:55:24Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 41,
      "id": "MDU6SXNzdWUyMTkwMDExNTI=",
      "title": "Optimize the storage of the resource URLs in the manifest, index, and main content",
      "url": "https://github.com/WICG/webpackage/issues/41",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "From @dimich-g's https://github.com/dimich-g/webpackage/pull/36#issuecomment-290316360:\r\n\r\nThe `resource-key` structure (which holds a URL and possibly a set of request headers) is used as the key for the index, manifest, and main content. URLs can be fairly long, so we may want to optimize or compress that redundancy.\r\n\r\nOne idea for avoiding this duplication: Add a section of abbreviations that assigns each resource-key an index, and use those indices as the keys in the other three sections.\r\n\r\n1. We could re-use the index as that section of abbreviations.\r\n2. We probably don't want to re-use the manifest as that section, so that aggregating packages can build their own abbreviations.\r\n3. The abbreviations need to be expanded before hashing or checking signatures.\r\n4. We could shorten the abbreviation section even more by:\r\n   1. Resolving each URL/resource-key relative to the previous one.\r\n   1. Using the array index of the URL as its abbreviation instead of making the section name an abbreviation.\r\n\r\nAnother possibility would be to use a shared brotli dictionary to compress all three sections. The main downside here is that shared brotli dictionaries don't exist yet, and when they do, we may want to use a URL to identify which shared dictionary to use, which we'd again want to compress.",
      "createdAt": "2017-04-03T17:11:58Z",
      "updatedAt": "2017-05-11T00:02:03Z",
      "closedAt": "2017-05-11T00:02:03Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "In face-to-face discussion, we settled on the following arrangement:\r\n* The index holds the only copy of the `resource-key`s.\r\n* They point into an array of response-header/body pairs, where you can't interpret this response pair without knowing the resource-key that points to it.\r\n* The manifest holds only a list of valid hashes for its origin, where a hash is computed over `resource-key||response-header||body`. I believe this guarantees that changing the untrusted index can't cause a body to be accessible by a different resource-key.\r\n\r\nThis also removes an attack where one might check validity over a resource found via the index, but then use a resource with the same `resource-key` found by linearly-searching the content, since now it's impossible to find resources by linearly-searching the content.",
          "createdAt": "2017-04-09T17:11:31Z",
          "updatedAt": "2017-04-09T17:11:31Z"
        }
      ]
    },
    {
      "number": 42,
      "id": "MDU6SXNzdWUyMTkwMDE0MDc=",
      "title": "Update examples for CBOR format",
      "url": "https://github.com/WICG/webpackage/issues/42",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/dimich-g/webpackage#use-cases has lots of examples that use an old version of the design.",
      "createdAt": "2017-04-03T17:12:55Z",
      "updatedAt": "2019-05-13T16:52:21Z",
      "closedAt": "2019-05-13T16:52:21Z",
      "comments": [
        {
          "author": "BigBlueHat",
          "authorAssociation": "NONE",
          "body": "@jyasskin is there a place to get visibility into the move to CBOR? The MIME-like packaging format described in the original [web-packaging](https://www.w3.org/TR/web-packaging/) spec felt very familiar and comfortable. :smiley: Mostly curious as to the choices made.\r\n\r\nThanks!\r\n:tophat:",
          "createdAt": "2017-06-02T20:50:42Z",
          "updatedAt": "2017-06-02T20:50:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#10 and #38 discuss the decision to move to a binary format. We also got feedback that it was hard to reliably generate the MIME boundary strings that the TAG's format needed, and that length prefixing was easier.",
          "createdAt": "2017-06-02T20:56:50Z",
          "updatedAt": "2017-06-02T20:56:50Z"
        },
        {
          "author": "BigBlueHat",
          "authorAssociation": "NONE",
          "body": "@jyasskin much thanks for the description and the links! CBOR does look promising. Cheers!",
          "createdAt": "2017-06-07T19:23:27Z",
          "updatedAt": "2017-06-07T19:23:27Z"
        }
      ]
    },
    {
      "number": 43,
      "id": "MDU6SXNzdWUyMTkzNDQ2MDg=",
      "title": "Remove references to urn:uuid URLs",
      "url": "https://github.com/WICG/webpackage/issues/43",
      "state": "CLOSED",
      "author": "mrdewitt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "With the switch to CBOR, we no longer need urn:uuid URLs for special parts.  Some of the example sections still refer to that type of URL.",
      "createdAt": "2017-04-04T18:40:22Z",
      "updatedAt": "2018-05-08T22:55:37Z",
      "closedAt": "2018-05-08T22:55:37Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I believe these are all gone.",
          "createdAt": "2018-05-08T22:55:37Z",
          "updatedAt": "2018-05-08T22:55:37Z"
        }
      ]
    },
    {
      "number": 45,
      "id": "MDU6SXNzdWUyMjExMTYzNzA=",
      "title": "Explain why we're not using ZIP",
      "url": "https://github.com/WICG/webpackage/issues/45",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "We have some hints in https://w3ctag.github.io/packaging-on-the-web/#intro, but it's not complete, and it needs to appear in the local explainer, not something remote.\r\n\r\nOther considerations against zip:\r\n* We've seen vulnerabilities caused by validating one copy of a resource but using a different one. #41 will avoid this for the CBOR-based format.\r\n* Zip resources are identified by filename, which isn't the primary key of web resources.\r\n* Zip resources don't include response headers.\r\n* Lots of details in the [format](https://www.iana.org/assignments/media-types/application/zip) are archaic and wouldn't be used.\r\n\r\nWe should probably also list reasons in favor of re-using zip so that proponents know we've considered their arguments:\r\n* A huge number of other formats are based on zip, so we're unlikely to run into something we can't express.\r\n* Existing tools would be able to extract packages.",
      "createdAt": "2017-04-12T00:16:56Z",
      "updatedAt": "2019-05-13T16:53:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "should make sure that the fact that .zip has duplication of headers that can cause mismatch of local vs central headers is mentioned",
          "createdAt": "2017-05-30T17:13:11Z",
          "updatedAt": "2017-05-30T17:13:11Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "how many of these arguments also stand against lzo or lz4 or (best) zstd?\r\n\r\ni'd also be interested in seeing how much of the raging popular https://github.com/opencontainers/image-spec would make sense to use, vs how much doesn't match up?",
          "createdAt": "2017-10-05T03:31:31Z",
          "updatedAt": "2017-10-05T03:31:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@rektide I believe lzo, lz4, and zstd are better compression algorithms, and none of the arguments are about any quality issues in zip's compression, so ... all of them?\r\n\r\nI haven't looked through the opencontainers spec and will do so. Thanks for the pointer.",
          "createdAt": "2017-10-17T04:26:13Z",
          "updatedAt": "2017-10-17T04:26:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Now that I've skimmed https://github.com/opencontainers/image-spec, it seems mostly-inapplicable. https://github.com/opencontainers/image-spec/blob/master/layer.md doesn't appear to support [random access](https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-00#section-3.1.5) because it's a tar file. I'm having trouble finding the primary key of items in the image, but it seems like it's a path, contrary to https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-00#section-3.1.1.",
          "createdAt": "2017-12-12T21:54:08Z",
          "updatedAt": "2017-12-12T21:54:08Z"
        },
        {
          "author": "skhameneh",
          "authorAssociation": "NONE",
          "body": "lz4 preferred for speed, zstd preferred for ratio.\r\n\r\nI am working on a similar packaging format and have a working tool, see\r\nhttps://github.com/lbryio/lbry-format\r\n\r\nI am very interested in cross adoption, @jyasskin  \ud83d\ude03 ",
          "createdAt": "2019-01-15T20:22:46Z",
          "updatedAt": "2019-01-15T20:22:46Z"
        }
      ]
    },
    {
      "number": 47,
      "id": "MDU6SXNzdWUyMjE0NTk3NzY=",
      "title": "Consider switching to DER-encoded ASN.1",
      "url": "https://github.com/WICG/webpackage/issues/47",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I received feedback from some of our security people that [DER](https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf) is easier to parse securely than [CBOR](https://tools.ietf.org/html/rfc7049). I'm not 100% sure that's the right choice yet, so here are some pros and cons.\r\n\r\nDER Pro's:\r\n1. Much older, with security-hardened implementations in many languages. e.g. BoringSSL includes a library for memory-safe DER parsing. CBOR has [many implementations](http://cbor.io/impls.html), but they aren't hardened.\r\n1. Prefixing with the length in bytes makes it easier to skip unneeded items. CBOR can work around this by embedding things into bytestrings.\r\n1. Generic parsing has only 2 cases: Primitive, where the interpretation of the bytes depends on the tag, and Constructed, where the content bytes encode a sequence of items. CBOR has 8 cases: integer, string, array, map, tag, simple value, simple value in next byte, and float. This is primarily used to skip unknown fields in structures.\r\n\r\nCBOR Pro's:\r\n1. ~8 primitive types instead of 30+. We can subset ASN.1 to only use INTEGER, OCTET STRING, UTF8String, and SEQUENCE, but we can also subset CBOR to use integers, byte strings, text strings, arrays, and maps.\r\n1. Extensibility based on maps from strings to values is easier to understand and possibly to manage than ASN.1's extensibility based on appending to sequences. However, it's possible I've missed a better way to extend structures in ASN.1.\r\n1. It's easy to find the latest specification.\r\n1. Combining the length into the type saves a byte for smaller items.\r\n1. Serializing canonical CBOR, which is needed for signature checking, is significantly easier to implement.\r\n1. All DER integers and floats have to deal with the complexity of encoding bignums. For our purposes, where bignums aren't needed, CBOR's 8,16,32, and 64-bit integers are simpler. Even if bignums were needed, it's likely that a fixed length would be simpler to specify and implement than DER's variable-length encoding.\r\n\r\n\r\nIf we stick with CBOR, we'll mandate [Canonical CBOR](https://tools.ietf.org/html/rfc7049#section-3.9), which includes minimal integer encodings. That means offsets will need to measure a range that doesn't include the offset itself, but that's doable for both the section list and the resource index.\r\n\r\nI'll update this list as more considerations come up.",
      "createdAt": "2017-04-13T05:09:55Z",
      "updatedAt": "2019-05-13T16:54:03Z",
      "closedAt": "2019-05-13T16:54:03Z",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "You also have the fact that DER has been around a lot longer and there are\nmany implementations in many different languages.  As noted, it's undergone\na lot more scrutiny for security, etc.\n\nOn Thu, Apr 13, 2017 at 1:09 AM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> I received feedback from some of our security people that DER\n> <https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf> is\n> easier to parse securely than CBOR <https://tools.ietf.org/html/rfc7049>.\n> I'm not 100% sure that's the right choice yet, so here are some pros and\n> cons.\n>\n> DER Pro's:\n>\n>    1. BoringSSL includes a library for memory-safe DER parsing. We'd have\n>    to write our own for CBOR.\n>    2. Prefixing with the length in bytes makes it easier to skip unneeded\n>    items. CBOR can work around this by embedding everything into bytestrings.\n>    3. Generic parsing has only 2 cases: Primitive, where the\n>    interpretation of the bytes depends on the tag, and Constructed, where the\n>    content bytes encode a sequence of items. CBOR has 8 cases: integer,\n>    string, array, map, tag, simple value, simple value in next byte, and float.\n>\n> CBOR Pro's:\n>\n>    1. ~8 primitive types instead of 30+. However, I think we can subset\n>    ASN.1 to only use BOOLEAN, INTEGER, OCTET STRING, UTF8String, and SEQUENCE.\n>    2. Extensibility based on maps from strings to values is easier to\n>    understand and possibly to manage than ASN.1's extensibility based on\n>    appending to sequences. However, it's possible I've missed a better way to\n>    extend structures in ASN.1.\n>    3. It's easy to find the latest specification.\n>    4. Combining the length into the type saves a byte for smaller items.\n>\n> Even if we stick with CBOR, I'm inclined to mandate Canonical CBOR\n> <https://tools.ietf.org/html/rfc7049#section-3.9>, which includes minimal\n> integer encodings. That means offsets will need to measure a range that\n> doesn't include the offset itself, but I think that's doable for both the\n> section list and the resource index.\n>\n> I'll update this list as more considerations come up.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/47>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNayKVCul9V4IR7UQx3TT-M0eGBqRks5rva4jgaJpZM4M8Q7U>\n> .\n>\n",
          "createdAt": "2017-04-13T13:15:21Z",
          "updatedAt": "2017-04-13T13:15:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol Incorporated.",
          "createdAt": "2017-04-13T18:50:48Z",
          "updatedAt": "2017-04-13T18:50:48Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@hsivonen mentioned that CBOR doesn't define error handling: https://tools.ietf.org/html/rfc7049#section-3.3. Does DER? I think we absolutely do not want to introduce a new format in browsers without well-defined error handling. (And forking CBOR to add error handling reduces the utility of reusing it.)",
          "createdAt": "2018-01-26T07:34:19Z",
          "updatedAt": "2018-01-26T07:34:19Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@annevk https://www.itu.int/ITU-T/studygroups/com17/languages/X.690-0207.pdf appears to be the spec for DER, and it only specifies how encoders must encode things, not how parsers decode or handle errors.\r\n\r\nI think the right place to specify error handling is the same places I'm currently requiring parsers to fail when an item wasn't encoded canonically. I should also be explicit that they must fail and return no data for invalid items.",
          "createdAt": "2018-01-26T23:26:53Z",
          "updatedAt": "2018-01-26T23:26:53Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "(DER parsers are supposed to reject non-canonical inputs, yes. That's the whole point of DER.)",
          "createdAt": "2018-01-26T23:56:55Z",
          "updatedAt": "2018-01-26T23:56:55Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm inclined to stick with CBOR. It seems noticeably simpler than DER for both the encoder and decoder, even if I try to subset DER, and I'm not confident I understand ASN.1 well enough to subset it.",
          "createdAt": "2018-01-29T04:53:30Z",
          "updatedAt": "2018-01-29T04:53:30Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "As an implementer, I'd also like to vote on using CBOR. The CBOR format was so simple and obvious to implement.\r\nre: error handling, I found the simple \"reject any non-canonical input\" to be enough to clarify the implementation.\r\nIn addition, Chromium already has a fuzz-tested CBOR encoder/decoder (for prior use-case in [Web Authentication](https://www.w3.org/TR/webauthn/)).",
          "createdAt": "2018-01-29T05:30:37Z",
          "updatedAt": "2018-01-29T05:30:37Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Chromium had a fuzz-tested DER encoder/decoder for much much longer by way of X.509. :-P In an ideal world, both Web Authentication and Web Packaging would use DER, as browsers already must parse that securely and pay for in binary size, but alas, since Web Authentication already messed up, we're stuck paying for both and either is probably fine.\r\n\r\n(I haven't looked closely at CBOR. DER has a critical nice property that it can be parsed without any allocations with a purely StringPiece-like API. If CBOR does not have this property, do not use it.)",
          "createdAt": "2018-01-29T06:11:58Z",
          "updatedAt": "2018-01-29T06:15:56Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@nyaxt it's unclear to me whether that is enough to lead to fully interoperable implementations. It also means that you cannot use any generic CBOR parser if you want interoperability.",
          "createdAt": "2018-01-29T06:47:18Z",
          "updatedAt": "2018-01-29T06:47:18Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "To be fair, a lot of existing DER parsers are buggy and accept all or bits of BER as well. The good ones only accept DER, but there are a lot of bad ones.",
          "createdAt": "2018-01-29T07:14:06Z",
          "updatedAt": "2018-01-29T07:14:06Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@annevk The IETF is working on a CBORbis at https://github.com/cbor-wg/CBORbis. I'll send them a patch to try to tighten up the error handling. It's still likely to have more than one option, like UTF-8 does.",
          "createdAt": "2018-01-29T18:59:36Z",
          "updatedAt": "2018-01-29T18:59:36Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "@jyasskin UTF-8 on the web doesn't (and note that too has been very problematic, a costly endavor, and not without security consequences).",
          "createdAt": "2018-01-30T07:40:50Z",
          "updatedAt": "2018-01-30T07:40:50Z"
        }
      ]
    },
    {
      "number": 48,
      "id": "MDU6SXNzdWUyMjIyNDY2NDE=",
      "title": "In links to packages, consider srcset-type mechanism",
      "url": "https://github.com/WICG/webpackage/issues/48",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "In whatever mechanism we use to offer a package to a browser, we should think about allowing browsers to choose optimized packages for their situations. There could be a fully-general package that includes many sizes of images that'll appear optimally on any device, but also a small-screen version of the same package that omits the high-resolution images entirely. There could also be other axes than screen size, along the lines of https://github.com/spanicker/device-ram.\r\n\r\nThis introduces some complications around having multiple different resources signed for the same URL. Normally, we could resolve such conflicts by just using the latest such resource, but it's possible that's one optimized for smaller screens than the current device.\r\n\r\nThis is not a v1 consideration.",
      "createdAt": "2017-04-17T22:14:56Z",
      "updatedAt": "2019-05-13T17:01:56Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Depends on #40.",
          "createdAt": "2019-05-13T17:01:55Z",
          "updatedAt": "2019-05-13T17:01:55Z"
        }
      ]
    },
    {
      "number": 52,
      "id": "MDU6SXNzdWUyMjc4MDc4Mjg=",
      "title": "Look into Macaroons for cross-signing",
      "url": "https://github.com/WICG/webpackage/issues/52",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "https://research.google.com/pubs/pub41892.html describes a way to grant capabilities in a way the receiver can attenuate and pass on. We're thinking of having authorities counter-sign packages in order to say, for example, that FooCorp trusts this package to `fetch()` from internal systems. Maybe macaroons are a better way to express this.",
      "createdAt": "2017-05-10T20:55:44Z",
      "updatedAt": "2019-05-13T16:55:36Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Also https://arxiv.org/pdf/1607.02192.pdf.",
          "createdAt": "2017-05-26T15:37:57Z",
          "updatedAt": "2017-05-26T15:37:57Z"
        }
      ]
    },
    {
      "number": 57,
      "id": "MDU6SXNzdWUyMzEwNDA4NDE=",
      "title": "Documenting webpackage tools",
      "url": "https://github.com/WICG/webpackage/issues/57",
      "state": "OPEN",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [
        "nyaxt"
      ],
      "labels": [
        "documentation"
      ],
      "body": "Having some minimal documentation for webpack would be helpful for those of us not fluent in Golang. ",
      "createdAt": "2017-05-24T13:31:41Z",
      "updatedAt": "2019-05-13T16:58:50Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "You're looking for documentation on the tool in https://github.com/dimich-g/webpackage/tree/master/go/webpack/cmd/wpktext2cbor, right? Yep, I should write some, but it'll probably come behind some more elaboration of the loading model.",
          "createdAt": "2017-05-26T15:37:30Z",
          "updatedAt": "2017-05-26T15:37:30Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "make sure to call it Webpackage, https://github.com/webpack is already a very large ecosystem for the web",
          "createdAt": "2017-05-30T17:11:19Z",
          "updatedAt": "2017-05-30T17:11:19Z"
        },
        {
          "author": "TheLarkInn",
          "authorAssociation": "NONE",
          "body": "Yes please!! \u2665\ufe0f",
          "createdAt": "2017-06-02T20:26:29Z",
          "updatedAt": "2017-06-02T20:26:29Z"
        },
        {
          "author": "dauwhe",
          "authorAssociation": "NONE",
          "body": "A few notes on my initial experiences with the tool:\r\n\r\n1. In the [Readme](https://github.com/WICG/webpackage/blob/master/README.md), the command `go install github.com/WICG/webpackage/tree/internet-draft/go/webpack/cmd/wpktext2cbor` didn't work for me. At least when downloading the master branch here, I had a path closer to `github.com/WICG/webpackage/go/webpack/cmd/wpktext2cbor`, and for some reason I had to go into the webpack directory and do `go install ./...`. \r\n\r\n2. The `wpktext2cbor` takes two parameters. `-i` points to a \"manifest*\" file (not the web app manifest!), with format like\r\n\r\n```\r\n[Content]\r\nhttps://dauwhe.github.io/html-first/MobyDickNav/index.html\r\n\r\n200\r\nContent-Type: text/html\r\nDate: Wed, 15 Nov 2016 06:25:24 GMT\r\nExpires: Mon, 01 Jan 2018 16:00:00 GMT\r\n\r\nMobyDickNav/index.html\r\n\r\nhttps://dauwhe.github.io/html-first/MobyDickNav/html/cover.html\r\n\r\n200\r\nContent-Type: text/html\r\nDate: Wed, 15 Nov 2016 06:25:24 GMT\r\nExpires: Mon, 01 Jan 2018 16:00:00 GMT\r\n\r\nMobyDickNav/html/cover.html\r\n```\r\nAnd for us HTML/XML folks, the line breaks are important :) Then the `-o` option points to the package file you want to create. \r\n\r\n3. So far I can't get the package signing to work\u2014I get the same resulting package whether or not I have a `[manifest]` section in the \u201cmanifest,\u201d even when using the samples in this repo. I'll keep trying.\r\n\r\n4. I found [these tools](https://github.com/cabo/cbor-diag) to be helpful when playing around with this stuff, especially `cbor2diag.rb`. \r\n\r\n5. As a tip for the exceedingly ignorant, like myself, the `hpackdec` tool takes the hpack-encoded headers (in hex, which you can get from the .wpk file by using the aforementioned `cbor2diag.rb`) and converts them back to \"English\":\r\n\r\n```\r\ncramerd$ bin/hpackdec 885F87497CA589D34D1F6196E4593E940B6A693F750400B8A01CB826EE09A53168DF6496DF3DBF4A002A651D4A08017540B97000B800298B46FF\r\n:status: 200\r\ncontent-type: text/html\r\ndate: Wed, 15 Nov 2016 06:25:24 GMT\r\nexpires: Thu, 01 Jan 2017 16:00:00 GMT\r\ncramerd$\r\n```\r\n\r\nNow I just have to teach a service worker to do all this stuff :)",
          "createdAt": "2017-09-12T02:15:02Z",
          "updatedAt": "2017-09-12T02:15:02Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@nyaxt, could you find someone to own documentation for the tools, or decide they're already documented enough?",
          "createdAt": "2019-05-13T16:57:26Z",
          "updatedAt": "2019-05-13T16:57:26Z"
        }
      ]
    },
    {
      "number": 58,
      "id": "MDU6SXNzdWUyMzE2NzAwNDg=",
      "title": "Figure out how to identify signing algorithms",
      "url": "https://github.com/WICG/webpackage/issues/58",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Options:\r\n1. [TLS 1.3 SignatureScheme](https://tlswg.github.io/tls13-spec/#rfc.section.4.2.3) codes.\r\n2. <strike>[JWS algorithm names](https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms).</strike> (I have advice to avoid these.)\r\n3. RFC5280's [AlgorithmIdentifier](https://tools.ietf.org/html/rfc5280#section-4.1.1.2) used in certificates.\r\n4. Define a mapping from the certificate's public key to a signature algorithm. This is easy for ECDSA and EdDSA keys, but would need work for RSA keys. Straw man: <=3072 bits gets rsa_pss_sha256, and >=3073 gets rsa_pss_sha384.\r\n\r\nIn some cases, like TLS' [ecdsa_secp256r1_sha256](https://tlswg.github.io/tls13-spec/#rfc.section.4.2.3) vs JWS' [ES256](https://tools.ietf.org/html/rfc7518#section-3.4), even though the algorithm is the same, the signature appears in different formats.\r\n\r\nAny of these options is sufficient to let us sign with any TLS certificate, but TLS doesn't yet have identifiers for post-quantum signature schemes that counter-signatures might want to use.\r\n\r\n",
      "createdAt": "2017-05-26T16:08:27Z",
      "updatedAt": "2017-06-17T04:31:32Z",
      "closedAt": "2017-06-17T04:31:32Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Crypto folks seem to strongly prefer Option 4.",
          "createdAt": "2017-05-26T16:42:28Z",
          "updatedAt": "2017-05-26T16:42:28Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "How would you use a TLS cert to sign \"code\" or content, which is what you\ndoing here?  It's not really what a TLS cert is supposed to be used for.\nIt would also bind things to the domain and not necessary to the\nauthor/producer/publisher of the content.\n\nOn Fri, May 26, 2017 at 12:08 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> Options:\n>\n>    1. TLS 1.3 SignatureScheme\n>    <https://tlswg.github.io/tls13-spec/#rfc.section.4.2.3> codes.\n>    2. JWS algorithm names\n>    <https://www.iana.org/assignments/jose/jose.xhtml#web-signature-encryption-algorithms>\n>    .\n>    3. RFC5280's AlgorithmIdentifier\n>    <https://tools.ietf.org/html/rfc5280#section-4.1.1.2> used in\n>    certificates.\n>    4. Define a mapping from the certificate's public key to a signature\n>    algorithm. This is easy for ECDSA and EdDSA keys, but would need work for\n>    RSA keys.\n>\n> In some cases, like TLS' ecdsa_secp256r1_sha256\n> <https://tlswg.github.io/tls13-spec/#rfc.section.4.2.3> vs JWS' ES256\n> <https://tools.ietf.org/html/rfc7518#section-3.4>, even though the\n> algorithm is the same, the signature appears in different formats.\n>\n> Any of these options is sufficient to let us sign with any TLS\n> certificate, but TLS and JWS don't yet have identifiers for post-quantum\n> signature schemes that counter-signatures might want to use.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/58>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNTPMmDx56DMBrcVcpUc4KSWV-W0Vks5r9vj7gaJpZM4NnyJ_>\n> .\n>\n",
          "createdAt": "2017-05-26T16:44:28Z",
          "updatedAt": "2017-05-26T16:44:28Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "For \"how\", see https://github.com/dimich-g/webpackage#manifest-signatures, which needs to be updated with the result of this issue.\r\n\r\nFrom talking to some security folks, it looks like it'll be safe enough to sign with a TLS cert if we also check for revocation and urgent package updates periodically. e.g. every 7 days would definitely be sufficient. I need to flesh that out in the explainer.\r\n\r\nYes, getting package content to be same-origin with a domain needs the signature to bind the content to the domain. It'll be possible to also counter-sign with extra certificates that might be attached to a real-world identity instead of a domain, and that's one reason I'm worried about certificate types that aren't supported by TLS.",
          "createdAt": "2017-05-26T16:51:49Z",
          "updatedAt": "2017-05-26T16:51:49Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "And for the specific use cases for web packages that you have today, I can\nsee that being sufficient.\n\nBut as we move things like PWP forward, it's not helpful there - as that\ncontent isn't bound to a domain, at least not by the author.  It could\npotentially be by a publisher, but then that limits the usefulness.\n\nOn Fri, May 26, 2017 at 12:51 PM, Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> For \"how\", see https://github.com/dimich-g/webpackage#manifest-signatures,\n> which needs to be updated with the result of this issue.\n>\n> From talking to some security folks, it looks like it'll be safe enough to\n> sign with a TLS cert if we also check for revocation and urgent package\n> updates periodically. e.g. every 7 days would definitely be sufficient. I\n> need to flesh that out in the explainer.\n>\n> Yes, getting package content to be same-origin with a domain needs the\n> signature to bind the content to the domain. It'll be possible to also\n> counter-sign with extra certificates that might be attached to a real-world\n> identity instead of a domain, and that's one reason I'm worried about\n> certificate types that aren't supported by TLS.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/issues/58#issuecomment-304333036>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNSw764DyadWBG-pCHnGbWGtJSKGwks5r9wMlgaJpZM4NnyJ_>\n> .\n>\n",
          "createdAt": "2017-05-26T17:29:15Z",
          "updatedAt": "2017-05-26T17:29:15Z"
        }
      ]
    },
    {
      "number": 59,
      "id": "MDU6SXNzdWUyMzE3MDE0MDg=",
      "title": "Describe how to check for revocation and downgrades when loading a package",
      "url": "https://github.com/WICG/webpackage/issues/59",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The sketch, which I've run by @sleevi, is:\r\n1. Check the manifest's signature and that the signing certificate is for the package's claimed origin and that it chains to a trusted root, using intermediate certificates included in the package.\r\n2. Each package also has an accompanying set of OCSP responses and anti-downgrade information.\r\n3. The UA checks that the OCSP responses are signed by the certificate's signer and were generated less than 7 days ago.\r\n4. The UA checks that the anti-downgrade information is signed by a certificate trusted for package's origin (potentially taking advantage of the package's intermediate certs), hasn't expired yet and was signed less than 7 days ago, and says that the package's date is sufficiently recent.\r\n5. If any of this isn't recent enough, the package identifies a URL from which to fetch newer validity information. This validity information is small (<1kb?), so it should be cheap enough to fetch even when full packages are too expensive.\r\n\r\nThere's some evidence that we'll still have a significant number of UAs that are fully offline and won't be able to fetch new validity information every week. Depending on the existing HTTP cache's behavior, maybe we don't need to revalidate once we've opened a package once. Maybe it's ok to trust older validations as long as the package doesn't make any network requests, and have revalidation block the package's first network request when the UA gets back online. We'll need to decide what to do about local storage if that validation fails.\r\n\r\nI need to add this to the main explainer.",
      "createdAt": "2017-05-26T18:25:20Z",
      "updatedAt": "2018-01-26T23:53:37Z",
      "closedAt": "2018-01-26T23:53:37Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "As long as it is an explainer (SHOULD not MUST) +1",
          "createdAt": "2017-07-31T15:53:43Z",
          "updatedAt": "2017-07-31T15:53:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is now in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity. It *is* a bunch of MUSTs. I'm tracking one need to loosen those up in #117. @bmeck, could you file any others you know about?",
          "createdAt": "2018-01-26T23:53:37Z",
          "updatedAt": "2018-01-26T23:53:37Z"
        }
      ]
    },
    {
      "number": 69,
      "id": "MDU6SXNzdWUyMzQ5ODE1NTk=",
      "title": "Look into Merkle trees for quick access to parts of large resources",
      "url": "https://github.com/WICG/webpackage/issues/69",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "For example, we might want to be able to start playing a large video file without hashing the whole thing.\r\n\r\nSee https://tools.ietf.org/html/draft-thomson-http-mice for one approach.",
      "createdAt": "2017-06-10T05:26:16Z",
      "updatedAt": "2018-01-24T18:39:54Z",
      "closedAt": "2018-01-24T18:39:34Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "can you clarify? we aren't encoding the resource so random access should work. Or are you talking about allowing integrity checks on ranges within a resource?",
          "createdAt": "2017-06-21T19:17:23Z",
          "updatedAt": "2017-06-21T19:17:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Allowing integrity checks on ranges within a resource.",
          "createdAt": "2017-07-06T17:38:48Z",
          "updatedAt": "2017-07-06T17:38:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#108 defined a generic way to identify a header that guards the content. The `MI` header from [draft-thomson-http-mice](https://tools.ietf.org/html/draft-thomson-http-mice) then provides incremental integrity for the beginning of a resource, and when there's a demonstrated need we can define another header or content encoding within the `MI` header that uses a balanced Merkle tree for random access integrity checks.",
          "createdAt": "2018-01-24T18:39:34Z",
          "updatedAt": "2018-01-24T18:39:54Z"
        }
      ]
    },
    {
      "number": 70,
      "id": "MDU6SXNzdWUyMzQ5ODE2MzI=",
      "title": "Do we need the :method header?",
      "url": "https://github.com/WICG/webpackage/issues/70",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "https://github.com/WICG/webpackage/pull/60#discussion_r121227994 points out that we might not want to store the [`:method` header](http://httpwg.org/specs/rfc7540.html#HttpRequest) in requests. We only know of uses of `GET` requests, and having the ability to code other methods might cause bugs.",
      "createdAt": "2017-06-10T05:27:22Z",
      "updatedAt": "2019-11-13T16:28:57Z",
      "closedAt": "2019-01-18T21:20:32Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I vote it is uneeded.",
          "createdAt": "2017-06-21T16:35:12Z",
          "updatedAt": "2017-06-21T16:35:12Z"
        },
        {
          "author": "ibnesayeed",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From an archival perspective it might be important to keep it. Also, apart from `GET` there are other methods that might be useful, such as, `HEAD` and `OPTIONS` or any other methods that do not change the state of the resource.",
          "createdAt": "2018-01-10T02:24:35Z",
          "updatedAt": "2018-01-10T02:24:35Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We'd already restricted the method to be [safe](https://tools.ietf.org/html/rfc7231#section-4.2.1) and [cacheable] (https://tools.ietf.org/html/rfc7231#section-4.2.3). Since the creation of HTTP, only GET and HEAD have met those requirements, and HEAD responses can be synthesized from a stored GET response. So #360 is dropping the `:method` field (since it would be the only remaining field in the request map).",
          "createdAt": "2019-01-03T21:26:23Z",
          "updatedAt": "2019-01-03T21:26:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#360 is merged. If a particular archival use case comes up, we can reopen the question.",
          "createdAt": "2019-01-18T21:20:32Z",
          "updatedAt": "2019-01-18T21:20:32Z"
        },
        {
          "author": "ibnesayeed",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin do we have a way to support `OPTIONS` request without this header? If not, then how will the CORS requests work that need pre-flight requests?",
          "createdAt": "2019-11-13T16:28:57Z",
          "updatedAt": "2019-11-13T16:28:57Z"
        }
      ]
    },
    {
      "number": 71,
      "id": "MDU6SXNzdWUyMzU3MDkxMTE=",
      "title": "Start an internet-draft",
      "url": "https://github.com/WICG/webpackage/issues/71",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "This supports the [IETF submission](https://mailarchive.ietf.org/arch/msg/dispatch/NQ0deHSsRvt4BL4alk_WYVnhhvo). It has to happen before they close the RFC database from July 3 until the [Prague meeting](http://ietf.org/meeting/99/index.html).\r\n\r\nWe can use https://github.com/cabo/kramdown-rfc2629 to author in markdown, and https://github.com/martinthomson/i-d-template to build with Travis CI.",
      "createdAt": "2017-06-13T22:16:28Z",
      "updatedAt": "2017-08-14T23:58:02Z",
      "closedAt": "2017-08-14T23:58:02Z",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin can you explain why you want to have this work happen through IETF instead of W3C? ",
          "createdAt": "2017-06-23T13:00:36Z",
          "updatedAt": "2017-06-23T13:00:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@lrosenthol The IETF has way more expertise developing file formats than the W3C. One can even think of the packaging format as a transport protocol with particular constraints on the connection, which is squarely in the IETF's domain.\r\n\r\nThat said, the W3C is definitely the right place to specify how browsers load the format, and, for publications, how publication-readers load it, which could be different from browsers. I expect to have 2+ specifications as a result: one in the IETF, and one or more in the W3C and maybe elsewhere.",
          "createdAt": "2017-06-26T04:26:26Z",
          "updatedAt": "2017-06-26T04:26:26Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin Historically, I would agree with you about that. However, with the IETF (which has over a decade) of packaging and format experience joining the W3C this year, you now have a group of people who not only have the knowledge *but* are also engaged to this work.  I am not sure that the IETF folks will be as engaged.  In a related bit, I would think that having the browser vendors at the W3C aligning on the format as a \"web archive\" would be a win.\r\n\r\nI would strongly prefer that we keep the entire thing, but broken into separate work items as you suggest, would be best.",
          "createdAt": "2017-06-26T14:15:27Z",
          "updatedAt": "2017-06-26T14:15:27Z"
        }
      ]
    },
    {
      "number": 72,
      "id": "MDU6SXNzdWUyMzU3NTU4OTA=",
      "title": "Test each kind of private key",
      "url": "https://github.com/WICG/webpackage/issues/72",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "[example.com.key](https://github.com/WICG/webpackage/tree/master/go/webpack/testdata/pki/example.com.key) is currently a secp256r1 key, but we should also test creating packages for each of:\r\n* RSA <= 3072 bits\r\n* RSA with 3073-7680 bits (probably 4096)\r\n* secp384r1\r\n* secp521r1\r\n\r\nI'll probably create the keys for `rsa2048.example.com`, `secp521r1.example.com`, etc.",
      "createdAt": "2017-06-14T03:56:27Z",
      "updatedAt": "2019-05-13T16:59:18Z",
      "closedAt": "2019-05-13T16:59:18Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The other key types are no longer allowed.",
          "createdAt": "2019-05-13T16:59:18Z",
          "updatedAt": "2019-05-13T16:59:18Z"
        }
      ]
    },
    {
      "number": 73,
      "id": "MDU6SXNzdWUyMzc2NTg5MTY=",
      "title": "HTML integration",
      "url": "https://github.com/WICG/webpackage/issues/73",
      "state": "CLOSED",
      "author": "matthewp",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello, is it within the scope to define (or speculate) on how a person might load a webpackage in an HTML document, and what the browser should do when it unpacks a package?\r\n\r\nOr is the idea that a document might request `GET /app.js` (from a script tag) and the server would reply with a webpackage, making any other resources that are later requested come from that package?\r\n\r\nThanks!",
      "createdAt": "2017-06-21T20:44:32Z",
      "updatedAt": "2017-08-10T22:52:10Z",
      "closedAt": "2017-08-09T14:45:56Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yes, that's in scope. That's probably the main subject of the specification that'll go through the W3C.",
          "createdAt": "2017-06-26T04:27:54Z",
          "updatedAt": "2017-06-26T04:27:54Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "In the history of this, the idea was WebPackage is a cache filling mechanism. So I would presume (don't count it as truth) that all environments using WebPackage including HTML would accept any request responding with WebPackage appropriately to fill things out.\r\n\r\nFor Node, that is with a file extension.\r\nFor Web, that is with a MIME Type.\r\n\r\nSo, if `./app.js` in Web returns a Webpackage we have a slight problem. `type=module` does not do aliasing for paths so Webpackage would need to declare a `main` field somewhere I would presume. For Node it follows the standard resolution, but that resolution is problematic for Web since it requires resolution with IO involved.\r\n\r\nI would go through WHATWG/W3C for figuring that out.",
          "createdAt": "2017-06-29T14:02:03Z",
          "updatedAt": "2017-06-29T14:02:03Z"
        },
        {
          "author": "matthewp",
          "authorAssociation": "NONE",
          "body": "Going to close as whatwg will likely define this.",
          "createdAt": "2017-08-09T14:45:56Z",
          "updatedAt": "2017-08-09T14:45:56Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Well, the WHATWG will only define this if our work in this repository results in a proposal to them. I'm working on writing one, so it's fine to have closed this issue, but I'll want reviewers when I send the PR.",
          "createdAt": "2017-08-10T22:15:40Z",
          "updatedAt": "2017-08-10T22:15:40Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Ill be at the ready\n\nOn Aug 10, 2017 5:15 PM, \"Jeffrey Yasskin\" <notifications@github.com> wrote:\n\n> Well, the WHATWG will only define this if our work in this repository\n> results in a proposal to them. I'm working on writing one, so it's fine to\n> have closed this issue, but I'll want reviewers when I send the PR.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/73#issuecomment-321688195>, or mute\n> the thread\n> <https://github.com/notifications/unsubscribe-auth/AAOUo6bBFED7TJxK4l8wNXI06LaJIV6Wks5sW4ENgaJpZM4OBfql>\n> .\n>\n",
          "createdAt": "2017-08-10T22:52:10Z",
          "updatedAt": "2017-08-10T22:52:10Z"
        }
      ]
    },
    {
      "number": 74,
      "id": "MDU6SXNzdWUyMzg0NDAzODA=",
      "title": "Be clearer that the TAG's proposal is very out of date.",
      "url": "https://github.com/WICG/webpackage/issues/74",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The link to https://w3ctag.github.io/packaging-on-the-web/ at the beginning of the explainer needs to say clearly that it's been superseded.",
      "createdAt": "2017-06-26T04:43:18Z",
      "updatedAt": "2018-01-24T18:36:30Z",
      "closedAt": "2018-01-24T18:36:30Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #77.",
          "createdAt": "2018-01-24T18:36:30Z",
          "updatedAt": "2018-01-24T18:36:30Z"
        }
      ]
    },
    {
      "number": 75,
      "id": "MDU6SXNzdWUyMzk2OTc1OTE=",
      "title": "Please do not use abbreviation PWA for Portable Web Applications",
      "url": "https://github.com/WICG/webpackage/issues/75",
      "state": "CLOSED",
      "author": "kenchris",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I saw this in your slides and that abbreviation is already quite commonly used for Progressive Web Apps.",
      "createdAt": "2017-06-30T07:22:50Z",
      "updatedAt": "2018-01-24T18:35:26Z",
      "closedAt": "2018-01-24T18:35:26Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "What slides? I believe we're always using PWA to mean \"Progressive Web App\".",
          "createdAt": "2017-06-30T14:09:57Z",
          "updatedAt": "2017-06-30T14:09:57Z"
        }
      ]
    },
    {
      "number": 78,
      "id": "MDU6SXNzdWUyNDA3MTc0ODM=",
      "title": "Look at using CMS or S/MIME for signatures",
      "url": "https://github.com/WICG/webpackage/issues/78",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In response to https://tools.ietf.org/html/draft-yasskin-dispatch-web-packaging-00, [Paul Hoffman](https://icannwiki.org/Paul_Hoffman) suggested, if I'm understanding his email correctly, that we replace the [signed-manifest item](https://tools.ietf.org/html/draft-yasskin-dispatch-web-packaging-00#section-2.4) that wraps the manifest, with a CMS or possibly S/MIME document that wraps the manifest.\r\n\r\nBecause CMS is an ASN.1 format, I think we'd want to accept #47, switching the overall format to DER-encoded ASN.1, first.\r\n\r\n[CMS](https://tools.ietf.org/html/rfc5652#section-5) is fairly complicated, so Adam Langley suggests that we pick a precise subset and mandate that in the packaging format, rather than allowing all the flexibility in the original standard. For example, instead of allowing arbitrary `RevocationInfoChoice`s, we might specify that the `SignedData.crls` field be filled with exactly one OCSP response. The result could still be parsed with CMS tools, but it could also be parsed with much simpler package-specific tools.\r\n\r\nI suspect we'll run into some trouble around the `SignerInfo.*algorithm` fields: the current format specifies exactly one digest+signature algorithm for each possible certificate type, and doesn't encode that algorithm into the serialized bytes. CMS appears to allow the attacker to select the algorithms, just like [JOSE](https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/). A package-specific parser would enforce the restriction, but a generic CMS tool wouldn't, and so would be vulnerable to the same attacks as JOSE. That's a reason to use a non-CMS format, to disallow generic tools from parsing package signatures.",
      "createdAt": "2017-07-05T17:11:00Z",
      "updatedAt": "2019-05-13T16:59:42Z",
      "closedAt": "2019-05-13T16:59:41Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We'll stick with our current signatures.",
          "createdAt": "2019-05-13T16:59:41Z",
          "updatedAt": "2019-05-13T16:59:41Z"
        }
      ]
    },
    {
      "number": 79,
      "id": "MDU6SXNzdWUyNDM4NTMxNTg=",
      "title": "Study the openZIM format",
      "url": "https://github.com/WICG/webpackage/issues/79",
      "state": "CLOSED",
      "author": "kelson42",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I kind of wonder why the ZIM format seems not to have been studied properly? Even if the format is not so rigorously documented and still lacks a few tools around it, this is probably the most used web content offline distribution file format.\r\n\r\nGeneral purpose web sites:\r\n* http://www.openzim.org/\r\n* http://www.kiwix.org/\r\n\r\nFor developers:\r\n* https://github.com/openzim/\r\n* https://github.com/kiwix/",
      "createdAt": "2017-07-18T21:12:46Z",
      "updatedAt": "2019-05-13T17:09:21Z",
      "closedAt": "2019-05-13T17:00:01Z",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@kelson42 can you define \"seems not to have been studied properly\"\r\n\r\nIt seems much more limited in capabilities / lacking signing / lacking requirements of things like Node.",
          "createdAt": "2017-07-31T15:57:04Z",
          "updatedAt": "2017-07-31T15:57:04Z"
        },
        {
          "author": "kelson42",
          "authorAssociation": "NONE",
          "body": "@bmeck \r\n\r\nIt's true about signing. That looks something relatively easy to specify and implement. Would make sense to make it on openzim side.\r\n\r\nWhat do you mean exactly about \"requirements of things like Node\". The README talks about self-exactracting things? Is that what you mean? If \"yes\", have you an extended explanation about the requirement?",
          "createdAt": "2017-07-31T16:10:09Z",
          "updatedAt": "2017-07-31T16:10:09Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "Node constraints: https://github.com/WICG/webpackage/issues/33\r\n\r\nOther things like supporting `link:`/`transfer-encoding:`/`cache-control:`/`expires:` style metadata and subpackages were the main things when commenting on limited capabilities.",
          "createdAt": "2017-07-31T16:17:40Z",
          "updatedAt": "2017-07-31T16:17:40Z"
        },
        {
          "author": "kelson42",
          "authorAssociation": "NONE",
          "body": "@bmeck Thx for the confirmation about self-extracting, but I do not really understand how data package with self-extracting could be used a  standard. This will be de-facto designed for one system/arch. Do you have somewhere the use case? Why having the decompressor in the package is so important?",
          "createdAt": "2017-07-31T18:52:29Z",
          "updatedAt": "2017-07-31T18:52:29Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@kelson42 use case is to create single file executables (of which both Node and Electron are interested), moving it to the host env means variations on how such is performed and loss of interoperability. Node certainly can use other formats than WebPackage such as `.zip` and `.asar` already but those are not standardized and agreed upon.",
          "createdAt": "2017-07-31T19:43:18Z",
          "updatedAt": "2017-07-31T19:43:18Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks to the pointer to an existing format. You're right that I didn't study it when designing the packaging format. Looking at it now, I think the lack of signing prevents us from just adopting it. The rest of the format looks tailored to Wikipedia articles: is it being used for other kinds of websites as well?",
          "createdAt": "2017-07-31T22:38:15Z",
          "updatedAt": "2017-07-31T22:38:15Z"
        },
        {
          "author": "kelson42",
          "authorAssociation": "NONE",
          "body": "It is a bit late, but this is only for documentation:\r\n* The format does still not provide content signing. The ticket is here https://github.com/openzim/libzim/issues/40\r\n* The format is suited for any kind of static content, not only Wikipedia & co. We provide already a lot of different content see https://download.kiwix.org/zim/",
          "createdAt": "2019-05-13T17:09:21Z",
          "updatedAt": "2019-05-13T17:09:21Z"
        }
      ]
    },
    {
      "number": 86,
      "id": "MDU6SXNzdWUyNjEzMDI1Mzk=",
      "title": "Noting open W3C TAG legacy issues",
      "url": "https://github.com/WICG/webpackage/issues/86",
      "state": "OPEN",
      "author": "torgo",
      "authorAssociation": "NONE",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "Hello web packaging fans - \r\n\r\nWe're just cleaning up issues in possibly obsolete repos under [our organization](github.com/w3ctag/) (W3CTAG). One of these documents was the original packaging on the web which has since been obsoleted by your work. However there are many open issues on our document and before we summarily closed them we wanted to alert you to these issues in case you wanted to bring any of them over into your issues list. Can you please have a look through [these issues](https://github.com/w3ctag/packaging-on-the-web/issues) and leave a note on each issue to let us know that it's OK to close it? If you do take one of them on as an issue, please leave a note including a link to your new issue.\r\n\r\nThanks,\r\nDan Appelquist\r\nCo-Chair, W3CTAG",
      "createdAt": "2017-09-28T12:36:00Z",
      "updatedAt": "2019-05-13T17:00:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 100,
      "id": "MDU6SXNzdWUyODQzNjcxNzk=",
      "title": "Hh",
      "url": "https://github.com/WICG/webpackage/issues/100",
      "state": "CLOSED",
      "author": "Sadlowski",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hnm",
      "createdAt": "2017-12-24T14:55:47Z",
      "updatedAt": "2017-12-24T15:30:17Z",
      "closedAt": "2017-12-24T15:30:17Z",
      "comments": []
    },
    {
      "number": 101,
      "id": "MDU6SXNzdWUyODY5NjMyMDk=",
      "title": "will support packaging only subresource ?",
      "url": "https://github.com/WICG/webpackage/issues/101",
      "state": "CLOSED",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in ES modules, we need to fetch a lot of module files.\r\nincreasing requests cause a performance issue. ([10k 1kB load is 10 times slower than single 10MB load](https://docs.google.com/document/d/1ds9EEkcDGnt-iR8SAN-_7nsOfw7gsMfhZjzZ_QAIyjM/edit))\r\n\r\nh2 will reduce connection handshake/establish, but doesn't reduce request/response itself which browser handles inside.\r\n\r\nbut reducing files via bundling like webpack is less merit of es modules(ex caching etc). \r\n\r\nsame things happens for image. so we sometimes concatting them aka Sprite.\r\n\r\ncurrent spec seems packaging main-resource + sub-resource in 1 file.\r\nso if webpackage support or have candidate to package lot of resources into 1 package(not include main-resoruce) seems solve fetching performance problem.\r\nexpected behavior is fetching single response but unpackaging in browser and handling/caching like separated ESModules/ImageIcons/StyleSheets etc.",
      "createdAt": "2018-01-09T03:55:58Z",
      "updatedAt": "2018-02-13T06:06:33Z",
      "closedAt": "2018-02-13T06:06:33Z",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a use case I discussed with @jyasskin, @addyosmani and @patrickkettner.\r\n\r\nI think using webpackage as a bundling format is an interesting use case, and will provide the same compression benefits bundling currently provides without all its downsides. I think it can and should be addressed by these specifications, but will require some extra mechanisms to enable it.\r\n\r\nI guess the first step is to send out a PR outlining this use-case.",
          "createdAt": "2018-02-12T13:11:10Z",
          "updatedAt": "2018-02-12T13:11:10Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Filed a use case PR. Beyond that, we also need to define a mechanism that will let the browser:\r\n* Know that a package download is required\r\n* Know which resources are covered by a certain package, so that their requests won't race with the package's response. Such a mechanism can use some form of digest that will include all the URLs in the package and will be delivered with the \"package is required\" markup.\r\n\r\nStraw-man for such markup may look like:\r\n`<link rel=package href=\"js_bundle\" digest=\"bcfd23234989734abdcef\">`",
          "createdAt": "2018-02-12T13:57:17Z",
          "updatedAt": "2018-02-12T13:57:17Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "It's not only for esmodules but also image, style, font, favicon etc.\r\n\r\nI have 2 plan for this in my mind.\r\n\r\ndump them in rough.\r\n\r\n## `<package>` like `<picture>` way for selective `<img>`\r\n\r\nfor example\r\n\r\n```\r\n<package src=bundle.wpac>\r\n  <!-- backword compat for no-package -->\r\n  <script type=module src=react.js>\r\n  <script type=module src=moment.js>\r\n  <script type=module src=main.js>\r\n\r\n  <!-- backword compat for no-module -->\r\n  <script type=nomodule src=bundle.js>\r\n\r\n  <!-- css -->\r\n  <link rel=stylesheet href=bootstrap.css>\r\n  <link rel=stylesheet href=style.css>\r\n\r\n  <!-- favicon -->\r\n  <link rel=\"shortcut icon\" href=\"favicon.ico\">\r\n</package>\r\n```\r\n\r\nbrowser which support webpackaging fetches `<package>` resource.\r\n\r\n```\r\nGET /bundle.wpac HTTP/1.1\r\nAccept-Encoding: wpac\r\n```\r\n\r\nserver responses bundled.wpac\r\n\r\n```\r\nHTTP/1.1 200 OK\r\nContent-Encoding: wpac\r\n\r\npackaged all resouces\r\n```\r\n\r\nunpack them and treat each file as fetched via reach request\r\n\r\n\r\nin this time we have 2 consideration\r\n\r\n\r\n- what is cache time for wpac ?\r\n  - longest cache in package\r\n- what is the cache information for each modules ?\r\n  - wpac format should contain meta information about how long each modules could cache\r\n- browser should not always fetch bundle.wpac, how to decide ?\r\n  - while bundle.wpac cache is valid, fetch each files. if bundle.wpac cache is invalid, fetch bundle.wpac\r\n- what happen if bundle.wpac doesn't include `moment.js` ?\r\n  - fetch moment.js again according to `<script>`\r\n\r\n\r\nthis requires adding new tag `<package>` and adding meta information for packaging format.\r\n\r\n\r\n## Content-Encoding and 209 Already Respond\r\n\r\n\r\nbrowser requests\r\n\r\n```\r\nGET index.js HTTP/1.1\r\nAccept-Encoding: wpac\r\n\r\nGET moment.js HTTP/1.1\r\nAccept-Encoding: wpac\r\n\r\nGET bootstrap.css HTTP/1.1\r\nAccept-Encoding: wpac\r\n```\r\n\r\n\r\nbrowser sends accept encoding wpac so server can response in single pack.\r\n\r\nand server responses\r\n\r\n\r\n```\r\nHTTP/1.1 200 OK // for index.js session\r\nContent-Encoding: wpac\r\nPacked-Content: index.js\r\nPacked-Content: moment.js\r\nCache-Control: max-age=3600\r\n// wpac body\r\n\r\n\r\nHTTP/1.1 209 Already Respond // for moment.js session\r\nCache-Control: max-age=1024\r\n// empty body\r\n\r\nHTTP/1.1 209 Already Respond // for bootstrap.css\r\nCache-Control: max-age=3600\r\n// empty body\r\n```\r\n\r\n1st response include packaged resouces. browser unpack them in files which treat as they are respond in Status Code 200 each.\r\n\r\nif client already cached wpac, but only index.js is expired, request index.js only.\r\n\r\n\r\nin this case, client/server can handle via content-negotiation\r\nno adding semantics for html but need new response status code `209 Already Respond`\r\n\r\n- why Already Reponed\r\n  - need to close http session. but browser don't need to care much about response which already respond in Pack.\r\n- what is HTML look like ?\r\n  - as-is, content-negotiation is opt in.\r\n- what is in package ?\r\n  - server knows which is depended in index.js, so server can bundle them, and show them in Packed-Content header\r\n- what will happen in unsupported browser\r\n  - work as is",
          "createdAt": "2018-02-13T03:26:12Z",
          "updatedAt": "2018-02-13T03:26:12Z"
        }
      ]
    },
    {
      "number": 102,
      "id": "MDU6SXNzdWUyODcwNjgyNDM=",
      "title": "Optionally check hashes of externally included packages",
      "url": "https://github.com/WICG/webpackage/issues/102",
      "state": "OPEN",
      "author": "HuangYuSan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "Scenario: Developer A includes a package from Developer B (e.g. a specific version of jQuery, or a hypothetical wasm implementation of python3) to serve the purpose of a shared library. This is loaded from a version-specific URL, say packages.jquery.com/v3-2-1, to ensure that A's app is running with the right version of jQuery or python that it was developed for. However, A has to trust the integrity of B and B's server to actually keep the resource static. B or any attacker on B's server has the power to inject malicious code into A's web app. This makes shared libraries impractical for security-critical applications. \r\n\r\nTo solve this problem, A links B's package with both a URL and a hash, which is checked by the client as soon as B's package is loaded (libraries are unlikely to need streaming). So A can have absolute confidence that their app uses the exact same version of the resource that it has been developed for, while keeping the benefits of shared library use.\r\n  ",
      "createdAt": "2018-01-09T12:13:24Z",
      "updatedAt": "2019-05-13T17:01:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Depends on #40.",
          "createdAt": "2019-05-13T17:01:45Z",
          "updatedAt": "2019-05-13T17:01:45Z"
        }
      ]
    },
    {
      "number": 103,
      "id": "MDU6SXNzdWUyODcxNzQ3MjU=",
      "title": "Clarify relationship with Publishing WG\u2019s Packaged Web Publications",
      "url": "https://github.com/WICG/webpackage/issues/103",
      "state": "CLOSED",
      "author": "js-choi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Several days ago, the [W3C Publishing WG published three working drafts][Publishing WG announcement], including [Packaged Web Publications][] (WPub/PWP), which defines a packaging format for combining collections of resources into a single portable WPUB file.\r\n\r\nThis WPub standard seem to be quite similar to this WICG\u2013IETF Web Packages (WPK) standard. But the relationship between the two is unclear.\r\n\r\nI could find some references to the Publishing WG here. [Web Packaging Format\u2019s use-cases note has a \u201cPackaged Web Publications\u201d][] in its \u201cNice-to-have\u201d section; it refers to the Publishing WG and discusses several abstract use cases provided by the WG, without actual reference to WPub as a specification. Several issues here (#3 \u201cRelationship to DPUB\u201d, #32 \u201cDocument Adobe\u2019s use cases\u201d, #37 \u201cAdd a list of goals and non-goals\u201d, #71 \u201cStart an internet-draft\u201d) also refer to the Publishing WG. Some Publishing WG members (@lrosenthol, @iherman, @dauwhe)  have participated in these issues.\r\n\r\nNone of these references talk about WPub as a separate specification, and none of them elaborate on its relationship with Web Packaging Format. Neither the [Web Packaging specification itself][] nor the [obsolete TAG Packaging on the Web draft](https://w3ctag.github.io/packaging-on-the-web/) make any mention of WPub either.\r\n\r\nThis is triply confusing. There is clear overlap between the two specifications\u2019 use cases. For instance, both initiatives appear to desire addressing Google AMP\u2019s use cases. Even their names are confusingly similar (WPK vs. PWP). Both are being actively developed\u2014there were even announcements regarding both on this same week (the [WPub public-draft announcement][Publishing WG announcement] and the [Google AMP Project\u2019s announcement on its transition to WPK][WPK for Google AMP]). And some of the same people have participated in both discussions on one standard and discussions on the other.\r\n\r\nFor readers of both specifications, it would be useful if their authors clarified this uncertainty. \u201cWhat is the relationship between the two standards?\u201d \u201cWhy are there two separate standards?\u201d \u201cHow are their use cases and file formats similar and different?\u201d Further active collaboration between the two specs\u2019 authors might also be worth pursuing. Though it might be too late for unification, it would be a shame if there was fragmentation of the same goal into two formats. Browser vendors are probably less likely to implement two formats than just one. On the other hand, if their use cases are irreconcilable, then that should be made explicit in the specifications.\r\n\r\n(Also cf. https://github.com/w3c/wpub/issues/5#issuecomment-314265230, https://github.com/w3c/wpub/issues/5#issuecomment-315076651 by @HadrienGardeur; as well as w3c/wpub#10, w3c/wpub#90, and w3c/wpub#111.)\r\n\r\n[Publishing WG announcement]: https://www.w3.org/blog/news/archives/6756\r\n\r\n[Packaged Web Publications]: https://www.w3.org/TR/2018/WD-pwpub-20180104\r\n\r\n[Web Packaging Format\u2019s use-cases note has a \u201cPackaged Web Publications\u201d]: https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#rfc.section.2.2.1\r\n\r\n[Web Packaging specification itself]: https://wicg.github.io/webpackage/draft-yasskin-dispatch-web-packaging.html\r\n\r\n[obsolete TAG Packaging on the Web draft]: https://w3ctag.github.io/packaging-on-the-web/\r\n\r\n[WPK for Google AMP]: https://amphtml.wordpress.com/2018/01/09/improving-urls-for-amp-pages/amp/\r\n  ",
      "createdAt": "2018-01-09T17:48:47Z",
      "updatedAt": "2018-01-09T21:57:43Z",
      "closedAt": "2018-01-09T21:57:43Z",
      "comments": [
        {
          "author": "js-choi",
          "authorAssociation": "NONE",
          "body": "I realized that it may be more appropriate to raise this issue in w3c/wpub, since WPub/PWP addresses more specific use cases than WPK does. I raised w3c/wpub#120 and will close this issue for now.",
          "createdAt": "2018-01-09T21:57:43Z",
          "updatedAt": "2018-01-09T21:57:43Z"
        }
      ]
    },
    {
      "number": 104,
      "id": "MDU6SXNzdWUyODcxODg2MjY=",
      "title": "Capture sources of non-determinism",
      "url": "https://github.com/WICG/webpackage/issues/104",
      "state": "OPEN",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "feature request"
      ],
      "body": "Some of the suggested uses cases seem to require that sources of non-determinism (such as RNG seeds and the current time) are captured to ensure that, for example, saving and sharing a web page can occur with greater fidelity.",
      "createdAt": "2018-01-09T18:38:39Z",
      "updatedAt": "2019-05-13T17:02:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I suspect this will be a v2 feature if we decide to do it at all: overriding the behavior of JS APIs is orthogonal to a bunch of the other things involved in packaging, and pinning RNG seeds has some definite security implications.\r\n\r\n@dimich-g, you know more about the \"save and share\" use cases. Do you think this will turn out to be important?",
          "createdAt": "2018-01-09T22:41:21Z",
          "updatedAt": "2018-01-09T22:41:21Z"
        }
      ]
    },
    {
      "number": 105,
      "id": "MDU6SXNzdWUyODcyNTM1MTM=",
      "title": "Archived / immutable content",
      "url": "https://github.com/WICG/webpackage/issues/105",
      "state": "CLOSED",
      "author": "craigfrancis",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "While some packages need to be kept up to date, and expired when they become too old; there are also things that should never expire/change.\r\n\r\nFor example the content of a webpage a user wants to keep, a report or invoice created by a website, etc (this is instead of using a PDF or MS Word document).\r\n\r\nSo would it be possible to skip the Expires header, and have some way of marking the package as immutable?\r\n\r\nThat immutable flag could also instruct the browser to never download any resources, and for the JS `Date` object to return a date/time based on the Date header from the package (not the current date/time)... may be related to issue #104?",
      "createdAt": "2018-01-09T22:31:52Z",
      "updatedAt": "2020-09-02T09:59:45Z",
      "closedAt": "2019-05-13T17:06:19Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "\"Archival\" makes me think of formats like [WARC](http://iipc.github.io/warc-specifications/specifications/warc-format/warc-1.1/), which we're not trying to compete with: they focus on recording the state of the web, while we're trying to distribute content to browsers.\r\n\r\nHowever, the rest of your comment looks like your use case is actually around saving a webpage for later personal use. Most of the need for expiration centers around preventing attackers from forging signatures or exploiting bugs, which isn't a risk for sites you've saved personally and don't distribute. We will support un-signed packages for this sort of thing, and there won't be anything forcing them to expire. Does that work for you?",
          "createdAt": "2018-01-09T22:46:36Z",
          "updatedAt": "2018-01-09T22:46:36Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "The [`cache-control: immutable` header](https://tools.ietf.org/html/rfc8246) also seems to follow that line of thought where it does have an expiration associated with it, even if it is immutable. I think saving from signed->unsigned seems a reasonable utility to have for most tools.",
          "createdAt": "2018-01-09T22:50:01Z",
          "updatedAt": "2018-01-09T22:50:01Z"
        },
        {
          "author": "TzviyaSiegman",
          "authorAssociation": "NONE",
          "body": "@prototypo Please see overlap with Archiving section (to come) in https://www.w3.org/TR/pwpub/",
          "createdAt": "2018-01-09T22:58:15Z",
          "updatedAt": "2018-01-09T22:58:15Z"
        },
        {
          "author": "ibnesayeed",
          "authorAssociation": "CONTRIBUTOR",
          "body": "The web archiving community is [taking notice of it](https://twitter.com/anjacks0n/status/950861384266416134). While WARC works well for its purpose, it would be good to give some more thoughts on the archiving aspect, be it in the form of some possibility of transformation between webpackage and WARC or some other way to interoperate. WARC might want to store the whole package as an object or unpack it to store individual resources.",
          "createdAt": "2018-01-10T01:58:44Z",
          "updatedAt": "2018-01-10T01:58:44Z"
        },
        {
          "author": "craigfrancis",
          "authorAssociation": "NONE",
          "body": "@jyasskin, @TzviyaSiegman, I think there are similarities to Web Archive (WARC) and Packaged Web Publications (PWPUB); but I think the WebPackage format is slightly more appropriate for these document types:\r\n\r\n- Invoices.\r\n- Terms and conditions.\r\n- Contracts.\r\n- Reports, assessments, statistics.\r\n- Bank statements.\r\n- CVs.\r\n\r\nWhere these document (as packages) could then be easily downloaded, emailed, viewed any time, and kept/stored/archived - where [PDF files cause problems](https://github.com/craigfrancis/wdoc/blob/master/readme.md#justification).\r\n\r\nAnd I agree, these documents do not *need* to be signed by an origin, so un-signed packages would be a simple solution.\r\n\r\n----\r\n\r\nBut, just to think about it further... if it was possible for the WebPackage format to work with \"cache-control: immutable\", as per the suggestion by @bmeck, that could be a flag to show that a package can be kept indefinitely.\r\n\r\nAnd later (version 2?), that flag could be used to sign the content in a slightly different way - e.g. the Code Signing approach, where the Date recorded within the package is used instead of the current date, both when checking the certificate, but also when executing JavaScript (you don't want some JS hiding content based on the date/time).",
          "createdAt": "2018-01-10T14:43:49Z",
          "updatedAt": "2018-01-10T14:43:49Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "@craigfrancis according to https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#rfc.section.4.1 ,\r\n\r\n> Packages are designed to hold public information and to be shared to people with whom the original author never has an interactive connection. In that situation, there\u2019s no way to keep the contents confidential: even if they were encrypted, to make the data public, anyone would have to be able to get the decryption key.\r\n\r\nThat said, if the only data inside the bundle is encrypted data, your use cases of holding secure personal information in a webpackage could be possible. Just keep in mind that you're somewhat in the explicit \"non-goals\" area of webpackage.\r\n\r\nThat all said, as a developer I would definitely expect some means available to me to keep resources available from the page for a long long time. \"Immutable\" content sounds like something I'd want. I'd hope that existing HTTP headers would be sufficient to make this happen. Is there any behavior of `cache-control: immutable` that needs improvement?",
          "createdAt": "2018-01-25T04:03:00Z",
          "updatedAt": "2018-01-25T04:03:00Z"
        },
        {
          "author": "craigfrancis",
          "authorAssociation": "NONE",
          "body": "@rektide, thanks for the comment, but (fortunately) I\u2019ve no interest in the package being encrypted from a sensitive data / privacy point of view. I don\u2019t think that will be possible for this spec, as secret key management is tricky, and isn\u2019t covered at all in this case... you might be able to argue for password protected packages, but that would need to be considered another day, when the basic principle of archivable/immutable packages exist.\r\n\r\nFor now I think it should be up to the user to protect their sensitive documents, and if they decide to share their personal data (or whatever is in these archive-able packages), that will be their choice :-)\r\n\r\nAs to the immutable header, I hope it\u2019s possible in some way... where the browser *might* then be able to show that the package is unchanging (which is slightly different to how other non-immutable packages will work).",
          "createdAt": "2018-01-25T06:52:06Z",
          "updatedAt": "2018-01-25T06:52:06Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Closed by #137. ",
          "createdAt": "2019-05-13T17:06:19Z",
          "updatedAt": "2019-05-13T17:06:19Z"
        },
        {
          "author": "craigfrancis",
          "authorAssociation": "NONE",
          "body": "[Issue 576](https://github.com/WICG/webpackage/issues/576) continues the discussion regarding disallowing network access for [unsigned bundles](https://github.com/WICG/webpackage/blob/master/explainers/navigation-to-unsigned-bundles.md).",
          "createdAt": "2020-09-02T09:59:44Z",
          "updatedAt": "2020-09-02T09:59:44Z"
        }
      ]
    },
    {
      "number": 107,
      "id": "MDU6SXNzdWUyODcyOTQ1NDI=",
      "title": "Use-case: Service Worker cache population and synchronization",
      "url": "https://github.com/WICG/webpackage/issues/107",
      "state": "OPEN",
      "author": "ibnesayeed",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "feature request",
        "help wanted"
      ],
      "body": "If and when browser support for webpackage arrives, batch cache synchronization [1] or cache initialization [2] might be good use-cases, especially in the context of Service Worker. Using some sort of content negotiation mechanism, Service Worker might be able to ask the server for a webpackage that at least contains desired request URL(s). By unpacking the response and populating the cache, it can serve subsequent requests pretty quickly. What will be packed in the response is something that can be negotiated using some means or the server can decide as it does in case of HTTP/2 Server Hints (`prefetch`).\r\n\r\n[1] https://github.com/WICG/BackgroundSync\r\n[2] https://developer.mozilla.org/en-US/docs/Web/API/Cache/addAll",
      "createdAt": "2018-01-10T02:20:20Z",
      "updatedAt": "2019-05-13T17:07:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "Given the current spec, I would expect a developer to be able to create a page that:\r\n\r\n1. Receives a WebPackage\r\n2. Activates a ServiceWorker\r\n3. Has user code in the ServiceWorker that:\r\n3.a. Requests well known resources that it expects to be sourced from the WebPackage\r\n3.b. Puts those resources into the Cache\r\n\r\nWhat's tricky about this is that there needs to be some out-of-band transfer about which resources have been sent, as the ServiceWorker has to know which resources it can explicitly ask for, request the item, & put the item into the Cache.",
          "createdAt": "2018-01-25T03:31:40Z",
          "updatedAt": "2018-01-25T03:31:40Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm expecting that, when the browser loads a web package that either has a manifest identifying a service worker, or that is within scope of an existing service worker, the SW will get an event with the full contents of the package, so the SW can add it to its cache. I haven't started specifying this yet. PRs to add a [Bikeshed](https://tabatkins.github.io/bikeshed/) spec for the SW APIs are welcome if anyone wants to get to it first.",
          "createdAt": "2018-01-25T04:53:27Z",
          "updatedAt": "2018-01-25T04:53:27Z"
        }
      ]
    },
    {
      "number": 113,
      "id": "MDU6SXNzdWUyOTE0MjY2NjA=",
      "title": "Officially rename webpackage to another name.",
      "url": "https://github.com/WICG/webpackage/issues/113",
      "state": "CLOSED",
      "author": "TheLarkInn",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'd like to propose that we explore an alternative name for webpackage. Although [webpack](https://webpack.js.org/) is a separate tool in concerns of responsibilities from webpackage, I've already had a variety of confusion expressed from our userbase about what webpackage is and how it relates to webpack. \r\n\r\n\r\nMaybe some options: \r\n* WebParcel\r\n* WebZip\r\n* WebDistro\r\n\r\nMind you these are off the cuff, but I'd like to formally spin up the work involved to start exploring a replacement if there are no objections. ",
      "createdAt": "2018-01-25T02:10:19Z",
      "updatedAt": "2018-05-08T22:54:07Z",
      "closedAt": "2018-05-08T22:54:07Z",
      "comments": [
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "I can't think of a better alternative.\r\n\r\nKeep in mind that the spec needs magic-bytes. Any replacement candidate names OUGHT also have a fair and sensible set of magic bytes that emphasize the name. Anything not having good magic-bytes is, imho, a major downgrade in DX.",
          "createdAt": "2018-01-25T03:19:20Z",
          "updatedAt": "2018-01-25T03:19:20Z"
        },
        {
          "author": "TheLarkInn",
          "authorAssociation": "NONE",
          "body": "> spec needs magic-bytes\r\n\r\nWould you mind expanding on this? ",
          "createdAt": "2018-01-25T03:38:38Z",
          "updatedAt": "2018-01-25T03:38:38Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "> Would you mind expanding on this?\r\n\r\nThese magic-bytes are defined in https://tools.ietf.org/html/draft-yasskin-dispatch-web-packaging-00#section-2.2 .",
          "createdAt": "2018-01-25T03:50:33Z",
          "updatedAt": "2018-01-25T03:50:33Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is related to https://github.com/WICG/webpackage/issues/57#issuecomment-304945769, but thanks for filing an explicit issue about it.\r\n\r\nI've started calling the [bundling spec](https://github.com/WICG/webpackage/pull/98), well, \"bundling\" for lack of a better name, but WebParcel, WebZip, WebBundle, or some other name is fine with me. WebDistro reminds me a bit too much of Linux.\r\n\r\nI don't think there will be any trouble finding decent magic bytes for whatever we choose. Even if we keep the cute use of emoji, there are enough emoji to match almost anything.",
          "createdAt": "2018-01-25T04:36:55Z",
          "updatedAt": "2018-01-25T04:36:55Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "I don't super look forward to explaining to everyone that the name changed. That personally feels like a fright & complication I'd rather not deal with, & I personally would rather roll with it as is.\r\n\r\nWebBundle would be accurate though.",
          "createdAt": "2018-01-25T04:44:12Z",
          "updatedAt": "2018-01-25T04:44:12Z"
        },
        {
          "author": "TheLarkInn",
          "authorAssociation": "NONE",
          "body": "I guess my goal here is: \r\n\r\n**A name that doesn't include the following**: webpack, bundle, bundler, module bundler, etc.\r\n\r\n**Avoiding also**: Anything that could be confused with webpack, module bundler, rollup bundler, etc.\r\n\r\nUnless I've missed some recent changes to this spec, this is to describe a compression and peer to peer transfer/transmission protocol no? And not static bundling/compiling of web assets?\r\n",
          "createdAt": "2018-01-25T05:39:17Z",
          "updatedAt": "2018-01-25T05:39:47Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "If we're going no clash with anything at all, [Parcel](https://github.com/parcel-bundler/parcel) is out too.\r\n\r\nOf the original list, that leaves WebDistro (too linuxy) and WebZip (it's not a zip and that's confusing).\r\n\r\nAre we going to have to leave the visible spectrum to find a color we can paint this bikeshed?",
          "createdAt": "2018-01-25T06:29:42Z",
          "updatedAt": "2018-01-25T06:29:42Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "Sean, it's a way to bundle web resources: a format containing an index, a\nmanifest and resources.\n\nWebwrap, Webcontainer, Webpacket?\n\nOn Thu, Jan 25, 2018, 3:29 PM rektide <notifications@github.com> wrote:\n\n> If we're going no clash with anything at all, Parcel\n> <https://github.com/parcel-bundler/parcel> is out too.\n>\n> Of the original list, that leaves WebDistro (too linuxy) and WebZip (it's\n> not a zip and that's confusing).\n>\n> Are we going to have to leave the visible spectrum to find a color we can\n> paint this bikeshed?\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/113#issuecomment-360374038>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AGD3CtFA58rVoRnPsNwUCnNbuTZL5-qFks5tOB9XgaJpZM4RsOW8>\n> .\n>\n",
          "createdAt": "2018-01-25T12:00:26Z",
          "updatedAt": "2018-01-25T12:00:26Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there is a systematic way to go about the naming conflicts itself. Using a generic naming like \"Package\" or \"Bundle\" will always lead to conflicts. Certainly Web \"Animations\" and CSS \"Grid\" conflicted with another project here and there. The conflicts on the generic term cannot be avoided. This is where the \"Web\" prefix comes in. Being customary for modern web specs it disambiguates the generic term.\r\n\r\nNow, there is a special case, since webpack also uses the web prefix and hence there is genuine chance of confusion, especially given the similar domain that webpack and Web Packaging operate in (webpack would likely eventually become one of the most popular ways to make Web Packages).\r\n\r\nWith that I agree that \"Web Packaging\" should be reconsidered to avoid the confusion with \"webpack\" outlined above, but I'd not further constrain the namespace.\r\n\r\nGiven the current use of terminology in this project it seems to me like \"Web Bundle\" or \"Web Bundling\" seems like the most straightforward choice. ",
          "createdAt": "2018-01-25T14:49:57Z",
          "updatedAt": "2018-01-25T14:49:57Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "Wrap doesn't make intuitive sense to me. Container is hella over loaded. Packet is a weird clash with network layer, where packet is typically the smallest unit not a bundle of other things.",
          "createdAt": "2018-01-26T23:23:51Z",
          "updatedAt": "2018-01-26T23:23:51Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@TheLarkInn Do you still dislike names involving \"bundle\" given @cramforce's argument and the fact that the format in #98 is actually about static bundling of web assets?\r\n\r\nIt's likely that we'll be referring to this as \"the specifications formerly known as web packaging\" for a while, but since the specification has split anyway, and packaging was too associated with other complications in people's minds, I'm definitely in favor of calling the two halves something other than packaging.\r\n\r\nWe have roughly 2 categories of options:\r\n\r\n1. A purely descriptive name\r\n   1. WebBundle\r\n   1. WebZip: follows the precedent of things like 7zip and correctly implies that resources can be directly accessed without decompressing a prefix of the file.\r\n1. A made-up codename, which can avoid colliding with anything else. I don't have any good ideas here yet, but clever suggestions with good rationales could win out.\r\n\r\nI also want to be clear that I don't know who @rektide is, and while their suggestions are welcome, they're not going to determine the name.",
          "createdAt": "2018-01-26T23:43:58Z",
          "updatedAt": "2018-01-26T23:43:58Z"
        },
        {
          "author": "TheLarkInn",
          "authorAssociation": "NONE",
          "body": "I do like WebZip. It makes it very clear what is happening.\n\nOn Fri, Jan 26, 2018, 3:44 PM Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> @TheLarkInn <https://github.com/thelarkinn> Do you still dislike names\n> involving \"bundle\" given @cramforce <https://github.com/cramforce>'s\n> argument and the fact that the format in #98\n> <https://github.com/WICG/webpackage/pull/98> is actually about static\n> bundling of web assets?\n>\n> It's likely that we'll be referring to this as \"the specifications\n> formerly known as web packaging\" for a while, but since the specification\n> has split anyway, and packaging was too associated with other complications\n> in people's minds, I'm definitely in favor of calling the two halves\n> something other than packaging.\n>\n> We have roughly 2 categories of options:\n>\n>    1. A purely descriptive name\n>       1. WebBundle\n>       2. WebZip: follows the precedent of things like 7zip and correctly\n>       implies that resources can be directly accessed without decompressing a\n>       prefix of the file.\n>    2. A made-up codename, which can avoid colliding with anything else. I\n>    don't have any good ideas here yet, but clever suggestions with good\n>    rationales could win out.\n>\n> I also want to be clear that I don't know who @rektide\n> <https://github.com/rektide> is, and while their suggestions are welcome,\n> they're not going to determine the name.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n>\n>\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/113#issuecomment-360935848>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ADQBMN-x7E0iTI0jdv_H2xuVIo7u0hFEks5tOmNAgaJpZM4RsOW8>\n> .\n>\n",
          "createdAt": "2018-01-27T12:38:04Z",
          "updatedAt": "2018-01-27T12:38:04Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "HTTP has a HPACK now.\r\nso I like WPACK for this.",
          "createdAt": "2018-01-29T06:31:59Z",
          "updatedAt": "2018-01-29T06:31:59Z"
        },
        {
          "author": "BigBlueHat",
          "authorAssociation": "NONE",
          "body": "> I do like WebZip. It makes it very clear what is happening.\r\n\r\nNot sure PKWARE would agree there... http://www.pkware.com/documents/casestudies/APPNOTE.TXT ...nor the ISO http://www.iso.org/iso/home/store/catalogue_tc/catalogue_detail.htm?csnumber=60101\r\n\r\nAlso, WebBundle seems to be the most promising name (of the current list) so far, though HTTPack is maybe closest. \ud83d\ude04 ",
          "createdAt": "2018-02-02T21:39:57Z",
          "updatedAt": "2018-02-02T21:39:57Z"
        },
        {
          "author": "edwardkenfox",
          "authorAssociation": "NONE",
          "body": "I think webpackage is most straightforward, but also think WebBundle makes sense, too. I came up with \"Site Packaging\" as well as \"HTTP Container\" as alternatives, yet, thinking to myself \"HTTP Container\" sounds more of a low-level thing and might not suit the need for this. ",
          "createdAt": "2018-02-23T16:05:15Z",
          "updatedAt": "2018-02-24T00:18:06Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've been referring and getting others to refer to the components as \"Signed Exchanges\" and \"Bundles\", but the \"Web Packaging\" name for the overall project has enough mindshare, dating back to https://www.w3.org/TR/2015/WD-web-packaging-20150115/, that I don't think we can change it. The IETF is using the [\"wpack\"](https://www.ietf.org/mailman/listinfo/wpack) shorthand. All of this is close to \"webpack\", but it's not directly ambiguous, so I think it's the best we can do.",
          "createdAt": "2018-05-08T22:54:07Z",
          "updatedAt": "2018-05-08T22:54:07Z"
        }
      ]
    },
    {
      "number": 114,
      "id": "MDU6SXNzdWUyOTE0NDE0ODc=",
      "title": "Use case: listing available content",
      "url": "https://github.com/WICG/webpackage/issues/114",
      "state": "CLOSED",
      "author": "rektide",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As a developer, it would be useful to be able to read what resources are in my own bundle.\r\n\r\nUse case example: I am writing a offline capable Zine webapp. I typically have a directory for each issue, and a number of html files in each directory corresponding to pages in my Zine. There is also a \"zine browser\" main interface that let's me pick which zine I want to read, or skip to pages, and the main interface knows what I was last reading. To let people share my zine, I create a webpackage of the client software, and a number of zine issues.\r\n\r\nDilemma: how does my main interface know what zines are available in the bundle?\r\n\r\nIdeally, as a developer, I could have the main-client reader able to ask- what resources do I already know about? Any zines in a webpackage ought to be able to present themselves to my main client, let it know: hey, there's content here.\r\n\r\nThis issue gets more pointed if users start collecting multiple webpackages, like if I release a new webpackage with new zines. Before- considering the case of only a single webpackage of main-client+zines- it would perhaps not be pleasant but it could be possible to build an index file into my webpackage that enumerates all the content. However when there are multiple webpackages available, it becomes outright impossible to work with this situation. The main-client will not have a way to figure out what is in other bundles.\r\n\r\nAn implementation of #107 would resolve this use case. If webpackage content were available via the page's Cache APIs then we could use `Cache.keys()` to discover the content.\r\n\r\nThere is a related problem in HTTP/2 PUSH, with not being able to detect content: whatwg/fetch#65. As a page, there's no way to detect resources that HTTP/2 PUSH has sent: once again the developer needs to create an out-of-band mechanism to ever be able to access the resource.\r\n\r\nI would like to see listing of at least same-origin content added to the use-cases. I hope this example of a Zine illustrates the need and how this capability would help. Thanks.",
      "createdAt": "2018-01-25T03:46:55Z",
      "updatedAt": "2019-05-13T17:07:40Z",
      "closedAt": "2019-05-13T17:07:40Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Probably a duplicate of #107.",
          "createdAt": "2019-05-13T17:07:40Z",
          "updatedAt": "2019-05-13T17:07:40Z"
        }
      ]
    },
    {
      "number": 115,
      "id": "MDU6SXNzdWUyOTE1Mjk3NzA=",
      "title": "Loading",
      "url": "https://github.com/WICG/webpackage/issues/115",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The README suggests loading will be done at the W3C, which made me wonder. Shouldn't loading be integrated into Fetch somehow?",
      "createdAt": "2018-01-25T11:00:07Z",
      "updatedAt": "2018-01-30T00:46:19Z",
      "closedAt": "2018-01-30T00:46:19Z",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(This concern also applies to some extent to response header processing, which also takes place in Fetch and has been a source of confusion for IETF efforts as they don't carefully consider service workers, synthetic responses, etc.)",
          "createdAt": "2018-01-25T11:01:31Z",
          "updatedAt": "2018-01-25T11:01:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yes, and sorry for conflating the W3C and the WHATWG. I expect to do the initial web-side spec in the WICG, and then merge into Fetch, Service Workers, and whichever other web specs make sense, in those specs' organizations.",
          "createdAt": "2018-01-25T15:21:50Z",
          "updatedAt": "2018-01-25T15:21:50Z"
        }
      ]
    },
    {
      "number": 117,
      "id": "MDU6SXNzdWUyOTIwNjYyNDg=",
      "title": "Address clients that are offline for long periods of time",
      "url": "https://github.com/WICG/webpackage/issues/117",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "architecture",
        "feature request",
        "help wanted"
      ],
      "body": "People with expensive data plans may run out of data early in a month, and not come back online until the next month. The 7-day validity limit in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity is good or even too long while online, but not enough while offline. We need to figure out if we can give clients permission to use expired signatures under certain circumstances, and if so, how to specify that.",
      "createdAt": "2018-01-26T23:53:10Z",
      "updatedAt": "2019-05-13T17:08:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Is the framing correct? It presumes it\u2019s desirable or even good for clients to use expired signatures, and it\u2019s just a matter of figuring out \u201chow.\u201d It seems the bigger question is whether that is a valid use case, given the security risks - with a perfectly acceptable answer being \u201cNo, this is not a valid use case.\u201d",
          "createdAt": "2018-01-26T23:58:28Z",
          "updatedAt": "2018-01-26T23:58:28Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi Yeah, good point. How's the new wording?",
          "createdAt": "2018-01-27T00:06:54Z",
          "updatedAt": "2018-01-27T00:06:54Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "\ud83d\udc4c\u2764\ufe0f",
          "createdAt": "2018-01-27T00:07:59Z",
          "updatedAt": "2018-01-27T00:07:59Z"
        }
      ]
    },
    {
      "number": 124,
      "id": "MDU6SXNzdWUyOTg0OTU2Mzk=",
      "title": "gen-signedexchange should be able to capture arbitrary request/response HTTP headers.",
      "url": "https://github.com/WICG/webpackage/issues/124",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "Originally requested by @kinu.\r\n\r\nWe should be able to set arbitrary request/response HTTP headers to be captured in the generated signed exchange.\r\n```\r\n$ ./gen-signedexchange \\\r\n    -requestHeader \"Accept-Language: en\" \\\r\n    -responseHeader \"Server: Nginx\" \\\r\n    -responseHeader \"X-Frame-Options: Deny\"\r\n```\r\n\r\n@hajimehoshi Would you work on this?",
      "createdAt": "2018-02-20T07:30:56Z",
      "updatedAt": "2018-03-01T17:29:55Z",
      "closedAt": "2018-03-01T17:29:55Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Looking",
          "createdAt": "2018-02-21T07:20:49Z",
          "updatedAt": "2018-02-21T07:20:49Z"
        }
      ]
    },
    {
      "number": 128,
      "id": "MDU6SXNzdWUzMDAxNjI5MDA=",
      "title": "http and P2p",
      "url": "https://github.com/WICG/webpackage/issues/128",
      "state": "CLOSED",
      "author": null,
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "With PWA's rise, there is allot of action going on with P2P. \r\nYour browser is almost a web server now.\r\nI am seeing so many different ways to do the security aspects for P2P. \r\nHTTPS is not designed to do P2P, so i wanted to raise this and se if there is any thoughts on this going forward.\r\n\r\nI am expected to be told that this aspect is not part of the \"WebPackage\" spec and probably rightly so.\r\nBut i am trying to find where people are trying things out using golang to try to use HTTPS and P2p.\r\n",
      "createdAt": "2018-02-26T09:27:12Z",
      "updatedAt": "2018-03-05T21:35:53Z",
      "closedAt": "2018-03-05T21:35:53Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Web packages would be good content to transfer peer-to-peer, but this repository won't define the Javascript API to actually make P2P connections. At one point Mozilla was working on https://flyweb.github.io/ to provide this kind of API, but I suspect they've abandoned it.",
          "createdAt": "2018-03-05T21:35:53Z",
          "updatedAt": "2018-03-05T21:35:53Z"
        }
      ]
    },
    {
      "number": 129,
      "id": "MDU6SXNzdWUzMDAxOTA4OTU=",
      "title": "spelling nit",
      "url": "https://github.com/WICG/webpackage/issues/129",
      "state": "CLOSED",
      "author": "thiemonagel",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It's \"Chrome OS\", not \"ChromeOS\".",
      "createdAt": "2018-02-26T10:51:09Z",
      "updatedAt": "2018-03-05T22:07:41Z",
      "closedAt": "2018-03-05T21:29:35Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks.",
          "createdAt": "2018-03-05T22:07:41Z",
          "updatedAt": "2018-03-05T22:07:41Z"
        }
      ]
    },
    {
      "number": 135,
      "id": "MDU6SXNzdWUzMDI0NzU5MDg=",
      "title": "Update http-exchange format to improve security+reliability",
      "url": "https://github.com/WICG/webpackage/issues/135",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "@davidben points out that it's hard to write streaming parsers, and that the most reliable protocols send a number of bytes to read, read that number of bytes, and then use a non-streaming parser to pull information out of that contiguous data. The format in https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-03#section-5.3 doesn't accomplish this because CBOR items are prefixed by their length in items, not bytes.\r\n\r\nIn multi-process clients, we also want to allow the main/verification process to bound the amount of memory it uses. This implies (1) a length limit on the exchange header set, and (2) mandating use of the MI header instead of the Digest header to verify the payload authenticity, since MI has fixed-size records.\r\n\r\nFinally, it would be nice to be able to check signatures against the literal bytes in the http-exchange format instead of needing to reserialize. Reserialization still needs to be *possible* so that intermediates can receive a signature in a normal same-origin HTTP response and then produce the http-exchange format, but final clients shouldn't need to do it.\r\n\r\nThis probably means the format will move away from being a general http-exchange serialization format and toward being specific to signed exchanges. This has the extra benefit of not needing to say that request payloads and response trailers cause the signature not to verify.",
      "createdAt": "2018-03-05T21:46:20Z",
      "updatedAt": "2018-04-04T22:51:53Z",
      "closedAt": "2018-04-04T22:51:53Z",
      "comments": []
    },
    {
      "number": 138,
      "id": "MDU6SXNzdWUzMDI2MDQ5MzM=",
      "title": "Remove Digest in favor of MI",
      "url": "https://github.com/WICG/webpackage/issues/138",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For DoS reasons, the low-level portions of the networking stack must never buffer memory unboundedly. That means the Digest option is not usable, unless we move the hash check to the higher-level portions, but integrity is handled in the low-level portions. This means the low-level portions must return data with a \"this is unchecked, please check it later\". This is a classic mistake in designing a crypto system. All in all, this means that it is unlikely that any implementation of Digest could pass muster in Chrome.\r\n\r\nAdditionally, adding random redundant options is generally a bad idea. There's no reason to offer Digest when MI suffices. Please remove Digest from the specification completely.",
      "createdAt": "2018-03-06T08:24:33Z",
      "updatedAt": "2018-05-01T23:45:19Z",
      "closedAt": "2018-05-01T23:45:19Z",
      "comments": []
    },
    {
      "number": 141,
      "id": "MDU6SXNzdWUzMDMyMjQ4MzM=",
      "title": "Deal with clock skew",
      "url": "https://github.com/WICG/webpackage/issues/141",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "help wanted"
      ],
      "body": "Our strictness in enforcing being within the 7-day signature validity period interacts badly with skewed clocks. Do we want to encourage signers to pre-date the signature's timestamp by X hours, or require clients to trust signatures that start being valid in X hours, or something else?",
      "createdAt": "2018-03-07T19:15:23Z",
      "updatedAt": "2019-05-13T17:09:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The spec currently says to [deal with clock skew in a particular way](https://wicg.github.io/webpackage/loading.html#validating-signature), but it's not obvious that's correct.",
          "createdAt": "2019-05-13T17:09:21Z",
          "updatedAt": "2019-05-13T17:09:21Z"
        }
      ]
    },
    {
      "number": 142,
      "id": "MDU6SXNzdWUzMDM1ODAxMzA=",
      "title": "gen-certurl: turn this into a library so that other tool can depend on this",
      "url": "https://github.com/WICG/webpackage/issues/142",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [
        "go"
      ],
      "body": "",
      "createdAt": "2018-03-08T18:17:04Z",
      "updatedAt": "2018-12-20T04:05:27Z",
      "closedAt": "2018-12-20T04:05:26Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Not sure the concrete plan.",
          "createdAt": "2018-03-13T06:12:10Z",
          "updatedAt": "2018-03-13T06:12:10Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Now we have the [certurl package](https://github.com/WICG/webpackage/tree/master/go/signedexchange/certurl) which can be used as a library. ([example usage](https://github.com/irori/htxg-b1/blob/sxg-test/gae/cert_handler.go))",
          "createdAt": "2018-12-20T04:05:26Z",
          "updatedAt": "2018-12-20T04:05:26Z"
        }
      ]
    },
    {
      "number": 147,
      "id": "MDU6SXNzdWUzMDUzMjg2NDQ=",
      "title": "Define or forbid relative certUrls",
      "url": "https://github.com/WICG/webpackage/issues/147",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "H/T @twifkak for noticing that these are underspecified and underthought.",
      "createdAt": "2018-03-14T21:06:18Z",
      "updatedAt": "2018-04-06T17:34:09Z",
      "closedAt": "2018-04-06T17:34:09Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "The same thought should go into validityUrl, which is also a \"valid URL string\". Also note that \"valid URL string\"s can contain fragments, per that link.\r\n\r\nAlso, should the client verify that responses from these URLs don't contain any stateful headers, or are evaluated in a cross-origin context?",
          "createdAt": "2018-03-14T21:48:29Z",
          "updatedAt": "2018-03-14T21:48:29Z"
        }
      ]
    },
    {
      "number": 149,
      "id": "MDU6SXNzdWUzMDU3MzQxNDE=",
      "title": "Signed exchange use case: selectively downgrading content?",
      "url": "https://github.com/WICG/webpackage/issues/149",
      "state": "CLOSED",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The use case document has a section on [how webpackages may help users avoid censorship](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#rfc.section.2.2.2) but I'm wondering if they may also help achieve the opposite outcome: to allow authorities to censor content. (In particular, to withhold new content, and present old content as if it were fresh.)\r\n\r\nWith current browsers, when a user clicks on a link, if a page subsequently loads and `https://news.example.com/` is shown in the URL bar, they can be confident that the browser is displaying content retrieved from `news.example.com` and that was retrieved *after* they clicked on the link.  (That is, the content is fresh.) However, this is not necessarily true if the resource in question is a signed webpackage delivered by a CDN: whilst the content was signed by `news.example.com`, it could be up to 7 days old.\r\n\r\nThis may result in unexpected behavior for users in regions where the use of such CDNs/caches is pervasive (for e.g. performance and/or regulatory reasons) and where the cache operator has the ability and desire to selectively censor information (perhaps in reaction to a particular event or crisis). \r\n\r\nIf the cache rewrites links, it may even be possible to arrange for an entire website to appear up to date and completely functional when in fact fresh content is mixed with old at the discretion of the intermediary.\r\n\r\nSome mechanisms that may help reduce these risks:\r\n\r\n- Clients could indicate to users that content was not retrieved from an intermediary, and not the origin, and recommend that the \"reload\" feature be used if users are unsure of its freshness. (This also requires that the reload feature applies to the user-visible URL, and not the network URL; is this a recommendation of the format?)\r\n- Clients could verify the `validityUrl` more frequently than required, or allow users to manually trigger a validity check. (Related to [6.3 Downgrades](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.6.3).)\r\n- Recommend that origins who believe they might be subject to such attacks expire signatures within seconds or minutes. (Perhaps this could vary per cache, depending on the degree of confidence the origin has in the cache.)\r\n- Recommend that origins embed absolute timestamps within their content (e.g. \"Last modified: 2018-03-15 18:45\"), so that users are aware when content is not fresh.",
      "createdAt": "2018-03-15T21:59:31Z",
      "updatedAt": "2018-05-15T16:10:30Z",
      "closedAt": "2018-05-15T16:10:30Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The first two paragraphs are definitely a risk. If someone's browsing an untrustworthy site, with signed exchanges it has the ability to link to an old version of a story instead of the newest version, and there's currently no plan to show the user that in the URL bar.\r\n\r\nThe third paragraph seems unlikely to me: each link source has to separately opt into serving a signed exchange for a resource, so the attack would have to come from a widely-used CDN that all of these sources opt into.\r\n\r\nCaches can't rewrite links within a signed exchange without breaking the exchange's signature, so I don't think that's a risk at all. With bundles, we'll even be able to ensure that the intermediate can't selectively upgrade resources: if the publisher signs their site as a group (TBD exactly how this'll be expressed), the intermediate will be able to selectively break the signature of a subset of the resources, but the client can remove those from the cache and re-request them instead of mixing an old cached version with a newer signed version.\r\n\r\nI haven't written the recommendation that \"reload\" always ask the logical origin for freshness information, but that's the plan.\r\n\r\nWe can't have publishers expire signatures within minutes because that doesn't give the intermediate enough time to serve it on, but hours are probably plausible in many cases. Sites can set the `Cache-control` header to expire in minutes, like they currently do, and we could maybe use that as the indication that the browser should fetch the `validityUrl` eagerly. Maybe we could also expose the fact that a loaded page failed its validity check to javascript so the page can force-reload itself or otherwise notify the user? Pages could also ping their origin server themselves.",
          "createdAt": "2018-03-18T16:08:58Z",
          "updatedAt": "2018-03-18T16:08:58Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> so the attack would have to come from a widely-used CDN that all of these sources opt into\r\n\r\nMy understanding is that internet connectivity in some regions already has an equivalent property: in some parts of the world, it is an actual or de facto requirement that all network traffic go through a central point.\r\n\r\nRight now, this gives the central point the ability to block entire origins. However, this proposal seems to introduce new capabilities: (1) the ability to downgrade (not block) resources (so content appears to be fresh, but isn't); and (2) the ability to selectively downgrade or block individual resources (paths), rather than entire origins (so some content really is fresh).\r\n\r\nPerhaps neither of these capabilities is especially powerful/dangerous, but they do seem to add complexity to the user's security model.\r\n\r\n> Caches can't rewrite links within a signed exchange without breaking the exchange's signature\r\n\r\nI was thinking of rewriting the links prior to signing, not after signing. (For example, caches might choose to rewrite links to always point back to the cache for improved performance/reliability.)",
          "createdAt": "2018-03-18T18:34:29Z",
          "updatedAt": "2018-03-18T18:34:29Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Closing, I think this concern is about a \"resolved\" as it ever will be.",
          "createdAt": "2018-05-15T16:10:30Z",
          "updatedAt": "2018-05-15T16:10:30Z"
        }
      ]
    },
    {
      "number": 151,
      "id": "MDU6SXNzdWUzMDU4MDk2NTk=",
      "title": "signedexchange: Only first request/response header is adopted when multiple values are specified",
      "url": "https://github.com/WICG/webpackage/issues/151",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [
        "bug",
        "go"
      ],
      "body": "https://github.com/WICG/webpackage/blob/master/go/signedexchange/signedexchange.go#L87\r\n\r\nIn multiple values are specified, it looks like ok to join all the values with comma:\r\n\r\nhttps://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html\r\n\r\n> Multiple message-header fields with the same field-name MAY be present in a message if and only if the entire field-value for that header field is defined as a comma-separated list [i.e., #(values)]. It MUST be possible to combine the multiple header fields into one \"field-name: field-value\" pair, without changing the semantics of the message, by appending each subsequent field-value to the first, each separated by a comma. The order in which header fields with the same field-name are received is therefore significant to the interpretation of the combined field value, and thus a proxy MUST NOT change the order of these field values when a message is forwarded.\r\n\r\n",
      "createdAt": "2018-03-16T05:48:40Z",
      "updatedAt": "2018-03-19T12:16:01Z",
      "closedAt": "2018-03-19T12:16:01Z",
      "comments": []
    },
    {
      "number": 152,
      "id": "MDU6SXNzdWUzMDU4MjU4MDE=",
      "title": "gen-signedexchange: Add a flag to override signature's date",
      "url": "https://github.com/WICG/webpackage/issues/152",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [],
      "body": "That would be useful for generating test htxg.\r\n\r\ncc: @hajimehoshi ",
      "createdAt": "2018-03-16T07:21:26Z",
      "updatedAt": "2018-03-20T07:00:37Z",
      "closedAt": "2018-03-20T07:00:37Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Done",
          "createdAt": "2018-03-20T07:00:36Z",
          "updatedAt": "2018-03-20T07:00:36Z"
        }
      ]
    },
    {
      "number": 154,
      "id": "MDU6SXNzdWUzMDYyMTIyNjQ=",
      "title": "Specify the cache lifetime of a signed exchange",
      "url": "https://github.com/WICG/webpackage/issues/154",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The signature's expiry limits when you can receive the exchange. The HTTP cache control headers limit when you can use the exchange after it's successfully received.\r\n\r\nIt's not obvious what the policy should be, but a simple policy is to say that the resource expires from the cache at the earlier time of the signature expiration and the cache expiration.\r\n\r\nWe also need to specify how the resource is revalidated after it expires.\r\n1. The first use needs to be similar to [`<link rel=preload>`](https://w3c.github.io/preload/#link-type-preload) so that it's not revalidated during that first use.\r\n1. Subsequent uses can either [update signature validity](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#updating-validity) if the signature's expired, or use a conditional request if the cache information's expired. Once the signature's expired, remember that the etag isn't trustworthy.",
      "createdAt": "2018-03-18T04:24:21Z",
      "updatedAt": "2018-05-08T22:41:28Z",
      "closedAt": "2018-05-08T22:41:28Z",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "Hm. If we're talking about signed exchanges that are transferred over \"normal\" HTTP (i.e., not inside a bundle), the HTTP caches receiving it will treat it like any other response with freshness controls. You can't really override that, since not all caches receiving it will understand the signature.\r\n\r\nIf we're talking about signed exchanges inside a bundle -- which is effectively a different protocol -- it makes sense to figure out what the basis of the freshness lifetime is. I'm thinking it might make sense to make the `date` of the signature input to [calculating age](http://httpwg.org/specs/rfc7234.html#expiration.model).\r\n",
          "createdAt": "2018-03-26T04:51:16Z",
          "updatedAt": "2018-03-26T04:51:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is now sketched at https://github.com/WICG/webpackage/blob/master/explainer.md#signed-exchange-loading-sketch via #173.\r\n\r\nFor now, we're omitting third-party signed exchanges from the HTTP cache entirely. If we [add them later](https://github.com/WICG/webpackage/blob/master/explainer.md#to-consider-cache-the-inner-exchange), I think we'll have them live the shorter of the signature validity and the HTTP cache freshness expiration.\r\n\r\nAs Mark says, first-party signed exchanges are cached purely according to their HTTP headers.",
          "createdAt": "2018-05-08T22:41:28Z",
          "updatedAt": "2018-05-08T22:41:28Z"
        }
      ]
    },
    {
      "number": 156,
      "id": "MDU6SXNzdWUzMDYzOTgzODc=",
      "title": "Resource Timing behavior for HTTP Exchange loading",
      "url": "https://github.com/WICG/webpackage/issues/156",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "igrigorik",
        "irori"
      ],
      "labels": [
        "feature request"
      ],
      "body": "This came up in https://chromium-review.googlesource.com/c/chromium/src/+/967632.\r\n\r\nWhen a HTTP Exchange is loaded from an application/http-exchange+cbor envelope, what the resource timing fields for that load should represent?\r\n\r\ncc: @jyasskin @kinu\r\n",
      "createdAt": "2018-03-19T10:05:07Z",
      "updatedAt": "2019-05-13T17:14:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Resource timing is https://w3c.github.io/resource-timing/.\r\n\r\nWe'll need to specify all of the fields in https://w3c.github.io/resource-timing/#dom-performanceresourcetiming.\r\n\r\nIf we treat a signed exchange as a redirect, the normal resource timing algorithms will skip most of the data transfer, so I suspect we want to special-case them to cover the envelope instead of its content.",
          "createdAt": "2018-04-10T23:56:29Z",
          "updatedAt": "2018-04-10T23:56:29Z"
        }
      ]
    },
    {
      "number": 160,
      "id": "MDU6SXNzdWUzMDY3NTE2NTU=",
      "title": "gen-singedexchange: Cause an error when a stateful header field is found",
      "url": "https://github.com/WICG/webpackage/issues/160",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [],
      "body": "https://jyasskin.github.io/webpackage/implementation-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#stateful-headers\r\n\r\nCC @twifkak @nyaxt ",
      "createdAt": "2018-03-20T07:12:25Z",
      "updatedAt": "2018-04-02T01:35:44Z",
      "closedAt": "2018-04-02T01:35:44Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Instead of causing an error, just eliminating sounds fine. ",
          "createdAt": "2018-03-20T07:26:26Z",
          "updatedAt": "2018-03-20T07:26:26Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm I'd actually want it to cause an error instead of silently eliminating.\r\nSignedExchange is not built to capture private responses, and the attempt to do so should be an error.",
          "createdAt": "2018-03-20T08:10:18Z",
          "updatedAt": "2018-03-20T08:10:18Z"
        }
      ]
    },
    {
      "number": 161,
      "id": "MDU6SXNzdWUzMDY3NTQ3MDE=",
      "title": "Case-different keys in CBOR exchange headers",
      "url": "https://github.com/WICG/webpackage/issues/161",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "CBOR representation of exchange headers must be canonically-serialized, which means maps must not have multiple entries with the same key.\r\n\r\nHowever, they still can have duplicated HTTP header fields with case differences. For example:\r\n```\r\n[\r\n  {\r\n    ':url': 'https://example.com/'\r\n    ':method': 'GET',\r\n  },\r\n  {\r\n    ':status': '200',\r\n    'Content-Type': ...\r\n    'content-type': ...\r\n  }\r\n]\r\n\r\n```\r\nShould the spec explicitly forbid such duplicated headers? Or specify that header names must be stored in lower-case?",
      "createdAt": "2018-03-20T07:26:45Z",
      "updatedAt": "2018-03-27T20:27:15Z",
      "closedAt": "2018-03-27T20:27:15Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "HTTP/2 requires that everything be lowercase. This isn't exactly HTTP/2 since `:url` is different, but it borrows `:method` and `:status` from HTTP/2, so aligning there seems reasonable. No reason to allow multiple spellings of the same thing.",
          "createdAt": "2018-03-20T20:53:44Z",
          "updatedAt": "2018-03-20T20:53:44Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yep, PTAL at #163.",
          "createdAt": "2018-03-21T14:27:33Z",
          "updatedAt": "2018-03-21T14:27:33Z"
        }
      ]
    },
    {
      "number": 164,
      "id": "MDU6SXNzdWUzMDc0ODI3NDI=",
      "title": "Remove validityUrl mechanism from implementation snapshot",
      "url": "https://github.com/WICG/webpackage/issues/164",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the #updating-validity section, the 3rd and subsequent paragraphs should be removed.\r\n\r\nAt present, Chromium requires the Signature to have a valid validityUrl, but doesn't use it except for including it in the signed message. (@nyaxt please correct me if I'm wrong.)",
      "createdAt": "2018-03-22T02:22:06Z",
      "updatedAt": "2018-04-06T03:00:13Z",
      "closedAt": "2018-04-06T03:00:13Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> At present, Chromium requires the Signature to have a valid validityUrl, but doesn't use it except for including it in the signed message. (@nyaxt please correct me if I'm wrong.)\r\n\r\nYes. This is correct.",
          "createdAt": "2018-03-22T02:27:09Z",
          "updatedAt": "2018-03-22T02:27:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "My thought in leaving this in was that the validityUrl isn't just intended for the browser to check: any intermediate can use it to update their signed exchange without fetching the whole body. Even though the AMP intermediate doesn't intend to use it, some other intermediate that syncs on this draft might want to. That said, taking out the mechanism reduces the amount of work other intermediates and package generators need to think about.\r\n\r\nIf I take out the mechanism, I'll keep the validityUrl itself to match Chrome's enforcement that it's present, even though we don't check that it's fetchable.\r\n\r\n\ud83d\udc4d/\ud83d\udc4ethis comment if you want to keep the validityUrl mechanism(\ud83d\udc4d) or take it out(\ud83d\udc4e)?",
          "createdAt": "2018-03-22T09:46:54Z",
          "updatedAt": "2018-03-22T09:46:54Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, I see, the option is there for intermediaries to rewrite the signed-exchange payload to include the new Signature header? In that case, I'm pretty ambivalent. Maybe leave it in, as a lever we might explore later.",
          "createdAt": "2018-03-22T18:58:37Z",
          "updatedAt": "2018-03-22T18:58:37Z"
        }
      ]
    },
    {
      "number": 165,
      "id": "MDU6SXNzdWUzMDc4OTc2Mzc=",
      "title": "gen-certurl should be updated to follow latest spec draft",
      "url": "https://github.com/WICG/webpackage/issues/165",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [
        "go"
      ],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cert-chain-format",
      "createdAt": "2018-03-23T04:18:00Z",
      "updatedAt": "2018-04-11T05:38:27Z",
      "closedAt": "2018-04-11T05:38:27Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "ack",
          "createdAt": "2018-03-23T04:18:19Z",
          "updatedAt": "2018-03-23T04:18:19Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@twifkak You may want to update your software to use nyaxt branch for gen-certurl before the change goes in.",
          "createdAt": "2018-03-23T04:18:39Z",
          "updatedAt": "2018-03-23T04:18:39Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks; will do. Please cc me on the PR for this.",
          "createdAt": "2018-03-23T05:02:25Z",
          "updatedAt": "2018-03-23T05:02:25Z"
        }
      ]
    },
    {
      "number": 169,
      "id": "MDU6SXNzdWUzMTE0ODE0OTA=",
      "title": "Cross-origin trust: Source of SCTs",
      "url": "https://github.com/WICG/webpackage/issues/169",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust\r\n\r\n> 6.4 Validate that main-certificate has an sct property (Section 3.3) containing valid SCTs from trusted logs. ([RFC6962])\r\n\r\nDoes this mean that SCTs have to be included as a map item of the cert-chain CBOR? Or SCTs can be provided as an X.509v3 extension of `main-certificate` or as an OCSP extension of the `ocsp` property?\r\n",
      "createdAt": "2018-04-05T05:55:51Z",
      "updatedAt": "2018-04-09T18:19:20Z",
      "closedAt": "2018-04-09T18:19:20Z",
      "comments": []
    },
    {
      "number": 172,
      "id": "MDU6SXNzdWUzMTI0MDA3NDE=",
      "title": "Is URL fragment (#foobar) allowed for URLs?",
      "url": "https://github.com/WICG/webpackage/issues/172",
      "state": "CLOSED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After the change https://github.com/WICG/webpackage/pull/170, URLs (request URL, certUrl, and validityUrl) must be **[absolute-URL string](https://url.spec.whatwg.org/#absolute-url-string)**.\r\n\r\nIf my understanding is correct, **[absolute-URL string](https://url.spec.whatwg.org/#absolute-url-string)** can't contain the fragment.\r\nThe fragments is meaningless for certURL and validityUrl.\r\nBut I think it is useful for request URL.\r\n\r\ncc: @jyasskin @twifkak @nyaxt ",
      "createdAt": "2018-04-09T05:43:44Z",
      "updatedAt": "2018-04-10T22:18:52Z",
      "closedAt": "2018-04-10T22:18:52Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think it makes sense to allow requestURL be an absolute-URL string with fragments",
          "createdAt": "2018-04-09T06:38:58Z",
          "updatedAt": "2018-04-09T06:38:58Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Hm, my model was that if a signed exchange has a request URL of `https://pub.com/page.html` then it's authoritative for all fragments inside that page.\r\n\r\nI'm assuming that if `https://intermediate.com/nytimes.com/foo.sxg` has a request URL of `https://nytimes.com/foo.html` then a fetch of `https://intermediate.com/nytimes.com/foo.sxg#fragment` will internally redirect to `https://nytimes.com/foo.html#fragment`. Do we need to fix something for that to work?\r\n\r\nIf it already works, what's the use case for saying that a signed exchange holds `https://nytimes.com/foo.html#fragment` but not `https://nytimes.com/foo.html` or `https://nytimes.com/foo.html#other-fragment`?",
          "createdAt": "2018-04-09T16:20:16Z",
          "updatedAt": "2018-04-09T16:20:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Note fragments aren't sent to the server in a fetch over the network either. Nor do they figure into HTTP cache keys or anything. Agreed with @jyasskin that including fragments in the signed exchanges doesn't make sense. Having the fragments preserved on sxg \"redirects\" seems reasonable. It is how redirects normally work.",
          "createdAt": "2018-04-09T16:24:31Z",
          "updatedAt": "2018-04-09T16:25:00Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "According to RFC 7231, the Location header of redirection response can have the fragment.\r\nhttps://tools.ietf.org/html/rfc7231#section-7.1.2\r\nSo I think the request URL in signed exchange should be able to have the fragment.",
          "createdAt": "2018-04-10T00:43:56Z",
          "updatedAt": "2018-04-10T00:43:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, the location header can have a fragment and, indeed, a signed location header can have one too. But that field is not analogous to this one. It's the request that's relevant, and remember that the fragment is *not* sent in the request line.\r\n\r\nAlso remember the signed exchange is *signed*, presumably offline. Including the fragment in the request wouldn't be useful because then every possible fragment on the page must be signed separately. That's a whole lot of effort for no gain, since the body does not normally vary by fragment.\r\n\r\nIf you wish to direct someone to a fragment within a signed exchange, the mechanism Jeff proposed makes a lot more sense. Because resources do not vary by fragments and one can freely direct a user to a fragment by including it in the URL, there's no reason for signed exchange matching to incorporate the fragment. Therefore, don't put the fragment in there.",
          "createdAt": "2018-04-10T00:49:46Z",
          "updatedAt": "2018-04-10T00:49:46Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me retract my reply earlier. I'm convinced with [@jyasskin's model](https://github.com/WICG/webpackage/issues/172#issuecomment-379809601).",
          "createdAt": "2018-04-10T01:16:47Z",
          "updatedAt": "2018-04-10T01:16:47Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, I agree that `https://intermediate.com/nytimes.com/foo.sxg#fragment` should internally redirect to `https://nytimes.com/foo.html#fragment`.\r\n\r\nBut [offline browsing](https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-01#section-2.1.2) is one of use cases. It is very useful if \"Alex can download a file containing a large website (e.g.  Wikipedia) **with a fragment URL** from its origin, save it to transferrable storage (e.g. an SD card).\"\r\n\r\nI agree that the fragment doesn't need to be signed.\r\nOne option would be to have a metadata section in the signed exchange file which is not used to generate the signature.\r\nBut I don't think there is a problem that the signed exchange **can** have request URL with fragment.",
          "createdAt": "2018-04-10T02:31:58Z",
          "updatedAt": "2018-04-10T02:31:58Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think saving the fragment in the signed exchange format makes a whole lot of sense. The fragment is roughly the scroll position. (Consider your example, Wikipedia. The fragment doesn't tell you what article you are reading. It tells you to jump to a heading in the article.) If a user saves an HTML page today, it doesn't save the fragment.\r\n\r\nWhile I can see uses where one would want to stash it in, say, a bookmark, or in whatever mechanism offline websites get transmitted as, this does not make sense part of the signed exchange format. Rather it should be some *external* pointer, which would be needed anyway to pick out which page to look at out of a large package. If it were part of the request URI, verifying the signature would become complex, which is a security risk. If it were part of the format, it would carry over into the other use cases, which is a security risk.\r\n\r\nThis issue should just be closed WontFix.",
          "createdAt": "2018-04-10T15:34:30Z",
          "updatedAt": "2018-04-10T15:34:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The offline browsing use case needs bundling in order to be useful. While that use case doesn't mention fragments, bundles will have metadata with a [`start_url`](https://w3c.github.io/manifest/#start_url-member), and that can include a fragment.\r\n\r\n@horo-t Does putting the fragment at the bundle level work for the uses you're thinking of, or do they really need it in the signed exchange? If they really need it, could you describe them in more detail?\r\n\r\nAlso, thanks for bringing up details like this. Even if we decide not to make the change, it's helpful to consider it explicitly.",
          "createdAt": "2018-04-10T17:03:42Z",
          "updatedAt": "2018-04-10T17:03:42Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I didn't know about `start_url`. Then, we don't need to allow fragments in request URL of the signed exchange.\r\n\r\nI submitted a Chromium CL which checks the validity and the fragment of the URLs.\r\nhttps://chromium.googlesource.com/chromium/src/+/da1e9ae5f918c66f3f35f56b00190f5ed9773405",
          "createdAt": "2018-04-10T22:18:52Z",
          "updatedAt": "2018-04-10T22:18:52Z"
        }
      ]
    },
    {
      "number": 175,
      "id": "MDU6SXNzdWUzMTMxNDcwMjE=",
      "title": "OCSP / SCT requirements of the cert-chain",
      "url": "https://github.com/WICG/webpackage/issues/175",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cert-chain-format\r\n\r\n> 2. The first certificate\u2019s ocsp value *if any* MUST be a complete, DER-encoded OCSP response for that certificate\r\n\r\nThis reads main certificate's ocsp property is optional, but actually it's required in the step 6.3 of [Cross-origin trust](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust)?\r\n\r\n> 3. Each certificate\u2019s sct value MUST be a SignedCertificateTimestampList for that certificate\r\n\r\n- Add \"if any\" since SCTs may be embedded in the `cert` or `ocsp`? (#171)\r\n- The step 6.4 of [Cross-origin trust](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust) uses only SCTs for main certificate. If `sct` is to provide a channel to supply SCTs instead of the TLS extension, should the spec say that subsequent certificates MUST NOT have a `sct` value?\r\n\r\n@jyasskin @hajimehoshi @nyaxt ",
      "createdAt": "2018-04-11T01:57:45Z",
      "updatedAt": "2018-07-10T06:34:41Z",
      "closedAt": "2018-07-10T06:34:41Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, my understanding is the spec allows the same-origin response to omit ocsp and sct, in which case the intermediary must collect and attach them. Question: If an intermediary made a stricter requirement that it would only ingest SXGs that include these, would it be a bad citizen?",
          "createdAt": "2018-04-11T04:49:07Z",
          "updatedAt": "2018-04-11T04:49:07Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "These are covered by #246.",
          "createdAt": "2018-07-10T06:34:41Z",
          "updatedAt": "2018-07-10T06:34:41Z"
        }
      ]
    },
    {
      "number": 176,
      "id": "MDU6SXNzdWUzMTMzMjc0MTQ=",
      "title": "Node ecosystem might need to preserve using `file:` protocol",
      "url": "https://github.com/WICG/webpackage/issues/176",
      "state": "OPEN",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "feature request"
      ],
      "body": "Various things in the ecosystem use symlinks, the behavior of symlinks in node and how HTTP redirects is not compatible per https://github.com/nodejs/modules/issues/62 . Could repurpose the `Location` header over `file:` but https://fetch.spec.whatwg.org/#scheme-fetch could be changed in a forwards incompatible way if we do that.",
      "createdAt": "2018-04-11T13:36:43Z",
      "updatedAt": "2019-05-13T17:15:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 177,
      "id": "MDU6SXNzdWUzMTM0MjkwMTU=",
      "title": "Internal referencing and internal only resources",
      "url": "https://github.com/WICG/webpackage/issues/177",
      "state": "OPEN",
      "author": "BigBlueHat",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "architecture",
        "feature request"
      ],
      "body": "Question related to the \"bundling\" spec draft: https://github.com/WICG/webpackage/pull/98\r\n\r\nAre there plans to include an internal referencing mechanism similar to [MHTML](https://tools.ietf.org/html/rfc2557)'s use of [`Content-ID`](https://tools.ietf.org/html/rfc2557#section-9.5) or the TAG's previous [Packaging on the Web](https://www.w3.org/TR/web-packaging/)'s use of [fragment identifiers](https://www.w3.org/TR/2015/WD-web-packaging-20150115/#fragment-identifiers)?\r\n\r\nFor instance, book (et al) publishers are coming from EPUB where \"everything\" is built using internal references and internal-only resources. Additionally, there may be other use cases where \"internal only\" package contents might be needed and beneficial.\r\n\r\nIf that seems out of scope for this sort of bundling, though, no worries. Just wanted to check. \ud83d\ude03 \r\n\r\nWe'll be exploring that need in the Publishing WG via https://github.com/w3c/pwpub/issues/24\r\n\r\nThanks!\r\n\ud83c\udfa9 ",
      "createdAt": "2018-04-11T18:01:54Z",
      "updatedAt": "2019-05-13T17:15:38Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 183,
      "id": "MDU6SXNzdWUzMTU2Mzk3MTc=",
      "title": "How are duplicate response headers handled in the same-origin response?",
      "url": "https://github.com/WICG/webpackage/issues/183",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "Google App Engine apparently has a small (undocumented) per-header-line size limit [1]. I imagine other such containers might have similar limits. This will be a problem with Signature (esp. if multiple sigs) and Link, unless a signer is allowed split them by newline.\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cbor-representation doesn't specify a canonical way to join duplicate response headers; could/should it?\r\n\r\n[1] Was 497, per [stackoverflow](https://stackoverflow.com/questions/15280027/is-there-a-size-limit-for-http-response-headers-on-google-app-engine), but may have increased to 1k or so.",
      "createdAt": "2018-04-18T20:57:31Z",
      "updatedAt": "2019-05-13T17:16:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "This is sort of issue is part of why we advocated changing the style of signature in issue #148. You don't need to worry as much about being able to round-trip what you got to and from the signed representation. Not that it's impossible to solve, but why solve a problem when you can just walk around it? :-)\r\n\r\nWhen what you get is the signed representation, it's more obvious how to verify it and that what you will process is exactly what you verified.",
          "createdAt": "2018-04-18T22:40:10Z",
          "updatedAt": "2018-04-18T22:40:10Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC, #148 changes the packaged `application/signed-exchange` format but not the https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#same-origin-response. I think there is value in publishers being able to deliver a same-origin response containing a Signature/Signed-Headers that is ignored by browsers and consumed by crawlers:\r\n\r\nThe `application/signed-exchange` is one that not all browsers understand (and likely suboptimal same-origin even for those that do). Therefore, there would need to be a discovery mechanism, by which the crawler knows a signed variant of a resource exists and how to get it. There are approximately two ways to do this:\r\n  1. By URL - the original page specifies via link tag where the htxg lives.\r\n  2. By header - the server Varies its response based on an as-yet-undefined request header\r\n\r\nThe first is bad for crawlers because it requires they maintain mappings between non-htxg and htxg, and handle all sorts of edge cases there. It's bad for publishers and search users because crawlers respect hostload maximums, and this would effect the rate at which updates could be crawled (and, in turn, search quality).\r\n\r\nThe second is bad for publishers because varying by request header is something that many frontends don't do well, or need special configuration for. (For instance, I don't know of any that let you specify a custom cache-key for request coalescing, so it would need to be disabled.) In the same-origin model, if a publisher is unable to configure Varying, that means they'll just be signing more responses than they need to. In the application/signed-exchange model, it means they'll be unable to serve signed exchanges.\r\n\r\n(In the end, there may be a need for a \"by URL\" mechanism, but I'd like to minimize the reasons publishers would want to take it, because of its downsides.)",
          "createdAt": "2018-04-18T23:10:09Z",
          "updatedAt": "2018-04-18T23:10:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "On the original question, I'm relying on https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04#section-3 to allow senders to split each signature into its own header line. A single RSA signature might still go over the limit.\r\n\r\nIt's possible we'll eventually decide against implementing the header field, but I currently think it's useful for same-origin responses. It's necessary for signature-based SRI, although if we find that @twifkak's use cases for signed-exchanges don't actually need it, we could simplify the SRI header.",
          "createdAt": "2018-05-01T18:34:11Z",
          "updatedAt": "2018-05-01T18:34:11Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin That covers Signature, but not the headers that would be signed over, which are not httpbis structured headers. e.g. What is the signed message given this response?\r\n\r\n```\r\nSigned-Headers: \"link\"\r\nLink: <foo.js>;rel=preload\r\nLink: <foo.css>;rel=preload\r\n```\r\n\r\nThe section I linked to above says \"the header field\u2019s value as a byte string\". Is this enough to imply that the \"MAY\" in https://tools.ietf.org/html/rfc7230#section-3.2.2 becomes a \"MUST\"? I'd suggest this be explicit (if the header field remains).",
          "createdAt": "2018-05-01T19:18:27Z",
          "updatedAt": "2018-05-01T19:18:27Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "'k, I'll make that more explicit. Yes, in all of the signing situations, I'm expecting any duplicated headers to be joined with commas.",
          "createdAt": "2018-05-01T19:25:13Z",
          "updatedAt": "2018-05-01T19:25:13Z"
        }
      ]
    },
    {
      "number": 185,
      "id": "MDU6SXNzdWUzMjE3ODkyODA=",
      "title": "explainer: Should prefetch recursion have a limit?",
      "url": "https://github.com/WICG/webpackage/issues/185",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "If A prefetches sxg_0, which includes a preload for sxg_1, which includes a preload for sxg_2, ... This could lead to unbounded prefetches. Perhaps include a limit like https://fetch.spec.whatwg.org/#ref-for-concept-request-redirect-count%E2%91%A0.",
      "createdAt": "2018-05-10T02:36:43Z",
      "updatedAt": "2018-05-10T21:25:59Z",
      "closedAt": "2018-05-10T21:25:59Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @kinu",
          "createdAt": "2018-05-10T17:47:48Z",
          "updatedAt": "2018-05-10T17:47:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think this issue belongs in the https://github.com/w3c/resource-hints/ repository where prefetch is defined. I don't see anything specific to signed exchanges here.",
          "createdAt": "2018-05-10T21:25:59Z",
          "updatedAt": "2018-05-10T21:25:59Z"
        }
      ]
    },
    {
      "number": 186,
      "id": "MDU6SXNzdWUzMjIwMDE0NzE=",
      "title": "Increment ver num on \"implementation checkpoint\"",
      "url": "https://github.com/WICG/webpackage/issues/186",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt"
      ],
      "labels": [],
      "body": "Chromium would like to start adding support for next \"implementation checkpoint\".\r\nCan we increment ver num on https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#rfc.section.5.3 ?",
      "createdAt": "2018-05-10T16:47:24Z",
      "updatedAt": "2018-07-09T18:41:36Z",
      "closedAt": "2018-07-09T18:41:36Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yes ... do you have a feeling for the subset of https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html that you'll be able to implement for the next checkpoint?",
          "createdAt": "2018-05-10T20:42:22Z",
          "updatedAt": "2018-05-10T20:42:22Z"
        }
      ]
    },
    {
      "number": 187,
      "id": "MDU6SXNzdWUzMjIxMDQ0OTQ=",
      "title": "Versioning support in Accept-Signature?",
      "url": "https://github.com/WICG/webpackage/issues/187",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [
        "feature request"
      ],
      "body": "It seems worth adding a \"desired version(s)\" to the Accept-Signature, so intermediaries can signal which version of the Signature header they are capable of consuming. Otherwise, I guess they would have to sniff, based on the names of the parameters, or add a non-standard request header for this purpose.",
      "createdAt": "2018-05-10T22:15:26Z",
      "updatedAt": "2019-05-13T17:17:07Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I need to redesign the Accept-Signature header, and the new version should at least start with a version number.",
          "createdAt": "2019-05-13T17:17:07Z",
          "updatedAt": "2019-05-13T17:17:07Z"
        }
      ]
    },
    {
      "number": 188,
      "id": "MDU6SXNzdWUzMjQ3NjY4MDQ=",
      "title": "Define a WebDriver extension for Signed Exchange testing",
      "url": "https://github.com/WICG/webpackage/issues/188",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Both Signed Exchange and CBOR cert chain have short lifetime (max 7 days). This makes it difficult to use pre-generated signed exchange / cert files in end-to-end testing. To workaround this, Chromium has an [internal testing API](https://chromium-review.googlesource.com/c/chromium/src/+/991833) (available only in test runner) that overrides signature verification time.\r\n\r\nIn order to test Signed Exchange Loading in web-platform-tests, we need an interoperable way to override signature verification time. The preferred way is defining a [WebDriver extension](https://w3c.github.io/webdriver/#dfn-extension-command) in the respective spec (in this case, Signed Exchange) so that the same surface API is used across UAs.\r\n\r\nSee [this doc](https://docs.google.com/document/d/1zlFRcKuTM3RpoYjcOtiVOioRErEkJyCyv8hDs9_mlXo/edit#heading=h.n0pzm6uk5f69) for more details and discussions.",
      "createdAt": "2018-05-21T02:14:14Z",
      "updatedAt": "2019-04-25T01:37:00Z",
      "closedAt": "2019-04-25T01:37:00Z",
      "comments": [
        {
          "author": "RByers",
          "authorAssociation": "MEMBER",
          "body": "@kereliuk, can you point to an example spec where this has been done now? This seems like it should be pretty straight forward to implement, and I'm a little concerned that the longer we continue with chromium-only testing, the more debt we might accidentally accrue. \r\n\r\nFWIW it looks like the existing chromium tests are here:\r\n[third_party/WebKit/LayoutTests/http/tests/loading/htxg](https://cs.chromium.org/chromium/src/third_party/WebKit/LayoutTests/http/tests/loading/htxg/)\r\n[third_party/WebKit/LayoutTests/http/tests/devtools/htxg/](https://cs.chromium.org/chromium/src/third_party/WebKit/LayoutTests/http/tests/devtools/htxg/)\r\n[content/test/data/htxg/](https://cs.chromium.org/chromium/src/content/test/data/htxg/)\r\n\r\nAnd there's already a devtools protocol API for mocking out the verification time: [setSignedExchangeVerificationTime](https://cs.chromium.org/chromium/src/third_party/WebKit/LayoutTests/http/tests/loading/htxg/resources/htxg-util.js?type=cs&q=setSignedExchangeVerificationTime&sq=package:chromium&g=0&l=38)\r\n\r\nAnything I missed @irori?",
          "createdAt": "2018-07-04T13:58:58Z",
          "updatedAt": "2018-07-04T13:58:58Z"
        },
        {
          "author": "kereliuk",
          "authorAssociation": "NONE",
          "body": "> @kereliuk, can you point to an example spec where this has been done now?\r\n\r\nHere is an example in [Reporting](https://w3c.github.io/reporting/#automation)\r\n\r\n@irori Let me know if you have any questions with defining the specification or the implementation steps that follow. I'm working on getting some end to end documentation/tutorials on the entire process.",
          "createdAt": "2018-07-05T15:40:09Z",
          "updatedAt": "2018-07-05T15:40:09Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "I initially thought we can override the verification time, but it seems not an option because OS/underlying library doesn't allow this.\r\n\r\nPasting @sleevi's comment (from an internal chat) about Signed Exchange testing (markup mine):\r\n\r\n> Here's things we can and can't do:\r\n> \r\n> 1. We can modify the HXTG interaction to support treating cert errors as interstitials, so that DevTools can bypass the interstitial (as it does today) - but that's going to be really weird with the whole flow and expected behaviours.\r\n> \r\n> 2. We can modify HXTG's cert verifier to lie (similar to `--ignore-cert-errors-spki-list`), but then like ICESL, we'd need to make sure it doesn't cache (which is why that flag requires `--user-data-dir`), but that means you can only DevTools with a custom profile (and ICESL already 'just works' for the cert part today)\r\n> \r\n> 3. We can generate an on-the-fly CA and on-the-fly responses. It needs to be an on-the-fly CA, not shared among WPT, because our TLS policies are such that we block vendors who generate shared-root-CA keys (meaning we'd blacklist the WPT CA key if it's generating a shared-key). That's the path WebPageReplay has gone, AIUI.\r\n> \r\n> What we can't do:\r\n> \r\n> - We can't verify a certificate and response \"in the past\" while still actually validating it. No one's APIs support that use case. PKI assumes time is linear and monotonic, and so to do the APIs\r\n\r\nFrom Chromium's point of view, 2. seems to be the easiest. Our test runner already uses `--ignore-cert-errors-spki-list` for WPT tests, so we just have to let SXG signature verifier lie (about signature expiration) too. Question is if other UAs have similar switches, and if we can/should make this switchable via a WebDriver extension. As Ryan noted, we have to make sure it doesn't cache, etc.\r\n\r\nOption 1 (let DevTools bypass interstitial SXG errors) is another way to bypass cert verification in tests. This might be more suitable for an underlying implementation of a WebDriver extension (I'm not completely sure). It's still question if other browsers are willing to implement the same WebDriver API.\r\n\r\nOption 3 actually exercises cert verification in tests. In addition to WPT infra work, this needs some Chromium-side testing infra change too (not to just ignore cert errors).\r\n\r\n\r\n## Strawman proposal\r\n- Add `.tentative` tests using the option 2. It wouldn't work unless UA is configured to ignore certificate errors, and wouldn't test the certificate verification behavior. But it would be still useful to test the \"loading\" aspect of SXGs. Also, we can add manual tests with instructions to generate SXGs using a test CA.\r\n\r\n- In the long term, explore an on-the-fly CA + SXG generation approach. Probably we can implement it in Go and submit binaries to the WPT repository.\r\n",
          "createdAt": "2018-08-14T02:06:36Z",
          "updatedAt": "2018-08-14T06:11:10Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI, I've started adding tentative tests in [wpt/signed-exchange](https://github.com/web-platform-tests/wpt/tree/master/signed-exchange). ([Tracking bug](https://bugs.chromium.org/p/chromium/issues/detail?id=895723))",
          "createdAt": "2018-10-16T09:03:05Z",
          "updatedAt": "2018-10-16T09:03:05Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "We've implemented the option 2 of https://github.com/WICG/webpackage/issues/188#issuecomment-412729051.\r\nProbably we won't need a WebDriver extension. Closing.",
          "createdAt": "2019-04-25T01:37:00Z",
          "updatedAt": "2019-04-25T01:37:00Z"
        }
      ]
    },
    {
      "number": 191,
      "id": "MDU6SXNzdWUzMjQ3OTkxMDc=",
      "title": "Request for fixed length magic string: \"sxg1-\"",
      "url": "https://github.com/WICG/webpackage/issues/191",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current spec draft, the magic string is allowed to be arbitrary length for implementation drafts.\r\n\r\n> Note: RFC EDITOR PLEASE DELETE THIS NOTE; The implementation of the final RFC MUST use this file signature, but implementations of drafts MUST NOT use it and MUST use another implementation-specific string beginning with \u201csxg1-\u201c and ending with a 0 byte instead.\r\n\r\nThis makes its streaming parsing non-trivial, since we need to scan for `\"\\0\"` to appear, rather than reading fixed length record.\r\n\r\nTwo proposals:\r\n- Allocate fixed length (8bytes?) for the magic string field, and pad the rest of the bytes `\"\\0\"` \r\n  - Will file a PR for this\r\n- Separate version field?",
      "createdAt": "2018-05-21T06:12:31Z",
      "updatedAt": "2018-05-24T23:19:19Z",
      "closedAt": "2018-05-24T23:19:19Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think an implementation can parse the current format by reading as many bytes as the longest magic string it supports, and then memcmp'ing against each of the magic strings including their trailing `'\\0'`.\r\n\r\nI think I prefer a version field over a `\\0`-padded magic string.",
          "createdAt": "2018-05-21T22:24:59Z",
          "updatedAt": "2018-05-21T22:24:59Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "We would like to simplify the decoder which would live in the browser process as much as possible. I will draft a change that basically does:\r\n```\r\n\"sxg1\" magic + 3byte ver + 3byte siglen + 3byte hdrlen + ...\r\n```\r\n\r\n> I think an implementation can parse the current format by reading as many bytes as the longest magic string it supports, and then memcmp'ing against each of the magic strings including their trailing '\\0'.\r\n\r\nYes, but it would require concatenating the overread portion to the start of {signature,headers} buffer.",
          "createdAt": "2018-05-21T23:12:51Z",
          "updatedAt": "2018-05-21T23:12:51Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> Yes, but it would require concatenating the overread portion to the start of {signature,headers} buffer\r\n\r\nIt is also possible that the signature/headers buffer may be smaller than the overread and you go into the body itself.\r\n\r\nThat said, you likely should be doing this anyway because issuing small reads at a time is not very efficient. (I don't remember being asked to review any CLs to implement the new format... I assume  they're just still in progress?) If you look at Chromium's HTTP/1.1 implementation, we read data in large chunks at a time and, if we got more or less than the full HTTP headers, we just handle that case.",
          "createdAt": "2018-05-21T23:20:05Z",
          "updatedAt": "2018-05-21T23:20:05Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I haven't written any code yet. (Mainly landing golang lib impl right now)\r\n\r\nThe current impl for the old format basically issues 3 reads at the minimum:\r\n- SignedExchangeHandler: Read fixed header's header === {magic, headerLen}\r\n- SignedExchangeHandler: Read CBOR header of headerLen\r\n- MercleIntegritySourceStream: Read payload\r\n  - SignedExchangeHandler moves ownership of the `source_` stream to MercleIntegritySourceStream\r\n\r\nWe can basically keep this 3+ read scheme if the new \"header's header\" is const, but needs to do buffering (as @davidben mentioned) to handle variable len magic.\r\n\r\n> That said, you likely should be doing this anyway because issuing small reads at a time is not very efficient. (I don't remember being asked to review any CLs to implement the new format... I assume they're just still in progress?) If you look at Chromium's HTTP/1.1 implementation, we read data in large chunks at a time and, if we got more or less than the full HTTP headers, we just handle that case.\r\n\r\nI discussed this a bit with @irori.\r\n\r\nWe are a bit hesitant to do our own buffering in SignedExchangeHandler until we are sure that this is a major performance bottleneck.\r\n- We expect the format to evolve in the short term so we want to keep the implementation as simple as possible at this point.\r\n- Getting rid of the `source_` move to MercleIntegritySourceStream is non-trivial. We need to either:\r\n  - Modify MerkleIntegirtySourceStream to take additional ctor param for the overread portion, while this makes it divert from other FilterSourceStreams impl.\r\n  - Make SignedExchangeHandler a SourceStream so it could proxy Read() calls.",
          "createdAt": "2018-05-22T01:11:21Z",
          "updatedAt": "2018-05-22T01:11:21Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Doing small reads at parsing layer and making buffered read in the underlying layer for efficiency can be decoupled in the implementation, I think impl concerns can be probably addressed (we chatted potential feasible impl options with @nyaxt, @irori and @horo-t too).\r\n\r\n@davidben -- one thing that's a bit unclear to us is your stance on non-deterministic/streaming parsing. Once you pushed back the format that requires streaming parsing in favor of fixed length format, while this time we say that the variable length is preferable or okay in the newer format. What is driving the difference, is that the level of required complexity?\r\n",
          "createdAt": "2018-05-22T02:06:56Z",
          "updatedAt": "2018-05-22T02:06:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not pushing back against a fixed-width string. Fixed-width strings are great. I was just agreeing with Jeffrey's comment that this isn't a big deal given you already round up your reads, as is standard. Though it sounds like you're not planning on doing it, in which case I agree this is a nuisance.\r\n\r\nI pushed back on trying to use a streaming CBOR parser because that one does not admit much of simplifications. You end up threading the streaming logic through an already complex format. That is a classic error dating all the back to ASN.1 (except that CBOR made some mistakes that even ASN.1 avoided, so it's even worse in CBOR).\r\n\r\nActually, come to think of it, I'm pretty sure this already came up and I'd already asked for a change that avoids this problem. The format shouldn't require dispatching on the magic string, only MIME type. That avoids this problem completely because you already know how big of a magic string to expect by the time you instantiate your handler.\r\nhttps://github.com/WICG/webpackage/pull/148#discussion_r178949840",
          "createdAt": "2018-05-22T15:53:21Z",
          "updatedAt": "2018-05-22T15:53:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Indeed, if we say that `application/signed-exchange;v=b1` has a magic string of \"sxg1-b1\\0\", then the handler should be able to read exactly 8 bytes, and if it gets \"sxg1\\0abc\" instead, that's just a failure to parse. It wouldn't try to push \"abc\" back onto the stream to continue as a different version of the spec.",
          "createdAt": "2018-05-22T17:01:03Z",
          "updatedAt": "2018-05-22T17:01:03Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I see, that makes a lot sense to me now, thanks @davidben and @jyasskin for better clarification!",
          "createdAt": "2018-05-23T01:42:33Z",
          "updatedAt": "2018-05-23T01:42:33Z"
        }
      ]
    },
    {
      "number": 197,
      "id": "MDU6SXNzdWUzMjY5NjAyNDM=",
      "title": "Clarify how we handle permanent diffs between impl checkpoint and the main draft (e.g. `MI` vs `MI-draft2`)",
      "url": "https://github.com/WICG/webpackage/issues/197",
      "state": "CLOSED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I suppose the latest draft of the -impl checkpoint basically follows the latest responses draft ('the main draft) with some gaps, so a typical workflow could be like to keep cherry-picking changes from the latest responses into the latest impl draft.  However there are some diffs that are only tracked by the impl checkpoint but not in the main draft, e.g. like https://github.com/WICG/webpackage/pull/155 (`MI` vs `MI-draft2`).  I can see the reason not to track this in the main draft, but I'm afraid tracking such changes that only exist in some branch but not in the master responses draft may become a bit cumbersome, especially if we start to have multiple of such diffs.\r\n\r\nWould it be possible to avoid doing this but instead put some instructions for the implementors in the main draft? (This is something @jyasskin mentioned as a potential alternative in some of our offline chat)  Or could we have some special section in the ChangeLog in the main draft so that all we need to cherry-pick can be still found in the main draft?",
      "createdAt": "2018-05-28T09:27:39Z",
      "updatedAt": "2018-08-14T18:25:27Z",
      "closedAt": "2018-08-14T18:25:27Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The current long-lived impl-only diffs are:\r\n\r\n* MI->MI-draft2: Will be handled by https://github.com/martinthomson/http-mice/pull/8, probably with a reference in the main draft.\r\n* A specific version number for the https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#internet-media-type-applicationsigned-exchange, for which I could have the existing editor's note call out draft-yasskin-httpbis-origin-signed-exchanges-impl.\r\n* A couple TBDs have actual numbers. I could move these into the main draft.\r\n   * mi-sha256 records must be <= 16kB.\r\n   * application/signed-exchange's header length must be <= 512kB.\r\n\r\n\r\nDid I miss any?",
          "createdAt": "2018-06-18T23:13:24Z",
          "updatedAt": "2018-06-18T23:13:24Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good, thanks!  We'll also watch https://github.com/martinthomson/http-mice/pull/8.  Moving some of the (tentative) actual numbers into the main draft sounds good too, or at least could be helpful for tracking changes from impl side (if you think having the change there is not harmful for future revisions).\r\nExplicitly cc-ing @nyaxt in case he has other or additional thoughts.",
          "createdAt": "2018-06-25T04:32:04Z",
          "updatedAt": "2018-06-25T04:32:04Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "As:\r\n\r\n  - https://tools.ietf.org/html/draft-thomson-http-mice-02 is still in draft\r\n  - there's a `Digest` header defined in https://tools.ietf.org/html/rfc3230 and https://tools.ietf.org/html/rfc5843\r\n\r\nWhat do you think of proposing:\r\n\r\n  - `mi-sha256` as an additional digest algo to rfc5843\r\n  - introduce `*base64url*` in rfc3230\r\n\r\nThe outcome would be:\r\n\r\n```\r\nDigest: mi-sha256=*...*\r\n```\r\n\r\n",
          "createdAt": "2018-07-04T13:00:30Z",
          "updatedAt": "2018-07-04T13:00:30Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Feedback from @martinthomson https://github.com/martinthomson/http-mice/issues/11",
          "createdAt": "2018-07-05T12:43:29Z",
          "updatedAt": "2018-07-05T12:43:29Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@ioggstream Let's keep discussing the Digest change over in the MICE repo.",
          "createdAt": "2018-07-06T21:29:20Z",
          "updatedAt": "2018-07-06T21:29:20Z"
        }
      ]
    },
    {
      "number": 201,
      "id": "MDU6SXNzdWUzMjg2ODczNjY=",
      "title": "Define how client-generated requests match serialized requests in signed exchanges and bundles",
      "url": "https://github.com/WICG/webpackage/issues/201",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-dispatch-bundled-exchanges.html currently doesn't specify how a client decides which bundled request to use in any particular context. We need to define that.\r\n\r\nhttps://docs.google.com/document/d/1JdJkdY7cK2rD9JXbK75sSn069c0rhF9UnLQACBZ1OtY/edit# starts exploring the space but doesn't come to a conclusion yet.",
      "createdAt": "2018-06-01T23:19:53Z",
      "updatedAt": "2019-03-22T18:56:29Z",
      "closedAt": "2019-03-22T18:56:28Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#285 and #360 defined this matching algorithm for signed exchanges, and https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html gives the algorithm we'll use for bundles when their loading spec is written.",
          "createdAt": "2019-03-22T18:56:28Z",
          "updatedAt": "2019-03-22T18:56:28Z"
        }
      ]
    },
    {
      "number": 202,
      "id": "MDU6SXNzdWUzMjkzMzM0MTA=",
      "title": "Clarify #load-metadata Step 12.2 Metadata field",
      "url": "https://github.com/WICG/webpackage/issues/202",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "cc: @jyasskin \r\n\r\nIn the step 12.2 of \"[Load a bundle's metadata](https://wicg.github.io/webpackage/draft-yasskin-dispatch-bundled-exchanges.html#load-metadata)\", the text says:\r\n> If \"name\"\u2019s Metadata field is \u201cNo\u201d, continue to the next triple.\r\n\r\nI couldn't find where a Metadata field for a \"name\" is. Can we clarify the text here?",
      "createdAt": "2018-06-05T07:30:26Z",
      "updatedAt": "2018-06-19T05:50:47Z",
      "closedAt": "2018-06-19T05:50:47Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Step 8\r\n\r\n> Let knownSections be the subset of the Section 6.2 that this client has implemented.\r\n\r\nlinks to https://wicg.github.io/webpackage/draft-yasskin-dispatch-bundled-exchanges.html#section-name-registry, which has a Metadata field. It's probably worth including the link in 12.2 also.",
          "createdAt": "2018-06-06T07:59:25Z",
          "updatedAt": "2018-06-06T07:59:25Z"
        }
      ]
    },
    {
      "number": 206,
      "id": "MDU6SXNzdWUzMzA4NzA5ODI=",
      "title": "Q: referrer from signed http exchanged page",
      "url": "https://github.com/WICG/webpackage/issues/206",
      "state": "CLOSED",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "feature request"
      ],
      "body": "1, navigate to https://example.com/a.sxg\r\n2, a.sxg is signed by https://example.net so browser display it as https://example.net\r\n3, clicking the link on https://example.net\r\n\r\nin request of 3, which origin should on referrer header example.com (actual) or example.net (display) ?\r\n(spec seems not mention this: https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html)",
      "createdAt": "2018-06-09T09:38:26Z",
      "updatedAt": "2019-05-13T17:18:38Z",
      "closedAt": "2019-05-13T17:18:38Z",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "That should be example.net I believe.  Also example.net *is* the actual origin once UA is navigated to the exchange.  The [loading sketch in the explainer](https://github.com/WICG/webpackage/blob/master/explainer.md#signed-exchange-loading-sketch)  discusses some of these (while not clearly specifying details like referrers)",
          "createdAt": "2018-06-12T03:43:52Z",
          "updatedAt": "2018-06-12T03:43:52Z"
        },
        {
          "author": "Jxck",
          "authorAssociation": "NONE",
          "body": "is there any plan to add actual url(example.com) on request header like referrer ?",
          "createdAt": "2018-06-12T08:47:42Z",
          "updatedAt": "2018-06-12T08:47:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "There's no plan to add a new `Referer`-like header that identifies the physical URL of the referrer. It's always possible, of course, given a strong enough use case.",
          "createdAt": "2018-06-12T20:23:15Z",
          "updatedAt": "2018-06-12T20:23:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#433 discusses the architectural question here.",
          "createdAt": "2019-05-13T17:18:38Z",
          "updatedAt": "2019-05-13T17:18:38Z"
        }
      ]
    },
    {
      "number": 212,
      "id": "MDU6SXNzdWUzMzE4MDY1MzA=",
      "title": "Structured responses section for streaming loading",
      "url": "https://github.com/WICG/webpackage/issues/212",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "# Goal\r\n- Easier streaming consumption of large bundles.\r\n- Easier non-streaming consumption of the small bundles.\r\n\r\n# Background\r\nIn the current bundle spec, the structure of the responses section is allowed to be very flexible and not required to be a CBOR construct.\r\n\r\n## Streaming loading algorithm for current format\r\nWhen loading a bundle in a streamed fashion, currently the parser will:\r\n1. Consume the index section\r\n1. Sort the exchanges by their response range offset\r\n1. Consume the other sections up till the responses section\r\n1. Discard the bytes until it reaches the first exchange in the sorted list\r\n1. Buffer the bytes until it reaches the end of the the first exchange\r\n1. The first exchange becomes ready for its use:\r\n  1. Parse its responses header CBOR map\r\n  1. Read its payload\r\n1. Append bytes to the buffer until it reaches the end of the next item.\r\n1. The second exchange becomes ready for its use.\r\n1. ...\r\n\r\nSince there may be overlap in the response exchange, we need to keep around the original responses section in the buffer (which probably will reside on memory), since they may theoretically be used more than 1 time in a different CBOR interpretation. It is non-trivial to compute the \"done\" part of the responses section which are not referenced in later exchanges to partially free the original responses bytes buffer.\r\n\r\n## Non-streaming consumption of the small bundles\r\nIf the entire bundle is guaranteed to be a valid CBOR, it will become very easy to consume small packages which will easily fit in memory. If efficiency is not an issue, you can feed the entire package to CBOR parser, and consume the exchanges without implementing the full parsing algorithm.\r\n\r\nFor example, @irori created [a live web demo of unbundler](\r\nhttps://bundle-load-test.surge.sh/) which assumes that the bundler output a CBOR array as response section.\r\n\r\n# Proposals\r\n- Specify the structure of the responses section\r\n  - A valid CBOR array? \r\n- An index section entry references the response via array index, not offset\r\n  - Enforces the start of the response is aligned to the start of the item in the responses CBOR array\r\n  - Can save an alignment assert in the parser\r\n- Require the responses section to be always after the index section",
      "createdAt": "2018-06-13T01:12:40Z",
      "updatedAt": "2018-06-22T18:51:37Z",
      "closedAt": "2018-06-22T18:51:37Z",
      "comments": []
    },
    {
      "number": 214,
      "id": "MDU6SXNzdWUzMzIwODgzODE=",
      "title": "Report failure to validate a signed exchange",
      "url": "https://github.com/WICG/webpackage/issues/214",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This should use http://wicg.github.io/reporting/.",
      "createdAt": "2018-06-13T17:18:55Z",
      "updatedAt": "2019-03-19T00:02:55Z",
      "closedAt": "2019-03-19T00:02:55Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This also needs to deal with the client being offline, and with clients who are fetching a signed exchange to avoid censorship/surveillance.",
          "createdAt": "2018-06-13T17:22:49Z",
          "updatedAt": "2018-06-13T17:22:49Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "It might be worth addressing two different use cases:\r\n\r\n1. For distributors, to collect metrics on the efficacy of their validation algorithms and maybe trigger a removal of their cached copy. This would be on the outer exchange. If the SXG was prefetched first, it would only need to occur on the prefetch, not the navigation.\r\n\r\n2. For publishers, to collect metrics on the validity of their publishing mechanism and maybe trigger a blacklist of that URL until the bug can be fixed. This would be on the inner exchange, and only occur on navigation, not prefetch.\r\n\r\nThere's a third case where the embedder is different from the distributor, but it's probably OK to make a simplifying assumption for now.",
          "createdAt": "2018-08-16T19:26:21Z",
          "updatedAt": "2018-08-16T19:26:21Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Chromium implementation issue: https://crbug.com/910516",
          "createdAt": "2018-11-30T10:46:07Z",
          "updatedAt": "2018-11-30T10:46:07Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@igrigorik suggested me to integrate with network-error-logging.\r\nSo I submitted an issue on NEL's repo.\r\nhttps://github.com/w3c/network-error-logging/issues/99\r\n",
          "createdAt": "2018-12-06T07:13:49Z",
          "updatedAt": "2018-12-06T07:13:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think this was solved by https://github.com/WICG/webpackage/pull/374.",
          "createdAt": "2019-03-19T00:02:55Z",
          "updatedAt": "2019-03-19T00:02:55Z"
        }
      ]
    },
    {
      "number": 221,
      "id": "MDU6SXNzdWUzMzMxMTUwOTE=",
      "title": "Certificate chain in exchanges",
      "url": "https://github.com/WICG/webpackage/issues/221",
      "state": "OPEN",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "architecture",
        "bundled-exchanges"
      ],
      "body": "By using [data-url](https://fetch.spec.whatwg.org/#data-urls) in cert-url of [Signature Header](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-header), the [certificate chain](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cert-chain-format) can be contained in a Signed HTTP Exchange. It is useful for offline loading.\r\n\r\nBut having the same certificate chain in multiple Signed HTTP Exchanges in a Bundled HTTP Exchange is not efficient. We should have a way to contain one certificate chain per one host name for multiple Signed HTTP Exchanges in a Bundled HTTP Exchange.\r\n\r\nI filed this issue from the discussion in https://crrev.com/c/1102281.",
      "createdAt": "2018-06-18T02:16:54Z",
      "updatedAt": "2019-05-13T17:19:42Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 222,
      "id": "MDU6SXNzdWUzMzMxMjA3OTY=",
      "title": "Clarify what schemes should be allowed for URL fields in the signature",
      "url": "https://github.com/WICG/webpackage/issues/222",
      "state": "CLOSED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current Signed Exchange spec draft [says](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.1) `cert-url` and `validity-url` should be [an absolute-URL string](https://url.spec.whatwg.org/#absolute-url-string), but that could potentially allow multiple schemes than http/https (e.g. file and ws), while it doesn't seem to include data: URL.  It looks we'd better clarify what schemes should be allowed there.",
      "createdAt": "2018-06-18T03:05:23Z",
      "updatedAt": "2018-06-21T02:30:43Z",
      "closedAt": "2018-06-21T02:30:43Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I *think* `data:` is allowed as an absolute-URL string by following the \"not an ASCII case-insensitive match for a special scheme\" branch, followed by the \"path-relative-scheme-less-URL string\" branch. That said, the real parsing for this should use the [URL parser](https://url.spec.whatwg.org/#url-parsing) with no base URL and then exclude fragments and filter for the schemes we want.\r\n\r\nI feel like the right set of schemes is https://fetch.spec.whatwg.org/#fetch-scheme, maybe subset by https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy, and maybe removing `file:` for the small risk of finding a way to read local files from the signed exchange.",
          "createdAt": "2018-06-18T21:26:21Z",
          "updatedAt": "2018-06-18T21:26:21Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/whatwg/url/issues/68 made me think it's not covered there but rather in fetch spec, but yeah the URL spec covers broader concepts so it might actually cover it.\r\n\r\nReg: https://fetch.spec.whatwg.org/#fetch-scheme I doubt we want to include `about`, `blob` and `filesystem` schemes either, unless we're considering dynamic package generation done by a JS code.  Loading data from these URL would basically need upper layer context than HTTP layer (e.g. we need a concept of Web origin there), and implementing it will become harder.",
          "createdAt": "2018-06-19T00:55:31Z",
          "updatedAt": "2018-06-19T00:55:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think `blob:` and `filesystem:` make sense for the newsreader app Jake demoed at I/O, where one SW stores signed exchanges for a bunch of other websites. That said, maybe we should assume bundles there, where the certificate can be stored inline.",
          "createdAt": "2018-06-19T05:49:51Z",
          "updatedAt": "2018-06-19T05:49:51Z"
        }
      ]
    },
    {
      "number": 229,
      "id": "MDU6SXNzdWUzMzQ3MTA5NDM=",
      "title": "Rename id-ce-testCanSignHttpExchanges",
      "url": "https://github.com/WICG/webpackage/issues/229",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Came up in https://crrev.com/c/1103430/5/net/cert/asn1_util.cc#241:\r\n\r\n@sleevi:\r\n> Gotcha. $.02 (but not critical) is we should rename this to id-ce-canSignHttpExchangesDraft (or id-ce-draftCanSignHttpExchanges), it was the 'test' bit that caught me by surprise.\r\n\r\n@jyasskin What do you think?",
      "createdAt": "2018-06-22T01:12:55Z",
      "updatedAt": "2018-06-25T01:47:11Z",
      "closedAt": "2018-06-25T01:47:11Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "SGTM.",
          "createdAt": "2018-06-22T16:13:45Z",
          "updatedAt": "2018-06-22T16:13:45Z"
        }
      ]
    },
    {
      "number": 234,
      "id": "MDU6SXNzdWUzMzYzMDQ4MjU=",
      "title": "Bad mi-sha256 signature in example",
      "url": "https://github.com/WICG/webpackage/issues/234",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I expect\r\n\r\n- mi-sha256 signatures to be base64 encoded\r\n\r\n## instead\r\n\r\n- in examples, they are hexdigest",
      "createdAt": "2018-06-27T16:38:08Z",
      "updatedAt": "2018-07-02T22:41:03Z",
      "closedAt": "2018-07-02T22:41:03Z",
      "comments": []
    },
    {
      "number": 236,
      "id": "MDU6SXNzdWUzMzY3ODAxOTE=",
      "title": "Include a list of used permissions in signed part of bundles",
      "url": "https://github.com/WICG/webpackage/issues/236",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "feature request"
      ],
      "body": "@slightlyoff mentioned that we might want to have [third-party security reviewers](https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-01#section-2.2.3) check more or less stringently depending on which permissions an app uses. To do that, they'll need to be able to sign over the permissions they've checked for.",
      "createdAt": "2018-06-28T21:06:38Z",
      "updatedAt": "2019-05-13T17:20:02Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 237,
      "id": "MDU6SXNzdWUzMzY3ODg5MDE=",
      "title": "Idea: use of jws in Signature header",
      "url": "https://github.com/WICG/webpackage/issues/237",
      "state": "CLOSED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "What do you think about using a JWS inside a signature headers instead of redefining a Subset of jws claims?\r\n\r\nWhich is the Right Place for Such a discussion?\r\n",
      "createdAt": "2018-06-28T21:36:45Z",
      "updatedAt": "2018-07-11T17:16:04Z",
      "closedAt": "2018-07-04T12:46:48Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "No, this should not use JWS. That would bring in a boatload of complexity and security risk (the JWT family of standards are rather famously problematic), as well as lose some of the important considerations such as domain separation between TLS, for no real gain.",
          "createdAt": "2018-06-28T22:26:35Z",
          "updatedAt": "2018-06-28T22:26:35Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Understood. \r\n\r\nI was just trying to generalize this mechanism (eg. to other keys, ...) to use it as a non-repudiation standard (eg. respect to https://tools.ietf.org/id/draft-cavage-http-signatures-10.html) \r\n\r\nSending `Signature` in every request/response would have done the job.\r\n\r\n\r\n",
          "createdAt": "2018-07-04T12:46:48Z",
          "updatedAt": "2018-07-04T12:46:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is the right place for the discussion though. :) I'd like to make sure we appropriately address your use cases without getting side-tracked on the question of what format to use to encode signatures.\r\n\r\nI'll point out that there are two kinds of generalization in here already:\r\n\r\n1. The [ed25519key](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-header) parameter allows basically the same header to work for https://github.com/mikewest/signature-based-sri.\r\n1. When the public key is vouched by an X.509 chain, it could be something other than a domain-trusted key. For example, I expect [third-party security reviewers](https://tools.ietf.org/html/draft-yasskin-webpackage-use-cases-01#section-2.2.3) to sign with X.509 keys signed by something other than a Web CA.\r\n\r\nNeither one addresses use in an HTTP *request*, and I do suspect that requests are different enough from responses that we shouldn't try to use the same header for both, but if you think we should, please suggest it in a new issue. (New to avoid the confusion with JWS.)",
          "createdAt": "2018-07-06T23:08:34Z",
          "updatedAt": "2018-07-06T23:08:34Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Hi @jyasskin and thank you very much for your reply!\r\n\r\n> please suggest it in a new issue. (New to avoid the confusion with JWS.)\r\n\r\nI moved the discussion to  #248 ",
          "createdAt": "2018-07-10T09:07:16Z",
          "updatedAt": "2018-07-11T17:16:04Z"
        }
      ]
    },
    {
      "number": 238,
      "id": "MDU6SXNzdWUzMzY4MzkxMjk=",
      "title": "Critical-ness of CanSignHttpExchanges extension",
      "url": "https://github.com/WICG/webpackage/issues/238",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This came up in https://crrev.com/c/1111485.\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req\r\n\r\n> Conforming CAs MUST mark this extension as critical, and clients MUST NOT accept certificates with this extension in TLS connections (Section 4.4.2.2 of [I-D.ietf-tls-tls13]). \r\n\r\nIn Chrome, certificate path building and verification is performed using underlying operating systems' API. So, if the CanSignHttpExchanges extension is marked as critical, the OS API will reject the cert, until the OS supports CanSignHttpExchanges extension.\r\n\r\nCan we revisit the critical-ness of this extension? What's the security implication of not marking it as critical?\r\n\r\ncc: @sleevi @jyasskin ",
      "createdAt": "2018-06-29T02:13:37Z",
      "updatedAt": "2018-07-18T15:49:04Z",
      "closedAt": "2018-07-18T15:49:04Z",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Thanks for filing, @irori! My understanding is that this could still be a potential issue for Edge/Safari, unless browser updates are strictly locked to OS updates (since the crypto APIs are controlled by the OS)\r\n\r\nBy making it critical, it ensures no existing application can use Signed Exchange certs in TLS - that is, it forces key separation by technological means. This minimizes risk for cross-protocol issues, and for ecosystem issues, by ensuring that 100% of (well-behaving) clients will reject Signed Exchange certs being used for TLS.\r\n\r\nHowever, it presents its own set of compatibility issues - every certificate verifying application has to be updated to recognize this extension - and, in general, OS and cryptographic libraries don't let applications extensibly say \"I know and recognize this extension\", which means they also have to be updated to recognize this extension.\r\n\r\nIf we make it non-critical, then there's the risk that users can end up deploying their Signed Exchanges key on their TLS endpoint. This doesn't undermine the signature scheme of Signed Exchanges, but it does present certain operational risks - particularly, if your TLS edge is compromised and that key is compromised, folks can MITM users without requiring an active-network presence.\r\n\r\nWe can mitigate that risk by having Signed Exchange supporting TLS clients refuse to connect to TLS servers that present this extension. That is, if the certificate for an on-the-wire exchange contains this extension, fail the connection, in the same way that if a certificate in a signed exchange lacks this extension, the exchange fails validation. This creates the ecosystem disincentive to deploy your signed exchange key at your TLS server - but runs a chicken and egg problem of if a bunch of users do this before browsers start shipping signed exchanges, the ecosystem could end up more broken once they do ship exchanges.\r\n\r\nDespite this, I think making it non-critical is fine. For example, there's nothing (at present) preventing a CA from issuing a TLS server cert and a \"signed exchange server cert\" using the same underlying key and CSR - providing two certificates, one with the extension and one without. This has all of the same security problems I just described above, and is not mitigated by the critical extension.\r\n\r\nMore broadly, I think the best way we can capture this is by making sure we have a \"Security Considerations\" section that details the risks from improper key hygiene, which can cover these scenarios in depth. This is somewhat captured in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.6.4 and https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.6.2 but may be worth fleshing out more comprehensively as its own bit.",
          "createdAt": "2018-06-29T15:32:11Z",
          "updatedAt": "2018-06-29T15:32:11Z"
        }
      ]
    },
    {
      "number": 242,
      "id": "MDU6SXNzdWUzMzc5NjYwNjU=",
      "title": "Fallback URLs for forward compatibility",
      "url": "https://github.com/WICG/webpackage/issues/242",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Chromium would like to be able to ship these formats and then continue evolving them as they make their way through the standards process. QUIC attempts something like this by defining [\"invariants\"](https://tools.ietf.org/html/draft-ietf-quic-invariants-01), \"properties of the QUIC transport protocol that are expected to remain unchanged over time as new versions of the protocol are developed.\" To try the same thing in these specifications, it might make sense to put a fallback URL in a fixed place in both the signed exchange and bundles formats.\r\n\r\nFor signed exchanges, this would be the request URL that's currently encoded as the `:url` field in the [request headers](https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-04#section-3.2). For bundles, it would be the [`start_url`](https://www.w3.org/TR/appmanifest/#start_url-member) that's expected to be in the bundle's [manifest](https://tools.ietf.org/html/draft-yasskin-wpack-bundled-exchanges-00#section-3.2.2). In both cases, the value would be moved instead of copied to the new location, to avoid the possibility of inconsistencies.\r\n\r\nWhen the client receives an unknown version of the format (either too old or too new), it would redirect to the fallback URL. Offline users would be out of luck, but online ones would still be able to get the content.\r\n\r\nThis could also be accomplished using content negotiation on the `Accept` header, but that's a [joint that might rust shut](https://www.imperialviolet.org/2016/05/16/agility.html), so we should try to make things work even if it's rusty, if possible.\r\n\r\nThoughts?",
      "createdAt": "2018-07-03T16:12:13Z",
      "updatedAt": "2018-08-20T07:21:21Z",
      "closedAt": "2018-08-20T07:21:21Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me.\r\nBy \"redirect to the fallback URL\", do we expect the fallback URL to be a plain content (not signed exchange nor bundle)?",
          "createdAt": "2018-07-04T01:20:53Z",
          "updatedAt": "2018-07-04T01:21:05Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Sounds good to me. Are there any strategies to keep the joint oiled for the time being (e.g. through origin trial)? Are there any cross-cutting concerns (e.g. referrer, SW) that need hammering out?",
          "createdAt": "2018-07-04T02:16:27Z",
          "updatedAt": "2018-07-04T02:16:27Z"
        },
        {
          "author": "RByers",
          "authorAssociation": "MEMBER",
          "body": "Yes, this sounds brilliant, thank you! I hope that we can plan for doing breaking format changes over a release or two of Chrome. Ensuring that version mismatch results only in loss of performance (no ability to pre-fetch due to privacy constraints) and offline functionality instead of hard breakage is critical to enabling that.\r\n\r\nShould we perhaps also add the higher level principle here to the \"Requirements\" section? I.e. signed exchanges need to be designed to plan for breaking format changes without the need for user agents to know how to decode more than one version.",
          "createdAt": "2018-07-04T13:42:41Z",
          "updatedAt": "2018-07-04T13:42:41Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "Cool idea.\r\n\r\nhttps://github.com/WICG/webpackage/issues/242#issuecomment-402335315 : given the context, I think it makes sense to require a plain response from the fallback URL. \r\n\r\nAssumption: IUC, said fallback URL would be the URL of the signed exchange's content / ..., right?\r\n\r\nMy original comment mentioned using a regular Accept header given the above assumption. But, I noticed Jeffrey's rusty joint comment. Confusion ensued :)",
          "createdAt": "2018-07-06T04:04:08Z",
          "updatedAt": "2018-07-06T04:07:25Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "+1, this sounds really neat to me.  Also +1 to mention something like this in the higher level principle section.  Reg: how this could work in play in clients/UAs I assume this'd still look like a (fancy) redirect, maybe less fancier than when the version was supported in the client.\r\n\r\nReg: version changes should the spec also note some recommendation about how long an old version of format should be supported by implementors?",
          "createdAt": "2018-07-06T05:19:54Z",
          "updatedAt": "2018-07-06T05:19:54Z"
        }
      ]
    },
    {
      "number": 243,
      "id": "MDU6SXNzdWUzMzgxMDE5OTY=",
      "title": "gen-certurl: make sct optional",
      "url": "https://github.com/WICG/webpackage/issues/243",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt",
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "> -sct should be optional (if not, we should fix gen-certurl), so we can omit it.\r\nThe `-sct` command-line flag of the `gen-certurl` tool is not currently optional",
      "createdAt": "2018-07-04T01:30:32Z",
      "updatedAt": "2018-07-09T05:14:39Z",
      "closedAt": "2018-07-09T05:14:39Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like this is already done in #196 :)",
          "createdAt": "2018-07-09T05:14:39Z",
          "updatedAt": "2018-07-09T05:14:39Z"
        }
      ]
    },
    {
      "number": 245,
      "id": "MDU6SXNzdWUzMzgxMzEzNDM=",
      "title": "openssl review needed: go/signedexchange/README.md",
      "url": "https://github.com/WICG/webpackage/issues/245",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "irori",
        "davidben"
      ],
      "labels": [],
      "body": "@davidben @irori, would you take a look at self-signed cert generation instructions at https://github.com/WICG/webpackage/tree/master/go/signedexchange#creating-our-first-signed-exchange ?",
      "createdAt": "2018-07-04T05:05:10Z",
      "updatedAt": "2018-07-23T16:21:01Z",
      "closedAt": "2018-07-23T16:21:01Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "You probably should mention that `example.org` should (I assume) be replaced with your origin.\r\n\r\nDoes `<(echo \"1.3.6.1.4.1.11129.2.1.22 = ASN1:NULL\\nsubjectAltName=DNS:example.org\")` work? That prints a literal `\\n` for me, not a newline, and indeed the instructions cause my `openssl` to break. (Had you run this before? Maybe we use different shells? I'm just using bash.) Perhaps `<(echo \"1.3.6.1.4.1.11129.2.1.22 = ASN1:NULL\"; echo \"subjectAltName=DNS:example.org\")` \r\n\r\nOtherwise LGTM.",
          "createdAt": "2018-07-06T19:40:03Z",
          "updatedAt": "2018-07-06T19:40:03Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!\r\n\r\n> Maybe we use different shells?\r\n\r\nI was using zsh and the shell expandeds it. Added `-e` param so that echo will expand it if the shell doesn't.",
          "createdAt": "2018-07-09T04:04:43Z",
          "updatedAt": "2018-07-09T04:05:51Z"
        }
      ]
    },
    {
      "number": 248,
      "id": "MDU6SXNzdWUzMzkyMzgzNTk=",
      "title": "Use case: non repudiation",
      "url": "https://github.com/WICG/webpackage/issues/248",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## I wish signed exchanges to cover the non-repudiation use-case\r\n\r\nI wish to use the `Signature` header for non repudiation.\r\n\r\nExample:\r\n\r\n  - client sends a request with a Signature of given headers and payload\r\n  - server replies with a Signature that may contain e.g. the request hash\r\n\r\n### Non repudiation\r\nSee [nist 800-32](https://csrc.nist.gov/publications/detail/sp/800-32/final)\r\n\r\nAssurance that:\r\n\r\n  - the sender is provided with proof of delivery \r\n  - and that the recipient is provided with proof of the sender's identity \r\n\r\nso that neither can later deny having processed the data.\r\n\r\nTechnical non repudiation refers to the assurance a Relying Party has that if a public key is used to validate a digital signature, that signature had to have been made by the corresponding private signature key. \r\n\r\nLegal non-repudiation refers to how well possession or control of the private signature key can be established. \r\n\r\n### Elements for non repudiation\r\n\r\nNon repudiation via PKI is usually achieved adding\r\n\r\n1- in a request\r\n\r\n  - an hash of the request representation\r\n  - a signature of the above hash and further elements, eg: `issuer, audience, subject, issued_at, not_before, expires`, similar to JWS claims\r\n  - sender informations\r\n\r\n2- in a response\r\n\r\n  - an hash of the response representation\r\n  - a signature of the above hash and further elements, including an hash of the original request\r\n  - original request informations (eg. the hash) may be added in the response representation\r\n\r\n\r\nFurther informations may include:\r\n\r\n  - URL or content of the certificate to be used for validating the signature\r\n\r\n### Signature and Non Repudiation\r\n\r\nThere are various similarities b/w the informations contained in this spec and Non Repudiation.\r\n\r\n  - `Digest` can be used to guarantee the integrity of the representation (eg. with other values of Content-Encoding)\r\n  - `Signature` covers a list of `Signed-Headers` which may cover all necessary headers\r\n\r\n\r\n## References\r\n\r\nAn example of non-repudiation via HTTP Headers is defined in:\r\n\r\n-  [Berlin Group Financial API \u00a711](https://docs.wixstatic.com/ugd/c2914b_5351b289bf844c6881e46ee3561d95bb.pdf) based on [https://tools.ietf.org/html/draft-cavage-http-signatures-10](draft-cavage-http-signatures-10)\r\n\r\n\r\n## Questions from #88 \r\n\r\nAbout https://github.com/WICG/webpackage/pull/88#discussion_r152628889\r\n\r\n  - agree JWS security issues though not everybody agrees on deprecating JOSE [see those tweets on jose vs paseto]( https://twitter.com/ioggstream/status/972126134136647687)\r\n\r\n  -  support for different curves and rsa is useful: is `CSP-style` eg `key=ed25519-base64` that dangerous, considering that we should somewhat converge in some way? Clearly RSA would be insanely longer\r\n\r\n  - about algos, in your opinion will ed25519 replace all the other algos in the near future so that we should \"hardcode\" its name? Should we \"deprecate\" RSA signatures?\r\n\r\n  \r\n\r\n\r\n",
      "createdAt": "2018-07-08T16:22:38Z",
      "updatedAt": "2018-08-29T12:25:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The `Signature` header here is already somewhat useful for non-repudiation for the response, although I believe that non-repudiation has more to it than just a signature with a possibly-stolen private key.\r\n\r\nIs there a reason to use the same header definition for both requests and responses? The semantics are noticeably different, especially in that a response has a matching request that (I think) needs to be included in the signature, but a request stands alone.\r\n\r\nDo non-repudiable requests need to be done with an HTTP header, or should there be a signed blob in the request payload that conveys the real request?\r\n\r\n`key=ed25519-base64` would generally be fine. I currently have `ed25519key` in the parameters just to reduce the number of parsers we have to use. I'd expect to add new `otheralgorithmkey` parameters just as freely as we'd define new `key=` prefixes. RSA is forbidden in order to reduce the complexity of implementations and because there have been various attacks on multi-purpose RSA keys, which we side-step by banning RSA here. See the links from #181 for more discussion around this.\r\n\r\nThe difference between the existing `Digest` header and mice-02's `MI` header is just that `MI` allows the headers and payload to be checked and processed incrementally and with a fixed-size buffer, while `Digest` requires the recipient to receive and buffer the whole payload before checking or processing any of it. If MICE changes to specify the top-level hash in the Digest header, that'll still allow the fixed-size buffer.",
          "createdAt": "2018-07-09T22:51:13Z",
          "updatedAt": "2018-07-09T22:51:13Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> ... non-repudiation has more to it than just a signature with a possibly-stolen private key.\r\n\r\nCan you share your non-repudiation requirements? iiuc if you lose your private key there's nothing\r\nyou can do (other that demonstrate the `iat|exp` > revocation time).  See \"Legal non-repudiation\" NIST definition above.\r\n\r\n> Is there a reason to use the same header definition for both requests and responses?\r\n\r\nIt is fair to use two different headers. My goal is a shared RFC for non-repudiable request/responses.\r\n\r\nMy basic idea was just to use signed claims containing:\r\n\r\n  - basic claims (iss, sub, ... )\r\n  - further claims that could be legislation-dependant (nbf, body_hash, request_id, correlation_id, ...)\r\n\r\n> The semantics are noticeably different, .. a response has a matching request\r\n> that (I think) needs to be included in the signature, but a request stands alone.\r\n\r\nSee above claims body_hash, request_id, ... feedback welcome!\r\n\r\n> Do non-repudiable requests need to be done with an HTTP header, \r\n> or should there be a signed blob in the request payload that conveys the real request?\r\n\r\nI'd avoid encapsulation or json extension as this modifies the service interface.\r\nEg. \r\n\r\n  - I want to implement a non-repudiation wrapper around [google storage api](https://cloud.google.com/storage/docs/json_api/v1/objects/insert)\r\n  - using headers I just have to add/validate the signature header with limited changes to the google api interface\r\n\r\n> key=ed25519-base64 would generally be fine.\r\n\r\nok\r\n\r\n> ... I'd expect to add new otheralgorithmkey parameters ...as we'd define new key= prefixes\r\n\r\nOk.\r\n\r\n> RSA is forbidden... because there have been various attacks on multi-purpose RSA keys,\r\n> which we side-step by banning RSA here. See the links from #181\r\n\r\nInteresting\r\n\r\n> ... MI allows the headers and payload to be checked and processed incrementally\r\n\r\nAgree (I stubbed a crappy  MICE implementation in python, dunno if it's worth sharing).  \r\n\r\n>  Digest requires the recipient to receive and buffer the whole payload...\r\n\r\ndoesn't that depend on the hash algorithm? \r\n\r\n> If MICE changes to specify the top-level hash in the Digest header, \r\n> that'll still allow the fixed-size buffer.\r\n\r\nSo that's fine for you https://github.com/martinthomson/http-mice/issues/11 ?\r\n\r\nQuestions (I'll add to MICE):\r\n\r\n-  should the mi-sha256 header contain the buffer size?\r\n-  How can I validate the mi-sha256 hash of a given payload (eg. an existing file)?",
          "createdAt": "2018-07-10T10:17:01Z",
          "updatedAt": "2018-08-29T12:22:52Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I guess my \"non-repudiation has more to it\" comment was trying to ask for more precise requirements from you. I don't deal with non-repudiation, so I don't know what it should require. What do you and folks like the Berlin Group mean by \"non-repudiation\"? The [document you linked to](https://docs.wixstatic.com/ugd/c2914b_5351b289bf844c6881e46ee3561d95bb.pdf) doesn't mention key compromise or signing oracles. It mentions revocation, but doesn't describe how anyone discovers that a key is revoked. It mentions expiration, but seems to do so only around OAuth2 tokens and not signatures. There's just not enough there to pull requirements from. Actual security folks would probably notice even more ambiguities.\r\n\r\nI also don't know what it means to have a non-repudiation wrapper around the [google storage api](https://cloud.google.com/storage/docs/json_api/v1/objects/insert). It sounds like you'd need to store a duplicate copy of whatever was sent to the API, so that you could produce it with its signatures later?\r\n\r\nA \"request ID\" is probably not enough to tie a response to a particular request. It *could* be if we could trust everyone not to re-use IDs, even maliciously, but that's a tall order. It needs to be the bytes of the request itself, or their hash, which is difficult in HTTP where proxies modify the set of headers.\r\n\r\n`Digest:SHA-256=...` requires the whole payload to be buffered not because SHA-256 needs the whole payload at once to produce a hash\u2014it doesn't\u2014but because the program trying to consume the payload can't start processing the first byte until the whole hash is computed, which requires the last byte to be available before the first byte can be processed and released. `Digest:MI-SHA256=...` wouldn't have this problem because of the interaction between the content encoding and the digest algorithm.\r\n\r\nDiscussion about the details of the mi-* encoding does belong over in [martinthomson/http-mice](https://github.com/martinthomson/http-mice/issues?utf8=%E2%9C%93&q=is%3Aissue) and not here.",
          "createdAt": "2018-07-11T17:41:51Z",
          "updatedAt": "2018-07-11T17:41:51Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin \r\n\r\n> ... ask for more precise requirements from you\r\n\r\nThe [European eIDAS directive](https://eur-lex.europa.eu/legal-content/EN/TXT/HTML/?uri=CELEX:32014R0910&from=EN) defines requirements on electronic signatures. In the next days\r\nI will try summarize the parts which may be relevant to this discussion.\r\n\r\n> The document you linked to doesn't mention key compromise or signing oracles\r\n\r\nI can anticipate that a x509 signed document (eg. a .p7m) from an unrevoked key is considered non-repudiable. Eventual claims of frauds / compromised keys should be judged by a Court.\r\n\r\n> It mentions revocation, but doesn't describe how anyone discovers that a key is revoked.\r\n\r\nI will ask them clarification about their OCSP workflow (see eIDAS above).\r\n\r\n> It mentions expiration, but seems to do so only around OAuth2 tokens and not signatures. \r\n\r\nYes, I contacted them asking why not mimic JWT fields ;) I hope we all converge on this spec.\r\n\r\n> There's just not enough there to pull requirements from.\r\n> Actual security folks would probably notice even more ambiguities.\r\n\r\nThanks for your great analysis. I'll try to cover them all!\r\n\r\n> I also don't know what it means to have a non-repudiation wrapper around the google storage api.\r\n> It sounds like you'd need to store a duplicate copy of whatever was sent to the API, \r\n> so that you could produce it with its signatures later?\r\n\r\nThe idea was to:\r\n  - attach `Signature` headers to request and responses\r\n  - log those headers thus tracing the communications\r\n  - don't store a duplicate copy, just forward the data to the API after logging its signature\r\n\r\nImplementing this workflow with headers allows this process to be \"transparent\" and independent by the underlying API. Let's say I'd prefer to use http headers without altering the payload. \r\n\r\n\r\n> A \"request ID\" is probably not enough to tie a response to a particular request. \r\n\r\nRight, see the `request_hash` in the issue. The cbor-representation should do the job, right? https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cbor-representation \r\n\r\n> which is difficult in HTTP where proxies modify the set of headers.\r\n\r\niiuc if proxies mess with headers:\r\n\r\n  -  `Signature` is affected too, right?\r\n  -  the request/response flow won't finish successfully so you won't have your signed response, and the parties acknowledge there's an issue.\r\n\r\nThanks for all your time, again!",
          "createdAt": "2018-07-12T22:09:27Z",
          "updatedAt": "2018-08-29T12:25:12Z"
        }
      ]
    },
    {
      "number": 253,
      "id": "MDU6SXNzdWUzNDA2NjgwMzE=",
      "title": "Accept-Signature specifies a syntax that violates the ABNF for sh-param-list",
      "url": "https://github.com/WICG/webpackage/issues/253",
      "state": "OPEN",
      "author": "CBonnell",
      "authorAssociation": "NONE",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "The Accept-Signature header (section 3.7) is defined as a sh-param-list. It also specifies that identifiers can be specified with a leading hyphen (\"-\") to denote a lack of support.\r\n\r\nHowever, the leading hyphen violates the ABNF for sh-param-list and identifier as defined in https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-07. Notably, sh-param-list has no provision to allow hyphens before the \"identifier\" (https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-07#section-3.3) and the identifier (https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-07#section-3.8) must begin with a lowercase letter.",
      "createdAt": "2018-07-12T14:40:42Z",
      "updatedAt": "2018-08-13T16:56:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 268,
      "id": "MDU6SXNzdWUzNDMyNTE0Njg=",
      "title": "Broken import with golang.org/x/net/http2 package ",
      "url": "https://github.com/WICG/webpackage/issues/268",
      "state": "CLOSED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It seems as if the `golang.org/x/net/http2` package moved its `lex` package elsewhere. Same issue, different repo logged here: https://github.com/ponzu-cms/ponzu/issues/245\r\n\r\n`$ go get -v github.com/WICG/webpackage/...`\r\n\r\n```github.com/WICG/webpackage (download)\r\nwarning: ignoring symlink /Users/averyharnish/go/src/github.com/WICG/webpackage/examples/pki\r\nFetching https://golang.org/x/net/lex/httplex?go-get=1\r\nParsing meta tags from https://golang.org/x/net/lex/httplex?go-get=1 (status code 200)\r\nget \"golang.org/x/net/lex/httplex\": found meta tag get.metaImport{Prefix:\"golang.org/x/net\", VCS:\"git\", RepoRoot:\"https://go.googlesource.com/net\"} at https://golang.org/x/net/lex/httplex?go-get=1\r\nget \"golang.org/x/net/lex/httplex\": verifying non-authoritative meta tag\r\nFetching https://golang.org/x/net?go-get=1\r\nParsing meta tags from https://golang.org/x/net?go-get=1 (status code 200)\r\ngolang.org/x/net (download)\r\npackage github.com/WICG/webpackage/go/bundle/cmd/gen-bundle\r\n\timports golang.org/x/net/lex/httplex: cannot find package \"golang.org/x/net/lex/httplex\" in any of:\r\n\t/usr/local/go/src/golang.org/x/net/lex/httplex (from $GOROOT)\r\n\t/Users/averyharnish/go/src/golang.org/x/net/lex/httplex (from $GOPATH)",
      "createdAt": "2018-07-20T21:23:02Z",
      "updatedAt": "2018-07-28T02:51:22Z",
      "closedAt": "2018-07-28T02:51:22Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes.\r\nWe are waiting for https://github.com/mrichman/hargo/pull/9 to get merged.",
          "createdAt": "2018-07-20T22:07:18Z",
          "updatedAt": "2018-07-20T22:07:18Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "Wasn't actually an issue, was running the go install command from the README which included a typo.  #275 fixes this",
          "createdAt": "2018-07-27T17:52:07Z",
          "updatedAt": "2018-07-27T17:52:07Z"
        }
      ]
    },
    {
      "number": 270,
      "id": "MDU6SXNzdWUzNDM4MzQ3OTM=",
      "title": " \"manifest\" section URL should first look if the resource is included in the bundle",
      "url": "https://github.com/WICG/webpackage/issues/270",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#manifest-section\r\n",
      "createdAt": "2018-07-23T23:49:24Z",
      "updatedAt": "2018-07-31T07:38:15Z",
      "closedAt": "2018-07-31T07:38:15Z",
      "comments": []
    },
    {
      "number": 276,
      "id": "MDU6SXNzdWUzNDU2MjU0Njc=",
      "title": "Make it easy to reuse the encoded header cbor when verifying signature",
      "url": "https://github.com/WICG/webpackage/issues/276",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We might want to adjust the signature message format so that it is easy to reuse the encoded headers when verifying the signature.\r\nThe `headers` required in Section 3.5 step 7.4.5 is a copy of the cbor appearing earlier. However, the fact that it appears inline in the map makes it hard for many cbor encoder implementation to reconstruct the cbor representation of the map without decode(encode(headers)), which is non-secure.\r\n\r\nMore discussion on the [crbug](https://bugs.chromium.org/p/chromium/issues/detail?id=863499)",
      "createdAt": "2018-07-30T06:19:51Z",
      "updatedAt": "2018-08-17T05:42:03Z",
      "closedAt": "2018-08-17T05:42:03Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#signed-message has an in-progress specification of how to build the signed message without re-encoding. I have no problem with making that easier.",
          "createdAt": "2018-07-30T19:58:25Z",
          "updatedAt": "2018-07-30T19:58:25Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm happy with your proposal.\r\n\r\nJust to enumerate alternatives:\r\n- Move `headers` out of the map #279\r\n    - slightly easier to implement, since we don't have to actually concat everything but construct hash func state but `headers` first, then progress the state with `headers` and then emit the final result\r\n- Don't use CBOR to encode {date, expires, headers, cert-sha256, validity-url}\r\n    - 64bit big-endian for date, expires\r\n    - bytes dump for cert-sha256, validity-url\r\n\r\nIIUC, the sole purpose of the `message` is to be used as input to signing algorithm, so we may not have to worry about its parsability so much and just focus on ease of its generation.",
          "createdAt": "2018-07-31T03:44:52Z",
          "updatedAt": "2018-07-31T03:44:52Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The CBOR map was originally designed to be clear about version changes, but that's now handled by the versioned context string. Given that, a pure concatenation of the input (making sure everything's length-prefixed or fixed length) may be better.",
          "createdAt": "2018-07-31T03:47:20Z",
          "updatedAt": "2018-07-31T03:47:20Z"
        }
      ]
    },
    {
      "number": 289,
      "id": "MDU6SXNzdWUzNTEwODgxNDU=",
      "title": "Feature detection and Accept: application/signed-exchanges headers",
      "url": "https://github.com/WICG/webpackage/issues/289",
      "state": "OPEN",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "For feature detection some of us have been discussing that we could add Accept: application/signed-exchanges headers.  However given that SXG can have any resources it looks the UAs that support SXG always need to attach / append SXG type even when anything can be accepted, so it could look something like `Accept: application/signed-exchange;q=0.9,*/*;q=0.8` for default, non-specific subresource requests.  Would it be just or if we want to think about alternative feature detection mechanism (e.g. specific headers etc)?",
      "createdAt": "2018-08-16T07:33:00Z",
      "updatedAt": "2018-08-20T04:43:57Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 293,
      "id": "MDU6SXNzdWUzNTI4NTU5MTg=",
      "title": "Discourage centralization ",
      "url": "https://github.com/WICG/webpackage/issues/293",
      "state": "CLOSED",
      "author": "AhsanE",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In order to discourage centralization of the web, authors should have an incentive to keep their websites active.\r\n\r\nOne way is to make sure is that the author's server provides the client with the decryption key to decrypt the package.\r\n\r\ni.e:\r\n1. example.com signs and packages example.com/index.html and submits to google.com\r\n2. google.com distributes example.com/index.html \r\n3. users downloads example.com/index.html from google.com\r\n4. user connects to example.com for the index.html's decryption key\r\n5. browser decrypt the index.html package supplied by google with the decryption key supplied by example.com\r\n\r\nThis all should be optional to the author. Some authors might only want google.com to distribute the html/css/js for faster loading but ensure that the client has a first party contact with example.com too.  \r\n\r\nIt is already possible to do the same with javascript, but the web should also provide a native way to do this. \r\n",
      "createdAt": "2018-08-22T08:40:36Z",
      "updatedAt": "2018-09-16T13:12:34Z",
      "closedAt": "2018-09-16T13:12:34Z",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I\u2019m afraid this is confusing some of the cryptography, such as the notion\nof a \u201cdecryption\u201d key.\n\nIt sounds like you aren\u2019t concerned about the cryptography, per se, but\nwant to ensure origins remain in control, correct? This property is already\nmaintained, by requiring fresh signatures over the package, which are\ndistributed by `example.com` in your example. Does that address your use\ncase?\n",
          "createdAt": "2018-08-22T13:13:57Z",
          "updatedAt": "2018-08-22T13:13:57Z"
        },
        {
          "author": "AhsanE",
          "authorAssociation": "NONE",
          "body": "I am no expert in cryptography, but used a non-detailed overview to convey what I wanted (had no other words to explain) and know if it is practical. \r\n\r\n> It sounds like you aren\u2019t concerned about the cryptography, per se, but\r\nwant to ensure origins remain in control, correct? \r\n\r\nWe'll if control means that user can only access the site/content after pinging to the author's server, in this case \"example.com\".",
          "createdAt": "2018-08-22T14:16:52Z",
          "updatedAt": "2018-08-22T14:38:56Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I see. That's the opposite of the design goal for the use cases.",
          "createdAt": "2018-08-22T14:56:04Z",
          "updatedAt": "2018-08-22T14:56:04Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@AhsanE A signed exchange package is valid for up to 7 days. (The exact period is controllable by the author, but this is expected to be >0 days.)\r\n\r\nThis means that users may see content that appears to be from `example.com` (i.e. the URL bar of the browser reads `example.com`) up to 7 days after `example.com` has lost network connectivity and completely disappeared from the net.",
          "createdAt": "2018-08-22T16:28:34Z",
          "updatedAt": "2018-08-22T16:28:34Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "For all practical purposes the content in a web packages also has to be available at the packaged URL. If you load a package in a browser and hit reload, it would be a terrible user experience if the content wouldn't load again. While this certainly can happen theoretically, any practical use would try to avoid this problem as much as possible.",
          "createdAt": "2018-08-22T16:54:23Z",
          "updatedAt": "2018-08-22T16:54:23Z"
        }
      ]
    },
    {
      "number": 295,
      "id": "MDU6SXNzdWUzNTMzNDkyOTM=",
      "title": "Recommend that a browser \"reload\" contacts the logical origin",
      "url": "https://github.com/WICG/webpackage/issues/295",
      "state": "OPEN",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Recommend that if the user hits the \"reload\" button in their browser, the browser will contact the logical origin (i.e. the URL that is visible in the browser's URL bar) to determine freshness.\r\n\r\n(Currently not specified, but seem to be the expected behaviour, see e.g. [1](https://github.com/WICG/webpackage/issues/149#issuecomment-374011263), [2](https://github.com/WICG/webpackage/issues/293#issuecomment-415102090), [3](https://github.com/WICG/webpackage/issues/300#issuecomment-456581227).) ",
      "createdAt": "2018-08-23T12:01:00Z",
      "updatedAt": "2019-02-01T11:13:23Z",
      "closedAt": null,
      "comments": [
        {
          "author": "lidel",
          "authorAssociation": "NONE",
          "body": "I feel a better design would be an ability to opt out from a forced freshness check for specified time. \r\nThink how it is possible to cache HSTS settings in the browser by including a `max-age` option:\r\n\r\n- \"pressing F5 in web browser _does not contact the logical origin_ until snapshot from SXG is `max-age` old\"\r\n  - `max-age=0` would mean that pressing \"reload\" button will always contact the logical origin\r\n  - Shift+F5 would ignore SXG just like it ignores the cache\r\n\r\nThe `max-age` approach is more flexible and accounts for use cases where people want to avoid sending HTTP traffic to logical origin by any means necessary (cc https://github.com/ipfs/in-web-browsers/issues/121 @jimpick )",
          "createdAt": "2018-11-05T13:04:37Z",
          "updatedAt": "2018-12-14T13:46:15Z"
        }
      ]
    },
    {
      "number": 297,
      "id": "MDU6SXNzdWUzNTQ1NjQ2NTE=",
      "title": "Specify how to handle too-long URLs?",
      "url": "https://github.com/WICG/webpackage/issues/297",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The new spec allows fallbackURLs up to 65536 bytes long, but several existing browsers have lower limits than that. Perhaps the fetch spec should say how browsers should respond if the fallbackUrl is too long, or alternatively specify a minimum length they must support. Otherwise, browsers may behave differently (e.g. network error, redirect to fallback URL, or display a trimmed URL). Or is this already covered by some other part of Fetch?",
      "createdAt": "2018-08-28T04:15:09Z",
      "updatedAt": "2018-11-28T20:06:39Z",
      "closedAt": "2018-11-28T20:06:39Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This should be more general than just web packaging. For example, a too-long 302 redirect should behave the same way. I've filed whatwg/fetch#841 to track it.",
          "createdAt": "2018-11-28T20:06:18Z",
          "updatedAt": "2018-11-28T20:06:18Z"
        }
      ]
    },
    {
      "number": 299,
      "id": "MDU6SXNzdWUzNTY2NTg3MDE=",
      "title": "Loading: Nested Signed Exchange is rejected only when comes with v=",
      "url": "https://github.com/WICG/webpackage/issues/299",
      "state": "OPEN",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just want to make sure this is what is intended: in Step 26 https://wicg.github.io/webpackage/loading.html#parsing-b1 says:\r\n\r\n> If parsedExchange\u2019s response's status is a redirect status or the signed exchange version of parsedExchange\u2019s response is not undefined, return a failure.\r\n\r\nThis means if an inner response's content type is `application/signed-exchange` but without `v=` UA just lets it go (and result in downloading for navigations, or may just return the outer response for other cases). This might be what the spec intends but felt a bit unclear so filing this issue. /cc @irori ",
      "createdAt": "2018-09-04T05:34:27Z",
      "updatedAt": "2018-11-17T00:23:29Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I didn't explicitly consider that case, but since the [HTTP fetch monkeypatch](https://wicg.github.io/webpackage/loading.html#mp-http-fetch) only processes a resource as a signed exchange if the `application/signed-exchange` mime type includes a `v=` parameter, this doesn't seem harmful.\r\n\r\nDo you think we should explicitly block `application/signed-exchange` without the `v=` to make mistakes easier to diagnose? I'd be inclined to do that in the Fetch monkeypatch rather than in the bit that blocks nested redirects, so that people hit it sooner.",
          "createdAt": "2018-11-17T00:23:29Z",
          "updatedAt": "2018-11-17T00:23:29Z"
        }
      ]
    },
    {
      "number": 300,
      "id": "MDU6SXNzdWUzNTY2NjIyNTU=",
      "title": "Should newer HTTP cache contents override signed exchange's inner content?",
      "url": "https://github.com/WICG/webpackage/issues/300",
      "state": "OPEN",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the loading spec says the newer HTTP cache contents should override the stashed exchange if the cached one is newer, but discussing this with @sleevi we suspected this may not make a lot sense if the underlying HTTP cache is NOT single-keyed (e.g. is double-keyed / partitioned).  So the question here is how much real benefit would this behavior have, and if we should really implement it.\r\n\r\n(Context: Chromium currently doesn't implement this behavior, and no plan to do so until this issue is clarified or we see a real, clear benefit)",
      "createdAt": "2018-09-04T05:54:08Z",
      "updatedAt": "2019-01-22T22:05:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think it has some value in blocking some downgrade attacks when loading a signed exchange for a top-level origin the user has already visited, even if cross-origin subresources are double-keyed. It'll help less for catching downgrades of common subresources being re-used by a new site.\r\n\r\nWhat did you and @sleevi think it breaks?",
          "createdAt": "2018-11-17T00:42:05Z",
          "updatedAt": "2018-11-17T00:42:05Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that this could still be beneficial for top-level origins.  Reg: what it may break: I think @sleevi's stance has been more about we'll need more investigation to see if it'd make the best sense.  And from impl pov: doing so simply requires more work, so we want to be very careful on the decisions.  (Interested in if @sleevi has renewed thoughts)",
          "createdAt": "2018-11-19T07:57:42Z",
          "updatedAt": "2018-11-19T07:57:42Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Is the suggestion here that clicking on the reload button in the browser UI might not necessarily result in a network request to the origin if SXG content is available locally? This is the opposite of #295, FWIW.\r\n\r\nAlso, is there any difference between reload mechanisms? (The service worker spec requires [force reload to go to network in all cases](https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle#shift-reload).)",
          "createdAt": "2019-01-22T21:29:04Z",
          "updatedAt": "2019-01-22T21:29:04Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@ithinkihaveacat No, a browser reload should always try to check the origin. This issue is about whether, if you've recently visited the origin, but a distributor offers you an older SXG, whether you use the newer from-origin content or the older SXG.",
          "createdAt": "2019-01-22T22:05:03Z",
          "updatedAt": "2019-01-22T22:05:03Z"
        }
      ]
    },
    {
      "number": 303,
      "id": "MDU6SXNzdWUzNTY5NTU3Mzk=",
      "title": "signedexchange: decoder for version b2",
      "url": "https://github.com/WICG/webpackage/issues/303",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-04T20:02:48Z",
      "updatedAt": "2020-03-23T06:05:11Z",
      "closedAt": "2020-03-23T06:05:11Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "`dump-signedexchange` can already decode the b2 format.",
          "createdAt": "2020-03-23T06:05:11Z",
          "updatedAt": "2020-03-23T06:05:11Z"
        }
      ]
    },
    {
      "number": 310,
      "id": "MDU6SXNzdWUzNjEwMzk1OTg=",
      "title": "Update loading spec per b2",
      "url": "https://github.com/WICG/webpackage/issues/310",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/loading.html makes several mentions of `b1`. It will need to updated to refer to `b2`, as well as changes to where inner URL and payload digest are found, per the changes in #296 ([change log](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#change-log)). Possibly other things?",
      "createdAt": "2018-09-17T20:52:52Z",
      "updatedAt": "2019-01-18T21:21:19Z",
      "closedAt": "2019-01-18T21:21:19Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "As long as Chrome supports loading both `b1` and `b2`, I'd like https://wicg.github.io/webpackage/loading.html#mp-http-fetch to accept both.\r\n\r\nhttps://github.com/WICG/webpackage/pull/285 has a change to use the fixed location of the URL to handle the 'anything else' case, which you'll want to adopt if you update for `b2` anywhere else.",
          "createdAt": "2018-09-18T22:48:08Z",
          "updatedAt": "2018-09-18T22:48:08Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Chrome M70+ has dropped support for `b1` and only supports `b2`.",
          "createdAt": "2018-09-19T01:50:00Z",
          "updatedAt": "2018-09-19T01:50:00Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Removing `b1` from the loading spec sounds good then.",
          "createdAt": "2018-09-19T02:15:54Z",
          "updatedAt": "2018-09-19T02:15:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #328.",
          "createdAt": "2019-01-18T21:21:19Z",
          "updatedAt": "2019-01-18T21:21:19Z"
        }
      ]
    },
    {
      "number": 314,
      "id": "MDU6SXNzdWUzNjUwNzg0NzU=",
      "title": "Integrity record size limit is missing from b2 snapshot",
      "url": "https://github.com/WICG/webpackage/issues/314",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt"
      ],
      "labels": [],
      "body": "[The snapshot](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#signature-validity) is missing the following text, present in the [spec](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html):\r\n\r\n\"If validating integrity using the selected header field requires the client to process records larger than 16384 bytes, return \u201cinvalid\u201d.\"\r\n\r\nHowever, this limitation still exists in the [implementation](https://cs.chromium.org/chromium/src/content/browser/loader/merkle_integrity_source_stream.cc?l=18&rcl=591949795043a818e50aba8a539094c321a4220c).",
      "createdAt": "2018-09-29T00:26:35Z",
      "updatedAt": "2018-09-29T00:26:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 315,
      "id": "MDU6SXNzdWUzNzE1ODUzNTU=",
      "title": "How to open a .wpk file?",
      "url": "https://github.com/WICG/webpackage/issues/315",
      "state": "CLOSED",
      "author": "jimbojetlag",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I noticed there are some sample .wpk file sin https://github.com/WICG/webpackage/tree/master/examples . Do browsers open these files at this point? If not, how are they supposed to be opened by the end user?",
      "createdAt": "2018-10-18T15:24:24Z",
      "updatedAt": "2018-10-25T08:03:50Z",
      "closedAt": "2018-10-25T08:03:50Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi! The examples in that directory are quite out-of-date. You can take a look at the instructions at https://github.com/WICG/webpackage/tree/master/go/signedexchange for how to generate a signed exchange, host it on a server, and browse it. They are intended for the end user, but for now, you need to enable an experimental flag in Chrome to view them.",
          "createdAt": "2018-10-18T23:12:32Z",
          "updatedAt": "2018-10-18T23:12:32Z"
        },
        {
          "author": "jimbojetlag",
          "authorAssociation": "NONE",
          "body": "That executable generates a .sxg file, when I tried to open it in Chrome by drang and drop, Chrome simply downloaded it.\r\n\r\nHow is it possible to share this package offline?",
          "createdAt": "2018-10-19T00:03:54Z",
          "updatedAt": "2018-10-19T00:03:54Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "With the current implementation, I believe sharing offline requires the receiver to host an HTTPS server on localhost. (i.e. Tools need to be built to enable this use-case.)\r\n\r\nHowever, the spec specifically calls attention to the [local disk use-case](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#privacy-considerations), so I imagine this is a temporary situation. It may be worth adding support for `file:` in the [loading spec](https://wicg.github.io/webpackage/loading.html), though that may be difficult given that the Fetch spec (that it monkeypatches) leaves `file:` [\"as an exercise for the reader\"](https://fetch.spec.whatwg.org/#scheme-fetch).",
          "createdAt": "2018-10-19T00:35:39Z",
          "updatedAt": "2018-10-19T18:01:16Z"
        },
        {
          "author": "jimbojetlag",
          "authorAssociation": "NONE",
          "body": "The specs have use cases for sharing _unsigned_ offline packages, which would not need a secure server.\r\n\r\nThink of it as how people would download and share html pages today, only instead of an index page + N asset files, it would be a single standard format package.",
          "createdAt": "2018-10-19T14:25:32Z",
          "updatedAt": "2018-10-19T14:25:32Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah yes, AFAIK, as of today, only a [snapshot of the signed exchanges spec](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html) is implemented in Chrome, and not the bundled exchanges spec.",
          "createdAt": "2018-10-19T15:45:59Z",
          "updatedAt": "2018-10-19T15:45:59Z"
        },
        {
          "author": null,
          "authorAssociation": "NONE",
          "body": "What's happening with Firefox and edge in terms of adaption or flags ?\r\nIs there a name for this functionality to allow checking on CanIUse website ?",
          "createdAt": "2018-10-24T07:35:49Z",
          "updatedAt": "2018-10-24T07:35:49Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't think it's on CanIUse, but it is here: https://www.chromestatus.com/feature/5745285984681984\r\n\r\nThat has some info on adoption, but I don't know if it's up-to-date; I'm primarily a consumer of the standard and haven't been doing much of the standardization work. I'll defer to others on that.",
          "createdAt": "2018-10-25T00:21:33Z",
          "updatedAt": "2018-10-25T00:21:33Z"
        },
        {
          "author": "RByers",
          "authorAssociation": "MEMBER",
          "body": "Web packaging is really still being designed and implemented - with a focus on the privacy-preserving pre-rendering use case in Chrome. It's really nowhere near the point of being a useful feature for end users.",
          "createdAt": "2018-10-25T05:17:16Z",
          "updatedAt": "2018-10-25T05:17:16Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for your interest!\r\n\r\nIn terms of *public* signals, the entry on chromestatus.com is up to date.\r\nStay tuned.",
          "createdAt": "2018-10-25T08:03:50Z",
          "updatedAt": "2018-10-25T08:03:50Z"
        }
      ]
    },
    {
      "number": 316,
      "id": "MDU6SXNzdWUzNzE3NDkwMTY=",
      "title": "Delete examples/ directory (except for firebase.json)",
      "url": "https://github.com/WICG/webpackage/issues/316",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "twifkak"
      ],
      "labels": [],
      "body": "The files in there (except for firebase.json) are out of date and caused some confusion in #315.",
      "createdAt": "2018-10-18T23:15:58Z",
      "updatedAt": "2018-11-14T21:55:17Z",
      "closedAt": "2018-11-14T21:55:17Z",
      "comments": []
    },
    {
      "number": 319,
      "id": "MDU6SXNzdWUzNzUzNzc3MTk=",
      "title": "dump-signedexchange: Implement signature verification",
      "url": "https://github.com/WICG/webpackage/issues/319",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "irori"
      ],
      "labels": [],
      "body": "Add a reference implementation of [signature validity](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity) check in go/signedexchange, and use it from `dump-signedexchange`.\r\n\r\nIt would help implementors of other signed exchange generators. Also, it will enable us to add roundtrip (sign-and-verify) tests.\r\n",
      "createdAt": "2018-10-30T08:46:48Z",
      "updatedAt": "2018-10-30T11:11:49Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM",
          "createdAt": "2018-10-30T11:11:49Z",
          "updatedAt": "2018-10-30T11:11:49Z"
        }
      ]
    },
    {
      "number": 321,
      "id": "MDU6SXNzdWUzNzYwMDk4NjM=",
      "title": "Reflecting the URL leads to content sniffing bugs",
      "url": "https://github.com/WICG/webpackage/issues/321",
      "state": "CLOSED",
      "author": "molnarg",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "When a server returns a web package in the application/signed-exchange format, it'll embed the request URL in the returned binary blob in the fallbackUrl field. Depending on the server implementation, the encoding of bytes of the URL might vary. Some implementation might choose the easiest solution, which is to just reflect whatever representation the client sends.\r\n\r\nThis is problematic, because this gives attackers an easy injection point within the first few bytes of the file, which can be turned into code running in the victim origin using content sniffing. The Adobe PDF parser for example ignores the unknown prefix bytes if it finds a valid PDF signature within the first 1kb of the file.\r\n\r\nThe \"x-content-type-options: nosniff\" header instruct browsers to not do content sniffing, but plugins can choose to (and in many cases do) ignore them. Because of this, the usual suggestion is to host partially user controlled binary files only on sandbox domains (when it's not possible to sufficiently escape the user controlled parts, which is usually not the case).\r\n\r\nThis demo page is not vulnerable to this, because it requires a special Accept request header: https://azei-package-test.com/ Clients that can't interpret the web package format will never send this header, so they'll never see the signed exchange file format.\r\n\r\nOne solution would be to use some kind of encoding for all reflected values (e.g. base64) to avoid introducing a valuable injection point in the first place.",
      "createdAt": "2018-10-31T15:06:48Z",
      "updatedAt": "2018-12-19T22:43:35Z",
      "closedAt": "2018-12-19T22:43:35Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "(Just chiming in to provide some detail; don't consider my response authoritative as I'm not an owner of this repo.)\r\n\r\nIf I'm reading correctly, the spec defines [fallbackUrl as an absolute URL](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#application-signed-exchange) and then defines [absolute URLs per the URL parser](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#terminology), and the URL parser requires [only URL code points in the path](https://url.spec.whatwg.org/#path-state), and here are [the URL code points](https://url.spec.whatwg.org/#url-code-points).\r\n\r\nOf course, even if the URL is base64-encoded, the attacker could modify the length of the fallback URL to manipulate those 2 bytes.",
          "createdAt": "2018-10-31T18:52:05Z",
          "updatedAt": "2018-10-31T18:52:05Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @sleevi @jyasskin \r\n\r\nThanks for filing the issue.\r\n\r\nWould you mind expanding the attack scenario details?\r\nIf I understand this correctly, the assumptions are:\r\n1. A Target HTTP User-Agent (more generic than web browsers, incl. plugins) runs a content parser that ignores unknown prefix bytes.\r\n2. A SXG server which returns SXG of `fallbackUrl` which reflects the request URL enough to inject an attack vector.\r\n3. It is useful for the attack vector to run on an HTTP origin which the SXG server runs on.\r\n\r\nI buy that 1 and 3 can theoretically hold but I'm not sure if 2 holds, since there are multiple restriction to the URL.\r\n- The server should not return a sxg unless the absolute url is valid, incl. the URL code points restriction @twifkak mentioned.\r\n- The server need to host the resource, otherwise the server should not be able to generate a sxg since it would not have valid certificates for the resource.\r\n  - Still, bad servers may still create sxgs containing a 404 response. We may want to disallow sxg enclosing non-2XX responses in the format spec.",
          "createdAt": "2018-11-01T01:48:22Z",
          "updatedAt": "2018-11-01T01:48:22Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@molnarg Note that the fallback URL isn't supposed to be reflected from the request URI. Instead, it's the canonical location of the signed content, which should be completely under the control of the server.\r\n\r\nThat said, I can't rule out a naive server making the mistake you're suggesting. Such a server might also reflect data from some HTTP request headers (as Google did in https://crbug.com/901477#c18) into an early part of the signed exchange, which provides another injection point a couple hundred bytes in. For that matter, even the start of the body may be within the first 1kB, if the server chooses to reflect attacker-controlled data into the body, but I suppose that's a vulnerability even without signed exchanges, and so out of the scope of your complaint.\r\n\r\nI assume that base64-encoding works because nearly all file signatures include a byte outside the base64 alphabet? Even then, does the attacker-controlled URL length get around that restriction?\r\n\r\n@twifkak, unfortunately, the URL parser doesn't limit its accepted input to URL code points. Code points outside that range cause non-fatal [validation errors](https://url.spec.whatwg.org/#validation-error), and then the parser continues. [`%PDF-`](https://en.wikipedia.org/wiki/List_of_file_signatures) is accepted and can be reflected back out. This prevents the server's parsing of the request URL from protecting us, even if the server has a conformant URL parser.\r\n\r\nSo, the question is what to do. I don't like the idea of base64-encoding every bit of data that a server might reflect, but it's a last-resort option.\r\n\r\nWould it be acceptable to just add a security consideration that servers must not naively reflect the request URL or request headers and then sign them? ",
          "createdAt": "2018-11-28T23:31:43Z",
          "updatedAt": "2018-11-28T23:33:34Z"
        }
      ]
    },
    {
      "number": 322,
      "id": "MDU6SXNzdWUzNzYyMjI2NTM=",
      "title": "Reserve a HTTP/2 Error Code in the Error Code Registry",
      "url": "https://github.com/WICG/webpackage/issues/322",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "(filing an open issue so we wouldn't forget)\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.8.5",
      "createdAt": "2018-11-01T01:51:58Z",
      "updatedAt": "2018-11-01T01:51:58Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 324,
      "id": "MDU6SXNzdWUzNzYyNTQ2OTY=",
      "title": "Specify how intermediates should load Signed Exchanges with validityUrl",
      "url": "https://github.com/WICG/webpackage/issues/324",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt",
        "jyasskin",
        "kinu"
      ],
      "labels": [],
      "body": "The current loading spec talks about UAs which do not involve checking validityUrl data.\r\n\r\nWe expect intermediates to check validityUrl data, and we need to specify how their SXG fetch would work.",
      "createdAt": "2018-11-01T05:01:53Z",
      "updatedAt": "2018-11-01T05:01:53Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 335,
      "id": "MDU6SXNzdWUzNzg0OTgyMzM=",
      "title": "Does the spec say that duplicate header names are disallowed?",
      "url": "https://github.com/WICG/webpackage/issues/335",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "nyaxt"
      ],
      "labels": [],
      "body": "I don't see it in https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#application-signed-exchange or https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#cbor-representation or https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#canonical-cbor. (Ditto for latest draft.)\r\n\r\nBut AFAICT this is required by chromium, and IIRC it was in a previous version of this spec.",
      "createdAt": "2018-11-07T22:33:21Z",
      "updatedAt": "2019-07-11T17:13:24Z",
      "closedAt": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Duplicate headers are disallowed from CBOR map not allowing duplicate key entries.\r\n\r\nI'll add a \"normative\".",
          "createdAt": "2018-11-07T23:13:49Z",
          "updatedAt": "2018-11-07T23:13:49Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, right. Yeah, an informative section would help.",
          "createdAt": "2018-11-08T04:10:26Z",
          "updatedAt": "2018-11-08T04:10:26Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "AFAICT, CBOR map allows duplicate key entries. https://tools.ietf.org/html/rfc7049#section-3.7 says:\r\n\r\n>    A CBOR-based protocol should make an intentional decision about what\r\n>    to do when a receiving application does see multiple identical keys\r\n>    in a map.  The resulting rule in the protocol should respect the CBOR\r\n>    data model: it cannot prescribe a specific handling of the entries\r\n>    with the identical keys, except that it might have a rule that having\r\n>    identical keys in a map indicates a malformed map and that the\r\n>    decoder has to stop with an error.\r\n\r\nhttps://www.rfc-editor.org/errata/eid4964 doesn't change that. Seems like this needs a normative comment.",
          "createdAt": "2019-07-11T17:13:24Z",
          "updatedAt": "2019-07-11T17:13:24Z"
        }
      ]
    },
    {
      "number": 336,
      "id": "MDU6SXNzdWUzNzg5ODc2OTM=",
      "title": "Transfer-Encoding in inner-exchange's response header.",
      "url": "https://github.com/WICG/webpackage/issues/336",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've noticed the `Transfer-Encoding` header usage in SXG inner response headers.\r\nWe should specify how it will work.\r\n\r\n- Option 1) Add to banned headers list.\r\n- Option 2) Clarify in the loading spec that...\r\n  - Option 2.a) Only compression schemes are allowed (Ban only `Transfer-Encoding: chunked`)\r\n  - Option 2.b) They are ignored.\r\n\r\nNote that Chromium ToT currently ~~ignores them. Which means, the response bytes are treated as they are raw bytes and doesn't go through decompressor/unchunking.~~ supports them",
      "createdAt": "2018-11-09T01:34:59Z",
      "updatedAt": "2019-01-10T17:31:58Z",
      "closedAt": "2019-01-10T17:31:58Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "My personal preference is Option 1, since we always mice encode the response stream.\r\n\r\nIf we want compression, then we can compress the outer-response.\r\nI think this aligns with the current bundling story where we want raw response bytes in order to achieve cross-resource compression.",
          "createdAt": "2018-11-09T01:38:22Z",
          "updatedAt": "2018-11-09T01:38:22Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks like Chromium ToT actually supports `Transfer-Encoding: Chunked` inside the mice stream.",
          "createdAt": "2018-11-09T04:27:43Z",
          "updatedAt": "2018-11-09T04:27:43Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "How do/should inner and outer `Transfer-Encoding` interact?",
          "createdAt": "2018-11-09T04:29:04Z",
          "updatedAt": "2018-11-09T04:29:04Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "+1 to rejecting it.\r\n\r\nChromium accepting it is odd. Perhaps a quirk of MICE not being implemented at the same layer as other Content-Encodings? Usually TE is removed before CE. Also the usual reason to do chunked TE is if the sender does not know the size ahead of time and is streaming the output. But the MICE encoder cannot work streaming anyway since the blocks are processed in reverse.",
          "createdAt": "2018-11-09T21:34:15Z",
          "updatedAt": "2018-11-09T21:34:15Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "It might make sense to align what packaging does with what we're discussing in https://github.com/httpwg/http-core/issues/165",
          "createdAt": "2018-11-11T04:10:35Z",
          "updatedAt": "2018-11-11T04:10:35Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We should definitely try to align packaging with httpwg/http-core#165. Specifically, I'm guessing that [non-cached headers](https://github.com/httpwg/http-core/issues/165#issuecomment-436287105) should be banned in signed exchanges. \r\n\r\nThe only set from https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc I'm not sure of is `kSecurityStateHeaders`, primarily `strict-transport-security` since `public-key-pins` is deprecated or gone. That seems like a header that shared caches would include, but the browser's private cache wants to omit.\r\n\r\nI don't see an obvious argument to ban the non-updated headers. Is there one?\r\n\r\nIn the long run, I'd like to just delegate this list of non-cached headers to [draft-ietf-httpbis-cache](https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html), but I don't see any such list there now, so I'm happy to just list headers in this spec for now.",
          "createdAt": "2018-11-16T23:24:44Z",
          "updatedAt": "2018-11-16T23:24:44Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Considering that `kSecurityStateHeaders` are potentially state modifying in\nthe same way that cookies are, it seems they should also be prohibited.\n",
          "createdAt": "2018-11-16T23:30:59Z",
          "updatedAt": "2018-11-16T23:30:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi I'll split that decision out to #340 to avoid derailing this discussion.",
          "createdAt": "2018-11-17T00:10:34Z",
          "updatedAt": "2018-11-17T00:10:34Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "From this thread + #340, I'm convinced that we should ban all headers in https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc .",
          "createdAt": "2018-11-21T04:37:14Z",
          "updatedAt": "2018-11-21T04:37:14Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm hoping to delegate to the \"don't cache these\" list in https://github.com/httpwg/http-core/pull/181, which will take a bit longer to get into the HTTP draft. ",
          "createdAt": "2018-11-30T22:03:07Z",
          "updatedAt": "2018-11-30T22:03:07Z"
        }
      ]
    },
    {
      "number": 338,
      "id": "MDU6SXNzdWUzNzg5OTEzMTI=",
      "title": "Cache-Control header / past Expires in inner exchange's response.",
      "url": "https://github.com/WICG/webpackage/issues/338",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I've seen SXG inner exchange's response headers containing:\r\n```\r\nCache-Control: no-cache, no-store\r\nExpires: <past date>\r\n```\r\n\r\nHow should we handle these cases?\r\n- Option 1) Add them to the banned headers list\r\n- Option 2) As proposed by @mnot in #326, enforce the [response cacheability algorithm](https://httpwg.org/specs/rfc7234.html#response.cacheability) in verification steps.\r\n\r\nMy preference is Option 2.",
      "createdAt": "2018-11-09T01:53:26Z",
      "updatedAt": "2018-11-09T02:05:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Why should these apply to verification? If a non-signed response comes with these response headers, the browser will display it, but not cache it. I would assume the same behavior would apply here.",
          "createdAt": "2018-11-09T02:05:31Z",
          "updatedAt": "2018-11-09T02:05:31Z"
        }
      ]
    },
    {
      "number": 340,
      "id": "MDU6SXNzdWUzODE4MDMyNjg=",
      "title": "Consider banning Strict-Transport-Security and Public-Key-Pins headers",
      "url": "https://github.com/WICG/webpackage/issues/340",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In https://github.com/WICG/webpackage/issues/336#issuecomment-439560219, @sleevi suggests that we add the contents of [`kSecurityStateHeaders`](https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc?l=77) to https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#stateful-headers.\r\n\r\n@sleevi, you're worried about attackers targeting sites that use a set of HSTS domains as an authentication cookie?\r\n\r\nHTTP will define some set of headers that shared caches don't store, and I'd like to just blindly ban that list in signed exchanges, but I do see an argument to be a bit stricter in signed exchanges, since with signed exchanges the attacker doesn't have to be the first to visit the cache.\r\n\r\nOn the other hand, to be vulnerable to this attack, a site has to be using HSTS in a user-hostile way.",
      "createdAt": "2018-11-17T00:10:08Z",
      "updatedAt": "2019-01-10T17:31:58Z",
      "closedAt": "2019-01-10T17:31:58Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "And, to be clear, the benefit of allowing `Strict-Transport-Security` in signed exchanges is that if we ban it, users can't bootstrap to HSTS before they're online, which increases the time they're vulnerable to network attackers.",
          "createdAt": "2018-11-17T00:16:34Z",
          "updatedAt": "2018-11-17T00:16:34Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "And the risk (in addition to the general risk of state modification via\nSXG) is that someone can serve a maxAge=0 to unset it, undetectably, and\nrepeatedly for the lifetime of the signature.\n",
          "createdAt": "2018-11-17T00:18:31Z",
          "updatedAt": "2018-11-17T00:18:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Do sites generally serve `maxAge=0` for some resources when they want most of their site to be served over HTTPS? If not, this seems similar to the risk of a vulnerability being repeatably served for the lifetime of its signature.",
          "createdAt": "2018-11-17T00:26:45Z",
          "updatedAt": "2018-11-17T00:26:45Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I don\u2019t know if it matters much what sites do, compared to the cognitive\ncost it would bring with reasoning.\n\nFor example, is maxAge relative to the first signature or the most recent\nsignature? If maxAge in SXG is <= what is served via TLS, then what is the\neffective maxAge? If the client has a stored maxAge > the SXG maxAge, what\nis the effective maxAge? Questions like this are all introduced by allowing\nstateful side-effects.\n\nCombine that with things like HSTS for subdomains, and could you use a\ncombination of SXG delivery to set a stateful identifier? That would be\ndependent on whether SXGs (or bundles) could be delivered for subresources,\nand how the browser handles subresources loads for HSTS. However, throw in\nportals and it continues to get more confusing.\n",
          "createdAt": "2018-11-17T00:33:01Z",
          "updatedAt": "2018-11-17T00:33:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Consider also a site that deployed HSTS and then had to turn it off for whatever reason. Normally one can assume that, after maxAge + timeHeaderWasDisabled, the entry will have expired in all clients. That property relies on liveness from TLS.",
          "createdAt": "2018-11-20T18:50:36Z",
          "updatedAt": "2018-11-20T18:50:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm surprised that https://tools.ietf.org/html/rfc6797#section-6.1.1 says \"The REQUIRED \"max-age\" directive specifies the number of seconds, after the reception of the STS header field, ...\" instead of incorporating the initial-age calculation specified in https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html#age.calculations.\r\n\r\nGiven that, I'm convinced by @davidben's point. (If the initial-age calculation were included, @sleevi's point would be more convincing. :smiley:)",
          "createdAt": "2018-11-20T19:06:27Z",
          "updatedAt": "2018-11-20T19:06:27Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I guess it's because HSTS is not really a property of the resource and really just connection metadata that we jam into HTTP responses because we have nothing better to do with it. :-) If you believe in that interepretation, then you would want the timer to start at the current time. Indeed if there's a site out there where no resource had been updated for years, all the age headers would be old and effectively disable HSTS.\r\n\r\nThough I suspect the actual answer is this was an oversight. :-) Otherwise it'd probably have done a better job of marking it a hop-by-hop header and all that.",
          "createdAt": "2018-11-20T19:22:46Z",
          "updatedAt": "2018-11-20T19:22:46Z"
        }
      ]
    },
    {
      "number": 342,
      "id": "MDU6SXNzdWUzODI4Mjk1ODQ=",
      "title": "Define the browser algorithm for determining cacheability of status codes",
      "url": "https://github.com/WICG/webpackage/issues/342",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "#326 leaves the loading spec more restrictive than the RFC draft in terms of which status codes are allowed. We should figure out how browsers implement https://httpwg.org/http-core/draft-ietf-httpbis-cache-latest.html#response.cacheability and refer to that from the loading spec instead of blindly requiring only status 200, or we should tighten the RFC draft to require just that status.",
      "createdAt": "2018-11-20T20:10:38Z",
      "updatedAt": "2018-11-27T06:54:43Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "FYI:\r\n  https://wpt.fyi/results/fetch/http-cache/status.html?label=stable&aligned\r\nand:\r\n  https://github.com/httpwg/http-core/issues/120",
          "createdAt": "2018-11-27T06:54:43Z",
          "updatedAt": "2018-11-27T06:54:43Z"
        }
      ]
    },
    {
      "number": 347,
      "id": "MDU6SXNzdWUzODg1NDcxMDY=",
      "title": "Extend link HTTP header to support subresource signed exchange loading",
      "url": "https://github.com/WICG/webpackage/issues/347",
      "state": "OPEN",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I want to introduce two new fields in application/signed-exchange format.\r\n - Alternative-Signed-Exchange-Subresources map in unsigned field.\r\n - Allowed-Alternative-Signed-Exchange-Subresources list in signed field.\r\n \r\n## Problem\r\nCurrently content publishers can sign their HTML contents using their own private keys. User Agents (UAs) can trust the signed contents as if the contents are served from the publisher\u2019s origins even if they are served from other distributors\u2019 origins. The signed contents can be served from any distributors\u2019 origins. But if the publisher wants to serve subresources such as scripts and images from the distributors\u2019 origin, the publisher needs to change the subresource URLs in the HTML to point to each distributors\u2019 URL and need to sign for each distributor. The proposed two fields can solve this problem.\r\n\r\n**Alternative-Signed-Exchange-Subresources map:**\r\nA map from the original subresource requests to the SXG URLs. This field is not signed. So the distributor can change this field to point to their URLs.\r\n\r\n**Allowed-Alternative-Signed-Exchange-Subresources list:**\r\nThe subresource URL list which can be served using SXG instead of fetching the original URL. This field is signed by the publisher. So the distributor can\u2019t change this field.\r\n\r\n## Example\r\n**Publisher:** https://publisher.example/article_1.html\r\n```\r\n  <script src=\"framework.js\"></script>\r\n  <img src=\"article_1.jpg>\r\n```\r\n\r\n**SXG in Publisher:** https://publisher.example/article_1.html.sxg\r\n```\r\n[\r\n  // URL\r\n  'https://publisher.example/article_1.html',\r\n  // Signature\r\n  'sig1: sig=*...; integrity=\"digest/mi-sha256\";cert-url=\"https://publisher.example/cert\"',\r\n  // [New field] Alternative-Signed-Exchange-Subresources\r\n  // The key of the mapping may need Accept headers info in order to enable content\r\n  // negotiation (e.g. for WebP).\r\n  [\r\n    [{':url': 'https://publisher.example/framework.js', 'accept': '*/*'},\r\n     'https://publisher.example/framework.js.sxg'],\r\n    [{':url': 'https://publisher.example/article_1.jpg', 'accept': '*/*'},\r\n     'https://publisher.example/article_1.jpg.sxg']\r\n  ],\r\n  // Signed headers\r\n  [\r\n    { ':method': 'GET', 'accept': '*/*' },\r\n    {\r\n      ':status': '200',\r\n      // [New field]\r\n      ':allowed-alternative-signed-exchange-subresources':\r\n          '\"https://publisher.example/framework.js\",'\r\n          '\"https://publisher.example/article_1.jpg\"',\r\n      'content-encoding': 'mi-sha256-03',\r\n      'content-type': 'text/html; charset=utf-8',\r\n      'digest': 'mi-sha256-03=....'\r\n    },\r\n  ],\r\n  // Payload body\r\n  '<html><body>...'\r\n]\r\n```\r\n\r\n**SXG in Distributor:** https://distributor.example/article_1.html.sxg\r\n```\r\n[\r\n  // URL\r\n  'https://publisher.example/article_1.html',\r\n  // Signature\r\n  'sig1: sig=*...; integrity=\"digest/mi-sha256\";cert-url=\"https://distributor.example/publisher.example/cert\"',\r\n  // [New field] Alternative-Signed-Exchange-Subresources\r\n  [\r\n    [{':url': 'https://publisher.example/framework.js', 'accept': '*/*'},\r\n     'https://distributor.example/publisher.example/framework.js.sxg'],\r\n    [{':url': 'https://publisher.example/article_1.jpg', 'accept': '*/*'},\r\n     'https://distributor.example/publisher.example/article_1.jpg.sxg']\r\n  ],\r\n  // Signed headers (Same as the SXG in Publisher)\r\n  [\r\n    { ':method': 'GET', 'accept': '*/*' },\r\n    {\r\n      ':status': '200',\r\n      // [New field]\r\n      ':allowed-alternative-signed-exchange-subresources':\r\n          '\"https://publisher.example/framework.js\",'\r\n          '\"https://publisher.example/article_1.jpg\"',\r\n      'content-encoding': 'mi-sha256-03',\r\n      'content-type': 'text/html; charset=utf-8',\r\n      'digest': 'mi-sha256-03=....'\r\n    },\r\n  ],\r\n  // Payload body (Same as the SXG in Publisher)\r\n  '<html><body>...'\r\n]\r\n```\r\n\r\n## How UAs should work\r\n- When the user opens the SXG in the distributor, the UA must check the signature using the certificate in https://distributor.example/publisher.example/cert. (This is the existing behavior)\r\n- The UA processes the script tag and the img tag and decides to fetch the \"framework.js\" and the image \"article_1_small.jpg\".\r\n- Instead of fetching the original URL in publisher.example, UA should fetch the SXG files in distributor.example after checking the `Alternative-Signed-Exchange-Subresources` field and the `Allowed-Alternative-Signed-Exchange-Subresources` field.\r\n- If the original URL is not in the `Allowed-Alternative-Signed-Exchange-Subresources` field, the UA must fetch the original URL. This is intended to avoid the subresource monitoring attack.\r\n- If the original URL\u2019s origin is not same as the signed origin of the main SXG (publisher.example), the UA must fetch the original URL. This restriction is intended to avoid providing a way of tracking.\r\n- UAs should handle the preload link header in the signed response header in the same way. (ex: `link: <https://example.com/framework.js>;rel=\"preload\";as=\"script\"`)\r\n\r\n## Subresource monitoring attack\r\nWe need the signed `Allowed-Alternative-Signed-Exchange-Subresources` to avoid the subresource monitoring attack like this:\r\n- A publisher generates a SXG of a html which shows the user's icon using JS. `icon.src = USER_ID + '.png';`\r\n- An attacker sets the mapping info like this: `{ 'example.com/a.png': 'attacker.com/a.png.sxg', 'example.com/b.png': 'attacker.com/b.png.sxg', ....}`\r\n- If UA fetches the SXG of png when the image tag is added, the attacker can know the USER_ID. Even if UA only uses the prefetched SXG, the attacker distributor can intentionally delay returning the SXGs one by one to see when the load actually finishes by monitoring the onload event, therefore can know the USER_ID.\r\n\r\n## Tracking using subresource SXG\r\nWe need to prohibit the SXG loading for cross-origin subresources to avoid the user tracking like this:\r\n- A publisher sets one subresource to the `Allowed-Alternative-Signed-Exchange-Subresources` field (https://tracking.example/id.js)\r\n- The distributor server can let the publishers\u2019 site know about the user\u2019s ID (ABCD1234) by changing the `Alternative-Signed-Exchange-Subresources` field.\r\n - tracking.example/id.js points to tracking.example/ABCD1234.sxg (body is `const id='ABCD1234';)\r\n\r\nTracking is still possible even if we prohibit cross-origin subresources using the following logic. But this is more difficult.\r\n- A publisher sets 30 subresources to the `Allowed-Alternative-Signed-Exchange-Subresources` field (https://publisher.example/00, 01, ... 29)\r\n- The publisher prepares 60 files, 00_0.sxg (body is 0), 00_1.sxg (body is 1),  01_0.sxg (body is 0), 01_1.sxg (body is 1)...\r\n- The distributor server can let the publishers\u2019 site know about the user\u2019s ID in binary digits by changing the `Alternative-Signed-Exchange-Subresources` field.\r\n  - publisher.example/00 points to 00_0.sxg or 00_1.sxg\r\n  - publisher.example/01 points to 01_0.sxg or 01_1.sxg\r\n  - ....\r\n- This logic provides a way of user tracking of 2^30 users.\r\n",
      "createdAt": "2018-12-07T08:10:30Z",
      "updatedAt": "2019-09-27T04:30:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "The security implications of this are non-obvious, and may benefit from being fleshed out more. In particular, I always get uncomfortable when seeing new unsigned field - they make it dangerous for parsers and give attackers a lot of opportunities, some non-obvious.\r\n\r\nMy first thought was about substitution attacks - what prevents an attacker from modifying the URL for `framework.js.sxg` to point to `other-different-payload.js.sxg`. I'm assuming here that the answer is the SXG is strongly-bound to the request URL, and thus changing it to `other-different-payload.js.sxg` will cause it to fail when it attempts to match the request to the SXG - is that correct?\r\n\r\nThe next question is what the implications are of a version substitution of the SXG subresource. In this case, `framework.js.sxg` (v1) is served instead of the intended `framework.js.sxg` (v2). The best I can tell is the intent is to address that through the SXG signature expiration (that is, stop signing v1). This would be a 'new' problem, in as much as SXG-subresource-fetches and SXG-caching-inner-resources are not well-defined (or implemented) enough to be a thing that folks would rely on, even though they would also introduce these problems.\r\n\r\nThe final question is what the implications are of creating a bidirectional communication path. As you note, by virtue of the Allowed-Alternative-Signed-Exchange-Subresources, this potentially creates a communication channel between the distributor and the publisher when loading the SXG. The privacy implications are profound (as noted), but also the security implications of what happens if sites begin to rely on this communication channel, but that it is, by nature, unauthenticated (i.e. `publisher.example` can't tell whether it was `distributor.example` setting those bits or whether it was `evil-distributor.example` setting those bits.",
          "createdAt": "2018-12-07T21:44:44Z",
          "updatedAt": "2018-12-07T21:44:44Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> My first thought was about substitution attacks - what prevents an attacker from modifying the URL for framework.js.sxg to point to other-different-payload.js.sxg. I'm assuming here that the answer is the SXG is strongly-bound to the request URL, and thus changing it to other-different-payload.js.sxg will cause it to fail when it attempts to match the request to the SXG - is that correct?\r\n\r\nYes. UAs must check the subresource SXG's inner URL.\r\n\r\n> The next question is what the implications are of a version substitution of the SXG subresource. In this case, framework.js.sxg (v1) is served instead of the intended framework.js.sxg (v2). The best I can tell is the intent is to address that through the SXG signature expiration (that is, stop signing v1). This would be a 'new' problem, in as much as SXG-subresource-fetches and SXG-caching-inner-resources are not well-defined (or implemented) enough to be a thing that folks would rely on, even though they would also introduce these problems.\r\n\r\nPublishers must be careful to add subresources to the `Allowed-Alternative-Signed-Exchange-Subresources` field.\r\nIf framework.js.sxg (v1) has a security bug and the signature of SXG is still valid, the publisher must change the URL of framework.js.\r\n\r\n> The final question is what the implications are of creating a bidirectional communication path. As you note, by virtue of the Allowed-Alternative-Signed-Exchange-Subresources, this potentially creates a communication channel between the distributor and the publisher when loading the SXG. The privacy implications are profound (as noted), but also the security implications of what happens if sites begin to rely on this communication channel, but that it is, by nature, unauthenticated (i.e. publisher.example can't tell whether it was distributor.example setting those bits or whether it was evil-distributor.example setting those bits.\r\n\r\nIntroducing a new CSP directive `sxg-src` could be a solution for that.\r\nFor example, if the signed response header has `Content-Security-Policy: sxg-src https://distributor.example`, the sxg on `evil-distributor.example` should be blocked.",
          "createdAt": "2018-12-11T08:43:15Z",
          "updatedAt": "2018-12-11T08:43:15Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> Introducing a new CSP directive sxg-src could be a solution for that.\r\nFor example, if the signed response header has `Content-Security-Policy: sxg-src https://distributor.example`, the sxg on `evil-distributor.example` should be blocked.\r\n\r\nI don't think this addresses the substance of the concern. I was not attempting to say \"We should grant control to page authors\", I was trying to frame it as \"We need to carefully reason about the security implications of allowing this\". The goal of framing it like that is to understand if we're proposing a mechanism that is default-insecure, whether that's desirable in and of itself, and what solutions might exist.\r\n\r\nEven more concretely: I'm not convinced we should be displaying the publisher origin if we allow for arbitrary content injection by the distributor, which having such a channel would imply. I think we need to carefully reason about that. This statement is based on seeing the harm come from code-signing systems that allow for (limited) content injection/manipulation - such as Authenticode or macOS Bundles. It's certainly true that such unauthenticated injection allows for things developers perceive interesting and useful use cases - for example, injecting whether or not a user has opted-in to metrics collection services on the download page for an executable (e.g. Chrome) - but it's also true that such methods have caused a substantial number of security vulnerabilities (e.g. https://docs.microsoft.com/en-us/security-updates/securityadvisories/2014/2915720 )",
          "createdAt": "2018-12-11T16:12:34Z",
          "updatedAt": "2018-12-11T16:12:34Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "How about having the each signatures of subresources in `Allowed-Alternative-Signed-Exchange-Subresources` to prevent distributors from injecting arbitrary content?\r\n\r\n```\r\n[\r\n  // URL\r\n  'https://publisher.example/article_1.html',\r\n  // Signature\r\n  'sig1: sig=*...; integrity=\"digest/mi-sha256\";cert-url=\"https://distributor.example/publisher.example/cert\"',\r\n  // [New field] Alternative-Signed-Exchange-Subresources\r\n  [\r\n    [{':url': 'https://publisher.example/framework.js', 'accept': '*/*'},\r\n     'https://distributor.example/publisher.example/framework.js.sxg'],\r\n    [{':url': 'https://publisher.example/article_1.jpg', 'accept': '*/*'},\r\n     'https://distributor.example/publisher.example/article_1.jpg.sxg']\r\n  ],\r\n  // Signed headers (Same as the SXG in Publisher)\r\n  [\r\n    { ':method': 'GET', 'accept': '*/*' },\r\n    {\r\n      ':status': '200',\r\n      // [New field]\r\n      ':allowed-alternative-signed-exchange-subresources':\r\n          '\"https://publisher.example/framework.js\" '\r\n            '*MEUCIQDX...=* '  // The first signature of framework.js.sxg\r\n            '*MEQCIGjZ...=*,'  // The second signature of framework.js.sxg\r\n          '\"https://publisher.example/article_1.jpg\" '\r\n            '*lGZVaJJM...=* '  // The first signature of article_1.jpg.sxg\r\n            '*MEYCIQCN...=*',  // The second signature of article_1.jpg.sxg\r\n      'content-encoding': 'mi-sha256-03',\r\n      'content-type': 'text/html; charset=utf-8',\r\n      'digest': 'mi-sha256-03=....'\r\n    },\r\n  ],\r\n  // Payload body (Same as the SXG in Publisher)\r\n  '<html><body>...'\r\n]\r\n```",
          "createdAt": "2018-12-12T07:57:06Z",
          "updatedAt": "2018-12-12T07:57:06Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "As I mentioned previously, it's probably more useful to analyze the problem before we try to step forward to solve the problem. The latest proposed approach has, for example, the same deficiency w/r/t user tracking - if you treat `framework.js` as 'bit 0', `article_1.jpg` as 'bit 1', etc, then the existence of the two signatures lets you smuggle a bit at a time from the distributor by allowing the distributor to select which signature to use, which allows altering the content (e.g. `framework.js` having 0 bytes vs 1 byte).\r\n\r\nThis is why it's helpful to first make sure we've analyzed the problem, clearly stated it, and made sure it's not, in fact, a pre-existing problem, so then we can look at solution spaces or make informed tradeoff decisions.",
          "createdAt": "2018-12-12T14:18:06Z",
          "updatedAt": "2018-12-12T14:18:06Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "IIUC, the core goal here is that if `publisher.example` has signed all of `article1.html`, `framework.v2.js`, `article1.400x300.jpg`, and `article1.1600x1200.jpg`, we'd like `searchengine.example` to be able to prefetch the appropriate subset of those for their user to be able to view the article without any new fetches to `publisher.example`. (See [Privacy-Preserving Prefetch](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#private-prefetch).)\r\n\r\n[Bundles](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html) solve this, but they require `searchengine.example` to subset the bundle to omit whichever of `article1.400x300.jpg` or `article1.1600x1200.jpg` is the wrong size for the user. This ability to subset gives, I think, the same communication abilities @sleevi's worried about here, but Bundles do give us a straightforward way to prevent version skew. The Bundles implementation is also farther off than @horo-t, et. al. think they could implement this extension to the SXG format.\r\n\r\nWe've talked at times about adding a way to specify [external dependencies](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#external-dependencies) for bundles. The `Allowed-Alternative-Signed-Exchange-Subresources` list is similar to what we'd need for that.\r\n\r\nThe `Alternative-Signed-Exchange-Subresources` map fundamentally, tells the browser \"for this dependency that the SXG or bundle said you need, you can fetch it from this URL.\" I don't particularly like the idea of requiring the distributor to modify the SXG file itself in order to communicate that. Would a response header work? e.g.\r\n\r\n```http\r\nContent-Location: https://distributor.example/article1.html.sxg\r\nLink: <https://distributor.example/framework.v2.js.sxg>; anchor=\"https://publisher.example/framework.v2.js\"; rel=alternate_tbd\r\n```",
          "createdAt": "2018-12-12T22:38:31Z",
          "updatedAt": "2018-12-12T22:40:22Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin Your mention of bundles made me realize that there may be another implication of this - cache probing. That is, if the distributor can modify the URL used to fetch subresources, can it infer or learn what sub-resources the user may already have (cached or loaded) by seeing which requests are *not* made?\r\n\r\nThat is, if I fetch `article1.html.sxg` from `distributor.example`, and it refers to `publisher.example/resources/a.jpg`, `distributor.example` does not learn whether or not the resource was cached or loaded - because the user contacts `publisher.example` to fetch that resource. In the Bundles case, if the user issues a range request (for the bundle), then `distributor.example` can learn which resources are needed. The same would apply with this sort of modification - whether or not `distributor.example/sxgs/publisher.example/resources/a.jpg.sxg` was fetched reveals whether or not the user needed `publisher.example/resources/a.jpg`. This is similar to the privacy implications mentioned by @horo-t with regards to user IDs, but isn't mitigated by the `Allowed-Alternative...` solution.",
          "createdAt": "2018-12-12T22:48:11Z",
          "updatedAt": "2018-12-12T22:48:11Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "In what ways is the recommended value for `Allowed-Alternative-Signed-Exchange-Subresources` different from the value we'd recommend for a [`Link: <>; rel=preload`](https://w3c.github.io/preload/) header in the signed response? Could we just have the browser use the signed preloads for this purpose?",
          "createdAt": "2018-12-12T22:51:22Z",
          "updatedAt": "2018-12-12T22:51:22Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi Cute. I agree cache probing is a risk, but I think the UA can solve it the same way we solve other cache-based tracking attempts: we fetch the resource redundantly if the server we're fetching it from shouldn't know whether it's already cached. Edit: And searchengine.example needs to take that cost into account when deciding whether to offer a SXG for any particular resource.",
          "createdAt": "2018-12-12T22:54:51Z",
          "updatedAt": "2018-12-12T22:59:55Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin Sure, I didn't explicitly come out and say 'double-keyed caching', but I think that's the assumption. But that's something unique, in this case, because it's not double-keying based on the resource's logical origin (`publisher.example`) but instead based on the physical origin (`distributor.example`). Introducing that sort of split - where some of the security properties use physical and some logical - would benefit from that sort of analysis about the implications.",
          "createdAt": "2018-12-12T22:57:31Z",
          "updatedAt": "2018-12-12T22:57:31Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> In what ways is the recommended value for `Allowed-Alternative-Signed-Exchange-Subresources` different from the value we'd recommend for a [`Link: <>; rel=preload`](https://w3c.github.io/preload/) header in the signed response? Could we just have the browser use the signed preloads for this purpose?\r\n\r\nWouldn't it be both signed and unsigned preloads?\r\n\r\nThat is, `https://distributor.example/publisher.example/article_1.html.sxg` would `Link: <https://distributor.example/framework.v2.js.sxg>; rel=preload` when serving the SXG (i.e. the unsigned part), but then within the SXG, you'd do\r\n\r\n```\r\n  // Signed headers (Same as the SXG in Publisher)\r\n  [\r\n    { ':method': 'GET', 'accept': '*/*' },\r\n    {\r\n      ':status': '200',\r\n      ':link', '<https://publisher.example/framework.v2.js>; rel=preload',\r\n      ...\r\n    }\r\n   ...\r\n  ]\r\n```\r\n\r\nOr did I misunderstand the question?",
          "createdAt": "2018-12-12T23:02:20Z",
          "updatedAt": "2018-12-12T23:02:20Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "My `Link: <>; rel=preload` question was more for @horo-t than @sleevi. \ud83d\ude04 We have to look at the signed one for the same reasons `Allowed-...` has to be signed in the original post.\r\n\r\nI think it's more complex than \"double-keying\" or even \"physical\" vs \"logical\". We need to find a way to describe which entities (origins or [organi](https://developers.google.com/digital-asset-links/v1/getting-started)[zations](https://developer.apple.com/documentation/uikit/core_app/allowing_apps_and_websites_to_link_to_your_content/enabling_universal_links)) know that which other entities have asked the profile to download a URL. I think each entry in the cache winds up annotated with a list of entities that are allowed to know it's cached, and if you request it but aren't in that list, it gets refetched from the network. ... But I haven't thought that all the way through.",
          "createdAt": "2018-12-13T00:18:20Z",
          "updatedAt": "2018-12-13T00:18:20Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> My Link: <>; rel=preload question was more for @horo-t than @sleevi. \ud83d\ude04 We have to look at the signed one for the same reasons Allowed-... has to be signed in the original post.\r\n\r\nI think introducing a new Link header instead of `Alternative-Signed-Exchange-Subresources` is an alternative solution. But if we have `Alternative-Signed-Exchange-Subresources` field in SXG, we can easily host the SXG files in HTTP servers. The distributor doesn't need to implement the logic of setting the HTTP header for each SXG files. So I want to introduce the new field in SXG format.\r\n\r\n\r\n> I think it's more complex than \"double-keying\" or even \"physical\" vs \"logical\". We need to find a way to describe which entities (origins or organizations) know that which other entities have asked the profile to download a URL. I think each entry in the cache winds up annotated with a list of entities that are allowed to know it's cached, and if you request it but aren't in that list, it gets refetched from the network. ... But I haven't thought that all the way through.\r\n\r\nTo avoid letting the distributor know about the existence of publisher's content in the user's HTTPCache, UA must fetch `https://distributor.example/publisher.example/framework.js.sxg` even if `https://publisher.example/framework.js` is in the HTTPCache. But if `https://distributor.example/publisher.example/framework.js.sxg` is in the HTTPCache, UA doesn't need to fetch it again.",
          "createdAt": "2018-12-15T03:09:21Z",
          "updatedAt": "2018-12-15T03:09:21Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> This is why it's helpful to first make sure we've analyzed the problem, clearly stated it, and made sure it's not, in fact, a pre-existing problem, so then we can look at solution spaces or make informed tradeoff decisions.\r\n\r\nI think the problem of this idea is that the user can't notice the channel which can be used by the distributor to send arbitrary information to the publisher. Is my understanding correct?",
          "createdAt": "2018-12-15T03:09:46Z",
          "updatedAt": "2018-12-15T03:09:46Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": ">\n>\n> I think the problem of this idea is that the user can't notice the channel\n> which can be used by the distributor to send arbitrary information to the\n> publisher. Is my understanding correct?\n>\nWe can frame the problem like this:\n\nIn the existing Web platform, the document always explicitly requests any\ndependent information - if it isn\u2019t inline in the document itself, it\u2019s in\nthe headers or the subresources it loads. In all cases, the displayed page\nexplicitly makes the requests to get extra information.\n\nThis explicitness is good for security. It helps make sure that all the\ninformation in the page can be audited, and you can be sure where and how\ninformation makes it\u2019s way in. A page author can then use things like CSP\nto restrict the inflow and outflow of information even further.\n\nThis explicitness is also good for privacy. By making all information flow\noutgoing and explicit, users and extensions can inspect, audit, or alter\nthe outflow of information. This is used heavily by privacy preserving\nextensions and users.\n\nThe proposed CSP directive is trying to address the security aspect, by\ngiving page authors a means to control the content. It is unsafe by default\n- the SXG packager that didn\u2019t use the CSP could find unexpected content\ninjected, which is functionally indistinguishable from a MITM. We might say\nthat requires cleverness by the distributor, but if we\u2019re worried about\nsecurity as browser and spec authors, we need to worry about clever\ndistributors.\n\nThe problem with the approach is it doesn\u2019t address the privacy angle. This\nis when both the distributor and publisher are clever and collaborating.\nFor example, one clever attack around third-party cookie blockers would be\nto have the publisher publish a \u201ctracking\u201d SXG that can be hosted by\ndifferent distributors. The distributors could inject information in using\nthis channel - smuggling bits into the SXG. If the SXG has access to\nstorage or persistence APIs - for example, it can use IndexedDB or service\nworkers - then it can create a persistent record, associated with\n\u201cpublishers\u201d origin that the user visited \u201cdistributor\u201d. This would all be\ninvisible to the privacy conscious user, who would only see resource loads\nfrom the distributor - no third-party loads or cookies.\n\nThe only way a privacy conscious user could regain those privacy properties\nwould be to either block these subresource loads and substitutions, or\nblock all SXGs from being loaded by distributors. Both seem like they would\nbe a significant setback for the utility of this functionality and the\nutility of SXG in general, since privacy conscious browsers would likely do\none or both of these things.\n\nI think those two properties - that the page explicitly requests the data\nthat gets loaded in to itself (the security property) and that users,\nextensions, and privacy conscious browsers can then inspect, audit, alter,\nor block this data loading (the privacy properties) - are what the existing\nsystem has, and which this might undermine.\n\nIf that\u2019s a good framing of the problem, at least, then we may be able to\nidentify or come up with solutions that can meet both sets of needs.\n",
          "createdAt": "2018-12-15T06:26:55Z",
          "updatedAt": "2018-12-15T06:26:55Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the detailed framing of the problem.\r\n\r\nI think if the allowed-alternative-signed-exchange-subresources field must have the signatures of SXG https://github.com/WICG/webpackage/issues/347#issuecomment-446495503, we can solve the security issue.\r\n\r\nOne possible solution for the privacy issue is like this: Privacy conscious browsers can delay the subresource SXGs loading until the all subresource SXGs are successfully verified. If one of the SXGs has an error, the browsers must fetch the original publisher's URL. So the distributors can't use the smuggling bits in the SXG.",
          "createdAt": "2019-01-07T02:23:55Z",
          "updatedAt": "2019-01-07T02:23:55Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@horo-t I may be misunderstanding the proposal a bit, so I thought I'd try to write it out and check if it's what you're proposing:\r\n\r\n* Only declaratively-specified subresources would have this mapping applied, and only for first-order SXGs. That is, those SXGs loaded by JS (e.g. mutating a .src attribute) or those referenced within SXGs (for example, loading a CSS file that then loads dependent resources) won't go through this transformation. This is, AIUI, more restrictive than the generic preload scanner.\r\n* (Naive algorithm) After the page has fully loaded, and it's determined all URLs that this transformation would apply to, it then attempts to fetch all SXGs. After it has fully downloaded and verified the SXG (the entire resource), it may then either use all of those resources in lieu of the original URLs, or may otherwise restart and begin fetching those other URLs (throwing out all of the SXGs it downloaded)\r\n\r\nIs that roughly the proposal? I see lots of edge cases, so I wasn't sure if I was missing something fundamental. ",
          "createdAt": "2019-01-07T20:24:03Z",
          "updatedAt": "2019-01-07T20:24:03Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I forgot to say about the link headers.\r\n\r\nMy proposal for the privacy issue is:\r\n- Privacy conscious browsers can use subresource SXGs only when the subresources are listed in the link (rel=preload) header in the signed response headers.\r\n- While loading the main resource SXG, the browser checks the link header.\r\n- If there are corresponding SXGs in Alternative-Signed-Exchange-Subresources map, the browser fetchs the SXGs.\r\n- After finishing the verification of the all SXGs, the browser can load the subresources from the SXGs. If there is an error, the browser must fetch the original URL for the all subresources.\r\n",
          "createdAt": "2019-01-09T01:59:33Z",
          "updatedAt": "2019-01-09T01:59:33Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "We (@jyasskin, @sleevi, @kinu, @horo-t) discussed about this issue yesterday. This is the summary.\r\n\r\n- Goal:\r\n  - Only while prefetching a main SXG before the content document starts to be processed, allow subresources SXGs to be preloaded using existing prefetch+preload mechanisms (e.g. link headers).\r\n  - Allow these subresource preloads to also be served by SXGs from the SXG distributor/physical origin, allowing more efficient loading and w/o requiring a connection to the inner resource\u2019s logical origin.\r\n\r\n- To limit the complexity:\r\n  - We might restrict the usage of SXG subresource only for prefetches. No plan to support SXG subresources which were NOT prefetched.\r\n  - We might restrict the main SXG and the subresources SXGs to be served from the same host.\r\n\r\n#### Possible attacks:\r\n1. The Source (who has a link to the SXG) or Distributor sends a tracking ID to the Publisher\r\n   1.1. In query parameters or fragment\r\n   1.2. In the set of prefetched resources\r\n   1.3. In the content of prefetched resources\r\n   1.4. In the user history (referrer)\r\n2. If the subresource request from the SXG is observable by the Distributor:\r\n   2.1. The Publisher can send arbitrary information to the Distributor\r\n   2.2. Accidental information leak may occur.\r\n3. Version skew attack. An evil Distributor can serve old version JS which contains a bug.\r\n\r\n- Attack 1.1 is already possible without SXG.\r\n  - If the SXG's physical URL is observable by publishers, the Source can use it to send a tracking ID to publishers (attack 1.1). Signed Exchange Reporting to the publishers may expose this. https://github.com/w3c/network-error-logging/issues/99\r\n- If SXG subresources must be declared as prefetchable and all must be prefetched for any of the prefetches to apply:\r\n  - The Distributor can send only 1 bit (succeeded or failed) to the Publisher using the set of prefetched resources. (attack 1.2)\r\n  - This requirement also prevents the attack 2.1 and 2.2.\r\n- If the main SXG must have the subresources SXG's signatures in signed field:\r\n  - This Distributors can\u2019t send a tracking ID in the content of prefetched resources. (attack 1.3)\r\n  - This also prevents version skew attack (attack 3).\r\n  - This requirement may make the packaging tool complex.\r\n  - We might need to think about WebFonts case.\r\n- Publishers can know the source page URL which has a link to the SXG using document.referrer. (attack 1.4)\r\n  - The source page can send a tracking ID using the page URL.\r\n  - This is the status quo.\r\n  - document.referrer in SXG is not supported yet in Chromium (https://crbug.com/920905).\r\n",
          "createdAt": "2019-01-18T10:08:01Z",
          "updatedAt": "2019-01-18T10:08:01Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "If attack 1 is already possible with or without SXG (using either 1.1 or 1.4), why is it important to block 1.2?\r\n\r\nRequiring subresource signatures makes sense from a security perspective (to prevent content injection). blocking 1.3 is a nice side-effect of that.\r\n\r\nIt's also not immediately clear to me how limiting this to prefetches reduces the complexity or increases privacy. Can you elaborate on that?",
          "createdAt": "2019-01-31T10:11:15Z",
          "updatedAt": "2019-01-31T10:11:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Limiting it to prefetches prevents attack #<b></b>2. Unless you're thinking of a third kind of fetch besides prefetches and post-load fetches?\r\n\r\n@rbyers, do you have a feeling for which attacks we can exclude from the threat model because they're possible today?",
          "createdAt": "2019-01-31T16:51:39Z",
          "updatedAt": "2019-01-31T19:31:08Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Isn't attack #2 readily available to any page with network access? e.g. can't they send a 1x1 pixel image to with request parameters `distributor.com/tracking` to leak whatever information that they so choose?",
          "createdAt": "2019-02-01T09:36:37Z",
          "updatedAt": "2019-02-01T09:36:37Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@yoavweiss No.\r\n\r\nWhen prefetching, the author has to declaratively commit to what to disclose, rather than being able to leak traffic from the current origin. Note the caveats on https://github.com/WICG/webpackage/issues/347#issuecomment-447541822 as well.\r\n\r\nI think an important gap in that comparison is that this is *not* loading `distributor.com/tracking`, but allowing any intermediary to insert and/or observe traffic in the session. While it's true that it's \"with the consent\" of the origin (by virtue of saying how they can collaborate), it's functionally indistinguishable from mixed content. That is, despite the HTTPS page 'wanting' to load the HTTP page, it's not in the user's security or privacy interests to do so. Similarly, unlike an explicitly keyed load of `distributor.com/example` (which you can do prior to signing the SXG, if you explicitly indicate to load that SXG), this would allow attackers full mutability of where that content is loaded from. That is, they're not just causing it to load from `distributor.com/tracking` but `{insert distributor here}`, which as the analysis above explains, turns into a full primitive for insecure side-channels and injection unless limited to prefetch.\r\n\r\nHopefully, that explains why it's not at all comparable.",
          "createdAt": "2019-02-03T15:54:01Z",
          "updatedAt": "2019-02-03T15:54:01Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Instead of adding two new dedicated fields (Allowed-Alternative-Signed-Exchange-Subresources,Alternative-Signed-Exchange-Subresources) in the application/signed-exchange format, extending the link header sounds reasonable.\r\n\r\nFor example:\r\n\r\nIn unsigned HTTP response from distributor.example:\r\n```\r\ncontent-type: application/signed-exchange\r\nlink: <https://distributor.example/publisher.example/script.js.sxg>;rel=\"alternate\";type=\"application/signed-exchange\";anchor=\"https://publisher.example/script.js\";\r\n```\r\nIn signed response header of SXG:\r\n```\r\nlink: <https://publisher.example/script.js>;rel=\"allowed-alt-sxg\";sig=\"MEUCIA...\"\r\nlink: <https://publisher.example/script.js>;rel=\"preload\";as=\"script\"\r\n```\r\n\r\n(Sorry for contradicting my [previous comment](https://github.com/WICG/webpackage/issues/347#issuecomment-447532457))\r\n",
          "createdAt": "2019-02-05T01:45:32Z",
          "updatedAt": "2019-02-05T01:45:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I looked through http://microformats.org/wiki/existing-rel-values and https://www.iana.org/assignments/link-relations/link-relations.xhtml but didn't see anything that seems to serve the purpose of `rel=\"allowed-alt-sxg\"`, so we're free to invent our own name.\r\n\r\nWe should think about whether to include the format version number in the `type=\"application/signed-exchange\"` bit. I suspect we *should* require that version number since the distributor has already received an `Accept` header saying which version(s) the client supports.\r\n\r\nShould we make `allowed-alt-sxg` a separate Link or an extra parameter to the `preload` Link? We have lots of precedent for [adding parameters](https://html.spec.whatwg.org/multipage/semantics.html#attr-link-integrity) to `preload`, but this one's a bit weird because we don't want it to affect preloads retrieved directly from the publisher.",
          "createdAt": "2019-02-07T00:45:16Z",
          "updatedAt": "2019-02-07T00:45:16Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, that makes that clearer. Thanks!",
          "createdAt": "2019-02-08T09:57:18Z",
          "updatedAt": "2019-02-08T09:57:18Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> We should think about whether to include the format version number in the `type=\"application/signed-exchange\"` bit. I suspect we _should_ require that version number since the distributor has already received an `Accept` header saying which version(s) the client supports.\r\n\r\nHaving the format version number in the `type=\"application/signed-exchange\"` bit sounds good to me.\r\n\r\n> Should we make `allowed-alt-sxg` a separate Link or an extra parameter to the `preload` Link? We have lots of precedent for [adding parameters](https://html.spec.whatwg.org/multipage/semantics.html#attr-link-integrity) to `preload`, but this one's a bit weird because we don't want it to affect preloads retrieved directly from the publisher.\r\n\r\nI think we should have the separate`allowed-alt-sxg` Link. If we have the signature param in `preload` Link, it will be completed to selectively preload images using [imagesrcset and imagesizes](https://github.com/whatwg/html/pull/4048).\r\n\r\nExample:\r\nIn unsigned HTTP response from distributor.example: \r\n```\r\ncontent-type: application/signed-exchange\r\nlink: <https://distributor.example/publisher.example/wide.jpg.sxg>;rel=\"alternate\";type=\"application/signed-exchange;v=XX\";anchor=\"https://publisher.example/wide.jpg\";\r\nlink: <https://distributor.example/publisher.example/narrow.jpg.sxg>;rel=\"alternate\";type=\"application/signed-exchange;v=XX\";anchor=\"https://publisher.example/narrow.jpg\";\r\n```\r\nIn signed response header of SXG:\r\n```\r\nlink: <https://publisher.example/wide.jpg>;rel=\"allowed-alt-sxg\";sig=\"MEUCIB...\"\r\nlink: <https://publisher.example/narrow.jpg>;rel=\"allowed-alt-sxg\";sig=\"MEUCIC...\"\r\nlink: <https://publisher.example/wide.jpg>;rel=preload; as=image;imagesrcset=\"https://publisher.example/wide.jpg 640w, https://publisher.example/narrow.jpg 320w\";imgesizes=\"(min-width: 400px) 50vw, 100vw\"\r\n```\r\n",
          "createdAt": "2019-02-25T07:03:20Z",
          "updatedAt": "2019-02-25T07:03:20Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Filed a crbug: https://crbug.com/935267",
          "createdAt": "2019-02-25T07:17:07Z",
          "updatedAt": "2019-02-25T07:17:07Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I [wrote](https://github.com/WICG/webpackage/issues/347#issuecomment-446495503) that 'allowed-alternative-signed-exchange-subresources' ('allowed-alt-sxg' in the current idea) should have the signatures of subresources.\r\nBut the signature is valid only for 7 days.\r\n\r\nInstead of the signature, I want to use SHA-256 hash of [`headerBytes`](https://wicg.github.io/webpackage/loading.html#the-signed-message) byte sequence which includes `digest` header and `content-type` header and other arbitrary headers.\r\nNote that we can't use the digest header for the integrity check. If we do so, subresource SXGs are used for user tracking by adding arbitrary headers or changing content-type to cause image load failure.\r\n\r\nThe signed response header of main SXG will be like this:\r\n```\r\nlink: <https://publisher.example/wide.jpg>;rel=\"allowed-alt-sxg\";header-integrity=\"sha256-h0KP...\"\r\nlink: <https://publisher.example/narrow.jpg>;rel=\"allowed-alt-sxg\";header-integrity=\"sha256-AmOC...\"\r\nlink: <https://publisher.example/wide.jpg>;rel=\"preload\";as=image;imagesrcset=\"https://publisher.example/wide.jpg 640w, https://publisher.example/narrow.jpg 320w\";imgesizes=\"(min-width: 400px) 50vw, 100vw\"\r\n```",
          "createdAt": "2019-02-27T06:39:56Z",
          "updatedAt": "2019-02-27T06:39:56Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "> Instead of fetching the original URL in publisher.example, UA should fetch the SXG files in distributor.example after checking the\r\n\r\nHow does this interact with service workers? Would the request go to publisher.example's service worker first?",
          "createdAt": "2019-03-14T03:49:11Z",
          "updatedAt": "2019-03-14T03:49:11Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "How about introducing a new method \"getPreloadedResponses()\" in FetchEvent?\r\nService workers can get the prefetched subresources which are preloaded while prefetching the main resource in the previous page.\r\n```\r\ninterface FetchEvent : ExtendableEvent {\r\n  ...\r\n  Promise<FrozenArray<Response>> getPreloadedResponses();\r\n};\r\n```",
          "createdAt": "2019-03-14T04:21:53Z",
          "updatedAt": "2019-03-14T04:21:53Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "It looks it should probably clarify where the URL replacement happens in the Fetch process model?  Is the assumption that the replacement layer sits between the page and SW?",
          "createdAt": "2019-03-14T07:42:10Z",
          "updatedAt": "2019-03-14T07:42:10Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "Yes this is my point of confusion... would be useful to see the sequence of which service workers get consulted when and when the replacement happens for the main resource and the subresources.",
          "createdAt": "2019-03-14T07:46:07Z",
          "updatedAt": "2019-03-14T07:46:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@mattto To [preserve privacy during the prefetch](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#private-prefetch), the publisher's SW MUST NOT get an event saying which subresources are getting prefetched, even transitively.\r\n\r\nWe do need to specify that ... but doing so will be difficult until there's a specification of how `<link rel=\"prefetch\">` interacts with Service Workers at all.\r\n\r\nMy guess is that whatever bit of the browser is scanning a prefetched resource for preloads to prefetch recursively (whew) needs to maintain the mapping of available alternate SXGs, and replace the URLs before it invokes Fetch. @horo-t / @kinu, does that make sense?",
          "createdAt": "2019-03-15T22:15:14Z",
          "updatedAt": "2019-03-15T22:15:14Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "My current idea of Service Worker and subresource SXG prefetching integration is like this:\r\n\r\n1. The user opens \"https://aggregator.example/index.html\".\r\n1. When the UA processes `<link rel=\"prefetch\" href=\"https://distributor.example/publisher/article.sxg\">`:\r\n   * Invoke the FetchEvent of aggregator's SW with \"article.sxg\" request.\r\n   * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The SXG is stored to the HTTPCache.\r\n1. The response has the following headers:\r\n   * In unsigned outer HTTP response:\r\n     * `content-type: application/signed-exchange`\r\n     * `link: <https://distributor.example/publisher/script.js.sxg>;rel=\"alternate\";type=\"application/signed-exchange[;v=...]\";anchor=\"https://publisher.example/script.js\";`\r\n   * In signed inner response header:\r\n     * `link: <https://publisher.example/script.js>;rel=\"allowed-alt-sxg\";header-integrity=\"sha256-MEUCIA...\"`\r\n     * `link: <https://publisher.example/script.js>;rel=\"preload\";as=\"script\"`\r\n1. The UA processes the headeres, and starts prefetching \"https://distributor.example/publisher/script.js.sxg\".\r\n   * Invoke the FetchEvent of aggregator's SW with \"script.js.sxg\" request.\r\n   * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The SXG is stored to the HTTPCache.\r\n1. The user clicks the link of https://distributor.example/publisher/article.sxg\r\n   * Invoke the FetchEvent of distributor's SW with \"article.sxg\" request.\r\n   * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The SXG is served from the HTTPCache.\r\n1. The UA processes the SXG response as if it is a 303 redirect to \"https://publisher.example/article.html\" and set [request\u2019s \"stashed exchange\" to the parsedExchange](https://wicg.github.io/webpackage/loading.html#mp-http-fetch).\r\n   * Invoke the FetchEvent of publisher's SW with \"article.html\" request.\r\n     * FetchEvent.request.url is \"https://publisher.example/article.html\".\r\n     * FetchEvent.preloadResponse is a promise which returns the inner response.\r\n     * FetchEvent.getPreloadedResponses() returns a promise which returns the preloaded responses (In this case: \"https://publisher.example/script.js\").\r\n   * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The response [is set to the stashed exchange's response](https://wicg.github.io/webpackage/loading.html#mp-http-network-or-cache-fetch).\r\n1. The UA processes the link header.\r\n   * Invoke the FetchEvent of publisher's SW with \"script.js\" request. The SW can return the response which have been retrieved using getPreloadedResponses() at 6.\r\n   * If the SW didn't call respondWith(), Check the existence of the prefetched \"script.js.sxg\" in HTTPCache, and returns the inner response of it if exists. Othewise perform a HTTP-network-or-cache fetch.",
          "createdAt": "2019-03-18T06:10:43Z",
          "updatedAt": "2019-03-18T06:10:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I like that overall sketch.\r\n\r\n\"The SXG is stored to the HTTPCache.\" is ambiguous here, since we're designing for a multi-key'ed HTTP cache. We'll wind up using terminology from https://github.com/w3c/resource-hints/issues/82, but I think the goal is to put:\r\n\r\n1. `https://distributor.example/publisher/article.sxg` in the new prefetch cache and\r\n2. The **inner resource** from `https://distributor.example/publisher/script.js.sxg` in a cache that's promoted to the `https://publisher.example` origin's partition of the HTTP cache **only if** the navigation is to `https://publisher.example/article.html`.\r\n\r\nThis promotion to the HTTP cache reminds me of things @sleevi has been nervous of, and I don't understand his concerns well enough to know if they're assuaged by this happening only on navigation to the controlling top-level document.\r\n\r\n----\r\n\r\nSeparately, I haven't thought through whether we need the `FetchEvent.getPreloadedResponses()` method, and I suspect you should propose it separately from this SXG proposal. It probably makes sense, or doesn't, for *all* recursive prefetches, so should go to https://github.com/w3c/resource-hints?",
          "createdAt": "2019-03-18T23:20:51Z",
          "updatedAt": "2019-03-18T23:20:51Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin @sleevi Reg: inner resource and HTTP cache, if we're feeling ready to talk about this I prefer we discuss the generic case first, possibly in a separate issue, before talking about this specific case, could we?\r\n\r\n@horo-t Reg: FetchEvent.getPreloadResponses(): why don't we just let FetchEvent.preloadResponse expose the preload-to-prefetched resource for the particular fetch (e.g. for \"script.js\")? It looks UA anyway needs to track the relationship until step 7, wasn't sure why returning an array in navigation request is better.  Either way I agree with @jyasskin that proposing this separately might be good, I think similar idea has been discussed somewhere else before (e.g. exposing prefetched response as FetchEvent.preloadResponse).\r\n\r\nBut also wondered if we do start to store innerResponse in HTTP cache when navigation happens something like 2. in [#issuecomment-474138609](https://github.com/WICG/webpackage/issues/347#issuecomment-474138609) then getPreloadResponses() might not be really needed?",
          "createdAt": "2019-03-19T01:04:24Z",
          "updatedAt": "2019-03-19T01:04:24Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "Thanks for sketching that out, that's very clear. I'll note that this adds more cases where `respondWith(fetch(event.request))` differs from not calling `respondWith()`. Historically we've tried to keep those equivalent, but maybe we've already lost that guarantee, and it aligns with the main resource SXG. Was there a discussion about the SW interaction described in https://wicg.github.io/webpackage/loading.html#overview?",
          "createdAt": "2019-03-19T01:27:27Z",
          "updatedAt": "2019-03-19T01:27:27Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu \r\nUsing FetchEvent.preloadResponse for the preload-to-prefetched resources sounds good to me.\r\nFetchEvent.getPreloadResponses() may be useful when we want to store the prefetched subresrouces to CacheStorage. But I don't think this is super important. \r\n\r\nI commented about using FetchEvent.preloadResponse in SW for prefetched resources at https://github.com/w3c/resource-hints/issues/78#issuecomment-474165639. Let's discuss about it there.\r\n",
          "createdAt": "2019-03-19T01:55:51Z",
          "updatedAt": "2019-03-19T01:55:51Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@mattto \r\nThe SW integration with signed exchange was added to the spec at https://github.com/WICG/webpackage/pull/281#discussion_r208055480. If we want to keep calling `respondWith(fetch(event.request))` and not calling `respondWith()` same behavior, we need to change the spec. I think we should discuss about it in a separate issue.  \r\n",
          "createdAt": "2019-03-19T02:22:24Z",
          "updatedAt": "2019-03-19T02:22:24Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "Thanks, filed #409 ",
          "createdAt": "2019-03-19T06:28:59Z",
          "updatedAt": "2019-03-19T06:28:59Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> 4. The UA processes the headeres, and starts prefetching \"https://distributor.example/publisher/script.js.sxg\".\r\n>    \r\n>    * Invoke the FetchEvent of aggregator's SW with \"script.js.sxg\" request.\r\n>    * If the SW didn't call respondWith(), perform a HTTP-network-or-cache fetch. The SXG is stored to the HTTPCache.\r\n\r\nI find this part uncomfortable and hard to reason about. In a 'normal' TLS loading case, my understanding is that `aggregator.example` would have no knowledge of `distributor.example` preloading here, so this feels like a new information disclosure vector.\r\n\r\nIf I understand correctly, but wanting to confirm, we're reasoning that this isn't particularly new information, because `aggregator.example` can see the headers of the inner SXG, and thus know about the `link: ...;rel=\"preload\"` content, and thus know what the user will load anyways. Does that sound roughly correct?\r\n\r\nI think one area that would need more specificity here is what happens if `aggregator.example` does trigger a respondWith() call for the fetch to `distributor.example/publisher/script.js.sxg`.\r\n  1) What if they glue it to a fetch event of `otherdistributor.example/publisher/script.js.sxg'\r\n  2) What if they glue it to a fetch event of `publisher.example/script.js`\r\n  3) What if they glue it to a synthetic response (e.g. a blob) which has the same `header-integrity` value as expressed in the `rel=\"allowed-alt-sxg\"` (which AIUI refers to the hash of the inner content not the outer content?)\r\n\r\nSeparate from these concerns, as @jyasskin highlighted, we need to figure out what it means by storing in the HTTPCache / serving from the HTTPCache, and how those requests are inserted and matched. If I understood @kinu's [comment](https://github.com/WICG/webpackage/issues/347#issuecomment-474158214) it sounds like we're good to defer that?",
          "createdAt": "2019-03-20T16:12:58Z",
          "updatedAt": "2019-03-20T16:12:58Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Humm...\r\nNow I think we should skip service workers for prefetching requests (2 and 4 of https://github.com/WICG/webpackage/issues/347#issuecomment-473782344), at least for MVP (minimum viable product).\r\n\r\n\r\nIntroducing the new prefetch cache sounds good to me. If we can put the prefetched resources (https://distributor.example/publisher/article.sxg and https://distributor.example/publisher/script.js.sxg) and the certificate URL of each SXGs to the new prefetch cache, and we can use the cached resources when navigating from https://aggregator.example/index.html, this mechanism works even when double-key caching is enabled. (I'm trying to find a good way to implement this in Chromium.)\r\n\r\nI still don't know whether it is ok or not to store the inner resources (https://publisher.example/article.html and https://publisher.example/script.js) into the prefetch cache.\r\nIt is good for performance because we can skip the verification process.\r\n@sleevi Do you have any concern about it?",
          "createdAt": "2019-03-23T05:36:34Z",
          "updatedAt": "2019-03-23T05:36:34Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I have written two explainer documents.\r\n - [Signed Exchange subresource substitution](https://github.com/horo-t/subresource-signed-exchange/blob/master/signed-exchange-subresource-subtitution-explainer.md)\r\n    - This introduces rel=\"allowed-alt-sxg\" link header.\r\n    - By using this header, content publishers can declare that the UA can load the specific subresources from cached signed exchanges which were prefetched in the referrer page.\r\n - [Signed Exchange alternate link](https://github.com/horo-t/subresource-signed-exchange/blob/master/signed-exchange-alternate-link-explainer.md)\r\n    - This extends the usage of the existing rel=\"alternate\" link header.\r\n    - By using this header, UAs can recursively prefetch appropriate subresource signed exchanges while prefetching the main resource signed exchange.",
          "createdAt": "2019-07-11T00:16:40Z",
          "updatedAt": "2019-07-11T00:16:51Z"
        }
      ]
    },
    {
      "number": 349,
      "id": "MDU6SXNzdWUzOTAyMjY1NzM=",
      "title": "Clarify SXG + SW interactions",
      "url": "https://github.com/WICG/webpackage/issues/349",
      "state": "CLOSED",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The [\"Navigations and subresources redirect\" section of the Explainer](https://github.com/WICG/webpackage/blob/master/explainer.md#navigations-and-subresources-redirect) seems to suggest that once the SXG is unwrapped and the publishing URL is available, if the browser then discovers that a service worker is controlling the publishing URL, the request will be routed through the SW via the standard \"fetch\" event.\r\n\r\nThe SW then executes as normal with one exception: if the SW attempts a network request to the publishing URL (e.g. via `fetch()`), the browser will return the response stream embedded within the SXG instead of performing the network request. (That is, from the point of view of the browser, no network access will occur--the already-available response will be returned to the SW.)\r\n\r\nIt would be useful to know:\r\n\r\n- Whether the various mechanisms that currently allow the SW to avoid the various browser caches (e.g. [cache = \"no-store\"](https://developer.mozilla.org/en-US/docs/Web/API/Request/cache)) will be respected. (If not, this introduces an awkward difference in behavior.)\r\n- Whether the response stream attached to the redirect will also be available via the [navigation.preload](https://developer.mozilla.org/en-US/docs/Web/API/NavigationPreloadManager) mechanism. (Also, was making the response available via this mechanism only considered? It seems a bit more compatible with what's actually going on, especially with respect to the time at which things occur.)\r\n\r\n/cc @jakearchibald @twifkak ",
      "createdAt": "2018-12-12T13:30:16Z",
      "updatedAt": "2018-12-13T17:59:17Z",
      "closedAt": "2018-12-13T17:59:17Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "https://wicg.github.io/webpackage/loading.html#mp-http-network-or-cache-fetch should give a precise answer to your questions, but please let me know if it's the wrong answer. :)",
          "createdAt": "2018-12-13T00:56:42Z",
          "updatedAt": "2018-12-13T00:56:42Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "That's perfect, thanks. (And sorry I missed it that section.)",
          "createdAt": "2018-12-13T17:59:17Z",
          "updatedAt": "2018-12-13T17:59:17Z"
        }
      ]
    },
    {
      "number": 350,
      "id": "MDU6SXNzdWUzOTA1MTE4Njk=",
      "title": "Implementation snapshot b3",
      "url": "https://github.com/WICG/webpackage/issues/350",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "We would like to prepare another implementation snapshot `b3` to incorporate the recent changes to the format.\r\nOur plan is to ship Chrome M73 with `b3` support.\r\n\r\n## Highlight of changes since `b2`\r\n\r\nof which we would definitely want to make it in `b3`:\r\n- [x] `Variants` header-based request matching (post #285)\r\n  - [x] https://github.com/WICG/webpackage/pull/285\r\n  - [x] https://github.com/WICG/webpackage/pull/360\r\n  - [x] https://github.com/httpwg/http-extensions/pull/735\r\n  - [x] https://github.com/httpwg/http-extensions/issues/570\r\n  - [x] Version the Variant headers (httpwg/http-extensions#747)\r\n- [x] Header bans (#336, #340)\r\n- [x] Reject uncachable and incomplete responses (#326)\r\n- [x] UTF-8 decode the URL string (#346) \r\n- [x] Prevent content-type sniffing (#354)\r\n",
      "createdAt": "2018-12-13T04:19:05Z",
      "updatedAt": "2019-07-25T15:12:29Z",
      "closedAt": "2019-07-25T15:12:29Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Also include httpwg/http-extensions#735 per comments on #285.",
          "createdAt": "2018-12-13T04:40:40Z",
          "updatedAt": "2018-12-13T04:40:40Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@twifkak noted. Am I correct that it is part of #285?",
          "createdAt": "2018-12-13T04:43:58Z",
          "updatedAt": "2018-12-13T04:43:58Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "@nyaxt #285 was landed with a dependency on httpwg/http-extensions, with the understanding that httpwg/http-extensions#735 would eventually land. Perhaps the snapshot, given it is time-sensitive, should reference it as a required amendment.",
          "createdAt": "2018-12-13T05:26:18Z",
          "updatedAt": "2018-12-13T05:26:18Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I just went over list of open PRs and found https://github.com/WICG/webpackage/pull/121 is not yet resolved.\r\n@jyasskin @davidben : I'd like to hear your latest thoughts. Do you think we should include the change in b3?",
          "createdAt": "2019-01-07T01:13:40Z",
          "updatedAt": "2019-01-07T01:13:40Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm currently inclined not to make the change in #121. We should encourage folks to use a unique URL for each version of the OCSP response, but signing it all together seemed to cause some problems for the Intermediate's serving infrastructure for not much benefit. (@twifkak had more details about the problems.)",
          "createdAt": "2019-01-08T00:34:23Z",
          "updatedAt": "2019-01-08T00:34:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I realized we should version our `Variants` headers too: https://github.com/httpwg/http-extensions/issues/747. It's not absolutely essential, since they're always embedded into a versioned SXG file, but it reduces the risk that it'll leak into the rest of the ecosystem.",
          "createdAt": "2019-01-08T00:42:23Z",
          "updatedAt": "2019-01-08T00:42:23Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "I believe this snapshot also needs to include the httpbis-header-structure upgrade, per http://crrev.com/c/1420506.",
          "createdAt": "2019-01-23T00:55:56Z",
          "updatedAt": "2019-01-23T00:55:56Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "Is there a timeline for when this will be included in the implementation checkpoints? https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02 has expired as of March 8",
          "createdAt": "2019-03-15T18:45:30Z",
          "updatedAt": "2019-03-15T18:45:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I-D expirations don't really mean anything, but you're right that we're overdue for publishing the -03 draft. I've started on it and should have a first version out for review today. Once I merge that, it'll be available at https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html. I can't publish anything to the IETF's server until [March 23](https://datatracker.ietf.org/submit/), but I may leave it open for several days to a week after that to make sure folks have time to review it.\r\n\r\nSorry for the slowness.",
          "createdAt": "2019-03-15T18:53:18Z",
          "updatedAt": "2019-03-15T18:53:18Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "Any chance this will be merged?",
          "createdAt": "2019-06-13T18:25:43Z",
          "updatedAt": "2019-06-13T18:25:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-03 is finally submitted. Sorry for the delay.",
          "createdAt": "2019-07-25T15:12:29Z",
          "updatedAt": "2019-07-25T15:12:29Z"
        }
      ]
    },
    {
      "number": 362,
      "id": "MDU6SXNzdWUzOTYzMjM5MTA=",
      "title": "Implement \"Implementation snapshot b3\"",
      "url": "https://github.com/WICG/webpackage/issues/362",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi",
        "nyaxt",
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "This issue tracks progress of implementation of [the b3 snapshot](https://github.com/WICG/webpackage/issues/350) in both gen-signedexchange and Chromium.\r\n\r\n| Task | [Go](https://github.com/WICG/webpackage/tree/master/go/signedexchange) | Chromium |\r\n|---|---|---|\r\n| New magic bytes \"1b3\" | #353 | https://crbug.com/919417 |\r\n| #360 CBOR no longer have request map | #357 | https://crbug.com/919420  |\r\n| ~~\"Response is complete\"~~ | #363 |  |\r\n| #360 shared cache cachable | #367 | [CL](https://chromium-review.googlesource.com/c/chromium/src/+/1400422) |\r\n| #339 Reject uncached headers | #373 |  https://crbug.com/920897  |\r\n| #360 Use Variants | #366 | https://crbug.com/923229  |\r\n",
      "createdAt": "2019-01-07T02:14:35Z",
      "updatedAt": "2019-01-24T08:00:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Go verifier changes (except Variants): https://github.com/WICG/webpackage/pull/384",
          "createdAt": "2019-01-24T08:00:44Z",
          "updatedAt": "2019-01-24T08:00:44Z"
        }
      ]
    },
    {
      "number": 365,
      "id": "MDU6SXNzdWUzOTYzNDUzOTI=",
      "title": "\"is complete\" check requires the entire response body. Streaming loading?",
      "url": "https://github.com/WICG/webpackage/issues/365",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Found by @irori while implementing \"is complete check\" #363 #364 \r\n\r\nWe introduced \"is complete\" check in #326.\r\n\r\nhttps://tools.ietf.org/html/rfc7234#section-3.1 says \r\n> A response message is considered complete when all of the octets\r\n   indicated by the message framing ([RFC7230]) are received prior to\r\n   the connection being closed.\r\n\r\nThis check is tricky to implement for streaming clients (e.g. Chromium).\r\n\r\nIf the offset at mice stream EOS doesn't match \"Content-Length\", what should the UA do?\r\n- If C-L > actual EOS. The response payload may be already fully consumed by the client.\r\n- The UA may track the expected C-L while running mice streaming encoder to:\r\n  - emit error if the mice stream payload exceeded the expected C-L\r\n  - emit error on the last chunk if the payload stream length doesn't match the expected C-L.\r\n\r\nI think we have at least the following options:\r\n- Option A: Implement the complex check.\r\n  - Chromium may need this anyway if we add support for mice decoder in for non-SXG raw HTTP.\r\n- Option B: Remove \"is complete\" check and replace it with plain 206 check.\r\n  - This was @kinu's preference in #326.\r\n- Option B': Check 206 && if Content-Length is formatted correctly (\"the response has valid message framing\")\r\n  - Not sure how much this is worth doing.\r\n\r\n@jyasskin, @irori, @kinu : Your thoughts welcome.\r\n",
      "createdAt": "2019-01-07T04:38:30Z",
      "updatedAt": "2019-01-10T07:23:41Z",
      "closedAt": "2019-01-10T07:23:41Z",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Another aspect of this is that https://tools.ietf.org/html/rfc7230#section-3.3.3 has a special case for \"Transfer-Encoding: chunked\" but not for \"Content-Encoding: mi-sha256\".\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-p1-messaging-26#section-3.3.3 says\r\n>        If a message is received with both a Transfer-Encoding and a\r\n>        Content-Length header field, the Transfer-Encoding overrides the\r\n>        Content-Length.  Such a message might indicate an attempt to\r\n>        perform request smuggling (Section 9.5) or response splitting\r\n>        (Section 9.4) and ought to be handled as an error.  A sender MUST\r\n>        remove the received Content-Length field prior to forwarding such\r\n>        a message downstream.\r\n\r\nbut https://tools.ietf.org/html/draft-thomson-http-mice-03 allows its use with a `Content-Length` header. At least, its [examples](https://tools.ietf.org/html/draft-thomson-http-mice-03#section-4) contain `Content-Length` headers.",
          "createdAt": "2019-01-07T04:46:09Z",
          "updatedAt": "2019-01-07T04:46:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Because MICE is a *content* encoding, I believe the `Content-Length` refers to the encoded bytes, not the decoded ones, so it doesn't conflict like it does with a `Transfer-Encoding`. Given that, I don't think there's a \"complex check\" to fall back to.\r\n\r\nI haven't studied the completeness problem in depth, but I suspect we were just wrong to require the response to be complete, since a streaming client can't check that up front as we've required. Instead, we could either treat an incomplete response like it's an MI decoding error (which it might actually be since we'd append a `0` byte to the last record where it expects a continuation record's `1`?), or just as an incomplete response in the browser. ",
          "createdAt": "2019-01-08T00:27:52Z",
          "updatedAt": "2019-01-08T00:27:52Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> I haven't studied the completeness problem in depth, but I suspect we were just wrong to require the response to be complete, since a streaming client can't check that up front as we've required.\r\n\r\nSounds good. Do you have a preference on what check to replace it with? Does 206 check sound reasonable to you?",
          "createdAt": "2019-01-08T03:53:59Z",
          "updatedAt": "2019-01-08T03:53:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Is \"the 206 check\" just a check that the response status isn't 206? The loading spec currently requires exactly a 200 status, and I wonder if it'd make sense to have the IETF side also require that, until someone finds a use case for another status.",
          "createdAt": "2019-01-08T04:08:58Z",
          "updatedAt": "2019-01-08T04:08:58Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm convinced that the 200 status check in the loading spec is sufficient for now.\r\n\r\nI was thinking of banning \"Content-Range\" response from signed exchanges since I couldn't find good use-case for it. But after giving it more thought, I don't have a security threat scenario for that either. We can reconsider once we actually find issues.",
          "createdAt": "2019-01-08T06:32:55Z",
          "updatedAt": "2019-01-08T06:32:55Z"
        }
      ]
    },
    {
      "number": 366,
      "id": "MDU6SXNzdWUzOTYzNjk2Mzg=",
      "title": "dump-signedexchange: Implement Variants validation",
      "url": "https://github.com/WICG/webpackage/issues/366",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi"
      ],
      "labels": [
        "go"
      ],
      "body": "We need to update `dump-signedexchange` to support Variants header validation per #360 [change](https://github.com/WICG/webpackage/pull/360/files#diff-a2197f2cbc199dc1463dc10213fa40d9R957).\r\nThe [loading spec](https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/360.html#request-matching) may be easier to follow step-by-step.\r\n",
      "createdAt": "2019-01-07T06:55:13Z",
      "updatedAt": "2019-01-10T00:34:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Be aware of https://github.com/httpwg/http-extensions/pull/750, which specifies `Variants-05`, etc., when implementing this.",
          "createdAt": "2019-01-10T00:34:15Z",
          "updatedAt": "2019-01-10T00:34:15Z"
        }
      ]
    },
    {
      "number": 376,
      "id": "MDU6SXNzdWU0MDA0NzU0MzI=",
      "title": "Purge mechanisms",
      "url": "https://github.com/WICG/webpackage/issues/376",
      "state": "OPEN",
      "author": "yoavweiss",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Related to https://github.com/WICG/webpackage/issues/324\r\n\r\nWhile talking to @bratell-at-opera about signed exchanges, he raised concerns about invalid content continuing to circulate after its publisher realized it is invalid.\r\n\r\nThinking about that problem, it's very similar to the one for which CDNs offer purge mechanisms:\r\n* Articles may include typos, embarrassing mistakes or even false information that can expose the publisher from a legal perspective. Once that is discovered, publishers are likely to want to take down that content immediately.\r\n* E-commerce sites may include pricing mistakes, which they typically want to correct ASAP, as that content can cause them to lose money.\r\n* Court order compliance may also be a reason a content's publisher may want it to no longer be considered valid.\r\n\r\nTalking to @jyasskin, the `validityUrl` can be used in order to verify that the content is still valid from the publisher's perspective. Although it was meant for intermediaries, we can use the same value for browser-side validation, to make sure the browser doesn't display invalid content. \r\n\r\nThe browser would fetch the validity information when navigating to an SXG page. (assuming the browser is online)\r\nIf the SXG content is invalid, the browser would force its reload. Assuming that caches validate content regularly, very few users would actually witness those reloads, in the already rare case that content needed to be purged.\r\n\r\nThis won't solve purge for offline access, but that's similar to any offline content (e.g. in a PWA or a native app)\r\n\r\nThoughts?",
      "createdAt": "2019-01-17T21:42:23Z",
      "updatedAt": "2019-04-17T11:26:10Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I think there's a tension here; the more work put on repudiation (effectively what this is), the less useful this becomes to actually enabling a distributed, decentralized, or more robust Internet, which is at least where some of the interesting use cases are. Similarly, this might be mistaken as enabling a DRM-like solution, which is not a goal.\r\n\r\nConsidering that these same issues already exist if, for example, a site sets a long cache lifetime, I think it may be worthwhile exploring more about the \"what if we didn't offer a purge mechanism\", as it seems like it comes with very, very high tradeoffs.",
          "createdAt": "2019-01-17T21:46:38Z",
          "updatedAt": "2019-01-17T21:46:38Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "In some sense, repudiation is already possible, by signing `<script>fetchUpdatedContent()</script>`. This would be soft repudiation if the original content is signed and then replaced at runtime, and hard repudiation if only the script is signed (in which case, none of those benefits of SXG are realized).",
          "createdAt": "2019-01-17T21:59:43Z",
          "updatedAt": "2019-01-17T21:59:43Z"
        },
        {
          "author": "bratell-at-opera",
          "authorAssociation": "NONE",
          "body": "One reason I pointed out the risks above is that information and misinformation is currently getting weaponized on the Internet, and for information there are two important parts: The data and the source. If you can replay a historic (may it be 1 day historic) mistake or transient data as current information from a reputable source, that can be used to either mislead people or damage the reputation of a source that is trying to be accurate. Or both.\r\n\r\nClient caches don't have this particular weakness since you cannot transfer a cache to someone that you want to mislead. \r\n\r\n",
          "createdAt": "2019-01-17T23:17:30Z",
          "updatedAt": "2019-01-17T23:17:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The proposal would compromise the [anti-censorship](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#anti-censorship) use cases if the censor can compel the origin to respond to `validity-url` requests without the `signature` field, or when the censor can MitM requests to the origin. If not, the fact that `validity-url` requests fail open prevents the censor from using that to censor. The proposal would compromise anti-surveillance use cases in general. It wouldn't compromise [privacy-preserving-prefetch](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#private-prefetch) as long as we're careful to only fetch the `validity-url` _after_ the navigation.\r\n\r\nAs @twifkak says, publishers can build a repudiation mechanism using Javascript even if we don't build this into the browser, so the main question is whether we want to build it in by default.\r\n\r\nA goal to be able to repudiate inaccurate content conflicts, although maybe not fatally, with @ericlaw1979's desire to make this work for [Archival](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#archival).\r\n\r\nI agree with @bratell-at-opera that SXGs are more of a risk than just long cache lifetimes, because they can be used maliciously, and if #300 goes toward trusting the SXG over the cache, that's not even persistently fixed by hitting reload, unlike the cache itself.",
          "createdAt": "2019-01-17T23:54:37Z",
          "updatedAt": "2019-01-17T23:54:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fetching the `validity-url` also makes a stolen private key much more discoverable: the attacker either has to be on-path, or their attack gets exposed to the origin server as a fetch to some URL that can include whatever reporting we think is reasonable.",
          "createdAt": "2019-01-18T00:00:10Z",
          "updatedAt": "2019-01-18T00:00:51Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Good points regarding the tension of such validity mechanisms between keeping access to the content secret and making sure the content is still valid.\r\n\r\nFrom the publisher's side:\r\nMaybe it is worthwhile to add a new caching directive (e.g. \"cache-but-validate\") which would tell the UA if it should or shouldn't validate the content from the publisher's perspective. That way, a publisher that knows it provides data which is restricted in some parts of the world will avoid the validation phase, at a risk of persisting typos, and publishers that consider their content not sensitive will turn on validation to get better assurances against persistent typos or mistakes.\r\n\r\nFrom the user's side:\r\nMaybe in some browser modes (e.g. \"Privacy\" or \"incognito\" modes), UAs can ignore above directives and skip validation altogether, as an intervention. (at the risk of serving potentially-invalid content)",
          "createdAt": "2019-01-21T07:40:03Z",
          "updatedAt": "2019-01-21T07:40:03Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Are there other use cases besides supporting censorship and geoblocking? It\nseems developers already have the tools to accomplish that without\nintroducing additional SXG features, so I\u2019m wondering what\u2019s missing?\n",
          "createdAt": "2019-01-21T12:43:15Z",
          "updatedAt": "2019-01-21T12:43:15Z"
        },
        {
          "author": "bratell-at-opera",
          "authorAssociation": "NONE",
          "body": "With SXG I can put on the face of someone else and replay something they have said/published. The problem I'm thinking of isn't the replaying operation (I think it's perfectly fine to archive and show old web pages), but that it will be attributed to the source even if the source has changed their mind. \r\n\r\nThere has been numerous cases from the last few years where an initial news report turned out to be incorrect and was later changed, updated or corrected. As news sources have come under attack from decision makers it has become so much more important that information is up to date. If a decision maker or hostile power can replay a news source' mistakes or early best-effort reporting as \"current reporting\" that can be used to undermine the credibility of reputable news organizations, which is dangerous in so many ways.\r\n\r\nIt might be that this feature would be too dangerous for a news source to use and they should stay away from it, but I don't trust everyone to fully understand the implications of using SXG, especially if it will be heavily promoted and use encouraged by portal sites (like those run by Google and Microsoft).\r\n\r\nMaybe there are ways to handle this scenario that I'm missing but with what I understand it seems like SGX comes packaged with a big foot gun.",
          "createdAt": "2019-01-21T13:00:31Z",
          "updatedAt": "2019-01-21T13:00:31Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "It seems like that threat model is \u201cSomething was published without\nincluding subsequent corrections\u201d - but that use case already seems\naccounted for in the design. That is, as has been pointed out,\n\u201cresponsible\u201d organizations (which seems to be the presumption, given they\nsubsequently issue corrections) can, for example, use JS to ping to see if\nthere have been corrections. This doesn\u2019t seem dissimilar from the same\nroot cause as publishing a vulnerable (e.g. XSS) SXG.\n\nHowever, I think the tension here - between privacy on one hand and having\nthe \u201clatest\u201d edition, and censorship and being able to repudiate SXGs - is\nsomewhat intentional. SXG opts for more privacy and censorship resistance,\nand that admittedly does come with trade offs.\n",
          "createdAt": "2019-01-21T13:06:37Z",
          "updatedAt": "2019-01-21T13:06:37Z"
        },
        {
          "author": "bratell-at-opera",
          "authorAssociation": "NONE",
          "body": "An alternative to not displaying the resource (what you categorize as censorship) would be to stop labeling it with the original source.\r\n\r\nSo instead of \"foonews.com\" it would be \"foonews.com 3 June as per portalsite.com\", but that seems to be opposite of what \"portalsite.com\" wants and I don't really see what UI design would want or allow such a complicated explanation. Or an interstitial \"You are about to visit a revoked page, do you want to load the new version instead?\". Might also not be the choice of a UI designer, but I don't see \"refuse to display the page\" (what you call censorship) as the only way to handle a page a site no longer wants to spread.\r\n\r\nThen if the goal is that only portalsite.com should know who reads the pages (and have it be secret from foonews.com), then maybe portalsite.com can have some kind of proxy for checking whether a page has been revoked. Again, I'm not saying that would be the solution, but that there may be ways to fix the foot gun without losing any features.",
          "createdAt": "2019-01-21T13:38:21Z",
          "updatedAt": "2019-01-21T13:38:21Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I think there\u2019s a first step, which is agreeing whether or not it\nrepresents a problem. We should be very careful in designing functionality\nthat is inherently anti-privacy (functionally, the scheme just reinvented\nonline revocation checking, which most UAs find problematic). We\u2019ve also\nidentified multiple alternatives that don\u2019t require a new primitive and\nachieve the same result. The argument for the new primitive seems to be\nthat it will be a \u201cfoot gun\u201d unless it can be actively blocked at will, and\nI\u2019m not sure that\u2019s a shared perspective. Have I missed why the multiple\noptions publishers have, including not publishing an SXG, aren\u2019t sufficient?\n",
          "createdAt": "2019-01-21T13:44:23Z",
          "updatedAt": "2019-01-21T13:44:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "* I like the idea of including the signing date in the UI somewhere. I'm not sure it will fit, but we should ask our UI folks. Given the signing date, maybe with an oldness threshold defined by the publisher, I don't think there's any need to also list the distributor.\r\n* \"some kind of proxy for checking whether a page has been revoked\" is exactly the validity-url. It merely gives you a fresher signing timestamp, not TLS's full liveness property.",
          "createdAt": "2019-01-21T15:44:23Z",
          "updatedAt": "2019-01-21T15:44:23Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "> If a decision maker or hostile power can replay a news source' mistakes or early best-effort reporting as \"current reporting\" that can be used to undermine the credibility of reputable news organizations, which is dangerous in so many ways. \u2014 @bratell-at-opera \r\n\r\nTo build on this thought a little bit: in a part of the world where all of foonews.com traffic is routed through a central point, SXG gives portalsite.com the ability to selectively downgrade part of foonews.com without disrupting access to the rest of it. So /sport might be downgraded, but /weather stays fresh. Since some pages are fresh, users may not notice that /sport is actually outdated.\r\n\r\n(This \"attack\" is most effective if the CDN delivers SXG in which all links go back to the CDN itself (not the origin), but the CDN could require this for performance or availability reasons.)\r\n\r\nWithout SXG, a central point cannot disrupt access to a part of foonews.com--it can only block all of it, since it can't see what's being requested, or the content of individual URLs. (Similarly, portalsite.com could provide access to all of foonews.com with the exception of all articles that mention \"bananas\", which get a 404.)\r\n\r\n> It might be that this feature would be too dangerous for a news source to use and they should stay away from it but I don't trust everyone to fully understand the implications of using SXG\u2026\r\n\r\nCautious origins will probably need to either not publish SXGs, or only publish to CDNs it trusts. Allowing any CDN to cache content seems risky (even though allowing anyone to copy content is usually a helpful anti-censorship technique).",
          "createdAt": "2019-01-22T22:43:22Z",
          "updatedAt": "2019-01-22T22:43:22Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@ithinkihaveacat Note that there's no way for the CDN to deliver an SXG such that all links go back to the CDN itself. Even after bundling ships, the CDN would have to convince users to manually fetch content via the CDN, perhaps by blocking direct connections.",
          "createdAt": "2019-01-22T23:02:40Z",
          "updatedAt": "2019-01-22T23:02:40Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin There's not? I was thinking it would be possible, though via the mechanism of CDN policy, rather than a technical fix. e.g. a CDN will only cache content if all sub-resources are delivered from the CDN, and all links go back to the CDN. This would be faster for users, but would also lead users to think they're navigating around https://foonews.com, when they're actually on  https://portalsite.com/s/foonews.com.",
          "createdAt": "2019-01-22T23:34:36Z",
          "updatedAt": "2019-01-22T23:34:36Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "The WebKit team has similar concerns.\r\nAlways getting back to the publisher to validate that the content is still valid seems a good approach in the context of a browser.\r\nThis validation should not require any user credentials, which is an improvement over navigating to the publisher. If user is wary of doing such validation directly, user can ask its browser to do it through means like trusted third-party, Tor...",
          "createdAt": "2019-01-29T23:57:32Z",
          "updatedAt": "2019-01-29T23:57:32Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems that there is no definitely correct behavior for this. There is a significant amount of users who would prefer one behavior over the other to fulfill their needs (e.g. stronger privacy). \r\n\r\nThis suggests that:\r\n - It'd be best resolved through a user preference or equivalent.\r\n - Different browser vendors may have different opinions about what constitutes a good default.\r\n - The default value could be the same for all users or could be segmented, i.e. markets where surveillance is a significant user concern vs. not.\r\n\r\n(edit: I removed the reference to Issue 388 since the root concern is still being explored).",
          "createdAt": "2019-01-31T00:00:38Z",
          "updatedAt": "2019-01-31T00:37:42Z"
        },
        {
          "author": "wimleers",
          "authorAssociation": "NONE",
          "body": "Yesterday, it was announced that Google Chrome will be shipping this: https://webmasters.googleblog.com/2019/04/instant-loading-amp-pages-from-your-own.html. AFAICT this has not yet been addressed.\r\n\r\nOn the same day, Cloudflare announced support for Signed Exchanges: https://blog.cloudflare.com/announcing-amp-real-url/.",
          "createdAt": "2019-04-17T11:26:10Z",
          "updatedAt": "2019-04-17T11:26:10Z"
        }
      ]
    },
    {
      "number": 378,
      "id": "MDU6SXNzdWU0MDA5MjUwNDc=",
      "title": "Limit CanSignHttpExchange certificate lifetimes",
      "url": "https://github.com/WICG/webpackage/issues/378",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In [the blink-dev Intent-to-Ship thread](https://groups.google.com/a/chromium.org/d/msg/blink-dev/gPH_BcOBEtc/WXRzifVlDQAJ), @agwa suggests \r\n\r\n> It may also be a good idea to limit the lifetime of certificates used in SXG, to reduce the amount of time that an illegitimate certificate can be used, in case an attacker exploits a CA vulnerability to obtain future-dated good OCSP responses.\r\n\r\n* @agwa [suggests 7-14 days](https://groups.google.com/a/chromium.org/d/msg/blink-dev/gPH_BcOBEtc/eL5q1f-rDQAJ).\r\n* @clintwilson says [\"Something around 7-10 days would be a nice target IMO, but even restricting to 30-90 days would be a substantial improvement.\"](https://groups.google.com/a/chromium.org/d/msg/blink-dev/gPH_BcOBEtc/mfxmsbZ3DQAJ)\r\n* If we go to 7 days, we can probably get rid of any mention of OCSP responses. What's the longest certificate lifetime where folks would be comfortable dropping our requirement for OCSP stapling?\r\n* A very-short lifetime will be a problem if a CA has to temporarily disable issuance, for example after security weaknesses in certain domain validation methods are discovered. \r\n* Even a 90-day limit probably requires automated certificate rotation, a'la ACME. Shorter certainly does.\r\n* Should we say anything about re-using an old public key in a new certificate?\r\n\r\nThese requirements may well wind up in the [BRs](https://cabforum.org/baseline-requirements-documents/) instead of this repository's specs, but this issue will track getting them where they need to go.",
      "createdAt": "2019-01-18T23:17:47Z",
      "updatedAt": "2019-02-08T19:52:19Z",
      "closedAt": "2019-02-08T19:52:19Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We talked to @grittygrease from Cloudflare about shorter lifetimes. My (fallible) notes are:\r\n* 90-day lifetimes seem ok; anything shorter would require some code changes.\r\n* 7-day lifetimes would multiply the number of certificates they need to handle enough that current designs might not scale.\r\n* 7-day lifetime would limit uptime. In practice they see longer downtime periods for certificate issuance than OCSP.\r\n* Clock skew is an issue, but SXG's requirement for stapled OCSP responses hits those issues anyway.\r\n* Reusing key material across successive certificates doesn't help with any of the important problems.\r\n* 7-day certificates could make CT logs significantly bigger, which could hurt that ecosystem.\r\n* Future-dated OCSP responses seem like they should be forbidden by [BR](https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.2.pdf) 4.9.9 (\"OCSP responses MUST conform to RFC6960 and/or RFC5019.\") and those RFCs saying [\"The time at which the status was known to be correct SHALL be reflected in the thisUpdate field of the response.\"](https://tools.ietf.org/html/rfc6960#section-2.5) and [\"When pre-producing OCSPResponse messages, the responder MUST set the thisUpdate, nextUpdate, and producedAt times as follows: thisUpdate: The time at which the status being indicated is known to be correct.\"](https://tools.ietf.org/html/rfc5019#section-2.2.4), respectively. Thus, not too excited about shortening lifetimes past 90 days.\r\n\r\n",
          "createdAt": "2019-01-23T23:46:09Z",
          "updatedAt": "2019-01-23T23:46:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@clintwilson asked in #383 that we have \"some very rough consensus on max validity\" before we codify a particular limit.\r\n\r\n* Given Cloudflare's points, it seems like 7-day validities definitely won't work with the current state of the ecosystem.\r\n* 14-day probably has similar problems.\r\n* Anything longer than that still needs stapled OCSP responses, so doesn't help us simplify the format or parsing.\r\n* @sleevi mentioned somewhere that a 30-day max-validity was about the longest that would help mitigate future-dated OCSP responses (for CAs that don't believe they're already forbidden by the BRs).\r\n* A 60- or 90-day maximum still has the following benefits:\r\n  * Improves ecosystem agility by setting the upper-bound on how long it takes to roll out changes to certificate-related things.\r\n  * Bounds validation risks: if a validation method (e.g. [BR](https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.2.pdf) 3.2.2.4.1) or process (e.g. lack of a CAA record) isn't secure enough, then the lifetime is the upper-bound for the 'not secure' certificates, which could let us leave SXGs up while those certs expire.\r\n  * Bounds the length of time an undetected compromised key can be used.\r\n* @shigeki for Yahoo! Japan is worried about the viability of even a 90-day limit for their processes and the certificate reseller they use.\r\n\r\nThe max-validity is not intended to handle CA compromise like DigiNotar as suggested in https://github.com/WICG/webpackage/pull/383#issuecomment-457971640, since for that browsers would revoke the affected root.\r\n\r\nSo, let's see if we can find rough agreement on a max-validity that we expect to hold until at least January 2020. This could change early if a significant issue comes up or if Mozilla or Safari demand a particular max-validity in order to support the specification, but we won't expect to change it early.\r\n\r\nI'd like to pick 90 days because LetsEncrypt has shown it can work for lots of server operators, and I don't know of a similar proof of concept for shorter validity periods.\r\n\r\nI'm going to run a poll by posting 30-, 60-, and 90-day limits as Github comments. Use the :+1: reaction on an option if you're pretty sure it'll work for the ecosystem, and :-1: if you're pretty sure it won't, and feel free to write a longer answer as a comment. Thanks!",
          "createdAt": "2019-02-01T19:02:36Z",
          "updatedAt": "2019-02-01T19:11:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Bound the maximum Validity Period at 30 days.",
          "createdAt": "2019-02-01T19:03:01Z",
          "updatedAt": "2019-02-01T19:03:01Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Bound the maximum Validity Period at 60 days.",
          "createdAt": "2019-02-01T19:03:05Z",
          "updatedAt": "2019-02-01T19:03:05Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Bound the maximum Validity Period at 90 days.",
          "createdAt": "2019-02-01T19:03:10Z",
          "updatedAt": "2019-02-01T19:03:10Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I don't see any objections to 90 days, so I'll merge that as the limit, and will resist calls to change it again until next year.",
          "createdAt": "2019-02-08T19:20:37Z",
          "updatedAt": "2019-02-08T19:20:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #383, although folks should feel free to re-open this question in 2020.",
          "createdAt": "2019-02-08T19:52:18Z",
          "updatedAt": "2019-02-08T19:52:18Z"
        }
      ]
    },
    {
      "number": 387,
      "id": "MDU6SXNzdWU0MDQ1NDA5MTk=",
      "title": "Can SXG be used to track users?",
      "url": "https://github.com/WICG/webpackage/issues/387",
      "state": "OPEN",
      "author": "youennf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Scenario is the following:\r\n- User A goes to site S and gets a SXG\r\n- User A shares the SXG to user B\r\n- User B loads the SXG\r\n- Site S learns that there is a connection between user A and user B.\r\n\r\nOverall, SXG seems to ask publishers to use SXG so that content is not user-specific.\r\nBut there is currently no way for users to ensure that this is the case.\r\n\r\nOne possible solution is some kind of SXG transparency, as added https://github.com/WICG/webpackage/pull/381.\r\nIt is not clear whether that will scale though.\r\n\r\nAnother possibility is to get such a proof from the server itself.\r\nA specific credential less request from user B to the signed URL or to an URL generated from it by the client could do the trick. Liveness check could also piggy back on such a request.",
      "createdAt": "2019-01-29T23:59:33Z",
      "updatedAt": "2019-01-30T19:32:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Is there perhaps a bug in your description of the issue?\r\n\r\nThat is, does User B share with User A, or does User A share with user B?\r\n\r\nIt's not clear how the proof fetching would resolve this:\r\n* User A goes to site S and gets a SXG\r\n* User A[?] shares the SXG to user B[?]\r\n* User B loads the SXG\r\n* User B checks with the Origin X that the SXG is valid\r\n* [Origin X learns that there is a connection between User A and User B]\r\n* [Site S seems to still learn there's a connection between User A and User B]\r\n\r\nIt's not clear how the privacy issue is resolved by any supplementary requests from User B?",
          "createdAt": "2019-01-30T00:04:59Z",
          "updatedAt": "2019-01-30T00:04:59Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> Is there perhaps a bug in your description of the issue?\r\n\r\nCorrected, thanks!\r\n\r\n> That is, does User B share with User A, or does User A share with user B?\r\n\r\nUser A shares with user B indeed.\r\n\r\n> It's not clear how the privacy issue is resolved by any supplementary requests from User B?\r\n\r\nThe issue is how user B can make sure that the content provided by user A does not contain any info specific to user A.\r\n",
          "createdAt": "2019-01-30T00:07:24Z",
          "updatedAt": "2019-01-30T00:07:24Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@youennf Sorry for being dense, but could you more concretely expand \"user info\"?\r\n\r\nFor example, if the URL itself was distinguishing (for example, `example.com/article/share/some_random_id`), it seems that the information disclosure is possible.\r\n\r\nAlso, I may have been unclear whether Site S is the physical location/distributor of the SXG, or the logical location embodied/server reflected by the SXG. I didn't help with that, as I assumed \"Site S\" was the distributor (`cdn.example`) serving an SXG for Origin X (`example.com`). If the SXG is for `example.com/article/share/some_random_id`, then any liveness check seems like it would reveal a relationship between User A and User B to `example.com`. Similarly, if the \"unique\" SXG was served per-CDN, then `example.com` would also learn that the user was visiting `cdn.example` when User A performed their liveness check.\r\n\r\nHave I missed something in the analysis?",
          "createdAt": "2019-01-30T00:12:49Z",
          "updatedAt": "2019-01-30T00:12:49Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> @youennf Sorry for being dense, but could you more concretely expand \"user info\"?\r\n\r\nA random ID identifying the user. Or advertisements specific to the user.\r\n\r\n> For example, if the URL itself was distinguishing (for example, `example.com/article/share/some_random_id`), it seems that the information disclosure is possible.\r\n\r\nThis is the existing behavior and SXG does not make this worse if this info is in the URL.\r\nURLs are something very visible, and easy to process or analyze. Browsers can for instance act on them. Acting on content is much harder.\r\n\r\nA different way of seeing this issue is if user A shares an article containing some targeted adds.\r\nSharing the URL usually does not mean sharing the targeted adds.\r\nSXG might mean sharing the targeted adds.\r\nThe spec is pushing against that practice, having a way to actually enforce it seems good.\r\n\r\n> Also, I may have been unclear whether Site S is the physical location/distributor of the SXG, or the logical location embodied/server reflected by the SXG.\r\n\r\nI was thinking of S as example.com",
          "createdAt": "2019-01-30T00:51:16Z",
          "updatedAt": "2019-01-30T00:51:16Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Hope it's okay to comment here. Just wanted to mention the current AMP SXG implementation, in case some of that can inform the spec at all.\r\n\r\nIIUC, in the current implementation, a few things prevent this from happening without User A's cooperation:\r\n 1. amppackager fetches content from its backend server anonymously\r\n 2. amppackager only responds SXG if the [`AMP-Cache-Transform` request header](https://github.com/ampproject/amphtml/blob/master/spec/amp-cache-transform.md) is present, which typical UAs won't include\r\n 3. Chromium provides no UI for downloading or sharing an SXG that it has loaded (maybe DevTools? otherwise `curl`)\r\n 4. Chromium does not load SXGs on `file:`.\r\n\r\n(1) is unverifiable from User A's perspective, and (1) and (2) may not be true of all SXG servers. However, (3) and (4) are a function of the UA, and require that User A go out of their way to download and share.\r\n\r\nHowever, future UAs may add a share UI. Perhaps, then, the request of proof should occur at share-time, and not receive-time (addressing @sleevi's concern about the liveness check leaking the relationship). But then I'm not sure how such a request could be sufficiently anonymized (otherwise the server would just lie when generating its proof). Perhaps something akin to certificate transparency? But that likely has other problems.",
          "createdAt": "2019-01-30T02:09:08Z",
          "updatedAt": "2019-01-30T03:15:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've expanded the Watermarking section in #381 based on the discussion here.\r\n\r\nUser B's ability to check for watermarking via the validity-url is limited by the fact that we want a publisher to be able to keep old versions live when the changes aren't important. Otherwise, folks might be forced to stop using an app, or spend lots of expensive bytes, when they don't need to.\r\n\r\nHowever, to the extent that we think URLs are sufficiently analyzable by the browser (which I'm skeptical of, but https://github.com/WICG/webpackage/issues/387#issuecomment-458767722 endorses), maybe the browser can analyze the validity-url instead of just the request URL.",
          "createdAt": "2019-01-30T19:32:51Z",
          "updatedAt": "2019-01-30T19:32:51Z"
        }
      ]
    },
    {
      "number": 388,
      "id": "MDU6SXNzdWU0MDQ1NDE5OTY=",
      "title": "Should a SXG document be considered SecureContext or not?",
      "url": "https://github.com/WICG/webpackage/issues/388",
      "state": "OPEN",
      "author": "youennf",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Say that liveness checks as described in https://github.com/WICG/webpackage/issues/376 are implemented and passing for a given SXG. It seems that the current document could be granted SecureContext.\r\n\r\nLet's say that liveness checks are not passing.\r\nIt seems that the level of security is not as high, which would mean that SecureContext should not be granted. Such variation may actually break content so it might be better to not render content to the user, and render the content fetched from the actual web site instead.\r\n\r\nA consequence is that while the liveness checks can be done in parallel to processing of the SXG (subresource loading, parsing...), the liveness checks should be validated before the first page rendering and any JavaScript execution.\r\n\r\nFor privacy/security purposes, even subresource loading should probably be postponed until these checks are done.",
      "createdAt": "2019-01-30T00:03:37Z",
      "updatedAt": "2019-04-09T12:15:54Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Could you explain why you don't believe that the level of security is as high? What are the properties that you think aren't met?",
          "createdAt": "2019-01-30T00:06:34Z",
          "updatedAt": "2019-01-30T00:06:34Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "As discussed in https://github.com/WICG/webpackage/issues/376, if there is a buggy SXG, chances are high that attackers will use it as much as possible.\r\nChances to get buggy SXG content is therefore bigger if you do get the SXG from somebody else than the publisher.\r\nThe liveness checks hopefully make the level of security on par.",
          "createdAt": "2019-01-30T00:13:42Z",
          "updatedAt": "2019-01-30T00:13:42Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Thanks! I was expecting you to say something about the key protection (which is similar to TLS session resumption, delegated credentials, secondary certs, and a host of other network-level things which may be invisible to the client), so that's a very different direction!\r\n\r\nWould this same logic apply to resources a client caches on disk, unrelated to SXG? That is, I'm trying to unpack what the property is that the HTTP disk cache provides (as we seen to be comfortable with SecureContext), but that SXGs do not.\r\n\r\nSimilarly, I'm trying to understand a bit more about where \"SecureContext\" is reflective of the integrity of the transport to when it becomes about the 'security' of the content. For example, whether we'd deny SecureContext for certain CSP policies. I had always imagined SecureContext to be about the transport-level security properties and integrity.",
          "createdAt": "2019-01-30T00:19:10Z",
          "updatedAt": "2019-01-30T00:19:10Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> Would this same logic apply to resources a client caches on disk, unrelated to SXG? That is, I'm trying to unpack what the property is that the HTTP disk cache provides (as we seen to be comfortable with SecureContext), but that SXGs do not.\r\n\r\nI think there is a difference between the two.\r\nA buggy HTTP disk cache entry is under the control of the client and the content publisher, the buggy SXG entry is not under the control of the content publisher.",
          "createdAt": "2019-01-30T00:53:15Z",
          "updatedAt": "2019-01-30T00:53:15Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "A cache entry isn\u2019t necessarily under the control of the publisher, is it?\nEspecially once the buggy entry is cached, only a Clear-Site-Data activity\nwould flush it, correct? Or is there some other element of control?\n\nI\u2019m trying to understand this concern more by trying to map to the world we\nhave, because I\u2019m not sure it\u2019s clear the property that is both missing and\ncritical enough to SecureContext to deny it for SXG, when we have much\nstronger signals of origin authenticity than TLS itself.\n\nFor example, in the world we have, we allow a site served over TLS to be\ntreated as SecureContext, even though it may have been served by a stale\nCDN that doesn\u2019t support Flushing. A site that \u201ccould\u201d flush their CDN, but\ndoesn\u2019t, doesn\u2019t seem fundamentally different from an SXG that \u201ccould\u201d have\na JS flush check, but doesn\u2019t. Should we deny SecureContext to known CDN\nASes, since we don\u2019t know whether the content is fresh?\n\nUnderstandably, there\u2019s a tradeoff for the priority of the constituencies,\nbut it\u2019s not clear why the freshness would impact SecureContext, or where\nthat threshold is.\n\nAlternatively, it may be that \u201cfreshness\u201d isn\u2019t the essential property, but\n\u201cvoluntary distribution agreement,\u201d since only CDNs with a private key\nassociates with that domain can serve that content. If that\u2019s the case, it\nseems alternative designs may exist to address the \u201crelationship\u201d property.\n",
          "createdAt": "2019-01-30T01:32:33Z",
          "updatedAt": "2019-01-30T01:32:33Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> only CDNs with a private key associates with that domain can serve that content\r\n\r\nRight, in such a case, there is a clear understanding that both parties are working together.\r\nProbably there are contracts between them, mechanisms for hot fixes...\r\n\r\nWith SXG, anybody can distribute the content.\r\nThe spec can probably add a way for a content provider to 'whitelist' some distributors so that these liveness checks be made optional for these 'trusted' distributors. I am not sure we should go there.",
          "createdAt": "2019-01-30T19:35:03Z",
          "updatedAt": "2019-01-30T19:35:03Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@youennf Thanks! I'm wanting to make sure I've got the problem well-framed enough to explore solutions. I mention this, because a liveness check is so critically disruptive to the privacy and performance properties of SXG that it seems like it would be a significant step back for a number of use cases.\r\n\r\nIt sounds like your primary concern is around \"A bug could be introduced in the content shipped in an SXG\", is that a fair (although grossly oversimplified) summary? If it is, could you help me unpack a bit more the type of \"bugs\" that would be concerning? Naively, I would get the impression that this is only concerned about scriptable content, but perhaps it's being seen to generalized to other types; for example, would an SXG of a CSS file be problematic? What about for a PNG file?\r\n\r\nThe concern - of a bug - sounds very different than the properties that SecureContext is meant to assert or guarantee. The client doesn't know about the relationship between the CDN and the Origin, for example, so at best, it merely seems to be an assumption that bugs \"could\" be fixed, not necessarily that they're prevented, purged, or otherwise managed. Given that SXGs (for scriptable content) have the ability to hotfix 'bugs', it seems similar to the status quo.\r\n\r\nI think it might be useful to compare with OCSP for checking certificate revocation. No UA has ever denied SecureContext or deferred processing content if an OCSP check does not succeed, which is (effectively) a \"liveness check\" for the TLS certificate. The closest that we got was Opera rendering the content, but degrading the UI, but they moved away from that. A liveness check for SXG would seem functionally identical to an OCSP request. Is there some property different for SXGs and TLS certs worth also capturing here?",
          "createdAt": "2019-01-30T19:55:53Z",
          "updatedAt": "2019-01-30T19:55:53Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "1. I'm curious about the distinction @youennf's making between liveness checks on signed exchanges (which he wants) vs liveness checks on certificate validity via OCSP (which @sleevi's saying Safari doesn't do). Is the important distinction that we trust people to protect their keys better than they avoid writing XSS bugs, or something else?\r\n2. The discussion of \"[SecureContext](https://w3c.github.io/webappsec-secure-contexts/#secure-contexts)\" would make more sense to me if it talked about whether signed exchanges should be considered same-origin with the same content retrieved over TLS. For example, an XSS exploit is likely to do more damage by leaking `localStorage` or `IndexedDB` information than by calling one of the [many fewer SecureContext APIs](https://cs.chromium.org/search/?q=SecureContext+lang:idl+-file:test&sq=package:chromium&type=cs). `[SecureContext]` APIs also often involve a permission prompt, and it'd be more plausible to delay those until we've fetched validity information, than to delay rendering or access to localStorage. So, did you mean to only talk about SecureContext, or to address the Origin of the signed content as a whole?",
          "createdAt": "2019-02-04T22:48:34Z",
          "updatedAt": "2019-02-04T22:48:34Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> for example, would an SXG of a CSS file be problematic? What about for a PNG file?\r\n\r\nI am mostly concerned about navigation loads. Once you have a document, other mechanisms like SRI can be used if need be.\r\n\r\n> 1. I'm curious about the distinction @youennf's making between liveness checks on signed exchanges (which he wants) vs liveness checks on certificate validity via OCSP (which @sleevi's saying Safari doesn't do)\r\n\r\nIIUIC, there were performance issues that make things difficult with OCSP checks.\r\nLiveness checks though are targeting the content author web site.\r\nThis web site has an incentive to deliver the content fast.\r\nChances are high that liveness checks will be fast as well.\r\n\r\n> 2\\. The discussion of \"[SecureContext](https://w3c.github.io/webappsec-secure-contexts/#secure-contexts)\" would make more sense to me if it talked about whether signed exchanges should be considered same-origin\r\n\r\nIn the case where signed exchanges are fetched same-origin, this is business as usual, probably no need for additional checks.\r\nWhen they are fetched from a cross-origin distributor, it seems the goal is that the generated document will have the origin of the content author, not the distributor origin.\r\n\r\n> 2\\. [many fewer SecureContext APIs](https://cs.chromium.org/search/?q=SecureContext+lang:idl+-file:test&sq=package:chromium&type=cs).\r\n\r\nConsequences with APIs like payment API might be bad.\r\nDitto for getUserMedia: for some websites, the user might not be prompted at all. Or microphone output is sent to someone unauthorized during a call.\r\n\r\n> 2\\. it'd be more plausible to delay those until we've fetched validity information, than to delay rendering or access to localStorage.\r\n\r\nThat might be feasible for some APIs but would add quite a bit of complexity.\r\nFor other APIs, like service worker, that seems pretty difficult.\r\n\r\n> a liveness check is so critically disruptive to the privacy and performance properties of SXG that it seems like it would be a significant step back for a number of use cases.\r\n\r\nThat is something that would be good to better understand. Maybe the use cases require different solutions or complementary solutions.\r\nI agree performance is important but there might be tradeoff with security, HTTPS is slower than HTTP for instance. Safari is implementing cache partitioning which has a theoretical perf hit.\r\nAs of privacy, if a page gets loaded, it will be easy for this page to trigger a load to its server so as to identify the user. Of course, there could be workarounds, like disabling the possibility for such pages to do any networking, but that might prevent any opportunity for the web page to implement hot fixes.\r\n\r\n\r\n",
          "createdAt": "2019-02-05T16:56:04Z",
          "updatedAt": "2019-02-05T16:56:04Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> I am mostly concerned about navigation loads. Once you have a document, other mechanisms like SRI can be used if need be.\r\n\r\nSorry, now I'm even more confused, in trying to understand the principle or goal you're trying to capture from not treating as `SecureContext`.\r\n\r\nIf it was about the transport properties, such as TLS, as it's used today, it would seem like it would matter equally regardless of content. You mentioned being concerned about bugs in the content, which seem possible there as well.\r\n\r\nHowever, the later parts of your reply leave me wondering whether the goal is to restrict access to certain APIs, and using `SecureContext` as a way of avoiding enumerating them individually / playing whack a mole. Going back to the original remarks, you mentioned that [it seems that the level of security is not as high](https://github.com/WICG/webpackage/issues/388#issue-404541996), but I'm not sure we've quite nailed down what that property is.\r\n\r\n> This web site has an incentive to deliver the content fast.\r\n\r\nI don't think the data supports this conclusion, as practiced today. But I also have concern that it's a bit at odds with the goals of improving distribution for Web developers and for users in emerging markets.\r\n\r\n> HTTPS is slower than HTTP for instance\r\n\r\nWhile not the issue for this, it would be useful if data could be shared on that. In many cases, we've seen HTTPS faster for users; whether through enabling new protocols (H/2 or QUIC) or through avoiding network (mis)management.\r\n\r\n> As of privacy, if a page gets loaded, it will be easy for this page to trigger a load to its server so as to identify the use\r\n\r\nI fear that may be overlooking significant use cases. I think one which we've heard from a number of developers is the idea to effectively prefetch or preload content in the background, to enable quick and efficient rendering. Using prefetch or preload, as they are today, reveals the user, just as much as liveness checks would. If this was aggregated across several domains, the act of that prefetching may reveal information about the content the user is viewing on the Distributor - for example, observing liveness fetches to `a.example`, `b.example`, and `c.example` may indicate you're viewing content related to those three domains.\r\n\r\nSpecifying a liveness check would introduce that same privacy risk, making it unlikely for Distributors to serve that content (versus, say, self-hosting it, as some may do today). Even restricting `SecureContext` can have impact - for example, in causing loads to be treated as mixed content and blocked (in the `Distributor` case) or allowing features that should be blocked (e.g. HTTP loads or WS).\r\n\r\nThis is why I'm so keen to understand those security properties we're talking about, and how we quantify them, in order to see if there are alternative, less disruptive solutions, which both help developers and help keep the platform consistent.",
          "createdAt": "2019-02-05T17:23:22Z",
          "updatedAt": "2019-02-05T17:23:22Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "> it'd be more plausible to delay those until we've fetched validity information, than to delay rendering or access to localStorage.\r\n\r\nFwiw I do like to avoid this too unless we find it'd be really the only desirable path. As far as I know (at least in most cases) security state is determined upon navigation / document creation, introducing a new intermediate state between non-SecureContext and SecureContext and allowing transition between them seems to open up another complex problem space, possibly too complex. I agree with @sleevi that we should nail down the security properties first. I also agree that the primary concern, i.e. bugs. seems something different from the property that SecurityContext is meant to guarantee.  Let me also /cc @mikewest reg: SecureContext",
          "createdAt": "2019-02-07T02:48:59Z",
          "updatedAt": "2019-02-07T02:48:59Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "> > HTTPS is slower than HTTP for instance\r\n> \r\n> While not the issue for this, it would be useful if data could be shared on that. In many cases, we've seen HTTPS faster for users; whether through enabling new protocols (H/2 or QUIC) or through avoiding network (mis)management.\r\n\r\nSure, the point is that HTTPS initial objective was probably to be right in terms of security as well as reasonably efficient. Follow-up efforts made it even better. \r\nI would tend to do the same here.\r\n\r\n> you mentioned that [it seems that the level of security is not as high](https://github.com/WICG/webpackage/issues/388#issue-404541996), but I'm not sure we've quite nailed down what that property is.\r\n\r\nLet's have a try.\r\n\r\nA website has a security issue related to a particular resource. The web site is using things like proxy-revalidate to only need to care about client caches.\r\nThe web site decides to wipe client caches conditionally on some client-side cookie parameter.\r\nThe client loads a web page, the server checks the cookie and includes in the response a Clear-Site-Data HTTP response header to wipe out the whole client cache. The web site also updates the client cookie. If needed, the page also does a ping to the server to trigger Clear-Site-Data/page reload.\r\n\r\nIn a world without signed content, this might be good enough.\r\nIn a world with signed content, this might be broken.\r\n\r\nAfter the client cache is empty, an attacker makes the client download a signed content of the faulty resource. The ping to the server will not trigger any cache data clearing/reload.\r\n\r\nAccording https://wicg.github.io/webpackage/loading.html, the signed content is not added to the HTTP cache (as some kind of a protection?). Let's say now the above web site is using service worker and Cache API. The faulty resource will be stored opportunistically by the service worker (its cache was cleared) and will poison the web site persistently.\r\n\r\n> I also agree that the primary concern, i.e. bugs. seems something different from the property that SecurityContext is meant to guarantee\r\n\r\nSecureContext is about the trust you can have in a given document.\r\nAs stated above, the spec does not seem to have enough trust in signed contents to update the HTTP cache with it.\r\n\r\nWe can also look at the HTTPS state of the resource.\r\nIn the case a liveness check is done and succeeds, should the HTTPS state of the signed exchange be set to the HTTPS state of the liveness check? I would tend to say yes.\r\nIn the case a liveness check is not done or fails for some networking reason, what should be the HTTPS state of the signed exchange? IIUIC, the spec says to use the HTTPS state of the signed content load. This seems ok if the provider and distributor are using the same connection. I am not sure this is ok if the provider and distributor do not share the same connection.\r\n\r\nLet's say a content provider web site has a bad TLS setup.\r\nFor the sake of argument, the user agent will set the HTTPS state to deprecated for any load to the content provider server. User agent will set the HTTPS state to modern for any load made to the distributor server.\r\nIn a world without liveness checks, the user agent will initially load from the signed content and will set the document as secure. When reloading the page, the user agent will go to the content provider and make the document insecure.\r\nIn a world with liveness checks, the user agent offers a consistent behavior before and after reload.\r\n\r\n> Specifying a liveness check would introduce that same privacy risk, making it unlikely for Distributors to serve that content (versus, say, self-hosting it, as some may do today).\r\n\r\nNote that self-hosting also causes some privacy issues since the distributor might know all the newspaper articles a user is reading, and not only the first one if user is navigating to the content provider.\r\n\r\nAgreed on the principle that the privacy implications need to be cautiously evaluated.\r\nPrefetch/preload/liveness check should probably all be without credential.\r\nIf the liveness check is done at load/navigation time, there is nothing lost compared to regular loads in terms of privacy.\r\n\r\nSome flexibility can also be left to user agents in the way they implement liveness checks.\r\nA user agent may preconnect to the provider web site as soon as possible. If done at navigation time, Service Worker may come to the rescue.  Bundling might be also something that could be used to mutualize the liveness checks. Another user agent may send the liveness check earlier, based on some user specific knowledge or interaction heuristics.",
          "createdAt": "2019-02-08T18:44:30Z",
          "updatedAt": "2019-02-08T18:44:30Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> According https://wicg.github.io/webpackage/loading.html, the signed content is not added to the HTTP cache (as some kind of a protection?)\r\n\r\nThe reasoning for this isn't a security protection, it's about the privacy aspects. Those privacy aspects may be addressed/addressable in the context of double-keyed caches; however, since such work is not normatively specified right now, and there are UAs that don't double key, we took an approach to maximize privacy (in many of the design elements)\r\n\r\nThis same focus on privacy is why liveness checks are deeply concerning; as shown with OCSP, liveness checks fundamentally harm efforts to protect user privacy. The design goal has been to try to ensure that SXG not only does not introduce any privacy issues from the status quo, but to also take opportunities to improve it, where they exist.\r\n\r\n@jyasskin Would it make sense to capture this in the draft privacy considerations or as an explainer, perhaps? Namely, to capture some of the explicit design goals for (privacy and security) that contributed to the current design? It doesn't quite feel right in the spec, but it seems like it'd be useful context for folks reading to understand \"Why X, not Y?\"\r\n\r\n> Note that self-hosting also causes some privacy issues since the distributor might know all the newspaper articles a user is reading, and not only the first one if user is navigating to the content provider.\r\n\r\nCan you please explain how this would be? This only seems like it would be possible if the Publisher actively collaborated with the Distributor, by providing Distributor-specific SXGs in which all outbound links (e.g. to other articles of the Publisher) instead explicitly specify Distributor SXGs. In such an 'active collaboration' model, it's unclear whether this is a change from the status quo - the Publisher could do this via Pings or back channels, right?\r\n\r\n> Prefetch/preload/liveness check should probably all be without credential.\r\n\r\nI suspect we may have differing understandings of the processing model for SXGs as proposed, and the privacy properties we're trying to achieve.\r\n\r\nIt sounds as if your focus is on UA-provided information to the Distributor, such as credentials or other headers. However, a big concern on our end has been both the Publisher learning about the Distributor, and those on the network learning about activities on the Distributor.\r\n\r\nThe problem with liveness checks is that they undermine privacy in ways similar to XS-Search, even in a credential-less fetch. For example, consider if `distributor.example/page1` were to preload `publisher-1.example/`, `publisher-2.example/`, `publisher-3.example/`, while `distributor.example/page2` were to preload `publisher-a.example/`, `publisher-b.example/`, and `publisher-c.example`.\r\n\r\nWith a liveness check, credentialed or not, a network observer would be able to determine whether or not a user is on `distributor.example/page1` vs `distributor.example/page2` by observing whether or not requests were made to `publisher-1.example` vs `publisher-a.example`.\r\n\r\nSimilarly, on the publisher side, a publisher that received a liveness check to `publisher-1.example` would be able to know - at the time of preload/prefetch - that the user was was looking at `distributor.example/page1` if they knew about that association.\r\n\r\nAs we've seen across the Web ecosystem, privacy-conscious distributors are concerned about these sorts of side-channels - to both network observers and to less privacy-conscious publishers - and so take steps, such as rehosting content same-origin to prevent these sorts of side channels. SXGs are a means of achieving those privacy-preserving properties, while allowing meaningful and accurate attribution to users.\r\n\r\nHopefully this captures more clearly why liveness checks are fundamentally hostile to user privacy, and why they've been an important design consideration throughout. One would expect that the first steps a privacy-conscious browser or extension would take would be to disable them (or disable SXGs), both of which would then result in even worse consequences for the ecosystem, especially around privacy and authenticity of content.\r\n\r\nI'm hoping we can find alternative solutions that achieve that same goal, which is a critical use case here.\r\n\r\n> SecureContext is about the trust you can have in a given document.\r\n\r\nWe've tried very carefully to avoid overloaded terms like 'trust', which can mean varying things for recipients. In the context of the objectives that the [SecureContexts spec](https://w3c.github.io/webappsec-secure-contexts/) sets out, our view has been that it affords an appropriate level of confidentiality, integrity, and authenticity. Much of the threat model and considerations address this in the context of whether or not an origin has been authenticated.\r\n\r\nAs it relates to SXGs, I hope we've got agreement that the integrity and authenticity properties have been sufficiently maintained and are equivalent to that of TLS. The SXG spec notes that there are trade-offs with respect to confidentiality/privacy are noted in the privacy considerations.\r\n\r\nI think we want to be careful about 'trust', because a definition that also includes \"trust that there were no bugs\", or \"trust that the content is honest or accurate\", or more broadly, \"users can trust this\", require a lot of unpacking and have differing expectations. Much like TLS doesn't and shouldn't guarantee that the content is 'trustworthy' - merely that it was delivered over a connection with C/I/A properties - we have tried to avoid introducing those more subjective and problematic elements of trust.",
          "createdAt": "2019-02-08T19:21:39Z",
          "updatedAt": "2019-02-08T19:23:21Z"
        },
        {
          "author": "youennf",
          "authorAssociation": "NONE",
          "body": "Below some more thoughts related to discussions we had with Jeffrey, Kouhei and Yoav during IETF 104.\r\n\r\n> With a liveness check, credentialed or not, a network observer would be able to determine whether or not a user is on `distributor.example/page1` vs `distributor.example/page2` by observing whether or not requests were made to `publisher-1.example` vs `publisher-a.example`.\r\n\r\nTrue.\r\nThat said, web packaging on its own is not sufficient to prohibit this to happen in a browser: reloading the page, clicking a link, the page loading some resources (high resolution images/videos)...\r\n\r\nCurrently, I think the benefits of a live check outweight its drawbacks, in the context of a browser.\r\nOther contexts, other additional technologies, other ways to do these kind of validations, might change things in the future.",
          "createdAt": "2019-04-01T17:51:54Z",
          "updatedAt": "2019-04-01T17:51:54Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "I think SecureContext should be granted provided a liveness check was done on the domain and passed, for a maximum of 30 days ago.\r\n\r\nThe reason, is that the minimum RGP (\"Redemption Grace Period\") according to ICANN, but are, by most registrars called a \"quarantine\" period, is 30 days.\r\nThis means, that we can be absolutely 100% sure, that a specific domain is in possession of the domain holder (or someone related to him - note that voluntary transfers are counted as \"related\"), atleast 30 days counted from the last liveness check.\r\n\r\nOnly past the 30 days there is a possibility that the domain have been aquired by a unrelated third-party.\r\n(For example, if a liveness check was done the second before the domain expired its renewal payment, after 30 days the domain would be free to be registred by someone else, whose might be affected by a signed SGX with regards to cross-origin)",
          "createdAt": "2019-04-09T06:59:31Z",
          "updatedAt": "2019-04-09T07:00:21Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I\u2019m not sure it\u2019s clear why the ICANN policies would relate at all to the\nliveness check. That seems largely orthogonal? In the event of a domain\nregistration change, the SXG certificate will have been revoked, or can be\nby the new holder, by virtue of the existing rules for certificates (e.g.\nthe Baseline Requirements, Section 4.9.1.1).\n",
          "createdAt": "2019-04-09T11:45:50Z",
          "updatedAt": "2019-04-09T11:45:50Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "The reason the liveness check should relate to the ICANN policies, is that within the grace period, we can, security-wise, know 100% that the content is trusted and by the domain owner.\r\n\r\nAway from that, the domain could potentially be by a new owner, and since automated CA's don't check whois for the domain expiration date, there will be no revocation, unless the new domain owner explicitly request it. He might not even be aware of the existence of the old cert.\r\n\r\nA TLS certificate for a domain who have changed owner, is of limited use for the old owner, as he would need to in some way capture or redirect traffic to his TLS server, and the 60 days left of the certificate, in worst case, also helps mitigate this issue.\r\n\r\nA SGX certificate however, is worser, as the signed content could be distributed, which creates a security hazard as CDNs propably will not do any further validations on content which is signed by the original domain owner where the SGX signature is still valid.\r\nThats why I propose tying the liveness check to ICANN policies, as the ICANN policies are minimum, no registrar ever are allowed to go below 30 days quarantine time.",
          "createdAt": "2019-04-09T12:10:19Z",
          "updatedAt": "2019-04-09T12:10:19Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I don\u2019t believe we can state \u201c100%\u201d, unless we\u2019re limiting the threat model\nto ONLY this specific attack. Note also that the ICANN policies only apply\nto a subset of TLDs (gTLDs), so it also does not provide a margin there.\n\nHowever, it does seem as if the concern is a misalignment between the\nlifetime of the assertion and the lifetime of the domain registration,\nwhich does seem as if it is a new concern (compared to those raised earlier\non the thread). I am curious whether a reduction in the certificate\nlifetime itself (e.g. from 90 days to 30) would be sufficient to mitigate\nthat concern, as an alternative to liveness checks.\n",
          "createdAt": "2019-04-09T12:15:53Z",
          "updatedAt": "2019-04-09T12:15:53Z"
        }
      ]
    },
    {
      "number": 389,
      "id": "MDU6SXNzdWU0MDYxMzc0NTM=",
      "title": "dump-signedexchange: make validation success/failure more obvious",
      "url": "https://github.com/WICG/webpackage/issues/389",
      "state": "CLOSED",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The `dump-signedexchange` tool's `-verify` option sort of hides the validation result in the middle of its output. It would be useful if this were more prominently reported, especially in the failure case. Not a crucial thing, but it's not immediately obvious that validation has failed.\r\n\r\nScreenshot of successful validation:\r\n\r\n<img width=\"922\" alt=\"screenshot 2019-02-03 at 22 07 59\" src=\"https://user-images.githubusercontent.com/51244/52183540-9b2c6600-2800-11e9-96e2-00948b7648f4.png\">\r\n\r\nScreenshot of unsuccessful validation:\r\n\r\n<img width=\"922\" alt=\"screenshot 2019-02-03 at 22 08 23\" src=\"https://user-images.githubusercontent.com/51244/52183543-a2ec0a80-2800-11e9-99fd-6c8e4138f339.png\">\r\n",
      "createdAt": "2019-02-03T22:12:15Z",
      "updatedAt": "2019-02-15T05:25:16Z",
      "closedAt": "2019-02-15T05:25:16Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for filing this! Created #398.",
          "createdAt": "2019-02-15T02:25:04Z",
          "updatedAt": "2019-02-15T02:25:04Z"
        }
      ]
    },
    {
      "number": 390,
      "id": "MDU6SXNzdWU0MDY2NjYyNzk=",
      "title": "Accept-Encoding in Variants",
      "url": "https://github.com/WICG/webpackage/issues/390",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When fetching a Signed Exchange, Chromium sets `Accept-Encoding` request header to `gzip, deflate, br`. However, actually Chromium accepts differnt set of content encodings for Signed Exchange's outer and inner responses. `gzip`, `deflate`, and `br` are supported for outer responses, and only `mi-sha256-03` is supported for inner responses.\r\n\r\nThis is problematic when performing the [Request Matching](https://wicg.github.io/webpackage/loading.html#request-matching). For example if exchange has:\r\n```\r\n Variants: Accept-Encoding;mi-sha256-03\r\n Variant-Key: mi-sha256-03\r\n```\r\nIt will not match the `browserRequest` which has `Accept-Encoding: gzip, deflate, br`.\r\n\r\nWhat should we do?\r\n\r\nIdeas:\r\n- When making a redirect to the inner response, overwrite the request's `Accept-Encoding` header to `mi-sha256-03`.\r\n- Or, specify that Cache Behavior for Request Matching does not support Accept-Encoding content negotiation, because it makes little sense for signed exchange's inner responses (?)\r\n",
      "createdAt": "2019-02-05T07:56:57Z",
      "updatedAt": "2019-02-09T00:33:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "In the long run, I think it'll be useful to support encoded inner responses in *bundles* to optimize local disk storage. Since signed exchanges don't need to be random access, it's less important to support compressing the inner response if that makes the implementation trickier.\r\n\r\nIn the short run, I think it'd be fine to say that seeing `Accept-Encoding` in the `Variants` header results in a `mismatch` from https://wicg.github.io/webpackage/loading.html#request-matching. I won't get around to this in the next couple weeks.",
          "createdAt": "2019-02-09T00:33:59Z",
          "updatedAt": "2019-02-09T00:33:59Z"
        }
      ]
    },
    {
      "number": 391,
      "id": "MDU6SXNzdWU0MDcwMzY2MTI=",
      "title": "Limit Content-Encoding?",
      "url": "https://github.com/WICG/webpackage/issues/391",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "The chromium implementation doesn't support any inner content-encodings other than `mi-sha256-03`.\r\n\r\n1. Should the implementation snapshot document this upper bound? (And, AFAICT, it's also a lower bound via [signature validity](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#signature-validity) step 9.)\r\n\r\n2. Should the draft spec place any limits or suggestion on inner content-encoding? I don't suppose it could specify an allowed list of content encodings because that would preclude future integrity specs. But perhaps it could ban br, deflate, and gzip (unless there's a good reason to specify those on inner rather than outer). Perhaps it could mandate a maximum of one, but maybe that would preclude some future `Digest` header that requires nested encodings.",
      "createdAt": "2019-02-06T00:40:47Z",
      "updatedAt": "2019-06-01T23:20:52Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "From impl pov it's possible to support multiple content encodings with modest / reasonable amount of work, so if this could be important we can support that. (And sounds like a good idea reg: 1)\r\n\r\nFor 2: I generally agree that it may not make a lot sense to support br/gzip etc as that encoding can be rather applied to outer response/bundle but don't have a good idea what list we should use. Only allow mi-sha256 for now and extend the list whenever it becomes desirable?",
          "createdAt": "2019-02-13T03:40:44Z",
          "updatedAt": "2019-02-13T03:40:44Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "IMO, the implementation snapshot should document this, but I'm uncomfortable with an exactly-one Content-Encoding rule in the long run. It probably makes sense to ask the httpwg for some feedback here.",
          "createdAt": "2019-03-27T10:34:55Z",
          "updatedAt": "2019-03-27T10:34:55Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "FYI: In the current work on `Digest` https://github.com/ioggstream/draft-polli-resource-digests-http/issues/20 we suggest that:\r\n\r\n- when signing the `Digest` header you MUST sign `Content-Type` and `Content-Encoding` too\r\n\r\nThis is because:\r\n\r\n```\r\nDigest := f(content-encoding(content-type( bits )))\r\n``` \r\n\r\nIn this spec then, I propose `Signed-Headers: content-type, content-encoding, ...` which in your case might provide some agility with future content codings (eg. mi-sha512, ...) without having to change the spec.",
          "createdAt": "2019-06-01T23:16:53Z",
          "updatedAt": "2019-06-01T23:20:52Z"
        }
      ]
    },
    {
      "number": 393,
      "id": "MDU6SXNzdWU0MDc1Nzc1NTg=",
      "title": "\"integrity header\" handling in loading spec",
      "url": "https://github.com/WICG/webpackage/issues/393",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The loading spec defines [integrity header](https://wicg.github.io/webpackage/loading.html#exchange-signature-integrity-header) as a list whose value is the result of splitting the `integrity` signature parameter on `/`.\r\n\r\nhttps://wicg.github.io/webpackage/loading.html#parsing-signature\r\n\r\n> 8. Set result\u2019s integrity header to the result of strictly splitting the \"integrity\" parameter of parsed[0] on U+002F (/).\r\n\r\nBut,\r\n\r\nhttps://wicg.github.io/webpackage/loading.html#read-a-body\r\n\r\n> 1. If signature\u2019s integrity header's first item is:\r\n>   \u21aa \"digest/mi-sha256-03\"\r\n\r\nThis can't be true. It should check if signature\u2019s integrity header is a two-elements list [\"digest\", \"mi-sha256-03\"]. Or maybe just let _integrity header_ a byte sequence, not a list?\r\n",
      "createdAt": "2019-02-07T07:53:22Z",
      "updatedAt": "2019-02-08T01:43:32Z",
      "closedAt": "2019-02-08T01:43:32Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Oops! This comes from #328, where I failed to catch that we needed to make the comparison match the fact that it's a list.\r\n\r\nI *think* we should just compare against the whole list here, instead of comparing by elements. I lean against representing it as just a byte sequence, since I do intend a hierarchical structure here, although a byte sequence would work just fine with the current state of the spec.",
          "createdAt": "2019-02-07T19:11:29Z",
          "updatedAt": "2019-02-07T19:17:10Z"
        }
      ]
    },
    {
      "number": 397,
      "id": "MDU6SXNzdWU0MDk2Mjc0MTI=",
      "title": "When to fallback redirect?",
      "url": "https://github.com/WICG/webpackage/issues/397",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "In the current loading spec, redirect to the fallback URL happens only when [the signed exchange version is not supported](https://wicg.github.io/webpackage/loading.html#mp-http-fetch).\r\n\r\nHowever, Chromium implementation performs fallback redirect in the following cases (corresponding to the error codes [here](https://chromium.googlesource.com/chromium/src/+/HEAD/content/browser/web_package/signed_exchange_error.h)):\r\n\r\n- SXG was served from non-secure origin.\r\n- Unsupported version of SXG (could extract fallback URL).\r\n- SXG parse error (could extract fallback URL).\r\n- Network error occurred while loading SXG header.\r\n- Failed to fetch certificate chain.\r\n- Failed to parse certificate chain.\r\n- Signature verification failed.\r\n- Cert verification failed.\r\n- CT verification failed.\r\n- OCSP check failed.\r\n- Certificate Requirements aren't met.\r\n- SXG was served without `X-Content-Type-Options: nosniff` header.\r\n\r\nChromium doesn't fallbeck on the following errors:\r\n\r\n- SXG parse error (couldn't extract fallback URL).\r\n- Merkle integrity error.\r\n\r\nWe should clarify that which error should cause a fallback redirect, and spec them.\r\n",
      "createdAt": "2019-02-13T04:57:55Z",
      "updatedAt": "2019-05-24T18:30:01Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "/cc @twifkak for consumer side feedback",
          "createdAt": "2019-02-13T05:01:16Z",
          "updatedAt": "2019-02-13T05:01:16Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for opening the issue. Sorry for the delay; I've been sick and this slipped my radar.\r\n\r\nAs a consumer & distributor, my product preference is to make as many things as possible a fallback. That said, I understand there may be reasons _not_ to prefer that, and I would like to know more about them:\r\n - Debugging -- as a developer, I won't even notice that my SXG is invalid unless I have DevTools Network tab open _and_ I scroll all the way to the top. That said, it seems like the UA should prioritize the typical user's experience over developer experience.\r\n - What others?\r\n\r\nFrom your list above, I think there are some that I would feel safe removing fallback for today:\r\n - SXG was served from non-secure origin.\r\n - Network error occurred while loading SXG header. _(I assume this is a network error on the outer response?)_\r\n - SXG was served without `X-Content-Type-Options: nosniff` header.\r\n\r\nEssentially these are all the \"outer exchange\" things that are well-trodden and I feel confident we'll do correctly; also, they require that we _generate_ the correct response rather than that we _validate_ (but don't modify) a given response.\r\n\r\nI'm also okay with not falling back for Merkle integrity (this one was simple enough to check) or parse error (fallback seems dangerous).\r\n\r\nFor a distributor with the privacy-preserving-prefetch use case, the downsides of having a network error page are:\r\n - The user sees an error page instead of simply reduced page speed & extra network bytes.\r\n - The error page is unbranded. (In the early days of AMP, there used to be more [branded error pages](https://www.seroundtable.com/photos/google-amp-error-man-21686.html), but my understanding is that these have significantly reduced in frequency due to improvements in search infra.).\r\n\r\nThe potential reasons that our cache may serve an invalid SXG include:\r\n - A known limitation in our implementation (i.e. we haven't implemented validation X yet).\r\n - An unknown difference (i.e. a bug in either our cache's or the UA's implementation of SXG validation).\r\n - An intrinsically unsolvable difference (e.g. it's impossible to know the UA's trusted roots, or UA clock jitter [skew changing significantly from one request to another]).\r\n\r\nAt this point, I'm mostly worried about the first two. But I'm mostly guessing. After #374 (and after we implement server-side monitoring of those reports), I'll be able to respond more usefully.",
          "createdAt": "2019-02-20T01:01:27Z",
          "updatedAt": "2019-02-20T01:06:20Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "(I'm presuming that the fallback for SXG version mismatch happens before the network error for MICE decode failure. Otherwise, future Chromium versions will need to continue supporting old MICE versions.)",
          "createdAt": "2019-02-21T02:00:07Z",
          "updatedAt": "2019-02-21T02:00:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thank you for collating all the error cases so we can just go through them. My suggestion is:\r\n\r\n|Situation|Behavior|Notes|\r\n|---------|--------|-----|\r\nSXG was served from non-secure origin. | \ud83d\uded1Error\r\nUnsupported version of SXG (could extract fallback URL). | \u21aa\ufe0fFallback\r\nSXG parse error (could extract fallback URL). | \ud83d\uded1Error\r\nNetwork error while streaming SXG header or body. | \ud83d\uded1Error\r\nFailed to fetch certificate chain. | \ud83d\uded1Error\r\nFailed to parse certificate chain. | \ud83d\uded1Error\r\n[Signature parsing](https://wicg.github.io/webpackage/loading.html#parsing-signature) failed (This includes fetching and parsing the certificate) | \ud83d\uded1Error\r\nSignature isn't [valid](https://wicg.github.io/webpackage/loading.html#validating-signature) | \u21aa\ufe0fFallback | This could error instead on the last step, which actually runs the validation algorithm?\r\nCertificate doesn't have the CanSignHttpExchanges OID | \ud83d\uded1Error | Maybe we shouldn't make this exception from the next step.\r\nCertificate chain [does not have a trusted leaf for the origin](https://wicg.github.io/webpackage/loading.html#certificate-chain-has-a-trusted-leaf) for another reason | \u21aa\ufe0fFallback | This includes cert path building, OCSP checking, and CT checking.\r\nCertificate chain does not [establish cross-origin trust](https://wicg.github.io/webpackage/loading.html#exchange-signature-establishes-cross-origin-trust) for another reason | \ud83d\uded1Error | The non-certificate reasons can be checked on the distributor.\r\nSXG was served without X-Content-Type-Options: nosniff header. | \ud83d\uded1Error\r\nSXG parse error (couldn't extract fallback URL). | \ud83d\uded1Error\r\nMerkle integrity error. | \ud83d\uded1Error\r\n\r\n\r\nI basically want anything the distributor could catch to be an Error, while anything that clients might vary on (mostly time & crypto validity) should fall back. @sleevi, how do you feel about this list?",
          "createdAt": "2019-05-15T00:25:03Z",
          "updatedAt": "2019-05-15T00:25:03Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> I basically want anything the distributor could catch to be an Error, while anything that clients might vary on (mostly time & crypto validity) should fall back.\r\n\r\nAt first glance, that sounds like a great principle and I think your analysis is reasonable and spot-on. Signature isn\u2019t valid seems a reasonable error?",
          "createdAt": "2019-05-15T00:56:21Z",
          "updatedAt": "2019-05-15T00:56:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi https://wicg.github.io/webpackage/loading.html#validating-signature includes the check against the client's clock (which I think should definitely fall back) and the check that it's a secp256r1 key (where I want to have clients fall back when they remove broken crypto, but maybe we should do that with a version increment instead). \r\n\r\nWe should also make sure that the reporting API distinguishes between the cases that error vs fall back. Right now there are distinctions in the table above that aren't captured in the reporting API results.",
          "createdAt": "2019-05-15T03:34:04Z",
          "updatedAt": "2019-05-15T03:34:04Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Yeah, the approach for changing crypto primitives was definitely seen as a version-bumpable thing. Perhaps it's worth splitting out \"validate a signature\" and \"validate the timestamp\" as two separate things, the former being an error, the latter being a fallback?",
          "createdAt": "2019-05-15T15:42:19Z",
          "updatedAt": "2019-05-15T15:42:19Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Initial NEL analysis from AMP Cache is available to Googlers in http://b/126787670. Overall, error rate is relatively low, but I'd say not low enough to serve network errors in all cases.\r\n\r\nThe two most prevalent errors are cert_fetch_error & mi_error. My understanding is that these can be due to a bad connection, which is beyond the control of the distributor (e.g. may be due to ISP issues or spotty cell coverage). I'm thinking that these cases should continue to fall back. Otherwise, spotty connnections would disproportionately affect SXG, because browsers are willing to render unsigned HTML that was truncated or had failed subresources. Are there downsides to falling back in these cases?",
          "createdAt": "2019-05-21T02:36:34Z",
          "updatedAt": "2019-05-21T02:36:34Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Cert Fetch Errors are more similar to failures to fetch AIA (which causes\nhardfail) or OCSP (for which behaviour varies between browsers), right?\n\nAs to whether it\u2019s safe, the analysis would be:\n- Identifying all the information an adversary could learn by observing the\nfallback occurred\n- Identifying whether and how that information might already be available\n- Identifying how that information could be abused\n- Identifying what the process would be if we \u201cgot it wrong\u201d in the\nanalysis (in this case, what the implications would be if a browser had to\nsuddenly switch to block)\n",
          "createdAt": "2019-05-21T02:41:58Z",
          "updatedAt": "2019-05-21T02:41:58Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Reg. mi_error:\r\n\r\nFrom the implementation's POV, browser sends SXG's inner response header to the renderer as soon as the SXG header is validated. Merkle integrity error is detected after that, so it's too late to chagne the response to 303 redirect at that pont.",
          "createdAt": "2019-05-21T03:30:49Z",
          "updatedAt": "2019-05-21T03:30:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "cert_fetch_error: My instinct is that a failure to fetch the certificate from the same origin that's already transferring the signed exchange is similarly likely to a failure to fetch the signed exchange itself or the content from the publisher. Since we don't auto-reload on a network error, we shouldn't auto-redirect on one either.\r\n\r\nmi_error:\r\n\r\n1. It seems confusing to have a network error that truncates the SXG be expressed as `mi_error`. I think I'd want to see one of https://w3c.github.io/network-error-logging/#transmission-of-request-and-response-errors instead? @irori/@horo-t Is that plausible?\r\n\r\n2. I hope the browser can render the parts of the content that have already been verified, even if the connection is broken which truncates and invalidates the last chunk.",
          "createdAt": "2019-05-23T19:17:00Z",
          "updatedAt": "2019-05-23T19:17:00Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "> mi_error:\r\n> \r\n> 1. It seems confusing to have a network error that truncates the SXG be expressed as `mi_error`. I think I'd want to see one of https://w3c.github.io/network-error-logging/#transmission-of-request-and-response-errors instead? @irori/@horo-t Is that plausible?\r\n\r\nIIUC, currently both a `mi_error` and a transmission error are reported. I think it's possible to stop sending mi_error for network error cases, but I'll defer to @horo-t.\r\n\r\n> 2. I hope the browser can render the parts of the content that have already been verified, even if the connection is broken which truncates and invalidates the last chunk.\r\n\r\nChrome works in this way, although it's not guaranteed that response is loaded to the last validated chunk (internal buffer is discarded upon network error).\r\n",
          "createdAt": "2019-05-24T01:42:31Z",
          "updatedAt": "2019-05-24T01:42:31Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> > mi_error:\r\n> > \r\n> > 1. It seems confusing to have a network error that truncates the SXG be expressed as `mi_error`. I think I'd want to see one of https://w3c.github.io/network-error-logging/#transmission-of-request-and-response-errors instead? @irori/@horo-t Is that plausible?\r\n> \r\n> IIUC, currently both a `mi_error` and a transmission error are reported. I think it's possible to stop sending mi_error for network error cases, but I'll defer to @horo-t.\r\n\r\nI agree.\r\nWe should not send `mi_error` when caused by a transmission error.\r\nWe need to update both the loading spec and Chromium implementation.",
          "createdAt": "2019-05-24T10:32:46Z",
          "updatedAt": "2019-05-24T10:32:46Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the clarifications; looks like I misunderstood what `mi_error` meant for the user. Re: `cert_fetch_error`; I'll defer to you all, unless I learn that these errors are disproportionately large and can't be mitigated at implementation side, and I can come up with a good reason they're different from AIA fetch. (The only difference I can think of is that a secure fallback seems *possible* in this case.)",
          "createdAt": "2019-05-24T18:30:01Z",
          "updatedAt": "2019-05-24T18:30:01Z"
        }
      ]
    },
    {
      "number": 399,
      "id": "MDU6SXNzdWU0MTQzNzEwMTI=",
      "title": "Long-lived content",
      "url": "https://github.com/WICG/webpackage/issues/399",
      "state": "OPEN",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The use case document mentions the [ongoing web publication work](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#rfc.section.2.2.1). The key question has come up in many conversations, but I wanted to get it in GitHub. Certain types of publications, such as books, hope to live forever. Users expect to be able to access the content whether or not the publisher still exists. Moby-Dick was published 61,126 days ago, which is somewhat longer than the 7 days that signatures are valid. \r\n\r\nWhat options might publishers have? What happens if we create a bundle of unsigned exchanges? Much of our content would use JS only for a service worker. How does that impact the security issues?\r\n\r\n",
      "createdAt": "2019-02-26T00:21:52Z",
      "updatedAt": "2019-11-19T02:36:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "> The key question has come up in many conversations, but I wanted to get it in GitHub.\r\n\r\nThank you for doing so.\r\n\r\nService Worker probably complicates the situation...\r\nCould you clarify use cases for which web publications would use a Service Worker?\r\n\r\nI had assume that any Web Publication designed to be long-lived would be a self-contained piece of content that completely work offline by virtue of having all their resources included in the bundle.",
          "createdAt": "2019-02-26T00:49:57Z",
          "updatedAt": "2019-02-26T00:49:57Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "You can absolutely create a bundle of unsigned exchanges, but then you wouldn't execute as a [secure context](https://w3c.github.io/webappsec-secure-contexts/) **in a web browser**, and that would prevent you from [installing a Service Worker](https://w3c.github.io/ServiceWorker/#navigator-serviceworker).\r\n\r\nHowever, an ebook reader doesn't necessarily need to have the same security model as a web browser. You could treat a particular file as an origin, and then the bundle in that file would be a secure context. (We could potentially even do that in a web browser...) You could define your own X.509 certificate extension, with its own rules for validity. How do publishers want to handle old signatures using potentially-broken algorithms or potentially-compromised signing keys?\r\n\r\nIncidentally, I think I put the requirement that signatures are valid for at most 7 days in the wrong section. It's currently in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity, so it affects even signatures that have nothing to do with a browser's security model, but I think it should actually be in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust, where it would only affect the decision about whether to trust the signature in that one particular way. I'm not likely to get to that before at least April, so patches to do it are welcome.\r\n\r\n",
          "createdAt": "2019-03-07T00:17:26Z",
          "updatedAt": "2019-03-07T00:17:26Z"
        },
        {
          "author": "pagelab",
          "authorAssociation": "NONE",
          "body": "The EPUB format it's more appropriate for long lived content.",
          "createdAt": "2019-11-19T02:35:38Z",
          "updatedAt": "2019-11-19T02:36:08Z"
        }
      ]
    },
    {
      "number": 400,
      "id": "MDU6SXNzdWU0MTUzMzM1Njg=",
      "title": "Add an example SXG error report",
      "url": "https://github.com/WICG/webpackage/issues/400",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@horo-t, could you add an example ([`<div class=\"example\" id=\"example-network-error-log\">`](https://tabatkins.github.io/bikeshed/#notes-etc)) Network Error Log that could be produced by the spec you added in #374? https://wicg.github.io/webpackage/loading.html#queue-report would be a reasonable place to put it unless you think somewhere else will be more clear.",
      "createdAt": "2019-02-27T21:24:25Z",
      "updatedAt": "2019-03-24T09:31:48Z",
      "closedAt": "2019-03-24T09:31:48Z",
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure.",
          "createdAt": "2019-02-28T03:49:54Z",
          "updatedAt": "2019-02-28T03:49:54Z"
        }
      ]
    },
    {
      "number": 402,
      "id": "MDU6SXNzdWU0MTU0NDcyMjM=",
      "title": "Consider adding web package mime types to CORB",
      "url": "https://github.com/WICG/webpackage/issues/402",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "CORB seems like a good thing to enable for more mime types. Since there are very few users of our mime types, we should see if it makes sense to turn on CORB for them. We're trying to discourage personalized data in signed exchanges, but unsigned bundles could certainly have it.\r\n\r\n@anforowicz for any thoughts.",
      "createdAt": "2019-02-28T04:54:55Z",
      "updatedAt": "2019-03-02T02:10:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "Covering web package mime types by CORB sounds good to me (*).  Could you please point out in https://github.com/whatwg/fetch/issues/860 which mime types should be covered (anything beside \"`application/signed-exchange`\"?).\r\n\r\n(*) Ideally we would figure out a more systematic protection for no-cors resources (e.g. credential-less or cors-only fetches by default), but current ideas seem likely to break existing websites and therefore CORB seems like a necessary short-term approach.  (cc @annevk @csreis)",
          "createdAt": "2019-02-28T17:03:13Z",
          "updatedAt": "2019-02-28T17:03:13Z"
        },
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "@annevk points out (in https://github.com/whatwg/fetch/issues/721#issuecomment-468363310) that for other new types (e.g. for JavaScript modules) we successfully started requiring CORS right from the beginning.  Mentioning this, in case this is something we should consider for web packages (but maybe web package fetches are never initiated from a web page - requiring CORS doesn't seem to make sense for navigation-like fetches?).",
          "createdAt": "2019-02-28T19:05:25Z",
          "updatedAt": "2019-02-28T19:05:25Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "> @annevk points out (in [whatwg/fetch#721 (comment)](https://github.com/whatwg/fetch/issues/721#issuecomment-468363310)) that for other new types (e.g. for JavaScript modules) we successfully started requiring CORS right from the beginning. Mentioning this, in case this is something we should consider for web packages (but maybe web package fetches are never initiated from a web page - requiring CORS doesn't seem to make sense for navigation-like fetches?).\r\n\r\nRequiring CORS doesn't mitigate risks of info leak through Spectre or renderer compromise. i.e. any website should still be able to do no-cors requests (e.g. `<img src=\"//victim.tld/secret.sxg\">`) and information will be loaded into renderer. So CORB makes sense right now. But once [347](https://github.com/WICG/webpackage/issues/347) comes in, requiring CORS for subresource SXG files might be a good idea. Otherwise we probably need inner mime type based CORB blocking for SXG files.",
          "createdAt": "2019-03-01T06:47:40Z",
          "updatedAt": "2019-03-01T06:47:40Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We should think about banning no-cors requests even for `<img src=\"//victim.tld/secret.sxg\">`, since nobody yet uses `.sxg` images, but if we can't do that, I agree we should use @kinu's suggestion of CORB filtering based on the inner content type.",
          "createdAt": "2019-03-01T22:32:56Z",
          "updatedAt": "2019-03-01T22:32:56Z"
        },
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "@shhnjk , the proposal is to disallow no-cors requests altogether (e.g. even `<img src=\"//victim.tld/secret.sxg\">` would require CORS).\r\n\r\n@jyasskin and @kinu - CORB is needed to prevent a compromised renderer to just asking a NetworkService for the contents of the *whole* SXG.  I don't understand why in addition to blocking *whole* SXG, CORB would also want to look *into* SXG - maybe I am missing some details / scenarios where this is important (e.g. I don't really understand how SXG enters the picture and maybe intercepts image and/or XHR requests)?",
          "createdAt": "2019-03-01T22:44:16Z",
          "updatedAt": "2019-03-01T22:44:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@anforowicz (With the caveat that I know very little about the CORB landscape) *If* we allow no-cors requests that find an `application/signed-exchange` resource, that resource might contain either an image or an HTML file. If it's an image, then the compromised renderer should be able to retrieve it, just like it could retrieve an image that's not wrapped into a signed exchange. If it's HTML, the renderer should be blocked, just like it's blocked from retrieving a non-wrapped HTML file.\r\n\r\nI'd rather just block SXG responses to no-cors requests if we can and if that's sufficient, because that sounds simpler.",
          "createdAt": "2019-03-01T22:49:53Z",
          "updatedAt": "2019-03-01T22:49:53Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "> @shhnjk , the proposal is to disallow no-cors requests altogether (e.g. even `<img src=\"//victim.tld/secret.sxg\">` would require CORS).\r\n\r\n@anforowicz \r\nHow will you compare CORS against navigation requests?\r\nWhich CORS header will you compare? Outer or Inner?\r\nI don't think CORS will makes sense for SXGs which will be used for navigation requests. Yes, it makes sense to require CORS for subresource requests to SXG files (so that CORB `application/signed-exchange` by default would still work).",
          "createdAt": "2019-03-01T23:09:30Z",
          "updatedAt": "2019-03-01T23:09:30Z"
        },
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "> I'd rather just block SXG responses to no-cors requests if we can and if that's sufficient\r\n\r\nMaybe it is sufficient to restrict SXG, no-cors requests to only image/*, audio/*, video/*, application/javascript, text/css content types?\r\n\r\nBut then - where are the SXG contents \"opened\" / \"extracted\"?  We can't block things in the renderer (it is already too late there because of Spectre and/or risk of compromised renderers).",
          "createdAt": "2019-03-01T23:15:03Z",
          "updatedAt": "2019-03-01T23:15:03Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "@anforowicz -- SXG is basically considered at network layer concept, in Chromium implementation it's unwrapped way before the content hits the renderer so sniffing the inner type for CORB should work. (To add a little more technical detail-- it's currently done in the browser process, we've discussed unwrapping in Network Service but it hasn't happened because of lack of strong pros vs cons, but that part can be discussed separately)\r\n\r\nGiven that outer body wouldn't hit the renderer process and renderer will only see the inner response, I'm not fully convinced why they (e.g. jpg image delivered in SXG) need to be handled differently from others (e.g. regular jpg image)-- while, to be clear, I'm generally in favor of pushing the word towards no-no-cors/cors-only so can understand the motivation.",
          "createdAt": "2019-03-02T00:07:16Z",
          "updatedAt": "2019-03-02T00:07:16Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "> Given that outer body wouldn't hit the renderer process and renderer will only see the inner response, I'm not fully convinced why they (e.g. jpg image delivered in SXG) need to be handled differently from others (e.g. regular jpg image)\r\n\r\nMaybe I didn't understand how SXG works. So in current implementation, if there's a image request to SXG file (from non-SXG page) which contains HTML (i.e. `<img src=\"//other.tld/html.sxg\">`), will it be parsed in the browser process to serve inner content or will it be passed to renderer's image parser? \r\n\r\nMy understanding was that subresource request from normal HTML page to SXG file wouldn't trigger SXG parser in the browser. Is that right?",
          "createdAt": "2019-03-02T00:21:33Z",
          "updatedAt": "2019-03-02T00:23:59Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "@shhnjk Well current implementation doesn't support subresources, so we need talk about hypothetical code base, and I started to realize that this has more subtlety than I thought but let me try. (I suppose you're familiar with the chrome architecture)\r\n\r\nIf there's a image request where SXG for HTML is returned, it will be surely parsed in the browser process (or possibly in Network Service if we make the change) at least in our currenmt thinking. For https://github.com/WICG/webpackage/issues/347 this is not that hard because we can know what subresource requests may be fulfilled as SXGs before the renderer starts to consume the main resource. If we start to support regular subresource requests for SXGs things will become a bit trickier for saner cross-origin isolation, and we probably need to move the parsing code into the Network Service due to the architectural reasons. But all in all unwrapping wouldn't happen in the renderer process in subresource cases either.",
          "createdAt": "2019-03-02T01:08:18Z",
          "updatedAt": "2019-03-02T01:08:18Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "Right, so the concern is that until there is a support for subresource requests in SXG, subresource requests to SXG files will be handled by other parsers (which means outer body will hit the renderer). Which we want to avoid because renderer process can then get cross-origin information.\r\n\r\nBut since unwrapping happens inside browser process, content type sniffing is possible. So until there is a subresource support in SXG, blocking SXG mime type as a whole should be safe. Once subresource supports comes in, inner content type based CORB blocking could happen (either by safe list or unsafe list). Require CORS for all SXG subresource is a nightmare++ :D",
          "createdAt": "2019-03-02T01:57:48Z",
          "updatedAt": "2019-03-02T01:57:48Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay-- fair enough. Currently I don't think SXG spec says anything about main resource vs subresource (so it's just that impl has a gap), could we say something like \"the CORB protection for SXG should be also applied unless implementation supports SXG handling for subresources\" ?\r\n",
          "createdAt": "2019-03-02T02:10:44Z",
          "updatedAt": "2019-03-02T02:10:44Z"
        }
      ]
    },
    {
      "number": 403,
      "id": "MDU6SXNzdWU0MTYwNTMwODY=",
      "title": "Support loading Signed Exchanges from blob: or filesystem: URI",
      "url": "https://github.com/WICG/webpackage/issues/403",
      "state": "OPEN",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Current loading spec is checking the `response\u2019s header list` in [Identifying signed exchanges](https://wicg.github.io/webpackage/loading.html#identifying-sxg) section.\r\nSo signed exchanges can't be loaded from blob: or filesystem: URI where no `header list` exists.",
      "createdAt": "2019-03-01T11:06:57Z",
      "updatedAt": "2019-03-01T18:32:06Z",
      "closedAt": null,
      "comments": [
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "Do you want to support data: URI too?",
          "createdAt": "2019-03-01T17:45:59Z",
          "updatedAt": "2019-03-01T17:45:59Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Note: If these are supported, they will probably meaningfully impact the\nNEL reporting aspects, particularly for publishers, but also potentially\nfor distributors. For example, if trying to report issues loading an SXG,\nif the top-level origin is a blob or data URI, that would create issues.\n",
          "createdAt": "2019-03-01T18:32:06Z",
          "updatedAt": "2019-03-01T18:32:06Z"
        }
      ]
    },
    {
      "number": 405,
      "id": "MDU6SXNzdWU0MjA3MzI4MTE=",
      "title": "Are OCSP responses with multiple SingleResponses allowed?",
      "url": "https://github.com/WICG/webpackage/issues/405",
      "state": "CLOSED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust item 7.3 says:\r\n\r\n> Validate that `main-certificate` has an `ocsp` property\r\n> ({{cert-chain-format}}) with a valid OCSP response whose lifetime\r\n> (`nextUpdate - thisUpdate`) is less than 7 days ({{!RFC6960}}).\r\n\r\nBut per https://tools.ietf.org/html/rfc6960#section-4.2, an `OCSPResponse` may have multiple `SingleResponse`s, each with its own `nextUpdate` and `thisUpdate`. Are such OCSP responses disallowed by the spec? Otherwise, to which `SingleResponse` does this requirement apply?",
      "createdAt": "2019-03-13T21:42:16Z",
      "updatedAt": "2019-03-14T00:52:11Z",
      "closedAt": "2019-03-14T00:52:11Z",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> Are such OCSP responses disallowed by the spec?\r\n\r\nNot at present. Considering the implications to CAs, that would start getting into a policy/certificate profile doc beyond just the extension. Both 6960 and 5019 permit multiple `SingleResponse`s.\r\n\r\n> Otherwise, to which SingleResponse does this requirement apply?\r\n\r\nConsistent with the existing handling of OCSP and RFC 5019/5280/6960, provided that there is a `SingleResponse` that meets this criteria, one may consider the `OCSPResponse` valid for that certificate.",
          "createdAt": "2019-03-13T22:07:17Z",
          "updatedAt": "2019-03-13T22:07:17Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, OK, thanks for the clarification. Do you think it's worth clarifying that in the spec text, or is the implicit consistency sufficient?",
          "createdAt": "2019-03-13T22:18:50Z",
          "updatedAt": "2019-03-13T22:18:50Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "That's a good question! If @jyasskin is OK with adding more text, I don't think there's fundamental harm in specifying/clarifying. I think we'd want feedback from other UAs - I don't believe this would present any challenges for Mozilla, but for Apple/Microsoft, their OCSP stacks are maintained by different teams, and they may have spec language feedback and/or want to leave it opaque/implicit (as it is in TLS and RFC 5280)",
          "createdAt": "2019-03-13T22:34:03Z",
          "updatedAt": "2019-03-13T22:34:03Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I don't really want this specification to be in the business of defining how we interpret OCSP responses. The SingleResponse specifies a certID, and duplicates of those could be inconsistent in all sorts of ways that we don't call out. Let's just stay with the language used by other specs in this area. For example, https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.3.pdf section 4.9.10 just says, \"OCSP responses from this service MUST have a maximum expiration time of ten days.\"",
          "createdAt": "2019-03-13T23:19:59Z",
          "updatedAt": "2019-03-13T23:19:59Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, closing then.",
          "createdAt": "2019-03-14T00:52:11Z",
          "updatedAt": "2019-03-14T00:52:11Z"
        }
      ]
    },
    {
      "number": 409,
      "id": "MDU6SXNzdWU0MjI1NTU2MzQ=",
      "title": "SXG loading and service worker integration",
      "url": "https://github.com/WICG/webpackage/issues/409",
      "state": "CLOSED",
      "author": "mattto",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm raising this issue as suggested by horo at https://github.com/WICG/webpackage/issues/347#issuecomment-474172523\r\n\r\nThe current spec has an Overview which explains service worker integration. I'm wondering whether some alternatives were considered and rejected.\r\n\r\n> If navigationPreload is enabled, the signed response will be available in the FetchEvent's preloadResponse. Note that this will also cause a network request for requests that aren\u2019t served from a signed exchange.\r\n\r\nI think this makes sense. My understanding is that if the request were to go to \"network\" (i.e., the service worker doesn't call respondWith()), the response would come from the signed exchange, so `preloadResponse` should be that response.\r\n\r\n> clone() the request and set its cache to \"only-if-cached\", to retrieve the matching response from either the signed exchange or the HTTP cache. Note that fetch()ing a new Request with the same url will not retrieve the response from the signed exchange.\r\n\r\nThis I'm not sure about. Historically `respondWIth(fetch(event.request))` is expected to have the same behavior as not calling `respondWith()`. Is it possible to arrange things such that fetch(event.request) gets the response from the signed exchange by default and you need to clone() request and set a flag to skip the signed exchange?",
      "createdAt": "2019-03-19T05:53:07Z",
      "updatedAt": "2019-03-21T14:41:01Z",
      "closedAt": "2019-03-21T14:41:01Z",
      "comments": [
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "One possibility (which @wanderview also mentions at https://github.com/w3c/resource-hints/issues/78#issuecomment-384981842 for prefetch) could be to tie the signed exchange to the request's [client](https://fetch.spec.whatwg.org/#concept-request-client), so that fetch(event.request) goes to the signed exchange by default, and you can construct a Request with a null `window` otherwise to disassociate from the signed exchange. Or introduce a similar property like `signedExchange`.",
          "createdAt": "2019-03-19T12:38:26Z",
          "updatedAt": "2019-03-19T12:38:26Z"
        },
        {
          "author": "wanderview",
          "authorAssociation": "NONE",
          "body": "Could we make Request cache value of \"default\" mean include checking the signed exchange by default and the \"reload\"/\"nocache\" would bypass it?",
          "createdAt": "2019-03-19T22:41:31Z",
          "updatedAt": "2019-03-19T22:41:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I intend that `respondWith(fetch(event.request))` does have the same behavior as not-calling `respondWith()` since the [stashed exchange](https://wicg.github.io/webpackage/loading.html#request-stashed-exchange) is attached to the request, and even follows its [clones](https://wicg.github.io/webpackage/loading.html#mp-request-clone). `respondWith(fetch(event.request.url))` does *not* have the same behavior, since the new request created from a plain URL doesn't include the stashed exchange.\r\n\r\nIf there's something in the algorithms that contradicts this, let me know so I can correct it (or realize that my intent is wrong, which is always possible).\r\n\r\nI think we talked about ways to make `respondWith(fetch(event.request.url))` also use the signed exchange and decided it was too complicated, but I don't remember where those conversations happened aside from my quick sketch in https://github.com/WICG/webpackage/pull/281#discussion_r208319315.",
          "createdAt": "2019-03-20T20:18:47Z",
          "updatedAt": "2019-03-20T20:22:15Z"
        },
        {
          "author": "mattto",
          "authorAssociation": "NONE",
          "body": "Thanks, that's good to know! Actually after writing that comment I saw the request's \"signed exchange\" defined and then wondered why it wouldn't be used but didn't want to triple post :)\r\n\r\nI think the current Overview wording may be confusing... I'd suggest clarifying that respondWith(event.request) just works (it reads as if you must clone() and set the cache mode).\r\n\r\nI think I can see why having the same behavior for `respondWith(fetch(event.request.url))` would be difficult if the idea was that fetching `https://publisher.example.org/` would normally not retrieve contents from the SXG while fetching it while inside the SW's fetch event during the SXG would. There's nothing tieing the SW or fetch event to the SXG, except the request's internal signed exchange, so having a new request skip the SXG sounds reasonable to me.\r\n\r\nI'm also wondering now about the suggestion to set the cache mode to get the SXG content after cloning. Wouldn't just cloning without changing the cache mode work?\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2019-03-21T13:53:16Z",
          "updatedAt": "2019-03-21T13:53:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The overview says, \"If [a Service Worker] needs to know that signed exchange content is available for the request it\u2019s handling, it has two options:\" before saying to use the cache mode, and I think you didn't read that before jumping to the text about `respondWith()`. Adding more words will not help with that problem.",
          "createdAt": "2019-03-21T14:39:57Z",
          "updatedAt": "2019-03-21T14:40:51Z"
        }
      ]
    },
    {
      "number": 411,
      "id": "MDU6SXNzdWU0MjQzNTg0NTA=",
      "title": "Bundles of JS modules should be able to express their dependency graph cheaply",
      "url": "https://github.com/WICG/webpackage/issues/411",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "If you have 2 modules:\r\n\r\nA.mjs:\r\n```javascript\r\nimport \"B\"\r\n// Lots of code.\r\n``` \r\nB.mjs:\r\n```javascript\r\n// Lots more code.\r\n``` \r\n\r\nYou have to download A and parse it to figure out that it depends on B. Then you have to download B and execute it before you can use nearly any of the bytes you downloaded for A.\r\n\r\nBundles should help speed this up, either by directly expressing the import dependency graph in a way that the JS interpreter will trust, or by letting the bytes of the resources interleave so they can parse and execute in the order they arrive.",
      "createdAt": "2019-03-22T19:03:58Z",
      "updatedAt": "2019-07-20T22:51:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@wycats wanted this too, IIRC.",
          "createdAt": "2019-03-22T19:07:35Z",
          "updatedAt": "2019-03-22T19:07:35Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "NONE",
          "body": "Thanks for opening up this issue, @jyasskin . I'm really excited by this idea. Among complexities, in addition to describing the dependency structure, I'm wondering, how can you tell which Realm should the JavaScript module be run in? E.g., the bundle may include a page HTML with an iframe; I'm not sure if there are interactions with HTML modules as well.\r\n\r\nOne way that these semantics could be accessed today in HTML would be to insert many `<script type=module>` tags, in postorder for how the module graph would be traversed. If, in a bundled exchange package, the HTML file comes first, and then the scripts in the order that is in parallel with those script tags, then there would be somewhat similar observable behavior.\r\n\r\nIncluding a built-in feature for this model of execution could be better than a bunch of tags in a few ways:\r\n- Maybe most importantly, which @domenic marked as new behavior in his [summary](https://github.com/whatwg/html/issues/4400#issuecomment-474944947), is that the UA would be allowed to *not* yield to the event loop if the module is already fetched.\r\n  - @nyaxt mentioned in https://github.com/whatwg/html/issues/4400#issuecomment-469551063 that yielding to the event loop too many times could be difficult for browsers to make cheap.\r\n  - However, @smaug---- expressed concern about *optional* yielding to the event loop in https://github.com/whatwg/html/issues/4400#issuecomment-474569945.\r\n- Fewer script tags, meaning shorter HTML to download, less DOM and possible events, and less need of tooling to generate the HTML. (I'm not sure how much overhead this actually is.)\r\n\r\nBottom-up loading could benefit JavaScript in terms of enabling bytecode generation to have access to dependencies having already been parsed. This isn't so necessary today, but may be helpful with a newer version of the the [decorators proposal](https://github.com/tc39/proposal-decorators/).\r\n\r\nMy guess is that bottom-up loading with optional yields to the event loop would not be web-incompatible (as @yoavweiss [asked](https://github.com/whatwg/html/issues/4400#issuecomment-475142860)), since probably not many people are shipping big native module graphs yet, but it could violate JavaScript programmer expectations about atomicity of module loading, as @rniwa [raised](https://github.com/whatwg/html/issues/4400#issuecomment-474570663).\r\n\r\nI'd be curious to figure out what parts of this might be possible to experiment with in bundler software today, and what parts require new web platform primitives. I imagine browsers might be able to make smarter decisions about how to interleave JavaScript execution and network access.",
          "createdAt": "2019-03-23T00:32:11Z",
          "updatedAt": "2019-03-23T00:32:11Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "NONE",
          "body": "(Or, as the never-yielding complement to a bunch of script tags, you could have a single module script which imports all the modules that will eventually be used, in post-order. And of course tools could play around mixing these two together, but only statically.)",
          "createdAt": "2019-03-23T00:34:53Z",
          "updatedAt": "2019-03-23T00:34:53Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "FWIW, I'm inclined to have folks write the single module script that imports everything in post-order, until we show that it costs enough more than a better solution to justify the complexity of the better solution.",
          "createdAt": "2019-03-30T12:24:17Z",
          "updatedAt": "2019-03-30T12:24:17Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "This assumed that the modules have no side-effects, right?",
          "createdAt": "2019-04-21T18:03:42Z",
          "updatedAt": "2019-04-21T18:03:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@yoavweiss It assumes they don't have syntax errors that are supposed to prevent side effects from happening, but I think it otherwise preserves side effects.",
          "createdAt": "2019-04-21T23:58:46Z",
          "updatedAt": "2019-04-21T23:58:46Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "NONE",
          "body": "The never-yielding variant of generated import statements would preserve side effects (while defeating much of the benefit of the optimization)--the entire module graph is checked for errors before any of it runs. Otherwise, I agree with @jyasskin.",
          "createdAt": "2019-04-23T02:51:41Z",
          "updatedAt": "2019-04-23T02:51:41Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "One possible strategy might be to use Link headers:\r\n\r\nAs a server, I am empowered to express relationships of my choosing via a `Link` header. If the ask in this ticket is for JS modules to express their dependency graph clearly, I a server might facilitate this ask my using a link header like:\r\n\r\n`Link: <http://yoyodyne.net/lib/dep.js>; rel=dependency; as=module`\r\n\r\nThis is a declaration of a dependency of this script's resource. I don't know who or what would listen & detect this, or what they would do with this. But as a server, I can enumerate relations of this resource, for example `rel=depenency`, which would give the user-agent a way to understand dependencies without having to parse JS modules.\r\n\r\n[Link Preload](https://www.w3.org/TR/preload/#server-push-http-2) might be related. Server admins might consider adding a `preload` relationship everywhere there is a `dependency` relationship, to let the browser know it will be expected.",
          "createdAt": "2019-07-20T22:51:03Z",
          "updatedAt": "2019-07-20T22:51:03Z"
        }
      ]
    },
    {
      "number": 413,
      "id": "MDU6SXNzdWU0MjQ2NDQ3MTk=",
      "title": "Support use case: using web package for H2-style JS bundles",
      "url": "https://github.com/WICG/webpackage/issues/413",
      "state": "OPEN",
      "author": "dvoytenko",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Reflecting on [H2 push is tougher than I thought](https://jakearchibald.com/2017/h2-push-tougher-than-i-thought/), there's still one common use case: a set of JS binaries are always downloaded together. This would typically be due to breaking down a big binary into smaller ones where:\r\n 1. The first binary is critical for immediate execution.\r\n 2. All other binaries could be delayed. But ideally not turned into a download waterfall.\r\n 3. Otherwise, the \"other\" binaries are never used by themselves, without the first binary.\r\n\r\nThis is one case, where H2 push would be useful and Web Packages could make this a much simpler and more predictable.\r\n\r\nTo further explain this, consider one big binary that looks like this:\r\n\r\n```\r\n// First critical block of JS.\r\n(function() {\r\n  global.doLater = function() {...};\r\n  // E.g. 20K of JS code.\r\n})();\r\n\r\n// Second non-critical block of JS.\r\ndoLater(function() {\r\n  // E.g. 40K of JS code.\r\n});\r\n\r\n// Third non-critical block of JS.\r\ndoLater(function() {\r\n  // E.g. 60K of JS code.\r\n});\r\n```\r\n\r\nThis kind of delivery could still save lots of CPU by not immediately executing block 2 and 3, but the main negative is that the overall binary is bigger and has to be fully parsed/compiled before anything can be executed, thus delaying execution of the critical block 1. While some engines are capable of lazy compiling some of the non-critical blocks, the full download/parse is still necessary.\r\n\r\nWeb Packages could help this case by splitting a big binary into smaller files and executing the smaller critical blocks as soon as they are downloaded/parsed.\r\n\r\n/cc @cramforce ",
      "createdAt": "2019-03-24T18:30:47Z",
      "updatedAt": "2019-03-26T22:51:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is similar to, but maybe not the same as https://github.com/WICG/webpackage/issues/411.\r\n\r\nWould you expect to wind up with `<script src=\"firstblock.bundle\"/> <script defer src=\"secondblock.bundle\"/> <script defer src=\"thirdblock.bundle\"/>` in the HTML, or some other structure to kick off loading the split-up script?",
          "createdAt": "2019-03-24T18:35:28Z",
          "updatedAt": "2019-03-24T18:35:28Z"
        },
        {
          "author": "dvoytenko",
          "authorAssociation": "NONE",
          "body": "It's similar and maybe would cooperate with #411, but not exactly the same. It'd be pretty close with [dynamic imports](https://github.com/tc39/proposal-dynamic-import). The benefit with Web Packages (similar to H2) would be that the download for secondary modules would be running implicitly, vs dynamically triggered by executing script.\r\n\r\nOtherwise, you're right, we'd wind up with dynamically inserted `<script async>` (maybe/maybe not `defer`) to trigger the parse/compile/execution. We'd win on download in this case, though it's possible that a smarter engine could also pre-parse/pre-compile related scripts in the web package if it gets a good idea that they will be used soon anyway.",
          "createdAt": "2019-03-25T01:57:09Z",
          "updatedAt": "2019-03-25T01:57:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think we should get some of that by using \r\n\r\n```html\r\n<link rel=preload as=bundle src=\"secondblock.bundle\" contents=\"bloomfilter-ewroDF8352DFi35GHDDI3=\">\r\n<link rel=preload as=script src=\"secondblock_main.js\">\r\n```\r\n\r\nThe first line (with TBD details in the syntax; credit to @yoavweiss) says to preload the bundle and which other resources it contains, while the second gives the JS engine enough information to start pre-parsing. I'm not certain if the second line actually does that today, but it seems like the right thing to try first?",
          "createdAt": "2019-03-25T05:57:47Z",
          "updatedAt": "2019-03-25T05:57:47Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "Preload doesn't parse today. I also hadn't seen the `contents` attribute. Is there a spec for that?\r\n\r\nOne benefit of a bundle over preload is that the optimization can be performed at the network layer without requiring to change the HTML. This is relevant for transparent deployability in CDNs and third-party scripts that don't own the HTML.",
          "createdAt": "2019-03-25T15:38:15Z",
          "updatedAt": "2019-03-25T15:38:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@yoavweiss sketched https://docs.google.com/document/d/1Hi8SvzLEXcBY7RsaSI9MUbgehuYJnKxLO6dFvvWZ5nY/edit a while ago to suggest a way to identify which subresources should be satisfied by the bundle, but there's no more formal spec.\r\n\r\nGood point that serving a bundle in response to a `<script src=\"foo.js\">` could be a transparent optimization if we do it right.\r\n\r\nI'm still not sure it makes sense to serve the two non-critical blocks in the same bundle as the one we want to execute immediately. How would you identify that they're downloaded and ready to call? How would you kick off their execution?",
          "createdAt": "2019-03-26T11:18:42Z",
          "updatedAt": "2019-03-26T11:18:42Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "My idea was that the whole bundle gets executed immediately. (But the main\nscript could also initiate that).\n\nThe big difference in executing all scripts in a bundle vs. a single script\nis that execution can start when the first script parsed, instead of\nwaiting for everything to parse. That is because JS mandates that scripts\nwith syntax errors must not be executed at all, and so for single-script\nexecution cannot start until download has completed.\n\nOn Tue, Mar 26, 2019 at 4:18 AM Jeffrey Yasskin <notifications@github.com>\nwrote:\n\n> @yoavweiss <https://github.com/yoavweiss> sketched\n> https://docs.google.com/document/d/1Hi8SvzLEXcBY7RsaSI9MUbgehuYJnKxLO6dFvvWZ5nY/edit\n> a while ago to suggest a way to identify which subresources should be\n> satisfied by the bundle, but there's no more formal spec.\n>\n> Good point that serving a bundle in response to a <script src=\"foo.js\">\n> could be a transparent optimization if we do it right.\n>\n> I'm still not sure it makes sense to serve the two non-critical blocks in\n> the same bundle as the one we want to execute immediately. How would you\n> identify that they're downloaded and ready to call? How would you kick off\n> their execution?\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/413#issuecomment-476582405>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAFeTzgyJzaMEft82BrNcp2FCgQa8ibWks5vagISgaJpZM4cFq2h>\n> .\n>\n",
          "createdAt": "2019-03-26T20:22:06Z",
          "updatedAt": "2019-03-26T20:22:06Z"
        },
        {
          "author": "dvoytenko",
          "authorAssociation": "NONE",
          "body": "I think it'd be very reasonable to start with the main script initiating the execution of the others. Either by dropping new script tags or doing a dynamic import.",
          "createdAt": "2019-03-26T22:51:09Z",
          "updatedAt": "2019-03-26T22:51:09Z"
        }
      ]
    },
    {
      "number": 418,
      "id": "MDU6SXNzdWU0MjkyNzcwODg=",
      "title": "option to output JSON from dump-signedexchange",
      "url": "https://github.com/WICG/webpackage/issues/418",
      "state": "CLOSED",
      "author": "patrickkettner",
      "authorAssociation": "NONE",
      "assignees": [
        "hajimehoshi",
        "nyaxt",
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "Hi there!\r\nI was helping @ithinkihaveacat with some SXG tooling, and were wondering if y'all would accept a PR that would cause `dump-signedexchange` to output JSON rather than its current format (via a flag perhaps?) to help the data be easier to export. Wanted to confirm before I dive into the go code, however",
      "createdAt": "2019-04-04T13:23:41Z",
      "updatedAt": "2019-06-06T05:29:23Z",
      "closedAt": "2019-06-06T05:29:23Z",
      "comments": [
        {
          "author": "patrickkettner",
          "authorAssociation": "NONE",
          "body": "(cc @irori)",
          "createdAt": "2019-04-04T13:24:15Z",
          "updatedAt": "2019-04-04T13:24:15Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "The plan SGTM",
          "createdAt": "2019-04-04T13:30:46Z",
          "updatedAt": "2019-04-04T13:30:46Z"
        }
      ]
    },
    {
      "number": 419,
      "id": "MDU6SXNzdWU0Mjk2MjM5OTM=",
      "title": "Spec review",
      "url": "https://github.com/WICG/webpackage/issues/419",
      "state": "OPEN",
      "author": "jakearchibald",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I've been going through the spec to review its service worker interactions. Here are the questions/thoughts I had along the way:\r\n\r\n> Note that fetch()ing a new Request with the same url will not retrieve the response from the signed exchange.\r\n\r\nI don't think `fetch(event.request)` will get the signed exchange either right now. Calling `fetch(request)` calls `new Request(request)` internally, so https://fetch.spec.whatwg.org/#dom-request will need to be modified to preserve the stashed exchange.\r\n\r\nhttps://wicg.github.io/webpackage/loading.html#mp-http-fetch - I think these steps will be invoked twice if there's a service worker in the middle.\r\n\r\n1. Resource requested.\r\n1. Ask service worker for response.\r\n    1. Service worker calls `fetch(event.request)`.\r\n    1. Response is an SXG, so the steps in https://wicg.github.io/webpackage/loading.html#mp-http-fetch happen.\r\n    1. Redirect mode is \"manual\", so the redirect response is returned from the service worker.\r\n1. Response is an SXG, so the steps in https://wicg.github.io/webpackage/loading.html#mp-http-fetch happen.\r\n\r\nThis seems wrong when it comes to reporting, but maybe also bad that the SXG is parsed twice.\r\n\r\n> Set actualResponse\u2019s status to 303.\r\n\r\nIf the request was a POST request, what's the expected behaviour here? 303s will typically drop the request body from the redirected request.\r\n\r\nShould I be able to add a signed exchanged into the cache API? Right now it looks like a fetch to an SXG would create and follow the redirect, and I'd get the other-origin response rather than the SXG itself. Should the processing of SXG responses be limited to navigations?\r\n\r\n> If response is null and httpRequest\u2019s initiator is \"prefetch\" or \"preload\", return a network error.\r\n\r\nIs it odd that this happens with \"prefetch\" and \"preload\" only? Should it happen with `fetch('whatever.sxg')` too?",
      "createdAt": "2019-04-05T07:42:42Z",
      "updatedAt": "2019-04-05T07:42:42Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 420,
      "id": "MDU6SXNzdWU0MzA3Nzk3ODk=",
      "title": "Certificates for signed exchanges should be allowed also for TLS connections.",
      "url": "https://github.com/WICG/webpackage/issues/420",
      "state": "OPEN",
      "author": "sebastiannielsen",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Pending Security + Privacy Review"
      ],
      "body": "I read this in the specification:\r\n\"Clients MUST NOT accept certificates with this extension in TLS connections (Section 4.4.2.2 of [RFC8446]).\"\r\n\r\nI don't see any specific reason for this. I would suggest removing this completely from specification, and allowing content to be signed with the same certificate as for TLS connections. (provided the certificate is allowed for signed exchanges)\r\n\r\nSince a signed exchange have a very specific format, I don't see any risk with for example an site-wide XSS becoming a signing oracle for signing exchanges, unless the administrator explicitly configures the page/server in that way for some specific application. (for example a timestamping service allowing signing of arbitary data which is then time-stamped)\r\n\r\nAnother way to improve on this, is to have a special magic value for the extension, that will allow dual usage, so if the extension, instead of having the null value ( 05 00 ), have the exact octet-binary value \"BOTH\" ( 04 42 4f 54 48 ), it will allow dual usage of the certificate.\r\n\r\nThus specification could be instead:\r\n\"A conforming CA MUST NOT issue certificates with this extension unless, for each dNSName in the subjectAltName extension of the certificate to be issued:\r\nAn \u201cissue\u201d or \u201cissuewild\u201d CAA property ([RFC6844]) exists that authorizes the CA to issue the certificate; and\r\nThe \u201ccansignhttpexchanges\u201d parameter (Section 4.2.1) is present on the property and is equal to \u201cyes\u201d or \"both\".\r\nA conforming CA MUST NOT issue certificates with this extension set to \"BOTH\", unless \"cansignhttpexchanges\" is equal to \"both\".\r\n\r\nClients MUST NOT accept certificates with this extension in TLS connections, unless the extension has the exact octet-binary value BOTH ( 04 42 4f 54 48 ) (Section 4.4.2.2 of [RFC8446]).\"\r\n\r\nFor this, the cansignhttpexchanges CAA value must also be extended with a \"both\" option to allow certificates to be issued with the BOTH extension value. (if \"yes\", it will only allow NULL, but if \"both\", it will alllow both NULL and BOTH values)\r\n\r\n------\r\n\r\nI also read this:\r\n\"TLS server certificates must be accessible from online servers, so they\u2019re easier to steal or use as signing oracles than an offline key. An exchange\u2019s signing key doesn\u2019t need to be online.\"\r\n and this:\r\n\"Using an exchange-signing key in a TLS (or other directly-internet-facing) server increases the risk that an attacker can steal the private key, which will allow them to mint packages (similar to Section 6.4) until their theft is discovered.\"\r\n\r\nThis is very untrue, as most content-signing servers will of course be directly internet-facing. A majority of server operators will just configure their servers to sign static content when requested, or possibly with a client whitelist (like cloudflares IPs) to prevent it from signing content for others.\r\nThus their CanSignHttpExchanges certificate will in most cases, reside side-with-side with their TLS certificate in the same folder on the same machine.\r\n\r\nOnly more sensitive and advanced companies will make content-signing servers airgapped.\r\n\r\nThe only way to enforce secure usage of such a certificate and make sure its \"airgapped\", is to require it to be loaded on a secure element with presence validation. This is a requirement imposed by most CA's for sub-CA certificates.\r\n\r\nThe only risk I see with completely dropping the restriction, is that a stolen content-signing certificate could be used to host a TLS server used for example phishing attacks and such.\r\n\r\nThats why it might be good to instead use the proposed NULL and BOTH values, so theres 3 types of certificates:\r\n1: Certificates ONLY valid for TLS connections.\r\n2: Certificates valid for BOTH.\r\n3: Certificates ONLY valid for Signed-exchanges.\r\n\r\nthus a server operator is able to choose the security level that fits them best.",
      "createdAt": "2019-04-09T05:55:03Z",
      "updatedAt": "2019-05-29T16:57:04Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Would it be possible to explain why it is desirable?\n\nCross-protocol attacks have caused a number of severe security issues - as\ndemonstrated by things as \u201csimple\u201d as between QUIC and TLS or TLS1.3 vs\nTLS1.2. Just as these protocols admonish users to make use of separate keys\nand identities, it seems there is no significant benefit, compared to the\nsignificant risk it introduces to users.\n\nFurthermore, ensuring key separation helps encourage better key hygiene for\nthe purposes being used. This is similar to the discussion of TLS Delegated\nCredentials, in that separating online and offline key pairs, via distinct\ntechnical capability, is highly desirable.\n\nFinally, given that SXGs, as a general technology, come with new trade offs\nand risks with respect to impersonation (if the key is compromised), the\nexplicit extension also serves to ensure direct and affirmative consent by\nthe site to use SXGs (e.g. via the CAA check)\n\nAs such, the use of the extension plays a critical and essential, perhaps\nirreplaceable, role in the overall security of SXG. It would have to be\ndemonstrated a significant and serious benefit to consider removing, and\nnecessary to introduce comparable security measures. Perhaps the spec can\nmake it clearer why this is such an essential property, so that proposals\nto remove it can be accompanied with the same thorough and thoughtful\nsecurity mitigations.\n",
          "createdAt": "2019-04-09T11:39:50Z",
          "updatedAt": "2019-04-09T11:39:50Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "1: My stance on it, is that its up to the server administrator if they want to share keys should be able to do that.\r\n\r\n2: I didn't say that the extension should be removed. What I said, is that the limitation where a certificate with said extension cannot be used as a TLS server certificate, should be removed.\r\nThe extension is good and need to be there, as SGX creates new risks.\r\n\r\nHowever, another solution is to extend the extension with the BOTH/NULL alternatives, so the ability of the certificate can be gated into \"Only TLS\", \"BOTH\" and \"Only SGX\", with accompanying CAA checks, so the server administrator can choose exactly how he wants to do it.",
          "createdAt": "2019-04-09T11:59:04Z",
          "updatedAt": "2019-04-09T11:59:04Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "On Tue, Apr 9, 2019 at 7:59 AM Sebastian Nielsen <notifications@github.com>\nwrote:\n\n> 1: My stance on it, is that its up to the server administrator if they\n> want to share keys should be able to do that.\n>\n\nIt\u2019s unclear. Are you disagreeing that there are fundamental cryptographic\ncross-protocol risks introduced by the reuse of keys in unrelated\nprotocols? It is basic cryptographic practice to ensure that unrelated\nprotocols should use unrelated keys. While significant effort has been made\nto reduce the cross-protocol confusion, the prohibition serves as a\ncritical and essential safety margin.\n\nCould you help explain the concern/motivation more? It\u2019s unclear whether\nthis is motivated by a concern of simply obtaining an additional\ncertificate, or whether there is some other consideration at play.\n",
          "createdAt": "2019-04-09T12:08:18Z",
          "updatedAt": "2019-04-09T12:08:18Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "No im not disagreeing with it.\r\n\r\nYes I do understand there need to exist a safety margin, but the final authority of a domain, should be able to decide if that safety margin should be in effect or not.\r\n\r\nThe advantage of being able to use the same certificate for more tasks, is multi-fold.\r\nFirst, by having lesser amount of keys and certificates in system, the certificates and keys can be secured more, and lesser management overhead.\r\n1: If its the same server serving both normal TLS content and SGX content, theres no security gain in having 2 certificates and 2 keys on the same machine.\r\n2: If you use a HSM or crypto accelerator that only supports one key and/or chain, it would be preferable to be able to use that.\r\n3: If the CA charges for certificates, having 2 certificates would of course incur additional costs than 1 certificate.",
          "createdAt": "2019-04-09T12:31:26Z",
          "updatedAt": "2019-04-09T12:31:26Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "On Tue, Apr 9, 2019 at 8:31 AM Sebastian Nielsen <notifications@github.com>\nwrote:\n\n> No im not disagreeing with it.\n>\n> Yes I do understand there need to exist a safety margin, but the final\n> authority of a domain, should be able to decide if that safety margin\n> should be in effect or not.\n>\n\nUltimately, the User Agent is responsible for ensuring the user\u2019s security\nneeds are met, above and beyond what domain holders may wish.\n\nThis is why User Agents disable SHA-1 or 1024-but RSA keys, or denote\ncertain powerful features to HTTPS. Yes, a domain operator may be\ninterested in setting their security policies lower, but such desire is\ncounter to the security of users needs.\n\nThe advantage of being able to use the same certificate for more tasks, is\n> multi-fold.\n> First, by having lesser amount of keys and certificates in system, the\n> certificates and keys can be secured more, and lesser management overhead.\n>\n\nThis does not seem to logically follow. Given that TLS keys are online,\nwhile SXG keys are inherently offline, coupling these two functionally\nreduces the security of the system and users. Every operation involving\nsuch shared keys needs to fully consider both protocols, causing more\nmanagement overhead.\n\n1: If its the same server serving both normal TLS content and SGX content,\n> theres no security gain in having 2 certificates and 2 keys on the same\n> machine.\n>\n\nThis does not logically follow. With SXG, there is no technical need to\ninstall keys on the server. Such a thing would seem counter to best\npractice.\n\n2: If you use a HSM or crypto accelerator that only supports one key and/or\n> chain, it would be preferable to be able to use that.\n>\n\nAre you aware of any such products? I have yet to encounter one in my\ncareer. In general, HSMs are unable to be deployed for TLS at scale, as\nmodern HSMs and \u201caccelerators\u201d (more of a 90s concept) are unable to\nperform signatures at the pace of modern large scale deployments. On the\nother hand, SXGs, and their infrequent signatures, absolutely make these\ntechnologies viable again for key protection.\n\n3: If the CA charges for certificates, having 2 certificates would of\n> course incur additional costs than 1 certificate.\n>\n\nI agree that this is a possibility, but it\u2019s not a technological concern.\nYou can choose CAs, for example, that do not charge for certificates at\nall, or which charge for validations (which both types of certificates can\nbe issued from a single validation). I totally understand and appreciate\nthe concern here - it\u2019s one introduced whenever anything involving\ncertificates is used - but it does not seem necessary to weaken the\ncryptographic security in order to address. As demonstrated by current and\npast CA practices, it also seems to be a practice going out of vogue and\nmore hypothetical?\n\n>\n",
          "createdAt": "2019-04-09T12:44:36Z",
          "updatedAt": "2019-04-09T12:44:36Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "1: I agree about the user agent responsible for end user security, and of course it should restrict certain sensitive features to HTTPS.\r\n\r\nBut in my opinion, the user agent should not put any restrictions on how the server operator may manage their keys and certificates.",
          "createdAt": "2019-04-09T12:58:18Z",
          "updatedAt": "2019-04-09T12:58:18Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Do we agree that User Agents already place restrictions on how servers\nmanage their keys (e.g. no 1024-bit) and certificates (e.g. expiration\npolicies, weak signatures)? This does not seem to be a change from the\nstatus quo.\n\nWe seem to be in agreement that an SXG key is more valuable than a TLS key,\ndue to the ability to mount off-path attacks, so it seems there\u2019s clear\njustification for putting stronger protection requirements on the SXG key.\nThose requirements are incompatible with TLS, due to TLS requiring online\nsigning.\n\nAssuming we had a technology which allowed a TLS key to be protected to\nthat same level, such as TLS Delegated Credentials proposes (moving the TLS\nkey offline, in favor of ephemeral assertions), then we also seem to be in\nagreement that there are still fundamental cryptographic reasons to keep\nkey material separate, to defend against cross-protocol attacks.\n\nI don\u2019t mean to dismiss the feedback, but to walk through how the\nconclusion was reached - which is that it is essential to the security of\nend users to ensure a TLS server does not reuse an SXG key. While of course\nsuch thing is possible by virtue of a CA issuing two certificates for the\nsame key - such a thing should be seen as a security vulnerability, rather\nthan an expected or accepted practice.\n",
          "createdAt": "2019-04-09T13:06:26Z",
          "updatedAt": "2019-04-09T13:06:26Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "I don't agree with the assertion that SXG key is strictly more valuable than a TLS key. An attacker that has possession of a TLS key can perform a MITM attack that steals authentication credentials such as cookies, while an attacker in possession of an SXG certificate can only display arbitrary content as the site owner. In some respects, being able to MITM TLS is a more powerful attack.\r\n\r\nWith that said, not all clients will implement the MUST NOT. This means that there will be a risk that a compromised SXG certificate can be used to MiTM a TLS connection, just not with Chrome. This puts all users of non-conforming browsers at risk.\r\n\r\nWhat is the point of adding this restriction to not allow TLS with the certificate if the extension is not marked critical? It seems to only protect users of conforming browsers while exposing other users to risk. I understand this has been discussed before (https://github.com/WICG/webpackage/issues/238) but it's not clear the conclusions still hold given that a large percentage of user agents that will not be updated to respect this MUST NOT.\r\n\r\nIn my opinion, this spec should be non-discriminatory and pick a side. Either SXG certificates should be permitted for use in TLS (maintaining the legacy browser behavior), or certificates should be forbidden to be used for TLS and the extension made critical (to protect the users of legacy browsers).\r\n\r\nI'm not swayed by the argument that just because some TLS clients use system PKI validators, that this extension should not be made critical. This is a big change to how the PKI is used and clients who want to support it should make correct validation of the certificate a requirement on platforms they run on. Fudging this with a MUST NOT that will only be used for a subset of clients does not improve the situation.",
          "createdAt": "2019-05-02T22:45:19Z",
          "updatedAt": "2019-05-02T22:45:19Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't agree with the assertion that SXG key is strictly more valuable than a TLS key. An attacker that has possession of a TLS key can perform a MITM attack that steals authentication credentials such as cookies, while an attacker in possession of an SXG certificate can only display arbitrary content as the site owner. In some respects, being able to MITM TLS is a more powerful attack.\r\n\r\nIn a web context, an attacker that can display arbitrary content as the site owner can, in turn, run arbitrary JS as the site owner. That allows them to read credentials for that origin, make credentialed requests as that origin, etc.",
          "createdAt": "2019-05-02T23:44:07Z",
          "updatedAt": "2019-05-02T23:44:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've been convinced that neither SXG keys nor TLS keys are strictly more powerful than the other, especially since we're talking in #376 and elsewhere of checking SXG contents against a live TLS connection. The difference in power is complicated and probably not too helpful in deciding this particular issue.\r\n\r\nI think @sebastiannielsen is right that many servers will put their SXG key on the same internet-facing server as their TLS key, unless we require it to be on a secure element, which I suspect will limit adoption too much.\r\n\r\nHowever, I'm also sympathetic to @sleevi's point that we want a buffer around the possibility of cross-protocol attacks. Especially since the SXG signed-message format is still evolving, I don't want to accidentally enable cross-protocol attacks in a future update, after we've allowed the keys to be used for TLS servers. On the other hand, it seems like it'll be easy to enable TLS use later, using the mechanism @sebastiannielsen suggests, once the format has settled down.\r\n\r\nOn the third hand, @grittygrease is right that not all clients will implement the MUST NOT, and so we have to be careful about cross-protocol attacks during the SXG evolution anyway, so maybe we should make that explicit by allowing use for TLS.",
          "createdAt": "2019-05-03T00:05:34Z",
          "updatedAt": "2019-05-03T00:05:34Z"
        },
        {
          "author": "sebastiannielsen",
          "authorAssociation": "NONE",
          "body": "@sleevi Also the reason to drop SHA-1 certificates, is not about key management or security of a single website. Its more about the security of ALL websites.\r\nBecause, a malicious actor could, with a valid SHA-1 certificate, be able to generate another such, with hash collision, to be valid to for example github.com or google.com\r\n\r\nSo even if one single website would be allowed to use SHA-1 certificates, it would hurt the security of all websites.\r\nIn the same way, most (if not all) CA's require sub-CA keys to be on a secure element, just because if one such leaks, ALL websites will be in danger, even a website that doesn't use that sub-CA.\r\n\r\nThat doesn't stand for TLS/SGX certificates. Even if I would publish the private key for my certificate to my website, it wouldn't hurt the security for any other website than mine.\r\n\r\nThus any cross-protocol attacks, if found, would only affect those websites that do use the same certificate for TLS and SGX.\r\n\r\nThus I stand my position on that the website administrator should be in full control of if a certificate should be allowed for either TLS, SGX or both.\r\nAlso there should possible be some mechanism preventing CA's from charging extra for SGX-enabled certificates, maybe in some baseline requirements or something.\r\nCurrently its one certificate each - and you also have to submit 2 full validations with papers and pay everything for most CA's (it was just StartSSL that did have the concept with a \"validation\" being valid for multiple certificates) - now Im talking about organizational certificates and not domain-only certificates.\r\n\r\nIf you had both certificates combined into one, you would only need to submit everything once - and only pay once. Some CA's might then charge extra for a combined cert because they know you save on not having to get 2 certificates, and there should be some mechanism preventing this, possible in baseline requirements.",
          "createdAt": "2019-05-03T05:38:45Z",
          "updatedAt": "2019-05-03T05:38:45Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Let's avoid the question of how much CAs charge for certificates here.",
          "createdAt": "2019-05-03T21:02:09Z",
          "updatedAt": "2019-05-03T21:02:09Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "On Fri, May 3, 2019 at 1:38 AM Sebastian Nielsen <notifications@github.com>\nwrote:\n\n> @sleevi <https://github.com/sleevi> Also the reason to drop SHA-1\n> certificates, is not about key management or security of a single website.\n> Its more about the security of ALL websites.\n> Because, a malicious actor could, with a valid SHA-1 certificate, be able\n> to generate another such, with hash collision, to be valid to for example\n> github.com or google.com\n>\n\n1024-bit certificates, then.\n\n<http://google.com>\n>\n> Thus I stand my position on that the website administrator should be in\n> full control of if a certificate should be allowed for either TLS, SGX or\n> both.\n>\n\nUser agents priorities dictate that the user comes first. Poor security\npractices by a website jeopardize user security. This is similar to UAs\nhaving policies about which ciphersuites in TLS they support, which CAs\nthey support, or even requiring TLS at all for certain features.\n\nArguments in favor of web developers need to consider risks to users, both\nfrom that of a single site and from an ecosystem perspective if all sites\nadopted that.\n\nThe key management issues highlight a significant change, just as the work\nproposed for Secondary Certificates would significantly alter the TLS key\nrisks.\n",
          "createdAt": "2019-05-03T21:21:35Z",
          "updatedAt": "2019-05-03T21:21:35Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi I'm mostly convinced by @grittygrease's argument that since we don't want to make the extension critical (doing so would prevent Chrome from adopting), any protocol confusion attacks put the users of non-adopting browsers at risk, and so we should allow use of SXG certs for TLS in order to make sure we pay attention to preventing protocol confusion attacks. How are you feeling about that argument?",
          "createdAt": "2019-05-03T21:45:48Z",
          "updatedAt": "2019-05-03T21:45:48Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I don\u2019t find it a particularly compelling argument for removing any\nprotections. I also don\u2019t deny the current design is significantly weaker\nthan desirable, from a security POV.\n\nDuring the design, we discussed other ways we could mitigate the risk. The\ncurrent design was chosen to favor the ease of adoption for CAs, but since\nit seems there\u2019s concern that it may not be sufficient, we should revisit\nthose designs.\n\nFor example, we discussed previously the use of EKUs, much in the same way\nCode signing and TLS certificates are distinguished. This requires CAs\nperform new issuance ceremonies for intermediates, before they can issue\nSXG certificates, but also allows for reliable and interoperable\nenforcement between SXG supporting clients and those that don\u2019t.\n",
          "createdAt": "2019-05-03T21:56:13Z",
          "updatedAt": "2019-05-03T21:56:13Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "@jyasskin @sleevi Is there a timeline for moving the PKIX components of Chrome from the OS into the browser? Doing so would allow this extension to be marked as critical, which would go a long way towards solving this issue.",
          "createdAt": "2019-05-29T16:04:45Z",
          "updatedAt": "2019-05-29T16:04:45Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "The decision here was not based solely on Chrome. This is an issue\nvirtually every implementation will face.\n",
          "createdAt": "2019-05-29T16:35:32Z",
          "updatedAt": "2019-05-29T16:35:32Z"
        },
        {
          "author": "grittygrease",
          "authorAssociation": "NONE",
          "body": "Once the underlying PKIX packages on the OS are updated, this should no\nlonger be an issue, right? Or are you indicating that there is a broader\npattern that makes extensions that introduce new security risks difficult\nto make critical?\n\nOn Wed, May 29, 2019 at 9:35 AM sleevi <notifications@github.com> wrote:\n\n> The decision here was not based solely on Chrome. This is an issue\n> virtually every implementation will face.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/420?email_source=notifications&email_token=ABHDHZ3LLZNNARYQYSKJUIDPX2WFVA5CNFSM4HEOU6G2YY3PNVWWK3TUL52HS4DFVREXG43VMVBW63LNMVXHJKTDN5WW2ZLOORPWSZGODWP5FLQ#issuecomment-497013422>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/ABHDHZ25U3OO7EPVXJMARYTPX2WFVANCNFSM4HEOU6GQ>\n> .\n>\n",
          "createdAt": "2019-05-29T16:39:15Z",
          "updatedAt": "2019-05-29T16:39:15Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "A design which forces the extension critical forces an implementation decision for UAs to either:\r\n  * Lock the UAs/consumers to the OS version, and either only update them in sync, or only make functionality available on certain OSes for these externalized reasons. This is often bad for the Web and for users, especially given the update cadence of OS vs browsers.\r\n  * Force implementors (which, in the case of SXG, is intended to be more than 'just' browsers) to ship their own PKI library, which is often a net-negative for user security [in the aggregate](https://crypto.stanford.edu/~dabo/pubs/abstracts/ssl-client-bugs.html), and a significant implementation cost.\r\n\r\nI think the comment in https://github.com/WICG/webpackage/issues/420#issuecomment-488858875 is making an implicit, but unsupported, assumption that an SXG certificate is at greater risk of compromise than a TLS certificate, and that therefore disadvantages legacy clients if that key is compromised because it can be used in MITM. It's unsupported, because SXG-supporting clients would be at just as much (if not greater) risk of malicious SXGs, and thus the assumption that SXG would encourage laxer key hygiene isn't actually explained. It also ignores the other benefits of having the explicit extension and signal, and doesn't explain or justify why using it in TLS is desirable or useful, other than it would avoid having to think about key protection - which is exactly what the extension is trying to force contemplation of (among other things).",
          "createdAt": "2019-05-29T16:57:04Z",
          "updatedAt": "2019-05-29T16:57:04Z"
        }
      ]
    },
    {
      "number": 421,
      "id": "MDU6SXNzdWU0MzM1NTIyODA=",
      "title": "dump-signedexchange should decode mice payload",
      "url": "https://github.com/WICG/webpackage/issues/421",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "`dump-signedexchange` tool currently output raw MICE payload to stdout.\r\nWe should provide an option to decode+check integrity of MICE payload, and that should be the default behavior.\r\n\r\n@hajimehoshi are you interested in owning this?",
      "createdAt": "2019-04-16T02:14:41Z",
      "updatedAt": "2019-04-16T03:00:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually `dump-signedexchange` decodes MICE if `-verify` is given. It would be useful if MICE is decoded by default, though.",
          "createdAt": "2019-04-16T03:00:37Z",
          "updatedAt": "2019-04-16T03:00:37Z"
        }
      ]
    },
    {
      "number": 422,
      "id": "MDU6SXNzdWU0MzUwMDc4NzU=",
      "title": "Avoiding Built-In Tracking in Signed Packages",
      "url": "https://github.com/WICG/webpackage/issues/422",
      "state": "OPEN",
      "author": "johnwilander",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi! John Wilander from Apple's WebKit team here.\r\n\r\nWe are concerned with the privacy implications of User A and user B not getting the same package when they load the same webpage, or to put it another way, **personalized signed packages with cross-site tracking built in.**\r\n\r\n## Threat Model\r\n\r\n### The Actors\r\n\r\n* **The user.** This is the human who relies on the user agent to protect their privacy.\r\n* **The user agent.** This is the web browser that tries to protect the user's privacy.\r\n* **AdTech or adtech.example.** This is a website that the user engages with as first-party site and that has a financial interest in 1) knowing what the user does on other websites to augment its rich profile of the user and 2) individual targeting of ads, based on its rich profile of the user.\r\n* **News or news.example.** This is a news website which wants its articles to be served as signed packages with the user agent's URL bar showing news.example.\r\n\r\n### The Threat\r\n\r\n1. The user does not want AdTech to be able to augment its profile of them while reading articles on news.example.\r\n2. The user does not want AdTech's rich profile of them to influence the content of ads or articles on news.example.\r\n\r\n### The Attack\r\n\r\nThis is how AdTech could foil the user agent's privacy protections with the current signed packages proposal:\r\n\r\nNews wants to take part in signed package loading but thinks the actual packaging is cumbersome and costly in terms of engineering resources.\r\n\r\nAdTech has a financial incentive to help News get going with signed packages because the technology makes AdTech's services better. Because of this incentive, AdTech decides to offer News a more convenient way to do the packaging; it offers to pull unsigned articles directly from News's servers and do packaging for them. News just has to set up a signing service that AdTech can call to get signatures back, or just hand a signing key straight to AdTech. News sees the opportunity to reduce cost and takes the offer.\r\n\r\nAdTech also has a financial incentive to identify the user on news.example to augment its profile of the user and to earn extra money by serving the user individually targeted ads, but it can't do so because the user's user agent is protecting the user's privacy. However, the request to get a signed News package is actually made to adtech.example, containing the user's AdTech cookies. To achieve their goals and earn more money, AdTech's decides to create news.example packages on the fly, bake in individually targeted ads plus an AdTech user ID for profile enrichment, and sign the whole thing with News's key.\r\n\r\nThis is a case of cross-site tracking. The user is on a news.example webpage, convinced that their user agent protects them from AdTech tracking them on this site, but instead they got a signed package with tracking built in.\r\n\r\n### How the Attack Relates To Other Means of Cross-Site Tracking\r\n\r\nOften when we criticize new, technically distinct tracking vectors, we are told that \u201cyou can track users in so many ways so why care about this one?\u201d In the case of signed packages we hear about means of tracking such as doctored links where cross-site tracking is built into the URL, or server-side exchanges of personally identifiable information such as users' email addresses.\r\n\r\nFirst, we don't think past mistakes and flaws in web technologies is a valid argument for why new web technologies should enable cross-site tracking.\r\n\r\nSecond, WebKit is working hard to prevent cross-site tracking, including new limits and restrictions on old technologies. Piling on more such work is not acceptable to us.\r\n\r\nFinally, the success of new web technologies such as signed packages relies on better security and privacy guarantees than what we've had in the past. We want progression in this space, not the status quo.\r\n\r\n## Potential Mitigations and Fixes\r\n\r\nA mitigation we'd like to discuss is this:\r\n\r\n1. The server responding with the signed package is required to send the signature up front. This is to incentivize AdTech to not sign other websites' packages on the fly.\r\n2. The user agent makes an ephemeral, cookie-less preflight request to news.example to get the signature and then validates the package from adtech.example against that signature.\r\n3. We add a signed time stamp to the package signature to avoid AdTech telling News to get signatures from adtech.example backend and send personalized signatures back as preflight responses. With such time stamps, the user agent can decide to not accept signatures younger than, say one minute. For this to work we need signed, official time.\r\n\r\nThe above scheme would make it significantly harder to \u201cpersonalize\u201d packages.\r\n\r\nAnother potential mitigation would be some kind of public repository of signatures to check against.\r\n",
      "createdAt": "2019-04-19T00:26:44Z",
      "updatedAt": "2019-04-24T22:44:15Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Thanks for filing this John!\n\nI had one quick question regarding the original proposal - the suggestion\nof a signed timestamp seems to introduce a trusted third party to the\nnegotiation, the timeserver. Do you have any sense or thought as to who\nwould operate such a timeserver, or how a U-A would select such a thing, as\nit seems like it could either lie (if using a simple time signing protocol)\nor collude with adtech.example (if using a more robust protocol, like\nRoughtime)\n",
          "createdAt": "2019-04-19T01:05:33Z",
          "updatedAt": "2019-04-19T01:05:33Z"
        },
        {
          "author": "kevinsimper",
          "authorAssociation": "NONE",
          "body": "@sleevi Trusted time could be provided by a blockchain, that would allow something that can't be tampared. \r\n\r\n@johnwilander Could content-addressable be regarded as a potential solution as well? By using that solution you could verify by third-party that you didn't get something customized, as yours would be different than everyone else. \r\n",
          "createdAt": "2019-04-19T05:38:59Z",
          "updatedAt": "2019-04-19T05:38:59Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> @sleevi <https://github.com/sleevi> Trusted time could be provided by a\r\n> blockchain, that would allow something that can't be tampared.\r\n>\r\n\r\nThanks for the reply!\r\n\r\n\r\nI think it would probably be more productive if we avoid abstract\r\ntechnology hypotheticals, and instead focus on concrete or actual\r\nsolutions. The problem with abstractions is that they largely tend to punt\r\nthe problem being discussed onto the abstraction, rather than providing a\r\nsolution themselves. That is, \u201cimagine if we had a perfect X that didn\u2019t\r\nhave problem Y\u201d doesn\u2019t quite solve for Y, and now we also have to solve\r\nfor X to find an actual X with that property \ud83d\ude05\r\n\r\n\r\nMy previous question acknowledges the possibility of the use of Merkle\r\nTrees as a basis for time, by focusing on an actual time protocol (that\u2019s\r\nwhat Roughtime is), and then discusses actual challenges with it that would\r\nstill exist, as a way of trying to better understand the actual\r\nrequirements. Collusion by adtech.example is an (extreme) possibility, and\r\nthus it seemed important to understand the requirements here, since it\r\nseemed like there might be some unstated requirements hidden between that\r\nlast bullet point. \ud83e\udd14\r\n\r\n\r\n> @johnwilander <https://github.com/johnwilander> Could content-addressable\r\n> be regarded as a potential solution as well? By using that solution you\r\n> could verify by third-party that you didn't get something customized, as\r\n> yours would be different than everyone else.\r\n>\r\n\r\n\r\nCould you explain how you see this working? Content-addressable storage\r\ndoesn\u2019t actually provide the guarantee you stated, at least as commonly\r\nunderstood by how CAS works. Indeed, one can view the existing SXG proposal\r\nas functionally CAS with an attached signature.\r\n\r\n\r\nIf you mean something like a peer-to-peer distribution network, using\r\nthings like DHT or the like, none of the existing technologies seem to\r\nprovide that guarantee. Understanding a bit more about what is meant by\r\nthis question helps better understand what you see the provided properties\r\nas.\r\n\r\n\r\nIf the suggestion is to use a Trusted Third Party and report the hash you\r\nsee, that of course comes with serious privacy concerns for the end user -\r\nit adds yet another way to see what the user is doing. It also introduces a\r\ncentralized censorship mechanism, by coercing the TTP to lie about whether\r\nit has seen a package, and thus preventing it from loading. However, one\r\ndoesn\u2019t typically think of a TTP as being CAS.\r\n\r\n\r\nThis is why I focused on trying to understand the proposal itself first, to\r\nmake sure we don\u2019t rabbit hole on such challenges until we\u2019re all on the\r\nsame page with base understanding \ud83d\ude03\r\n",
          "createdAt": "2019-04-19T10:45:30Z",
          "updatedAt": "2019-04-19T10:52:47Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "body": "> Thanks for filing this John! I had one quick question regarding the original proposal - the suggestion of a signed timestamp seems to introduce a trusted third party to the negotiation, the timeserver. Do you have any sense or thought as to who would operate such a timeserver, or how a U-A would select such a thing, as it seems like it could either lie (if using a simple time signing protocol) or collude with adtech.example (if using a more robust protocol, like Roughtime)\r\n\r\nHi Ryan!\r\n\r\nSigned, trusted time is a Hard Thing, at least the last time I dug into it. It even plays into human culture where citizens of some countries would trust the government to issue such timestamps and others would rather have an independent non-profit do it.\r\n\r\nI do not have a ready solution. But there seems to be a few interested parties who want these signed exchanges, Google and Cloudflare being two. Maybe these parties can propose a solution that we can review? Even if we don't achieve a perfect solution, something transparent and explicitly designed to prohibit abuse may be enough to instill (more) trust in this technology.\r\n\r\nThere is at least one more benefit of signed, trusted timestamps in these packages and that is the ability to audit when content was created. A temporary compromise of News's publishing apparatus could issue fake news and then push that news to a micro targeted audience to sway public opinion \"dark ads\"-style. Trustworthy timestamps in packages would at least allow for an audit after the fact. Or if abuse gets really ugly, user agents could support things like \"News was compromised between TimeA and TimeB and doesn't know what was published and signed under its name during that time. Therefore all News packages signed between TimeA and TimeB are blocked.\"",
          "createdAt": "2019-04-19T15:07:43Z",
          "updatedAt": "2019-04-19T15:08:31Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> I do not have a ready solution. But there seems to be a few interested parties who want these signed exchanges, Google and Cloudflare being two. Maybe these parties can propose a solution that we can review? Even if we don't achieve a perfect solution, something transparent and explicitly designed to prohibit abuse may be enough to instill (more) trust in this technology.\r\n\r\nI definitely think it's something worth discussing, and I'm wanting to make sure to tease out the requirements a bit more up front, so we can find something workable.\r\n\r\nYou mentioned trusted time, which evokes protocols like [Roughtime](https://roughtime.googlesource.com/roughtime) (which, incidentally, Cloudflare [also supports](https://blog.cloudflare.com/roughtime/) ). However, the 'trusted' part of that time is achieved by having the Roughtime client send a random 'nonce', and that doesn't seem like a good fit here, for a number of reasons.\r\n\r\nFrom the threat model described, my understanding of how the suggested mitigation would work is that sounds like you're talking more-so about a Time-Stamping authority - some third-party (or set of third-parties) to attest that, at a given time, it was aware of a given hash. Does that sound roughly correct?\r\n\r\nTypically, these sorts of approaches imply direct trust in the TSA to always be honest. I was trying to understand how much or how little of your threat model included the TSA as a bad actor - for example, understanding whether or not the threat includes `adtech.example` colluding with (or operating their own) time-stamping authority. If the threat model is considering this, what sort of mitigations would be seen as acceptable versus unacceptable, to help inform possible solutions?\r\n\r\nFor example, if the idea is Apple (or other UAs) would select a TSA and explicitly trust it, say, using business controls like audits - an approach Mozilla is taking with their selection of [trusted recursive resolvers](https://blog.nightly.mozilla.org/2018/06/01/improving-dns-privacy-in-firefox/) - then there are simpler options with very little technical complexity, because it's addressed by the business controls. However, if the idea is that there should be zero trust in the trusted time server, except that which can be proved mathematically, then that would require much more complex solutions, which haven't yet been solved for related areas.\r\n\r\n> There is at least one more benefit of signed, trusted timestamps in these packages and that is the ability to audit when content was created. A temporary compromise of News's publishing apparatus could issue fake news and then push that news to a micro targeted audience to sway public opinion \"dark ads\"-style. Trustworthy timestamps in packages would at least allow for an audit after the fact. Or if abuse gets really ugly, user agents could support things like \"News was compromised between TimeA and TimeB and doesn't know what was published and signed under its name during that time. Therefore all News packages signed between TimeA and TimeB are blocked.\"\r\n\r\nI think this would be best discussed in a separate issue, and understanding the use case more. It seems that there are several use cases mixed up in here, such as repudiation (or revocation) and transparency. Given that almost every technical solution to these sorts of use cases introduces negative effects, they're likely topics in themselves, and worth tracking as such. For example, repudiation/revocation (the compromise scenario described) has commonly enabled greater centralization and censorship, and the transparency aspect comes at significant cost to user privacy (the ability to say \"I know you read/published targeted article X\").\r\n\r\nI don't want to lose sight of these, but also don't want to miss out on the big picture here, so if you have a write-up for these use cases and could file them as new issues, I think we'd be happy to engage. I'm not sure I understand your specific goals there well enough to do it myself :)",
          "createdAt": "2019-04-19T15:48:39Z",
          "updatedAt": "2019-04-19T15:49:12Z"
        },
        {
          "author": "nminnov",
          "authorAssociation": "NONE",
          "body": "> I definitely think it's something worth discussing, and I'm wanting to make sure to tease out the requirements a bit more up front, so we can find something workable.\r\n\r\nAgree that the requirements need to be understood and appreciated before discussing the \"how\". Would you agree that:\r\n- \"The Threat\" as described is indeed a threat to privacy\r\n- the threat needs to be addressed",
          "createdAt": "2019-04-19T22:00:34Z",
          "updatedAt": "2019-04-19T22:00:34Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "body": "> > I do not have a ready solution. But there seems to be a few interested parties who want these signed exchanges, Google and Cloudflare being two. Maybe these parties can propose a solution that we can review? Even if we don't achieve a perfect solution, something transparent and explicitly designed to prohibit abuse may be enough to instill (more) trust in this technology.\r\n> \r\n> I definitely think it's something worth discussing, and I'm wanting to make sure to tease out the requirements a bit more up front, so we can find something workable.\r\n> \r\n> You mentioned trusted time, which evokes protocols like [Roughtime](https://roughtime.googlesource.com/roughtime) (which, incidentally, Cloudflare [also supports](https://blog.cloudflare.com/roughtime/) ). However, the 'trusted' part of that time is achieved by having the Roughtime client send a random 'nonce', and that doesn't seem like a good fit here, for a number of reasons.\r\n> \r\n> From the threat model described, my understanding of how the suggested mitigation would work is that sounds like you're talking more-so about a Time-Stamping authority - some third-party (or set of third-parties) to attest that, at a given time, it was aware of a given hash. Does that sound roughly correct?\r\n\r\nYes.\r\n\r\n> Typically, these sorts of approaches imply direct trust in the TSA to always be honest. I was trying to understand how much or how little of your threat model included the TSA as a bad actor - for example, understanding whether or not the threat includes `adtech.example` colluding with (or operating their own) time-stamping authority. If the threat model is considering this, what sort of mitigations would be seen as acceptable versus unacceptable, to help inform possible solutions?\r\n\r\nAdTech operating the TSA sounds problematic. But a shared TSA, funded/controlled/audited by multiple stakeholders could probably work. Also transparency will work in our favor here. It should be easy to check the integrity of the TSA, not just for UAs but for anyone.\r\n\r\n> For example, if the idea is Apple (or other UAs) would select a TSA and explicitly trust it, say, using business controls like audits - an approach Mozilla is taking with their selection of [trusted recursive resolvers](https://blog.nightly.mozilla.org/2018/06/01/improving-dns-privacy-in-firefox/) - then there are simpler options with very little technical complexity, because it's addressed by the business controls. However, if the idea is that there should be zero trust in the trusted time server, except that which can be proved mathematically, then that would require much more complex solutions, which haven't yet been solved for related areas.\r\n\r\nHaving not discussed the TSA issue in detail with my team, I'd say zero trust is not a must to get something on the table for serious review.\r\n\r\n> \r\n> > There is at least one more benefit of signed, trusted timestamps in these packages and that is the ability to audit when content was created. A temporary compromise of News's publishing apparatus could issue fake news and then push that news to a micro targeted audience to sway public opinion \"dark ads\"-style. Trustworthy timestamps in packages would at least allow for an audit after the fact. Or if abuse gets really ugly, user agents could support things like \"News was compromised between TimeA and TimeB and doesn't know what was published and signed under its name during that time. Therefore all News packages signed between TimeA and TimeB are blocked.\"\r\n> \r\n> I think this would be best discussed in a separate issue, and understanding the use case more. It seems that there are several use cases mixed up in here, such as repudiation (or revocation) and transparency. Given that almost every technical solution to these sorts of use cases introduces negative effects, they're likely topics in themselves, and worth tracking as such. For example, repudiation/revocation (the compromise scenario described) has commonly enabled greater centralization and censorship, and the transparency aspect comes at significant cost to user privacy (the ability to say \"I know you read/published targeted article X\").\r\n\r\nI hesitated bringing up the auditing+dark ads case because, as you say, it's a separate issue. I just wanted to mention it here to make it clear that trusted time stamps might have other benefits too.\r\n\r\n> I don't want to lose sight of these, but also don't want to miss out on the big picture here, so if you have a write-up for these use cases and could file them as new issues, I think we'd be happy to engage. I'm not sure I understand your specific goals there well enough to do it myself :)\r\n\r\nI'll hold off for now to make sure that the cycles I have to spare are spent on this issue here. :)",
          "createdAt": "2019-04-19T22:21:37Z",
          "updatedAt": "2019-04-19T22:21:37Z"
        },
        {
          "author": "frivoal",
          "authorAssociation": "NONE",
          "body": "Unless, I am missing something, this boils down to \"if you hand someone your private keys, they can impersonate you while doing things you wouldn't\". Right?\r\n\r\nIf I understand correctly, the atracks that this enables seem already possible when handing your private keys to a CDN so that it can do https on your behalf.\r\n\r\nAs you said in the initial post, just because a similar attack already exists doesn't mean we shouldn't do anything about it. So I am absolutely in favor of mitigating this if we can.\r\n\r\nHowever, I think it is worth considering what happens if we cannot. On balance, it seems to me that this might still be an overall improvement to security, because of the https/CDN case.\r\n\r\nThe attack described here is possible when news.example chose to let adtech.example do the crypto on their behalf. But they can (and should) do it themselves. However, in the https/CDN case, news.example has no choice: if it wants cdn.example to do https on the unchanged URLs, it has to hand over it's private keys. However, with signed exchanges, it becomes possible for news.example to sign its content itself, and have the signed package be delivered via CDNs without revealing its private keys to anyone.\r\n\r\nUnless I am misunderstanding this, this means that while the introduction of signed packages may make it tempting to \"do the wrong thing\" (share your private keys) in more cases, it also makes it possible to do the right thing (do all the signing yourself) in cases where it previously was not. Whether that's a net positive probably depends on how strong the temptation is (i.e. how easy it is to sign packages yourself, how much will addTech.example pay you to do it on your behalf, etc).",
          "createdAt": "2019-04-20T01:27:26Z",
          "updatedAt": "2019-04-20T01:27:26Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "body": "> Unless, I am missing something, this boils down to \"if you hand someone your private keys, they can impersonate you while doing things you wouldn't\". Right?\r\n> \r\n> If I understand correctly, the atracks that this enables seem already possible when handing your private keys to a CDN so that it can do https on your behalf.\r\n\r\nActually, that is not the case.\r\n\r\nGoing back to the threat:\r\n1. The user does not want AdTech to be able to augment its profile of them while reading articles on news.example.\r\n2. The user does not want AdTech's rich profile of them to influence the content of ads or articles on news.example.\r\n\r\nIn the case of News handing AdTech a private key to do CDN things from a *.news.example subdomain, the user agent will send news.example's cookies in requests for articles (and possibly in requests to the CDN subdomain). This allows the user agent to protect the user's privacy by blocking adtech.example from accessing **its** cookies as third-party resource on a news.example page.\r\n\r\nIn the case of a signed package loaded from adtech.example, the user agent will send adtech.example's cookies in the request which allows AdTech to leverage its rich profile of the user to \"personalize\" content and ads as well as plant an AdTech user ID in the package to use in third-party requests to enrich its profile of the user.\r\n\r\n> As you said in the initial post, just because a similar attack already exists doesn't mean we shouldn't do anything about it. So I am absolutely in favor of mitigating this if we can.\r\n> \r\n> However, I think it is worth considering what happens if we cannot. On balance, it seems to me that this might still be an overall improvement to security, because of the https/CDN case.\r\n> \r\n> The attack described here is possible when news.example chose to let adtech.example do the crypto on their behalf. But they can (and should) do it themselves. However, in the https/CDN case, news.example has no choice: if it wants cdn.example to do https on the unchanged URLs, it has to hand over it's private keys. However, with signed exchanges, it becomes possible for news.example to sign its content itself, and have the signed package be delivered via CDNs without revealing its private keys to anyone.\r\n> \r\n> Unless I am misunderstanding this, this means that while the introduction of signed packages may make it tempting to \"do the wrong thing\" (share your private keys) in more cases, it also makes it possible to do the right thing (do all the signing yourself) in cases where it previously was not. Whether that's a net positive probably depends on how strong the temptation is (i.e. how easy it is to sign packages yourself, how much will addTech.example pay you to do it on your behalf, etc).\r\n\r\nGiven my explanation above, I'll let you revisit your analysis before commenting further.",
          "createdAt": "2019-04-20T02:15:25Z",
          "updatedAt": "2019-04-20T02:15:25Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "Question: the same planting of IDs can always be done via link\naugmentation. My understanding is that Safari is trying to protect against\nthat by blocking query/fragment on cross origin navigation.\n\nCould an SXG navigation be made equivalent to a cross-origin navigation by\nsaying: UA will only render the SXG if\n- the original request was cookieless\n- was a get request\n- has no query string or fragment\n- the path of the SXG request is the same as the path on the target domain.\n\n\nOn Sat, Apr 20, 2019, 11:15 AM John Wilander <notifications@github.com>\nwrote:\n\n> Unless, I am missing something, this boils down to \"if you hand someone\n> your private keys, they can impersonate you while doing things you\n> wouldn't\". Right?\n>\n> If I understand correctly, the atracks that this enables seem already\n> possible when handing your private keys to a CDN so that it can do https on\n> your behalf.\n>\n> Actually, that is not the case.\n>\n> Going back to the threat:\n>\n>    1. The user does not want AdTech to be able to augment its profile of\n>    them while reading articles on news.example.\n>    2. The user does not want AdTech's rich profile of them to influence\n>    the content of ads or articles on news.example.\n>\n> In the case of News handing AdTech a private key to do CDN things from a\n> *.news.example subdomain, the user agent will send news.example's cookies\n> in requests for articles (and possibly in requests to the CDN subdomain).\n> This allows the user agent to protect the user's privacy by blocking\n> adtech.example from accessing *its* cookies as third-party resource on a\n> news.example page.\n>\n> In the case of a signed package loaded from adtech.example, the user agent\n> will send adtech.example's cookies in the request which allows AdTech to\n> leverage its rich profile of the user to \"personalize\" content and ads as\n> well as plant an AdTech user ID in the package to use in third-party\n> requests to enrich its profile of the user.\n>\n> As you said in the initial post, just because a similar attack already\n> exists doesn't mean we shouldn't do anything about it. So I am absolutely\n> in favor of mitigating this if we can.\n>\n> However, I think it is worth considering what happens if we cannot. On\n> balance, it seems to me that this might still be an overall improvement to\n> security, because of the https/CDN case.\n>\n> The attack described here is possible when news.example chose to let\n> adtech.example do the crypto on their behalf. But they can (and should) do\n> it themselves. However, in the https/CDN case, news.example has no choice:\n> if it wants cdn.example to do https on the unchanged URLs, it has to hand\n> over it's private keys. However, with signed exchanges, it becomes possible\n> for news.example to sign its content itself, and have the signed package be\n> delivered via CDNs without revealing its private keys to anyone.\n>\n> Unless I am misunderstanding this, this means that while the introduction\n> of signed packages may make it tempting to \"do the wrong thing\" (share your\n> private keys) in more cases, it also makes it possible to do the right\n> thing (do all the signing yourself) in cases where it previously was not.\n> Whether that's a net positive probably depends on how strong the temptation\n> is (i.e. how easy it is to sign packages yourself, how much will\n> addTech.example pay you to do it on your behalf, etc).\n>\n> Given my explanation above, I'll let you revisit your analysis before\n> commenting further.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/422#issuecomment-485050921>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AAAV4T7K56Y2MSSAM5EN423PRJ4D5ANCNFSM4HHBF6UQ>\n> .\n>\n",
          "createdAt": "2019-04-20T03:26:20Z",
          "updatedAt": "2019-04-20T03:26:20Z"
        },
        {
          "author": "frivoal",
          "authorAssociation": "NONE",
          "body": "> Given my explanation above, I'll let you revisit your analysis before commenting further.\r\n\r\nThanks, I had indeed missed that key distinction. Revising what I said earlier, my understanding is now:\r\n* The ability to inject customized/undesired things into the page is the same for the https+CDN and for the adTech packager\r\n* The ability to use cookies meant for adTech to identify the user in order to inform what kind of custom/undesired things to inject into the page is **not** the same in both scenario\r\n\r\nYou were focused on the second thing, while I was on the first.\r\n\r\nThat said, I wonder if the ability to modify the page before serving it and to inject arbitrary stuff along the way does not enable the malicious CDN to get back the same information with additional network requests from the page once it is loaded. Maybe blocking third party cookies effectively prevents this, but I don't feel overly confident. Once you hand your private keys to a third party, it seems hard to limit what they can do.",
          "createdAt": "2019-04-20T05:08:15Z",
          "updatedAt": "2019-04-20T05:08:15Z"
        },
        {
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "body": "Hi Malte!\r\n\r\n> Question: the same planting of IDs can always be done via link augmentation. My understanding is that Safari is trying to protect against that by blocking query/fragment on cross origin navigation. Could an SXG navigation be made equivalent to a cross-origin navigation by saying: UA will only render the SXG if - the original request was cookieless - was a get request - has no query string or fragment - the path of the SXG request is the same as the path on the target domain.\r\n> [\u2026](#)\r\n\r\nI avoided bringing this up to not inflate my original description and take focus off of the particular issue with built-in tracking. What you mention are additional things we'll have to do to protect signed packages, but they apply to arbitrary navigations that start on AdTech's site.",
          "createdAt": "2019-04-20T12:47:12Z",
          "updatedAt": "2019-04-20T12:47:12Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It might take me until Wednesday, but I'd like to check this threat model into the repository as a description of the anti-tracking requirements that at least Apple wants on the design. I'm then going to add the other attacker abilities and constraints that I think I've seen in the Twitter discussion and comments here, along with the attacker goals that we want the design to frustrate.\r\n\r\nI think it'll be more productive to get agreement on a full understanding of the requirements before we look for solutions or try to knock over the solutions that have already been proposed.",
          "createdAt": "2019-04-20T18:49:03Z",
          "updatedAt": "2019-04-24T22:43:18Z"
        },
        {
          "author": "kevinsimper",
          "authorAssociation": "NONE",
          "body": "@johnwilander \r\n> But a shared TSA, funded/controlled/audited by multiple stakeholders could probably work. Also transparency will work in our favor here. It should be easy to check the integrity of the TSA, not just for UAs but for anyone.\r\n\r\nThis sounds exactly like a blockchain. (and I don't work or have investments in blockchains). It can be transparent, it is easy to check the integrity, and has many stakeholders. I know it overused and many have burnt out on the concept, but it is a valid technology. There is even work to do with \"verifiable delay function\".\r\n\r\n\r\n@sleevi \r\n> Collusion by adtech.example is an (extreme) possibility, and thus it seemed important to understand the requirements here, since it seemed like there might be some unstated requirements hidden between that last bullet point. \ud83e\udd14\r\n\r\nYeah, and I was also hesitant to suggest it as it is a misused concept for a lot of stuff. I didn't suggest any particular blockchains. Your merkledag reference gives me clues that you have considerations about it \ud83d\udc4d \r\n\r\n\r\n---\r\n\r\nIf the requirement is to keep it simple and solutions could be also to so some kind of proof of work, which would make it very expensive to make one on the fly, but cheap to do once. This also avoids contacting anybody else as the proof can be verified easily by the user agent.",
          "createdAt": "2019-04-20T20:35:16Z",
          "updatedAt": "2019-04-20T20:35:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "https://github.com/WICG/webpackage/pull/424 tries to document the threat model we're trying to handle here, along with a couple notes on the mitigations I've seen proposed so far. How's it look?",
          "createdAt": "2019-04-24T22:44:15Z",
          "updatedAt": "2019-04-24T22:44:15Z"
        }
      ]
    },
    {
      "number": 423,
      "id": "MDU6SXNzdWU0MzYyNzQyODY=",
      "title": "Cross-site loads of signed packages should be done stateless and with no personalization",
      "url": "https://github.com/WICG/webpackage/issues/423",
      "state": "OPEN",
      "author": "johnwilander",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "As brought up by @cramforce in https://github.com/WICG/webpackage/issues/422#issuecomment-485054801, we should require cross-site loads of signed packages to be stateless. Specifically:\r\n- The request chain must be credential-less. Maybe we can leverage some Fetch policy here.\r\n- It must be an HTTP GET request.\r\n- The request URL must not have a query string or fragment.\r\n- The path of the package request must be the same as the path on the target domain.\r\n\r\nThe above requirements are to ensure that cross-site tracking or personalization information is not transferred in the request for the package.",
      "createdAt": "2019-04-23T16:13:05Z",
      "updatedAt": "2019-07-11T19:53:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dfabulich",
          "authorAssociation": "NONE",
          "body": "A common tracking technique is to put personalized information in the ETag, e.g. `ETag: W/your-login-id-plus-content-hash` \r\n\r\nThus, to be truly stateless, the request would also have to prevent conditional GET requests (`If-None-Match`, `If-Modified-Since`)",
          "createdAt": "2019-05-14T17:42:00Z",
          "updatedAt": "2019-05-14T17:42:00Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "From the Chrome anti-tracking team, we agree that SXGs should require mitigations for cross-site information flow. We think the suggestions here should be adopted, though of course details like how to trigger such a credential-less navigation still need to be worked out.\r\n\r\nA minor quibble/note, the last two points as written require a distinct distributor origin per publisher origin, which seems off. (It even risks the SXG prefetch leaking the distributor origin via DNS and SNI.) I would suggest rephrasing it as: the path + query string of the navigation needs to be some specific deterministic function of the SXG target URL. For instance, `https://distributor.example/.well-known/sxg/[some encoding or cryptographic hash of target URL]`.",
          "createdAt": "2019-07-11T19:53:34Z",
          "updatedAt": "2019-07-11T19:53:34Z"
        }
      ]
    },
    {
      "number": 430,
      "id": "MDU6SXNzdWU0Mzk4MjQzOTA=",
      "title": "Proposal: Required Domains extension for certificates",
      "url": "https://github.com/WICG/webpackage/issues/430",
      "state": "OPEN",
      "author": "grittygrease",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "Pending Security + Privacy Review"
      ],
      "body": "It's been widely discussed that SXG certificates enable off-path attacks. This means that an attacker that has stolen an SXG private key and created SXG content can send it to a client from any server controlled by that attacker, such as a phishing site, and the browser will trust it. This opens up a lot of possibilities for impersonation that are not currently available to an attacker that compromises a TLS certificate. An attacker with a TLS certificate needs to somehow get a client that is already connecting to a site (via DNS and TCP/IP) to connect to a server under their control to fetch the content. This usually requires DNS poisoning or being on-path between the victim and the server.\r\n\r\nBecause SXG introduces a new off-path vector of attack, it's worth considering ways to mitigate this attack vector in the specification. This is the situation we found ourselves in for the Secondary Certificates project (https://tools.ietf.org/html/draft-bishop-httpbis-http2-additional-certs-05), which allows attackers with specially-issued secondary certificates to serve content from multiple sites over the same connection, which enables similar off-path attacks.\r\n\r\nThe mitigation that was discussed in Secondary Certificates to prevent arbitrary off-path domain hijacking was a simple one: we proposed that for a certificate to be used as secondary, it needs an additional field called \"Required Domain\". In order to accept a certificate with a \"Required Domain\" extension, the server must have previously served a certificate that covers the required domain on the same connection. This has the nice property that if a secondary certificate is compromised, it can only be used to hijack traffic if they also have control over the secondary domain.\r\n\r\nI'd like to suggest that this mechanism be considered here for SXG certificates. In order to serve an SXG from a cache, the certificate would need to have that cache's domain in its set of \"Required Domains\". This would drastically reduce the capabilities of an attacker who steals an SXG cert key, mints SXGs and serves them from an arbitrary phishing domain.",
      "createdAt": "2019-05-02T23:03:23Z",
      "updatedAt": "2019-05-08T21:23:53Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We've talked about ideas in this direction, although not exactly this one, and while they improve security, they also worsen, for example, @ekr's concern that the feature increases large organizations' control over the internet. For example, we don't want `publisher.example` to be able to declare that only Google is allowed to cache their SXGs.\r\n\r\n@martinthomson, will your document discuss how Mozilla feels about mitigating stolen private keys vs mis-issued certificates? IIUC, this suggestion doesn't help with mis-issued certificates.",
          "createdAt": "2019-05-02T23:27:15Z",
          "updatedAt": "2019-05-02T23:27:15Z"
        },
        {
          "author": "ekr",
          "authorAssociation": "NONE",
          "body": "It seems like there are two questions here, actually:\r\n\r\n1. Should it be possible for publishers to constrain the origins where there content can be cached?\r\n2. Should certificates contain that constraint so that stolen keys are not a compromise threat?\r\n\r\nObviously, the answer to (2) is \"no\" if the answer to (1) is \"no\", but that's not a complete answer. It seems like what's really at stake is whether we think of an SXG as a portable object or as a cooperative venture between the publisher and the cache.",
          "createdAt": "2019-05-02T23:31:38Z",
          "updatedAt": "2019-05-02T23:31:38Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "A useful variant may be to allow certificates to grant all origins to serve their SXG, but also provide a mechanism to restrict them. That would enable use of the SXG primitive for for decentralized web use cases, while also allowing publishers to restrict distribution.",
          "createdAt": "2019-05-03T00:33:26Z",
          "updatedAt": "2019-05-03T00:33:26Z"
        }
      ]
    },
    {
      "number": 431,
      "id": "MDU6SXNzdWU0Mzk5MzM2NTY=",
      "title": "Go: Avoid mutating (signedexchange.Exchange).Payload",
      "url": "https://github.com/WICG/webpackage/issues/431",
      "state": "OPEN",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi",
        "nyaxt",
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "cc: @twifkak \r\n\r\nIn the current code, the `Payload []byte` field may contain payload either before or after mice encoding.\r\nThis is confusing behavior and we should avoid.\r\n\r\nPerhaps we should factor out other `Exchange` members to a separate struct.\r\n#427 would also benefit from such change.",
      "createdAt": "2019-05-03T08:06:54Z",
      "updatedAt": "2019-05-03T08:07:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 432,
      "id": "MDU6SXNzdWU0NDE5ODI5OTU=",
      "title": "Prevent fallback loop when publisher publishes invalid SXG",
      "url": "https://github.com/WICG/webpackage/issues/432",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://crbug.com/939684 handles this by removing `application/signed-exchange` from the `Accept` header on fallback, but @gregable mentions the possibility of not-checking the signature for a same-origin signed exchange.\r\n\r\nThis interacts with #397 in that we'll want to make sure the loop prevention works for every reason we might use the fallback URL.",
      "createdAt": "2019-05-08T23:15:32Z",
      "updatedAt": "2019-05-09T19:39:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We also need to remember to check either [`Service-Worker-Allowed`](https://w3c.github.io/ServiceWorker/#service-worker-allowed) or a similar mechanism to make sure folks don't impersonate a path they're not authoritative for.",
          "createdAt": "2019-05-09T19:39:45Z",
          "updatedAt": "2019-05-09T19:39:45Z"
        }
      ]
    },
    {
      "number": 433,
      "id": "MDU6SXNzdWU0NDMxNzc5NTc=",
      "title": "Is it OK to let the publishers know the SXG distributor's URL?",
      "url": "https://github.com/WICG/webpackage/issues/433",
      "state": "OPEN",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "Pending Security + Privacy Review",
        "architecture",
        "feature request"
      ],
      "body": "I have stopped working on Signed Exchange Reporting for publishers. https://github.com/w3c/network-error-logging/issues/99#issuecomment-490739647\r\nThis is mainly because it is not clear whether is it OK to let the publisher know the distributor's URL.\r\n\r\nIf my understanding is correct, we can't know redirecting URLs.\r\nThe publisher can only know \"aggregator.example/feed\" using referrer in this case: \r\n- aggregator.example/feed -> redirect.example/publisher.example/article (returns 301 redirect) -> publisher.example/article\r\n\r\nSo I think it sounds reasonable not to let the publisher know the SXG distributor's URL.\r\n\r\nAnd also if the publishers can know the distributor's URL, this can be used for user tracking.\r\nExample:\r\n https://TRACKING_ID.distributor.example/publisher.example/article.html.sxg\r\n https://distributor.example/TRACKING_ID/publisher.example/article.html.sxg\r\nI think we should avoid adding new features which can be used for user tracking.",
      "createdAt": "2019-05-13T02:14:41Z",
      "updatedAt": "2019-05-20T05:46:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Is the above different from the distributor adding an `<a ping=\"publisher.example/collection_endpoint/TRACKING_ID\">` to the SXG link?",
          "createdAt": "2019-05-13T05:52:29Z",
          "updatedAt": "2019-05-13T05:52:29Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "From the user tracking point of view, it is almost same.",
          "createdAt": "2019-05-13T13:04:50Z",
          "updatedAt": "2019-05-13T13:04:50Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Well, since we enable `ping` attributes, `onclick` events, redirections and multiple other ways of communicating that information out-of-band, I don't see why we'd want to block this particular one.",
          "createdAt": "2019-05-13T13:50:58Z",
          "updatedAt": "2019-05-13T13:50:58Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I\u2019m not sure I see how you see those others as substantively similar. They\nseem very different than what I\u2019ve seen discussed/proposed.\n\nFor example, `ping` lets you initiate as the outgoing link - but the\nproposal here does not establish any relationship between the distributor\nand the link provider. Further, `ping` let\u2019s you notify that a link is\nbeing followed, but not the final target of that link.\n\nI think it\u2019s unlikely to sway anyone to simply state that there are\nparallels, because it doesn\u2019t establish the parallels, nor that those\ncurrent behaviours are desired. A more thorough analysis would be useful,\nif that is the one to justify this.\n",
          "createdAt": "2019-05-13T13:54:39Z",
          "updatedAt": "2019-05-13T13:54:39Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Maybe I misunderstood the threat model. Are we worried that publishers will know about tracking IDs without the distributor actively communicating them?",
          "createdAt": "2019-05-13T14:40:23Z",
          "updatedAt": "2019-05-13T14:40:23Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Fair point. I don't think we've articulated a particular threat model or set of threat models. The question is, as I understood it, trying to articulate the potential risks.\r\n\r\nWe've got at least four parties in play:\r\n- The Publisher, the provider of the SXG\r\n- The Distributor, the hoster of the SXG resource\r\n- The \"Sender\", the one who provides the outbound link or initiates loading of SXG (I hesitate to use the term aggregator, as I think it implies a particular type of Sender)\r\n- The User, for whom we are the agent.\r\n\r\nOne potential risk is, as @horo-t noted, about active collusion between Publisher and Distributor in a way that allows them to exchange information.\r\n  - As you note, if the Sender is colluding, then there's no need for the Publisher to have special capabilities / adding special capabilities does not change this, since they can always get the information out-of-band from the Sender.\r\n  - However, if the Sender is not colluding / party to the threat, then I think this changes the calclus\r\n\r\nAnother potential risk is where the User does not wish the Publisher to learn about the Distributor they're using, especially if it may reveal the User's activity with the Sender. This is one of the tensions we noted early on with reporting the Distributor to the Publisher - whether or not it aligns with the user's interests, or whether it allows the Publisher to learn information about the User based on the Distributor.\r\n\r\nI'm sure there are other scenarios being overlooked here, but I think it's a fair point that we're likely talking about different things, but which collectively go to identify whether or not it's OK.",
          "createdAt": "2019-05-13T14:52:16Z",
          "updatedAt": "2019-05-13T14:53:10Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#424 has an attempt to build an anti-tracking threat model, although I'm sure it's incomplete. In particular, there's only a tracking risk if the same request or JS environment exposes both the Distributor's tracking ID and the Publisher's tracking ID. Simply sending `https://DISTRIBUTOR_TRACKING_ID.distributor.example/publisher.example/article.html.sxg` to the publisher with no other information isn't enough, since it doesn't include the publisher's tracking ID.\r\n\r\n`<a ping>` is specified to [`include` credentials](https://html.spec.whatwg.org/multipage/links.html#hyperlink-auditing), so anyone trying to block tracking will need to change that along with any restrictions on reporting the distributor URL to the publisher. I think we should design for uncertainty in how far that effort will go, rather than assuming we need to pre-emptively block all communication via this one channel.\r\n\r\n#424 doesn't cover the worry about the Publisher learning things about the User's interaction with the Sender because that's a more immediate risk than anti-tracking (i.e. fixing it doesn't assume a pile of other changes to the web platform). We should also write that more immediate threat model. If someone other than me can volunteer, it'll get done faster.",
          "createdAt": "2019-05-13T21:01:21Z",
          "updatedAt": "2019-05-13T21:02:11Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> Simply sending https://DISTRIBUTOR_TRACKING_ID.distributor.example/publisher.example/article.html.sxg to the publisher with no other information isn't enough, since it doesn't include the publisher's tracking ID.\r\n\r\nI'm not sure that analysis is correct. When the SXG is loaded, the Publisher's JS will have access to localState and other storage mechanisms, and thus if the Distributor ID is exposed, can link that with the Publisher ID stored in localStorage and link them, right?\r\n\r\nWe talked a little about this in #347, in the context of what information about the content the Distributor can infer, as well as what affects the Distributor can have on the Publisher and how it loads its content.",
          "createdAt": "2019-05-13T22:11:27Z",
          "updatedAt": "2019-05-13T22:11:27Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi I think having the DISTRIBUTOR_TRACKING_ID in the publisher's javascript context is \"with other information\", but I want us to be clear that it's the combination that enables tracking. Maybe browsers that want to prevent identifier correlation can block JS access to the full URL but still send reports to the publisher via credential-less HTTP requests, for example.",
          "createdAt": "2019-05-13T22:27:22Z",
          "updatedAt": "2019-05-13T22:27:22Z"
        },
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Re, linking+tracking: we briefly explored this in the Navigation Timing thread, but I'll reiterate it here as well.. We don't necessarily need to expose the full distributor URL to satisfy some of the [core use cases](https://github.com/w3c/navigation-timing/issues/107) from a publisher's perspective: providing the origin, or even just the eTLD+1 if we're concerned about tracking ID being embedded in the subdomain, is likely good enough.\r\n\r\nIn absence of any signals about the distributor, my fear is that the publishers would simply default to whitelisting a small set of distributors that \"they trust\" \u2014 e.g. trust not to have negative impact on user experience, expect insights from distributors about such page loads in return, etc.",
          "createdAt": "2019-05-17T20:35:07Z",
          "updatedAt": "2019-05-17T20:35:07Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "If https://github.com/WICG/webpackage/issues/430 was resolved in such a way that Publishers had to explicitly allowlist Distributors, would that obviate the need for exposing this information?\r\n\r\nAlternatively, it would seem if https://github.com/WICG/webpackage/issues/430 is not accepted - that is, neither an allowlist nor blocklist is pursued - it would seem that would obviate the Publisher\u2019s ability to place such restrictions, thus reducing the risk of such ossification of Distributors.\r\n\r\nIt\u2019s not clear to me, though, which of these outcomes was being imagined with the remark about lacking signals.",
          "createdAt": "2019-05-17T21:22:59Z",
          "updatedAt": "2019-05-17T21:22:59Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "> However, if the Sender is not colluding / party to the threat, then I think this changes the calclus\r\n\r\nHow does this change the calculus of distributor/publisher being able to correlate tracking IDs? The sender (aka [embedder](https://github.com/WICG/webpackage/blob/master/explainer.md#signed-exchange-loading-sketch)) cannot read or intercept the bytes that the distributor sends to the user. ISTM the distributor could send an unsigned response containing any of the usual tricks, followed by a redirect to the SXG, and the sender couldn't prevent this with static analysis. (Perhaps there's another way the sender could prevent this that I'm not seeing...)",
          "createdAt": "2019-05-19T05:25:54Z",
          "updatedAt": "2019-05-19T05:29:36Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> How does this change the calculus of distributor/publisher being able to correlate tracking IDs?\r\n\r\nApologies, as I suppose my example could have been clearer. I was trying to highlight that there are more risks than 'just' tracking IDs, and this adds to the security and privacy complexity.\r\n\r\nThe Sender may not wish for the Publisher to learn about what the user is doing on the Sender. This is similar to, but distinct from, the User Privacy case; I think that many of their mitigations end up looking similar, but there are cases where the User may be fine with the information leakage, but the Sender not, and vice-versa, which is why I tried to enumerate them as separate in the considerations.\r\n\r\nBasically, I'm trying to treat all of this from the lens of side-channels. Functionally, the Distributor gets to be the 'last mile' to the user for Publisher's content. This can be seen in some of the motivations for the [RUM use-case](https://github.com/w3c/navigation-timing/issues/107). However, SXGs allow both the Sender and Distributor to look into what Publisher is sending, and further, be able to influence how that information is loaded. This can lead to accidental or intentional side channels (like those in #347 ) that allow the Sender/Distributor to learn not just about Publisher's content, but about the User's state at Publisher.\r\n\r\nFrom the perspective of URLs, I'm trying to work through cases where the User or Sender may not want the Publisher to know about the URL they're viewing (or that of the Distributor's), and then see if and how we can balance those cases against the desire for the Publisher to control the Distributor (as in #430 )",
          "createdAt": "2019-05-20T05:46:55Z",
          "updatedAt": "2019-05-20T05:46:55Z"
        }
      ]
    },
    {
      "number": 434,
      "id": "MDU6SXNzdWU0NDQ1MTczNzQ=",
      "title": "Spec makes it difficult to distinguish signed and unsigned parameters",
      "url": "https://github.com/WICG/webpackage/issues/434",
      "state": "OPEN",
      "author": "sleevi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The [`Signature` header](https://github.com/WICG/webpackage/blob/7aef9b9bd97ab3ea432f4cec22cc7020267f7c29/draft-yasskin-http-origin-signed-responses.md#the-signature-header--signature-header) makes use of Structured Headers to encapsulate a number of parameters.\r\n\r\nHowever, the structural layout of the specification makes it difficult to easily determine what parameters are signed and unsigned. Through a careful reading, it would appear that only `cert-url` is unsigned.\r\n\r\nThis came up when trying to evaluate the proposal in #397 to understand the assurance level of different fields, at different points within the algorithm. For example, the current algorithm for [validating a signature](https://github.com/WICG/webpackage/blob/7aef9b9bd97ab3ea432f4cec22cc7020267f7c29/loading.bs#L775) would appear to be making use of a signed field before the signature has actually been verified.\r\n\r\nA few thoughts come to mind to help simplify this:\r\n- In the discussion of the parameters that participate in the signature, clearly indicate whether each parameter is covered by the 'sig' or not.\r\n- In the discussion of validation algorithms, either\r\n  1. Ensure that signature validation is consistently performed before any accesses to unvalidated data\r\n  1. Use descriptive labels to indicate the level of assurance that each field as. For example, `unverified-validityUrl` becomes `signed-validityUrl` after the signature has been checked, while `integrity` becomes `unverified-integrity`, transitions to `signed-integrity` after signature validation, and becomes `verified-integrity` after the (certificate and revocation) checks.\r\n\r\nThe idea here is to try to encapsulate, in the spec, the state machine that each of these variables goes through, so that it's clear whether we're operating on 'untrusted' (not yet signature checked / certificate checked) data or after. While an implementation may simply use the same variable throughout the implementation, the annotations help highlight the assurance. This also helps for future spec changes, because any reordering of sequences would cascade into re-evaluating the labels for any variables.\r\n\r\nOr this might all be a terrible idea, but it was definitely hard to read and reason about the algorithm without knowing clearly whether the variables were signed and when/if they'd been validated.",
      "createdAt": "2019-05-15T15:53:37Z",
      "updatedAt": "2019-05-15T15:53:37Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 435,
      "id": "MDU6SXNzdWU0NDU1MTcwMzA=",
      "title": "Content-Type version identifier, should it be case-sensitive?",
      "url": "https://github.com/WICG/webpackage/issues/435",
      "state": "CLOSED",
      "author": "Gregable",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "For a server returning a signed exchange, the content type will be something like:\r\n\r\n```\r\ncontent-type: application/signed-exchange;v=b3\r\n```\r\n\r\nAs per https://www.w3.org/Protocols/rfc1341/4_Content-Type.html, the `application/signed-exchange` and `v` parts of this are case-insensitive, whereas the `b3` part (parameter value) is not well defined in the RFC:\r\n\r\n> Parameter values are normally case sensitive, but certain parameters are interpreted to be case- insensitive, depending on the intended use.\r\n\r\nI don't see anything explicit in the Signed Exchange spec about the case-sensitivity of the parameter value. Should we call this out explicitly?\r\n\r\nIt's a small point, but I would also suggest that it seems a little error-prone to have this entire string be case-insensitive except for one character (the `b`). Perhaps we should define the version identifier to also be case-insensitive for consistency. Thoughts?",
      "createdAt": "2019-05-17T16:13:18Z",
      "updatedAt": "2019-07-01T22:21:39Z",
      "closedAt": "2019-07-01T22:21:39Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The Signed Exchange spec does give an ABNF for the parameter value of `DIGIT/%x61-7A` (should be `1*(DIGIT/%x61-7A)`), i.e. only lowercase ASCII letters.\r\n\r\nI'm not certain that's the right behavior, but I'm inclined to keep it since it limits unnecessary variation in server behavior.\r\n",
          "createdAt": "2019-07-01T22:21:39Z",
          "updatedAt": "2019-07-01T22:21:39Z"
        }
      ]
    },
    {
      "number": 436,
      "id": "MDU6SXNzdWU0NDU4NjA3MjU=",
      "title": "Could an SXG cache know how long you \"lingered\" on a page it served?",
      "url": "https://github.com/WICG/webpackage/issues/436",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The thread at https://twitter.com/colinbendell/status/1129040437929492480 describes this attack. If the cache serves an SXG to the user, but leaves the connection open. According to the thread, this would allow it to learn the time until the user unloaded that document (e.g. clicked a link, closed the tab, etc.). Is this possible given the current spec / implementation snapshot? If so, is there a way to mitigate it?",
      "createdAt": "2019-05-19T20:28:21Z",
      "updatedAt": "2020-09-02T16:26:25Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This *might* work, depending on how browsers decide to close hung or very-slow connections. If it works for signed exchanges, it probably also works for subresources, although that's a less serious problem since the main page at least has to opt into any subresource origins being able to learn this information.\r\n\r\nThe mitigation would probably be to have browsers leave hung connections open until some timeout, whether or not the page depending on that connection unloads during the timeout.",
          "createdAt": "2019-05-21T00:22:38Z",
          "updatedAt": "2019-05-21T00:22:38Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Agreed re: subresources.\r\n\r\nThat mitigation helps guard against attackers interested in short stay durations. To guard against attackers interested in long stay durations, perhaps SXG could have that hung-connection timeout be relatively short, and apply to all open connections (effectively `Connection: close` if there are no pending prefetches). Though the former would negatively affect users with bad connections.\r\n\r\nIs this outside the scope of the spec and its dependencies? If I find it's possible, should I open a bug against the Chromium implementation instead?",
          "createdAt": "2019-05-21T00:46:34Z",
          "updatedAt": "2019-05-21T00:51:49Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I don\u2019t think Connection: Close will have the desired semantics, especially\nin the case of HTTP/2. And I\u2019m a bit apprehensive of having to change the\nfundamental networking implementation to accommodate if a connection has\nbeen tainted by an SXG loss - that sort of complexity discourages\nimplementation. Browser stacks don\u2019t have anything like that, even for slow\nconnections.\n\nAre there other options or ideas worth exploring?\n",
          "createdAt": "2019-05-21T00:57:51Z",
          "updatedAt": "2019-05-21T00:57:51Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Browsers could dump the request on navigation.  That means dropping connections (HTTP/1.1) or aborting requests (HTTP/2 or /3).  Content that was acquired prior to the navigation might be loaded from the bundle; other content can be fetched as though anew.  This would remove any incentive for the cache to play this game.\r\n\r\nThe cost is that it makes partial loading of bundled content more wasteful.  Preemptive preloading is already pretty wasteful and this could make it worse by forcing partial loads to be abandoned.  It seems likely that navigation could happen during fetching bundles in a great many cases and you probably don't want to throw away the effort invested.  Progressive loading becomes more helpful.  You can at least get those resources that were all loaded, with some amount of waste (that might be tuneable).  Any partially fetched pieces would probably have to be re-fetched from the start, unless you had really good validators and range requests, but that assumes a level of coordination I wouldn't count on.",
          "createdAt": "2020-09-02T06:35:16Z",
          "updatedAt": "2020-09-02T06:35:16Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm a little confused what the attack is. Is the assumption that the browser correlate closing the connection with unloading the document spawned from the SXG, and thus you can learn the linger time by observing the connection closure?\r\n\r\nI don't think that's an issue, at least not in Chrome's implementation. The socket pools have no idea when documents are unloaded, except indirectly from when subresource requests stop coming in (which could either be unload or the document has nothing more to load). But that doesn't matter here because, post storage partitioning, all those subresources would come from the destination's partition anyway. That means there isn't even a reason for the browser to correlate the SXG cache connection with the resulting document.",
          "createdAt": "2020-09-02T16:25:31Z",
          "updatedAt": "2020-09-02T16:26:25Z"
        }
      ]
    },
    {
      "number": 438,
      "id": "MDU6SXNzdWU0NTAwNTUzODk=",
      "title": "bundle tool install error",
      "url": "https://github.com/WICG/webpackage/issues/438",
      "state": "CLOSED",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [
        "irori"
      ],
      "labels": [],
      "body": "The signedexchange tools installed easily, but I get an error trying to install the bundle tools: \r\n\r\n```\r\n$ go get -u github.com/WICG/webpackage/go/bundle/cmd/...\r\npackage github.com/influxdata/influxdb/client/v2: cannot find package \"github.com/influxdata/influxdb/client/v2\" in any of:\r\n\t/usr/local/go/src/github.com/influxdata/influxdb/client/v2 (from $GOROOT)\r\n\t/Users/cramerd/go/src/github.com/influxdata/influxdb/client/v2 (from $GOPATH)\r\n\r\n```\r\nGoing to https://github.com/influxdata/influxdb finds:\r\n\r\n> If you are looking for the InfluxDB 1.x Go Client, we've created a new [repo](https://github.com/influxdata/influxdb1-client) for that. \r\n",
      "createdAt": "2019-05-29T22:56:36Z",
      "updatedAt": "2019-05-30T19:49:01Z",
      "closedAt": "2019-05-30T19:49:00Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. https://github.com/mrichman/hargo/pull/12 should fix this.",
          "createdAt": "2019-05-30T02:31:57Z",
          "updatedAt": "2019-05-30T02:31:57Z"
        },
        {
          "author": "dauwhe",
          "authorAssociation": "NONE",
          "body": "It works! Thanks!",
          "createdAt": "2019-05-30T19:49:00Z",
          "updatedAt": "2019-05-30T19:49:00Z"
        }
      ]
    },
    {
      "number": 441,
      "id": "MDU6SXNzdWU0NTQ2NDAwODE=",
      "title": "dump-signedexchange: command not found",
      "url": "https://github.com/WICG/webpackage/issues/441",
      "state": "CLOSED",
      "author": "prash-mi",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I am trying to install 'dump-signedexchange' on Linux (Debian) and Mac(v10.14) running go 1.12.5, using this command:\r\n\r\n`go get -u github.com/WICG/webpackage/go/signedexchange/cmd/...`\r\n\r\nbut its simply exiting with no output on the console: \r\n\r\n```\r\n$ go get -u github.com/WICG/webpackage/go/signedexchange/cmd/...\r\n$ dump-signedexchange\r\nbash: dump-signedexchange: command not found\r\n```\r\n\r\nIs there an alternate way to install it?\r\n\r\n\r\n",
      "createdAt": "2019-06-11T11:42:22Z",
      "updatedAt": "2019-06-20T04:57:55Z",
      "closedAt": "2019-06-20T04:57:55Z",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "`go get` installs the binaries at `$HOME/go/bin` by default :)",
          "createdAt": "2019-06-11T15:33:09Z",
          "updatedAt": "2019-06-11T15:33:09Z"
        },
        {
          "author": "prash-mi",
          "authorAssociation": "NONE",
          "body": "Thanks @hajimehoshi . (Somehow I was expecting the binary to be available in the $PATH, my bad!)\r\n\r\nOne follow-up, would you know how to use `-verify` with `dump-signedexchange`, the following command is not returning:\r\n`\r\n./dump-signedexchange -verify https://staging.example.com \r\n `\r\n\r\nI want to verify signed exchange on a staging server",
          "createdAt": "2019-06-12T07:13:50Z",
          "updatedAt": "2019-06-12T07:13:50Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "`dump-signedexchange` is not returning because it's waiting for SXG input from stdin. The following command pipe would do the work:\r\n```\r\ncurl https://staging.example.com | dump-signedexchange -verify\r\n```\r\n\r\nOnce https://github.com/WICG/webpackage/pull/429/ is merged, `dump-signedexchange` will accept the `-uri` flag:\r\n```\r\n./dump-signedexchange -verify -uri https://staging.example.com\r\n```",
          "createdAt": "2019-06-12T09:01:54Z",
          "updatedAt": "2019-06-12T09:01:54Z"
        },
        {
          "author": "prash-mi",
          "authorAssociation": "NONE",
          "body": "Thanks for the update @irori . One followp, I tried this command with a couple of URLs with and without signexchange implemented and got the same response, here is the output:\r\n\r\nThis URI has SGX enabled on prod: \r\n`curl -si -H 'amp-cache-transform: google' -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3' https://www.oyorooms.com/hotels-in-delhi/ | dump-signedexchange -verify`\r\nOutput:\r\n`2019/06/14 14:19:25 singedexchange: unknown magic bytes: [72 84 84 80 47 50 32 50]`\r\n\r\nThis URI is not having SGX enabled: \r\n`curl -si -H 'amp-cache-transform: google' -H 'accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3' https://mweb-demos.appspot.com | dump-signedexchange -verify`\r\nOutput:\r\n`2019/06/14 14:21:31 singedexchange: unknown magic bytes: [72 84 84 80 47 50 32 50]`\r\n\r\nCan you please let me know that what output is expected when SGX is enabled ?\r\n\r\n",
          "createdAt": "2019-06-14T08:58:41Z",
          "updatedAt": "2019-06-14T08:58:41Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Curl's `-i` option outputs HTTP response headers to the stdout, so `dump-signedexchange` tries to parse it as SXG format (`[72,84,84,80,47,50,32,50]` == \"HTTP/2 2\" in ASCII).\r\n\r\nNow https://github.com/WICG/webpackage/pull/429 is merged, you can use `dump-signedexchange` with the `-uri` flag:\r\n\r\n```\r\n$ dump-signedexchange -requestHeader 'amp-cache-transform: google' -uri https://www.oyorooms.com/hotels-in-delhi/ -verify -payload=false\r\n\r\nformat version: 1b3\r\nrequest:\r\n  method: GET\r\n  uri: https://www.oyorooms.com/hotels-in-delhi/\r\n  headers:\r\nresponse:\r\n  status: 200\r\n  headers:\r\n    Content-Encoding: mi-sha256-03\r\n...\r\n```\r\n",
          "createdAt": "2019-06-19T04:22:24Z",
          "updatedAt": "2019-06-19T04:22:24Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, but feel free to add comments if you have further questions.",
          "createdAt": "2019-06-20T04:57:55Z",
          "updatedAt": "2019-06-20T04:57:55Z"
        }
      ]
    },
    {
      "number": 442,
      "id": "MDU6SXNzdWU0NTUwMTA5NTg=",
      "title": "Can parameterised identifiers in Signature header have extra parameter?",
      "url": "https://github.com/WICG/webpackage/issues/442",
      "state": "OPEN",
      "author": "tomokinat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "architecture"
      ],
      "body": "According to https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-header, each parameterised identifier MUST have parameters 'sig', 'integirty', and so on. Then is it okay for them to contain other parameters not referred as 'necessary' in the spec?",
      "createdAt": "2019-06-12T04:52:42Z",
      "updatedAt": "2019-06-27T21:55:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The spec currently says it's allowed.\r\n\r\nAnother reasonable point in the design space would be to say that a particular parameterised identifier from the list is only valid in this version of the specification if it has exactly the set of parameters required or explicitly allowed in this version of the spec. Then future evolution could work by adding extra elements to the list instead of adding extra parameters to elements that might be interpreted by old implementations.\r\n\r\nThe current design for evolving the spec, which is currently only implemented as the `application/signed-exchange` format, is to increment the overall version number and rely on content negotiation to pick the right file, which doesn't need an extension point here at all. However, there's some interest in making the format a little more extensible than that, so we should come back to this when we think that through.",
          "createdAt": "2019-06-27T21:55:33Z",
          "updatedAt": "2019-06-27T21:55:33Z"
        }
      ]
    },
    {
      "number": 445,
      "id": "MDU6SXNzdWU0NTcyNjIzNzI=",
      "title": "Content-Type requirement for bundled responses",
      "url": "https://github.com/WICG/webpackage/issues/445",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#load-response\r\n\r\n> 9. If headers does not contain a Content-Type header, return an error.\r\n>\r\n>    The client MUST interpret the following payload as this specified media type instead of trying to sniff a media type from the bytes of the payload, for example by appending an artificial X-Content-Type-Options: nosniff header field ([FETCH]) to headers.\r\n\r\nShould we require `Content-Type` for 3xx redirection responses that don't have response body?\r\n\r\n",
      "createdAt": "2019-06-18T05:02:57Z",
      "updatedAt": "2019-08-09T18:37:41Z",
      "closedAt": "2019-08-09T18:37:41Z",
      "comments": []
    },
    {
      "number": 446,
      "id": "MDU6SXNzdWU0NTkzNDI3MjY=",
      "title": "Bundle parsing algorithm doesn't describe when to apply critical section",
      "url": "https://github.com/WICG/webpackage/issues/446",
      "state": "CLOSED",
      "author": "davidben",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Section 3.3.3, parsing the critical section, is only referenced in 3.1, which is non-normative, and 6.2, which is just some registry bits. However, if I'm understanding this right, webbundle parsers *today* need to correctly handle it. Otherwise, critical sections defined in the future won't work properly. Should section 3.3 include it?\r\n\r\nRelatedly, given how critical (hah) it is, maybe it makes sense to put it in section-lengths, and have it be 3-tuples of name, length, boolean. That saves parsers an extra seek and read.",
      "createdAt": "2019-06-21T19:32:01Z",
      "updatedAt": "2019-06-21T19:45:56Z",
      "closedAt": "2019-06-21T19:45:56Z",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, I see. It's parsed as part of step 17.6 when you process all the metadata sections.",
          "createdAt": "2019-06-21T19:45:56Z",
          "updatedAt": "2019-06-21T19:45:56Z"
        }
      ]
    },
    {
      "number": 449,
      "id": "MDU6SXNzdWU0NjM4OTM5NzY=",
      "title": "Expose signing date to Javascript",
      "url": "https://github.com/WICG/webpackage/issues/449",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "While a publisher could manually incorporate the signing time into the content of their signed package, it would be easier for libraries to use that time, for example to [check that content isn't \"too old\"](https://github.com/WICG/webpackage/issues/376), if there were a standard place to look for it.\r\n\r\nFor signed exchanges, we could put it into the `Document`, for example `document.package.signedAt`. However:\r\n\r\n1. A signed exchange can have multiple signatures with different signing times. The most important one is the one that establishes cross-origin trust, but libraries might want to be able to see other signatures.\r\n1. We also want to be able to see the signing time for members of bundles, which might work better as a field in the [`Response`](https://fetch.spec.whatwg.org/#concept-response), and then we might refer to the Response or the relevant fields from any Document [initialised from it](https://html.spec.whatwg.org/multipage/browsing-the-web.html#initialise-the-document-object)...\r\n1. This might be a concept we should expose for other cached things, in which case the place we expose it should make sense for non-packaged things. At that point, would we just expose the `Date` HTTP header? The signing time(s) could be different from the `Date`, so we might want to expose both anyway.",
      "createdAt": "2019-07-03T18:24:51Z",
      "updatedAt": "2019-07-03T18:41:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "I'd like to avoid exposing this, for now.\r\n\r\nAs you note, there isn't a notion of a single signing date, but there may be multiple. It's also important the the signing dates may change over time as content is resigned, but the 'logical' date of the content, if you will, may not have changed. That is, if I append a signature, is it refreshing the lifetime of the data?\r\n\r\nOther signing solutions make sure to treat these elements as distinct; even counter-signature schemes like timestamping schemes treat signing and timestamping independently.\r\n\r\nFrom an [Extensible Web Manifesto](https://github.com/extensibleweb/manifesto) perspective, it seems like SXG and Bundles provide all the necessary building blocks to explore a variety of solutions. Further, as you note, the 'Date' header may be sufficient in the future, or may be generally applicable even to content from the disk cache.\r\n\r\nBy avoiding prematurely standardizing it, we ensure that there are not implicit or explicit dependencies, by 'things-that-are-packaged', on 'how-they-are-packaged'. For example, I want to avoid a situation where moving from one signature to many signatures complicates the API, or if a trusted timestamping service would be introduced, where there are multiple notions of 'signing date'. The less we expose, the better, and authors have the flexibility to explore the paths with their cows for the platform to later standardize :)",
          "createdAt": "2019-07-03T18:41:44Z",
          "updatedAt": "2019-07-03T18:41:44Z"
        }
      ]
    },
    {
      "number": 462,
      "id": "MDU6SXNzdWU0Njk4OTEwMDI=",
      "title": "dump-certurl and dump-signedexchange do not verify the dates of OCSP response",
      "url": "https://github.com/WICG/webpackage/issues/462",
      "state": "OPEN",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When `NextUpdate` is in the past, signed exchanges are invalid. `dump-certurl` and `dump-signedexchange` do not currently check these dates -- they should.",
      "createdAt": "2019-07-18T17:15:37Z",
      "updatedAt": "2019-07-18T17:15:37Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 463,
      "id": "MDU6SXNzdWU0NzExNjUxODc=",
      "title": "Document how the web relies on transport security",
      "url": "https://github.com/WICG/webpackage/issues/463",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "At IETF105, @DKG explained a worry that I think several people have: The web's only current security system is based on proving that the transport channel is connected to an appropriate endpoint. Signed Web Packages try to replace that with object security, proof that the right person signed the resource at some time. Since the web is big, it's hard to be confident that we're not going to break anything by making that change.\r\n\r\nSo, we should try to make a complete list of how the web tries to be secure, describe how those attempts rely on transport security, and describe how that's affected by a switch to object security.",
      "createdAt": "2019-07-22T15:38:46Z",
      "updatedAt": "2019-07-22T15:38:46Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 465,
      "id": "MDU6SXNzdWU0NzE4MzA3NTM=",
      "title": "Write a Human Rights Considerations section",
      "url": "https://github.com/WICG/webpackage/issues/465",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "The first step is to answer the rough questionnaire at https://tools.ietf.org/html/draft-irtf-hrpc-guidelines-03.",
      "createdAt": "2019-07-23T17:31:21Z",
      "updatedAt": "2019-07-23T17:31:21Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 468,
      "id": "MDU6SXNzdWU0NzMxMzc3ODE=",
      "title": "Clarify what URL schemes are allowed in Bundled Exchanges",
      "url": "https://github.com/WICG/webpackage/issues/468",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "Current bundle spec says that [Bundled Exchanges parser must fail if URL have a fragment or credentials](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#index-section), but says nothing about the URL scheme.\r\n\r\nIn Signed Exchange, [exchange's URL must be `https:`](https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#application-signed-exchange). Sould Bundled Exchanges follow this, or should also allow `http:`? Since exchange is defined as HTTP request+response pair, I think non-http(s) schemes don't make sense.\r\n",
      "createdAt": "2019-07-26T01:42:32Z",
      "updatedAt": "2020-01-29T04:49:44Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Especially for books, there's some use for the [`cid:`](https://tools.ietf.org/html/rfc2392) scheme for things that exist within the package but aren't reachable with an HTTP lookup. I haven't thought through all the details of which schemes actually work.\r\n\r\nWe could restrict bundle resource URLs to http(s) anyway and loosen that when we get a more concrete use case, or we could restrict them just in the browser-side loading spec for now. I don't have a strong preference here.",
          "createdAt": "2019-08-09T00:40:28Z",
          "updatedAt": "2019-08-09T00:40:28Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Got it. For now, I'm going to restrict them to http(s) in Chromium implementation.\r\n\r\n> We could restrict bundle resource URLs to http(s) anyway and loosen that when we get a more concrete use case, or we could restrict them just in the browser-side loading spec for now. I don't have a strong preference here.\r\n\r\nI don't have a preference either.\r\n",
          "createdAt": "2019-08-16T05:04:57Z",
          "updatedAt": "2019-08-16T05:04:57Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm trying to implement \"Save page as Web Bundle\" feature in Chromium (https://crbug.com/1040752). This feature will provide users with a way to save the selialized current page as a Web Bundle file. This will behave almost same as the existing \"Save page as MHTML\" feature.\r\n\r\nFor serializing a page, we want to use the `cid:` scheme for two purposes.\r\n\r\n1. URL for subframes:\r\n   - We can\u2019t use the original URL of subframe, because there may be the same URL subframes which contents are different when they are serialized. And also inline iframe `<iframe srcdoc=\u201d...\u201d>` doesn\u2019t have a URL. So we need `cid:` scheme for it.\r\n   - See this doc https://goo.gl/GYT7Br#heading=h.jb2ehfs7vtcw about how Chromium handles iframes while generating MHTML. \r\n\r\n1. Style elements\r\n   - Chrome also uses `cid:` scheme for stlye element while generating MHTML.\r\n   - See this doc https://goo.gl/GYT7Br#heading=h.1mjt2ly8g7u about how Chromium handles style elements while generating MHTML. \r\n   - Even if we can't use `cid:` scheme for Web Bundles, we can just put the serialized CSS text into the style elemnts. But if we can use `cid:` scheme, we can reuse the existing logic for MHTML.\r\n",
          "createdAt": "2020-01-28T01:59:27Z",
          "updatedAt": "2020-01-28T01:59:27Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Having endorsed `cid:` [before](https://github.com/WICG/webpackage/issues/468#issuecomment-519735907), I'm now nervous about using it for this, as its [definition](https://tools.ietf.org/html/rfc2392) is very tied to MIME, which packages aren't. That said, it'll probably work fine.\r\n\r\nI *think* we could use a [`urn:uuid:` URI](https://tools.ietf.org/html/rfc4122) for this purpose. Even if y'all go with `cid:` now to re-use the MHTML code paths, please try to architect it so that we could switch as the standardization process proceeds.",
          "createdAt": "2020-01-28T21:43:41Z",
          "updatedAt": "2020-01-28T21:43:41Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Using `urn:uuid:` URI sounds good.\r\nWe need to slightly change the serialization logic, but it is possible to implement.\r\n",
          "createdAt": "2020-01-29T04:49:44Z",
          "updatedAt": "2020-01-29T04:49:44Z"
        }
      ]
    },
    {
      "number": 469,
      "id": "MDU6SXNzdWU0NzMxNzMzMDI=",
      "title": "Requirements of bundle's primaryUrl",
      "url": "https://github.com/WICG/webpackage/issues/469",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges",
        "needs spec"
      ],
      "body": "[Section 2.2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#semantics-load-metadata) of Bundled Exchanges spec says:\r\n\r\n> primaryUrl  The URL of the main resource in the bundle.\r\n\r\nDoes this mean that the bundle's index section must have an entry for `primaryUrl`? If so, \"Parsing the index section\" section should check that condition.\r\n(Also, that would imply that requirements of exchange URLs are applied to `primaryUrl` too.)",
      "createdAt": "2019-07-26T04:36:22Z",
      "updatedAt": "2019-08-16T22:58:38Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think it's plausible to consider bundles that don't include their primary URL, and are just used to serve its subresources, but that's a little weird, so I'm happy to ban it for now.",
          "createdAt": "2019-08-09T00:30:24Z",
          "updatedAt": "2019-08-09T00:30:24Z"
        },
        {
          "author": "toyoshim",
          "authorAssociation": "NONE",
          "body": "Exchange URLs have a restriction that it could not contain a fragment part, but how about primaryURL?\r\n\r\nThere may be a case that author want it to point the anchor point in an exchange. But in such case, we will see a conflict if the given bundle's URL also had a fragment part (*1), and it's unclear what is the right URL to navigate. Probably it's fine to have the same restriction to disallow fragment parts unless someone find an important use-case.\r\n\r\n(*1) an example:\r\nWhen a user navigate to https://www.example.com/example.wbn#first_section, primaryUrl may be https://www.example.com/primary_url#overview.",
          "createdAt": "2019-08-16T08:15:00Z",
          "updatedAt": "2019-08-16T08:15:00Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think we should ban fragments in the primaryURL.",
          "createdAt": "2019-08-16T22:58:38Z",
          "updatedAt": "2019-08-16T22:58:38Z"
        }
      ]
    },
    {
      "number": 470,
      "id": "MDU6SXNzdWU0NzM0NDU3NDY=",
      "title": "Extend Accept-Signature to include app/s-e response type",
      "url": "https://github.com/WICG/webpackage/issues/470",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "[The Accept-Signature header](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#accept-signature) says:\r\n\r\n> When a server receives an `Accept-Signature` header field in a client request, it SHOULD reply with any available `Signature` header fields for its response that the `Accept-Signature` header field indicates the client supports.\r\n\r\nHowever, the same-origin `Signature` response may be less reliable than `application/signed-exchange`, due to possible undesired transformations of signed data (headers or payload). Consider modifying this section to say that a server MAY reply with an `application/signed-exchange` instead.",
      "createdAt": "2019-07-26T16:44:12Z",
      "updatedAt": "2019-08-16T22:59:42Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "That sounds like a good change.",
          "createdAt": "2019-08-16T22:59:32Z",
          "updatedAt": "2019-08-16T22:59:32Z"
        }
      ]
    },
    {
      "number": 471,
      "id": "MDU6SXNzdWU0NzM0NDgwNjA=",
      "title": "Consider removing or generalizing Accept-Signature identifiers",
      "url": "https://github.com/WICG/webpackage/issues/471",
      "state": "OPEN",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Once https://github.com/WICG/webpackage/issues/187 is fixed, the signaling of requested algorithms may be redundant, or worse, ossifying.\r\n\r\nIt's not clear to me if some signaling may still be useful e.g. whether this is meant for SRI or top-level. Is there harm in the server sending all signatures in all cases?",
      "createdAt": "2019-07-26T16:50:44Z",
      "updatedAt": "2019-07-26T16:50:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 472,
      "id": "MDU6SXNzdWU0NzM5NTU0MTM=",
      "title": "Signature Validation of Bundled Exchanges",
      "url": "https://github.com/WICG/webpackage/issues/472",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Bundled Exchanges spec [defines the format of signature section](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#signatures-section) but doesn't define how to validate it.\r\n\r\nI can imagine how validation works; To validate `(authority, sig, signed)` triple in `vouched-subsets`, a client would run an algorithm similar to the [SXG's Signature validity](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity) but its entities replaced as follows:\r\n\r\n- `requestUrl` -> `signed.subset-hashes` which includes `whatwg-url`\r\n- `responseHeaders` -> `signed.subset-hashes` which includes `header-sha256`\r\n- `payload` -> `payload` in the responses section\r\n- `signature` -> `sig`\r\n- `integrity` -> `payload-integrity-header` included in `signed.subset-hashes`\r\n- `validity-url` -> `signed.validity-url`\r\n- `cert-sha256` -> `signed.auth-sha256`\r\n- `date` -> `signed.date`\r\n- `expires` -> `signed.expires`\r\n- `certificate-chain` -> `authorities`\r\n- `main-certificate` -> `authorities[authority]`\r\n\r\nDoes this align with your idea? @jyasskin\r\n\r\nQuestions:\r\n\r\n- Will signing message be the `signed` binary string itself? It doesn't have the 64-spaces padding nor a context string.\r\n- What's the content of resource at `validity-url`?\r\n- Do the requirements of SXG headers (e.g. no uncached fields) apply to BXG too? Response headers are not included in bundle's metadata, so it'd have to be checked in a later step of loading (it wouldn't be a big deal though).\r\n- What about the certificate requirements?\r\n- Is it possible to unify the algorithm to SXG's validation algorithm? It would make implementation simpler.\r\n",
      "createdAt": "2019-07-29T09:47:51Z",
      "updatedAt": "2019-08-29T07:58:56Z",
      "closedAt": "2019-08-29T07:58:56Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "In general, bundle signature checking should happen before the `signed` `bstr` is parsed into fields. Then a resource gets checked against the `subset-hashes` as it's being loaded. Looking at https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#load-response, I need to change that to check the `headers` `bstr` against the `header-sha256` before parsing it.\r\n\r\n1. To check a TLS-like X.509 certificate's signature, I believe the message needs to be the concatenation of:\r\n   1. A string that consists of octet 32 (0x20) repeated 64 times.\r\n   1. A context string: the ASCII encoding of \"Web Package 1\". (\"Web Package 1 b1\" for the b1 implementation version.)\r\n   1. A single 0 byte which serves as a separator.\r\n   1. The `signed` `bstr`.\r\n\r\n   For non-X.509 authorities, I think we don't really need that prefix, but I'm not sure if we should keep it just to keep everything uniform.\r\n\r\n1. I haven't worked out what the `validity-url` will point to yet. I think it may be the same as in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#updating-validity with the `signatures` field's value changed from `[ + bytes ]` to the `signatures` CDDL rule from https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#signatures-section.\r\n\r\n1. Yes, the restrictions on headers will need to be processed while loading the resource, rather than while parsing the metadata. I think the same set of \r\n\r\n1. Also the same certificate requirements as SXG for cross-origin trust.\r\n\r\n1. If we want to unify Signed Exchange signature checking with Bundle signature checking, I'd push for changing the SXG `Signature` string (\"sigLength bytes holding the Signature header field\u2019s value\" from https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#application-signed-exchange) into a format where the signed data can also be checked before it's parsed.",
          "createdAt": "2019-08-09T22:10:36Z",
          "updatedAt": "2019-08-09T22:10:36Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks, I'm working on a bundle signing tool based on this information. ([WIP code here](https://github.com/irori/webpackage/tree/sign-bundle))\r\n\r\nTwo additional questions:\r\n\r\n- Is `payload-integrity-header` the same format as the SXG signature's `integrity` parameter (like \"digest/mi-sha256-03\")?\r\n- Is `auth-sha256` the hash of the DER-encoded X.509v3 certificate (that matches SXG's `cert-sha256`), or the hash of the `authority` (= `augmented-certificate`) CBOR item?\r\n",
          "createdAt": "2019-08-15T06:25:05Z",
          "updatedAt": "2019-08-15T06:25:05Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "1. My intent is that `payload-integrity-header` is the same format as the SXG signature's `integrity` parameter.\r\n1. My intent is that `auth-sha256` is the hash of the same bytes as the SXG's `cert-sha256`. I think there's a possibility that both of those will change, but  I think they'll change together if they do.",
          "createdAt": "2019-08-16T22:22:18Z",
          "updatedAt": "2019-08-16T22:22:18Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Now we have signature generation / verification implementation in the Go tools (#490 #493).",
          "createdAt": "2019-08-29T07:58:55Z",
          "updatedAt": "2019-08-29T07:58:55Z"
        }
      ]
    },
    {
      "number": 473,
      "id": "MDU6SXNzdWU0NzQwMTg2NzI=",
      "title": "Certificate verification error ERR_CERT_AUTHORITY_INVALID",
      "url": "https://github.com/WICG/webpackage/issues/473",
      "state": "CLOSED",
      "author": "iesiyok",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi there,\r\n\r\nI am doing the same instructions here https://github.com/WICG/webpackage/tree/master/go/signedexchange without the trusted signed exhanges.\r\n\r\n```\r\n>echo \"<h1>hi</h1>\" > payload.html\r\n>openssl ecparam -out priv.key -name prime256v1 -genkey\r\n>openssl req -new -sha256 -key priv.key -out cert.csr -subj '/CN=localhost/O=Test/C=US'\r\n>openssl x509 -req -days 360 -in cert.csr -signkey priv.key -out cert.pem \\\r\n  -extfile <(echo -e \"1.3.6.1.4.1.11129.2.1.22 = ASN1:NULL\\nsubjectAltName=DNS:localhost\")\r\n>gen-certurl -pem cert.pem -ocsp <(echo ocsp) > cert.cbor\r\n>gen-signedexchange \\\r\n  -uri https://localhost:1447/welcome/hello.html \\\r\n  -content ./payload.html \\\r\n  -certificate cert.pem \\\r\n  -privateKey priv.key \\\r\n  -certUrl https://issuer.org.dev:1448/cert.cbor \\\r\n  -validityUrl https://localhost:1447/resource.validity.msg \\\r\n  -o payload.sxg\r\n```\r\n\r\nI am using nginx:\r\n>vim nginx.conf\r\n```\r\nserver {\r\n      listen 1448 ssl;\r\n      server_name issuer.org.dev;\r\n       ssl_certificate      cert_ca/sites/issuer/dev.issuer.org.crt;\r\n       ssl_certificate_key  cert_ca/sites/issuer/dev.issuer.org.key;\r\n       ssl_protocols TLSv1 TLSv1.1 TLSv1.2;\r\n       ssl_prefer_server_ciphers  on;\r\n       ssl_ciphers  ECDH+AESGCM:ECDH+AES256:ECDH+AES128:DH+3DES:!ADH:!AECDH:!MD5;\r\n       ssl_dhparam cert/dhparam.pem;\r\n       ssl_session_cache   shared:SSL:40m; #40M size of cache\r\n       ssl_session_timeout 2h; #2 hours\r\n       ssl_session_tickets on;\r\n      root /usr/local/etc/openresty/cert_ca/sites/webserver/v2;\r\n      location /cert.cbor {\r\n       \r\n      }\r\n\r\n      location /payload.sxg {\r\n\r\n        add_header Cache-Control \"no-transform\";\r\n        add_header X-Content-Type-Options \"nosniff\";\r\n\r\n      }\r\n    }\r\n\r\n```\r\n\r\n>curl -k -i https://issuer.org.dev:1448/payload.sxg           \r\n```\r\nHTTP/1.1 200 OK\r\nServer: openresty/1.15.8.1\r\nDate: Mon, 29 Jul 2019 12:09:39 GMT\r\nContent-Type: application/signed-exchange;v=b3\r\nContent-Length: 570\r\nLast-Modified: Mon, 29 Jul 2019 11:55:26 GMT\r\nConnection: keep-alive\r\nETag: \"5d3edeae-23a\"\r\nCache-Control: no-transform\r\nX-Content-Type-Options: nosniff\r\nAccept-Ranges: bytes\r\nWarning: Binary output can mess up your terminal. Use \"--output -\" to tell \r\nWarning: curl to output it to your terminal anyway, or consider \"--output \r\nWarning: <FILE>\" to save to a file.\r\n```\r\n\r\n>curl -k -i https://issuer.org.dev:1448/cert.cbor  \r\n```\r\nHTTP/1.1 200 OK\r\nServer: openresty/1.15.8.1\r\nDate: Mon, 29 Jul 2019 12:10:34 GMT\r\nContent-Type: application/cert-chain+cbor\r\nContent-Length: 419\r\nLast-Modified: Mon, 29 Jul 2019 11:54:48 GMT\r\nConnection: keep-alive\r\nETag: \"5d3ede88-1a3\"\r\nAccept-Ranges: bytes\r\nWarning: Binary output can mess up your terminal. Use \"--output -\" to tell \r\nWarning: curl to output it to your terminal anyway, or consider \"--output \r\nWarning: <FILE>\" to save to a file.\r\n```\r\n\r\n\r\n```\r\n>vim a.html\r\n<html>\r\n<head>\r\n\t<link rel=\"prefetch\" href=\"https://issuer.org.dev:1448/payload.sxg\" >\r\n</head>\r\n<body>\r\n</body>\r\n</html>\r\n```\r\n\r\n>`google-chrome a.html --args --user_data_dir=/dev/null Support/Google/Chrome/Default --ignore-certificate-errors-spki-list=`openssl x509 -noout -pubkey -in cert.pem | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64` --enable-features=SignedHTTPExchange`\r\n\r\n>The page is empty and inspect gives two errors like the following:\r\n\r\n**Certificate verification error: ERR_CERT_AUTHORITY_INVALID\r\nFailed to load resource: net::ERR_INVALID_SIGNED_EXCHANGE**\r\n\r\nWhat could I do to solve this?\r\n",
      "createdAt": "2019-07-29T12:17:53Z",
      "updatedAt": "2019-08-02T08:54:53Z",
      "closedAt": "2019-08-02T08:54:53Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "ERR_CERT_AUTHORITY_INVALID error suggests that `--ignore-certificate-errors-spki-list` flag is not working as intended.\r\n\r\nWhen you launched `google-chrome`, did you see an infobar saying \"You are using unsupported command-line flag: --ignore-certificate-errors-spki-list=<base64 value>. Stability and security will suffer.\" ? If not, try again after closing all other Google Chrome windows.\r\n",
          "createdAt": "2019-07-30T08:28:27Z",
          "updatedAt": "2019-07-30T08:28:27Z"
        },
        {
          "author": "iesiyok",
          "authorAssociation": "NONE",
          "body": "Thank you very much for your support.\r\n\r\nI exactly see the infobar saying \"You are using unsupported command-line flag: --ignore-certificate-errors-spki-list=. Stability and security will suffer.\"\r\n\r\nI couldn't find anything about this problem,",
          "createdAt": "2019-07-30T09:24:36Z",
          "updatedAt": "2019-07-30T09:24:36Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Just to confirm, the infobar showed some base64 encoded string after `--ignore-certificate-errors-spki-list=`, right?\r\n\r\nIf not, just run\r\n```\r\nopenssl x509 -noout -pubkey -in cert.pem | openssl pkey -pubin -outform der | openssl dgst -sha256 -binary | base64\r\n```\r\nand see what happens.",
          "createdAt": "2019-07-30T09:51:55Z",
          "updatedAt": "2019-07-30T09:51:55Z"
        },
        {
          "author": "iesiyok",
          "authorAssociation": "NONE",
          "body": "No, it shows the base64 \r\n\r\nYou are using unsupported command-line flag: --ignore-certificate-errors-spki-list=Elmufwo55170Htld8S5/7ffozDOe9khQzoxDqfltY2I=.  Stability and security will suffer.\r\n\r\nBut, the inspect doesn't show any warnings any more, \r\nI believe it's working now even though there is this unsupported command-line flag.\r\n\r\nThank you very much for your support.",
          "createdAt": "2019-07-30T10:31:06Z",
          "updatedAt": "2019-07-30T10:37:14Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "I wonder if the problem is `--user_data_dir=/dev/null`; try putting an empty directory there.",
          "createdAt": "2019-07-30T15:35:53Z",
          "updatedAt": "2019-07-30T15:35:53Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Oh, that should be `user-data-dir` with dashes not underscores.",
          "createdAt": "2019-07-30T15:36:40Z",
          "updatedAt": "2019-07-30T15:36:40Z"
        },
        {
          "author": "iesiyok",
          "authorAssociation": "NONE",
          "body": "I think it works now, but I couldn't figure out how to use this with link prefetch.\r\nImagine I just have a json file packed with sxg.\r\nIn html header I prefetch it, \r\n<link rel=\"prefetch\" href=\"https://issuer.org.dev:1448/payload.sxg\" >\r\n\r\nin body, I want to use it if its signature is verified.\r\n\r\n$.get( \"https://issuer.org.dev:1448/payload.sxg\", function( data ) {\r\n  console.log( data );\r\n});\r\n\r\nBut it gives me the raw .sxg content:\r\nsxg1-b3\u0000\u0000!https://localhost:1447/hello.html\u0000\u0001W\u0000\u0000\ufffdlabel;cert-sha256=*HrdZMVAqYm+rynoFP3GM89JfKxwqfbTbSPAXG7ysMrU=*;cert-url=\"https://issuer.org.dev:1448/cert.cbor\";date=1564498201;expires=1564501801;integrity=\"digest/mi-sha256-03\";sig=*MEUCIQD/FQBZ9rBybf0c4u0BTK8rheTOgkkjtWmy1xqqkcunYAIgS3GMVx7wJ/5Sn/536+R3GQnslM92SqtCZNfyThwM3oE=*;validity-url=\"https://localhost:1447/resource.validity.msg\"\ufffdFdigestX9mi-sha256-03=KJEdU9urAJP74QIDJW9z7/ehLlmaZmbRdlYb73Nu/3k=G:statusC200Lcontent-typeX\u0018text/html; charset=utf-8Pcontent-encodingLmi-sha256-03\u0000\u0000\u0000\u0000\u0000\u0000\u0010\u0000{\r\n ...............\r\n\r\nI want to get the json content, are there any events that I can check if the signature verified and I can take the content without the signature and so on?\r\n",
          "createdAt": "2019-07-30T15:41:51Z",
          "updatedAt": "2019-07-30T15:41:51Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "In Chrome, currently signed exchanges cannot be used as XHR targets. It can be used only as main resources, for example:\r\n\r\n```\r\n<head>\r\n<link rel=\"prefetch\" href=\"https://issuer.org.dev:1448/payload.sxg\" >\r\n</head>\r\n<a href=\"https://issuer.org.dev:1448/payload.sxg\">navigate to SXG</a>\r\n```\r\n\r\nThis prefetches a sxg, and if a user clicks the link, navigates to the sxg content (using the prefetched sxg resource).\r\n",
          "createdAt": "2019-07-31T05:22:34Z",
          "updatedAt": "2019-07-31T05:22:34Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing, but feel free to add comments if you have further questions.",
          "createdAt": "2019-08-02T08:54:53Z",
          "updatedAt": "2019-08-02T08:54:53Z"
        }
      ]
    },
    {
      "number": 477,
      "id": "MDU6SXNzdWU0NzYyNzA2ODI=",
      "title": "Study tlsnotary.org experience",
      "url": "https://github.com/WICG/webpackage/issues/477",
      "state": "CLOSED",
      "author": "safinaskar",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hi. There is a https://tlsnotary.org/ project, which has somewhat similar goal with \"Signed HTTP exchanges\", i. e. an ability to prove that http(s) exchange was performed. But https://tlsnotary.org/ is different in many aspects. Please, learn their experience",
      "createdAt": "2019-08-02T16:52:56Z",
      "updatedAt": "2019-08-02T19:36:38Z",
      "closedAt": "2019-08-02T17:18:21Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "tlsnotary.org describes an online protocol that depends critically on the order of messages sent between the auditor (client in web packaging terms?), auditee (distributor in web packaging terms?), and server (publisher in web packaging terms), in particular information transferred from the auditor to the server, while web packaging intends to work offline. It also says changes in TLS1.2 broke it. So, I don't think it's likely to give useful information to the web packaging effort. If you know of particular experience from that project that's relevant here, I'd still be happy to hear it.",
          "createdAt": "2019-08-02T17:18:21Z",
          "updatedAt": "2019-08-02T17:21:48Z"
        },
        {
          "author": "safinaskar",
          "authorAssociation": "NONE",
          "body": "@jyasskin. I didn't use that project, I just have read that site. tlsnotary also have https://tlsnotary.org/pagesigner.html , i. e. tool for offline proving. But it requires trusted server. And authors propose using Amazon virtual server with published sources",
          "createdAt": "2019-08-02T19:04:49Z",
          "updatedAt": "2019-08-02T19:04:49Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Hi, thanks for the link. I'm just a consumer of the spec, not an author, but here's my attempt to learn from that site.\r\n\r\nIIUC, if this worked on TLS1.3, it might be usable as a way to generate SXGs from sites that don't generate one themselves. AFAIK, that's not a goal of web packaging (though I'm not sure I've heard that it's an explicit non-goal). To do so would require additional work to protect those sites from attacks such as [downgrade](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#seccons-downgrades) / [misleading content](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#seccons-misleading-content).\r\n\r\nFor sites that generate SXGs, then doing so is a lot less complex (and thus easier to reason about) than the tlsnotary solution.\r\n\r\nOTOH, it alone doesn't solve all the issues necessary to trust the content enough to render it in a user-agent, such as downgrades, cert revocation, and cert misissuance. So a solution built on this would need much of the extra SXG infrastructure anyhow.\r\n\r\nIn addition, it seems like the PageSigner approach depends on trust in the central \"oracle\" servers in order to trust the integrity. SXG has some central dependencies (on PKI infra & CT logs), but creating new ones seems risky.",
          "createdAt": "2019-08-02T19:27:35Z",
          "updatedAt": "2019-08-02T19:36:38Z"
        }
      ]
    },
    {
      "number": 478,
      "id": "MDU6SXNzdWU0NzY3Mjg2OTM=",
      "title": "Allowable HTTP status code for Bundle?",
      "url": "https://github.com/WICG/webpackage/issues/478",
      "state": "OPEN",
      "author": "toyoshim",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Currently, file formats just expect the status code should be exactly 3 ASCII decimal digits.\r\n\r\nBut for SignedExchanges, the \"Loading Signed Exchanges\" spec allows only 200 for the status code (https://wicg.github.io/webpackage/loading.html#parse-cbor-headers step 2).\r\n\r\nProbably, BundledExchanges also needs a similar restriction, but probably we want range requests and redirects work (206, 307, 308).\r\n\r\nFor Chrome implementation, we will start from just allowing only 200 for the initial experimental implementation, but will support others if we want.\r\n\r\ncrbug.com/990733 tracks the Chrome side implementation.",
      "createdAt": "2019-08-05T08:38:54Z",
      "updatedAt": "2019-09-05T08:54:37Z",
      "closedAt": null,
      "comments": [
        {
          "author": "toyoshim",
          "authorAssociation": "NONE",
          "body": "cc: @irori @kinu @jyasskin ",
          "createdAt": "2019-08-05T08:39:26Z",
          "updatedAt": "2019-08-05T08:39:26Z"
        },
        {
          "author": "toyoshim",
          "authorAssociation": "NONE",
          "body": "Here is the discussion for SignedExchange case; https://github.com/WICG/webpackage/pull/326",
          "createdAt": "2019-08-05T09:05:01Z",
          "updatedAt": "2019-08-05T09:05:01Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think it probably makes sense to allow redirects in the bundle, but given the complexity of partial responses, I'd be inclined to keep them out until we find a more concrete use case. A bundle could still serve a partial request when it contains a complete response, although in cases where that's important, we probably also want a more seekable encoding than mi-sha256.\r\n\r\nFor now, +1 on having the Chrome implementation only handle 200s.",
          "createdAt": "2019-08-05T17:59:28Z",
          "updatedAt": "2019-08-05T17:59:28Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I agree that it could be useful to support range requests / 206. (We were looking into a use case where we want to support video resources in a bundle)  While- if we want to support it with mi-sha256 UA still probably needs to read everything in-memory or somewhere, so you're right that we might want a more seekable encoding :thinking: ",
          "createdAt": "2019-09-05T08:54:37Z",
          "updatedAt": "2019-09-05T08:54:37Z"
        }
      ]
    },
    {
      "number": 496,
      "id": "MDU6SXNzdWU0OTM2NjI4NzY=",
      "title": "Provide a formal way for one bundle of JS Modules to optionally reuse already loaded modules from another bundle ",
      "url": "https://github.com/WICG/webpackage/issues/496",
      "state": "OPEN",
      "author": "bahrus",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "This whole proposal is vague enough in my mind that I don't know if what I'm asking for is applicable or not.  I'm providing all my uncertainties, hoping that what I'm asking for will be clearer.  Hopefully this isn't totally irrelevant :-)\r\n\r\nLet's say two different [packages](https://github.com/WICG/webpackage/issues/411) may depend on possibly different versions of a common JS module (or is that never going to happen?).  It's great that ES Modules can (normally) be able to work with different versions at the same time, due to scope isolation, and not contend with \"dll hell\" type issues.  Packaging should honor that by default, erring on the side of caution.\r\n\r\nBut what about if the two packages aren't that particular about what version they can use (think specifying version ranges in npm dependencies)?  I'm assuming that packages wouldn't be able to figure that out on the fly.  So I would guess an ideal option might be manually creating a third package that contains the common dependencies.  In an ideal world, that all seems fine (I guess), no issues there.  And I'm also quite fine with the concept that we don't always live in an ideal world, and there will be scenarios where applications **download** multiple packages containing some redundancies.\r\n\r\nBut **downloading** is one thing.  **Loading** redundant modules into memory is also something that would be good to minimize where possible.  And there's one scenario where it's vital, and that has to do with using ES6 Symbols cross-package. \r\n\r\nI raised the issue in the [import maps proposal](https://github.com/WICG/import-maps/issues/132), thinking the issue would applicable there, but it isn't.  I just wanted to basically raise the same issue here, in case it is relevant here.\r\n\r\nI'm afraid I don't understanding the packaging proposal enough to propose anything concrete, but basically in the case of ES6 Symbols, I want to *require* only loading that module once, regardless of which one downloads first, but more generally, be able to specify ranges of acceptable versions, and reuse which one is loaded into memory first. ",
      "createdAt": "2019-09-14T20:23:11Z",
      "updatedAt": "2019-09-14T20:23:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 497,
      "id": "MDU6SXNzdWU0OTUwMDcwOTk=",
      "title": "unbundling tool?",
      "url": "https://github.com/WICG/webpackage/issues/497",
      "state": "OPEN",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I've been making bundles of exchanges from directories of files. It might be nice if there was a tool to do the reverse.\r\n\r\nFor the ESCAPE Workshop, I was going to submit my paper as a bundle, but I figured the organizers couldn't unbundle it :)",
      "createdAt": "2019-09-18T06:03:38Z",
      "updatedAt": "2020-01-23T07:18:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "casey",
          "authorAssociation": "NONE",
          "body": "Somewhat related: It would be nice if an unbundling tool could write a manifest file containing enough information for the original bundle to be losslessly reconstituted from the unbundled files + the manifest. Perhaps it could just be a normal bundle, but refer to the resources by hash, instead of containing the contents inline.",
          "createdAt": "2020-01-23T07:18:01Z",
          "updatedAt": "2020-01-23T07:18:18Z"
        }
      ]
    },
    {
      "number": 498,
      "id": "MDU6SXNzdWU0OTUwNTgxODc=",
      "title": "publishing use cases for persistent storage for bundles",
      "url": "https://github.com/WICG/webpackage/issues/498",
      "state": "OPEN",
      "author": "dauwhe",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "We hope that bundles (most likely unsigned?) would be used for distributing publications, such as ebooks. We do hope that some sort of persistent storage would be available on the user's device. Here's a list of a few use cases, [created by @jaypanoz](https://github.com/kobolabs/epub-spec/issues/38#issuecomment-365185776):\r\n\r\n\r\n* storing a list of quizzes/games which have already been done so that it doesn\u2019t reset every time you open the publication;\r\n* storing a list of values for a checklist so that you can automatically save the progress;\r\n* saving a drawing in a canvas \u2013 although this is a little bit of a hack as it can only store strings and you must base64-encode it on the fly\u2026 but when you\u2019ve got nothing else, it does the job;\r\n* saving the current position in an overflowing element since mishandling can happen (turning the page accidentally, which loads a new resource and resets the state of the current one);\r\n* saving the origin of a redirection to easily get back to the previous page if needed \u2013 yeah I know there\u2019s a \u201cprevious button\u201d in the bottom left corner but sometimes it takes years for users to discover it;\r\n* more generally saving any information you\u2019ll retrieve later, which can go from practical things like the examples above, to technical things like storing the results of a feature detect requiring to create an element, test its styles and remove it, which will cause a repaint (there are obviously different strategies to deal with upgrades or invalidate those results whenever needed there).\r\n\r\n\r\n\r\n\r\n",
      "createdAt": "2019-09-18T08:06:40Z",
      "updatedAt": "2020-06-11T08:05:18Z",
      "closedAt": null,
      "comments": [
        {
          "author": "elliotl",
          "authorAssociation": "NONE",
          "body": "I am also interested in using bundles as a publishing mechanism for distributing animations created with a Paint program that I wrote. The program currently supports the export of animations as simple web pages animated with webGL. Unfortunately, most of my users do not own domains, so copying a web page up to the web is not really feasible. I am hoping that running a web bundle stored on the local file system would provide a way for my users to share animations. An example of an exported animation  from my Paint program can be found at https://www.torpor.com/webgl/Hal/index.html .",
          "createdAt": "2020-06-11T08:05:18Z",
          "updatedAt": "2020-06-11T08:05:18Z"
        }
      ]
    },
    {
      "number": 499,
      "id": "MDU6SXNzdWU1MDA3NTg1MTc=",
      "title": "Can the manifest section be optional?",
      "url": "https://github.com/WICG/webpackage/issues/499",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "bundled-exchanges",
        "needs spec"
      ],
      "body": "Currently Bundled Exchanges [must have a `manifest` section](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#load-metadata). It was reasonable in the past because its `start_url` could be used to indicate the default resource in the bundle, but we now have the [primary URL](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#semantics-load-metadata) which is meant to be the bundle's main resource URL.\r\n\r\nAlso, in some use cases (for example [Save and share a web page](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html#snapshot)) manifest may not be available.\r\n",
      "createdAt": "2019-10-01T08:59:48Z",
      "updatedAt": "2019-10-16T23:52:27Z",
      "closedAt": "2019-10-16T23:52:27Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think it's a good idea to make the manifest optional, since the only field we actually need from the manifest is the `start_url`.",
          "createdAt": "2019-10-04T18:45:42Z",
          "updatedAt": "2019-10-04T18:45:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Fixed by #505.",
          "createdAt": "2019-10-16T23:52:27Z",
          "updatedAt": "2019-10-16T23:52:27Z"
        }
      ]
    },
    {
      "number": 500,
      "id": "MDU6SXNzdWU1MDEwNTc2Mzk=",
      "title": "SXG files can't be protected by nonce-based CSP",
      "url": "https://github.com/WICG/webpackage/issues/500",
      "state": "OPEN",
      "author": "shhnjk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "SXG file is valid for 7 days (IIRC), and that file will serve static response header specified inside SXG file. This doesn't align with the concept of nonce-based CSP, where server needs to serve random nonce for every request.\r\n\r\nSince SXG might have DOM-based XSS, attacker can just read nonce inside the SXG file and use same nonce in the XSS payload.\r\n\r\nWe should expose option to service CSP nonce, which is generated by browser when rendering SXG file. Publisher of SXG file can specify `<script nonce={}>`, where browser will replace `{}` with randomly generated nonce for every request. This should be safe because SXG file is a static file, so there is no threat for stored or reflected XSS. The only concern is the DOM XSS.",
      "createdAt": "2019-10-01T18:05:45Z",
      "updatedAt": "2019-10-08T18:15:12Z",
      "closedAt": null,
      "comments": [
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "CC: @mikewest @arturjanc",
          "createdAt": "2019-10-01T18:07:20Z",
          "updatedAt": "2019-10-01T18:07:20Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks for noticing this! Would it be better to ban nonces from packaged resources entirely? Or https://lists.w3.org/Archives/Public/public-webappsec/2014Sep/0055.html suggests an 'unsafe-static-inline', which might be equivalent to your `nonce={}` suggestion.",
          "createdAt": "2019-10-02T04:49:54Z",
          "updatedAt": "2019-10-02T04:49:54Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "My suspicion is that something like Trusted Types is going to be a better defense against DOM-based XSS than CSP.\r\n\r\nThat said, I have been thinking about a variant of CSP in which the browser would send out a nonce along with each request (I wrote a doc internally back in July... I should publish it somewhere), and expect the server to reflect it. It seems like that might be something we could assume for SXG, as you've noted above.",
          "createdAt": "2019-10-02T07:00:27Z",
          "updatedAt": "2019-10-02T07:00:27Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "(https://github.com/mikewest/strict-csp-for-everyone/, FWIW)",
          "createdAt": "2019-10-02T07:10:37Z",
          "updatedAt": "2019-10-02T07:10:37Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": ">Thanks for noticing this! Would it be better to ban nonces from packaged resources entirely? Or https://lists.w3.org/Archives/Public/public-webappsec/2014Sep/0055.html suggests an 'unsafe-static-inline', which might be equivalent to your nonce={} suggestion.\r\n\r\nI think browser should implement a way to serve nonce for static files. It's not only SXG that requires this feature, but also [extensions](https://bugs.chromium.org/p/chromium/issues/detail?id=965986).\r\n\r\n>My suspicion is that something like Trusted Types is going to be a better defense against DOM-based XSS than CSP.\r\n\r\nThen maybe we enforce Trusted Types to SXG files that has CSP? That way, we break all SXGs and the web is now safe\ud83d\ude0a  ",
          "createdAt": "2019-10-02T18:38:20Z",
          "updatedAt": "2019-10-02T18:38:20Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "I would say that Trusted Types and Mike's https://github.com/mikewest/strict-csp-for-everyone/ proposal are interesting platform solutions to this problem, and I'd bank on them being the recommended solutions for static content in the future.\r\n\r\nCurrently, CSP nonces have limitations which makes them a fairly poor fit for any cacheable content. Instead, an approach that could work well for SXG is hash-based CSP where external scripts are loaded via a bootstrapping script, as outlined in https://csp.withgoogle.com/docs/faq.html#static-content. My guess is that this would be fairly straightforward to deploy and can be useful until the other features ship.",
          "createdAt": "2019-10-04T09:26:19Z",
          "updatedAt": "2019-10-04T09:26:19Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "I agree with @arturjanc. So should we BAN nonce in SXGs until those feature ships? ",
          "createdAt": "2019-10-04T17:57:16Z",
          "updatedAt": "2019-10-04T17:57:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm happy to ban nonces in SXGs. Should they be banned or ignored for all cacheable content (which [is a superset of SXGs](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust))?",
          "createdAt": "2019-10-04T18:41:09Z",
          "updatedAt": "2019-10-04T18:41:09Z"
        },
        {
          "author": "arturjanc",
          "authorAssociation": "NONE",
          "body": "I don't think it's really necessary to have special logic for CSP in SXG. It's already possible to configure your CSP in ways that gives you no security benefit (e.g. `script-src 'unsafe-inline' https:`) and it's up to the developer to define a policy that will work for their setup. \r\n\r\nAlso, there is one mode of deploying nonce-based CSP in SXGs that could be useful:\r\n1. Set a CSP of `script-src 'nonce-staticknownvalue' 'strict-dynamic'`\r\n2. Add the nonce to all scripts in the SXG `<script nonce=\"staticknownvalue\">`.\r\n3. In the SXG, after `DOMContentLoaded`, add a new CSP via a `<meta>` element with a random, dynamically generated nonce and `strict-dynamic`:\r\n`script-src 'nonce-[Math.random()]' 'strict-dynamic'`\r\n\r\nSince both the original CSP and the dynamically added one will apply simultaneously, and their nonces will be different, the only scripts that will be able to be loaded by the SXG are those created by APIs allowed by `'strict-dynamic'`. This would protect the SXG from any injections that happen after `DOMContentLoaded`, assuming the lack of script gadgets.\r\n\r\nI wouldn't claim that it's a *good* way to use nonces, but it could be an interesting alternative to hashes in some scenarios. So allowing them in SXG files and cacheable content may offer some benefits (in addition to not introducing the complexity of different CSP behavior depending on the type of document.)",
          "createdAt": "2019-10-05T14:42:21Z",
          "updatedAt": "2019-10-05T14:42:21Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I generally agree with Artur's comments.\r\n\r\nI'd also note that hashes are probably a better answer, especially given the timeframe in which a specific bundle is known to be good. Some script files do change every 7 days, but many don't, and would be best locked-in via hashes. Since I imagine that bundler scripts must exist regardless in order to deal with the signature mechanism, it seems reasonable to point folks in that direction (with Artur's crazy hacks as a backstop).",
          "createdAt": "2019-10-07T09:00:39Z",
          "updatedAt": "2019-10-07T09:00:39Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "Agreed :)",
          "createdAt": "2019-10-07T13:47:28Z",
          "updatedAt": "2019-10-07T13:47:28Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Is that consensus to close this issue? If not, what's the next step?",
          "createdAt": "2019-10-08T18:11:45Z",
          "updatedAt": "2019-10-08T18:11:45Z"
        },
        {
          "author": "shhnjk",
          "authorAssociation": "NONE",
          "body": "Probably add security consideration, or inform SXG users to not to use nonce and use hash instead, if they are using CSP in SXG's inner response.",
          "createdAt": "2019-10-08T18:14:15Z",
          "updatedAt": "2019-10-08T18:14:15Z"
        }
      ]
    },
    {
      "number": 502,
      "id": "MDU6SXNzdWU1MDI5MjE0NjM=",
      "title": "How can I trigger SGX responses from an AMP cache?",
      "url": "https://github.com/WICG/webpackage/issues/502",
      "state": "CLOSED",
      "author": "coventry",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Cloudfront recently blogged [a demo](https://blog.cloudflare.com/real-urls-for-amp-cached-content-using-cloudflare-workers/#generating-http-signed-exchanges-with-workers) of \"HTTP signed exchanges in action on 1-800-Flowers,\" using Chrome Beta for Android. Is there a way to replicate that interaction using `curl`, so that the signed exchange is returned and I can inspect the headers? I can't figure out how to get a response via `curl` which includes a `Signature:` header, or otherwise seems to be a signed exchange.\r\n\r\nApologies if this is a bit off-topic for a repo which seems to be mostly focused on the webpackage standard. If there are better places to ask this question, I'd be grateful for pointers.",
      "createdAt": "2019-10-05T05:59:28Z",
      "updatedAt": "2019-10-05T19:38:16Z",
      "closedAt": "2019-10-05T19:12:54Z",
      "comments": [
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "From Google's AMP cache, you can trigger SXG responses via by passing an `accept: application/signed-exchange;v=b3` request header:\r\n\r\n```sh\r\ncurl -sS --output - -H 'accept: application/signed-exchange;v=b3' https://amp-dev.cdn.ampproject.org/wp/s/amp.dev/\r\n# SXG response\r\n```\r\n\r\nFrom an *origin*, you will typically need to pass both `accept: application/signed-exchange;v=b3` and `amp-cache-transform: google;v=\"1..100\"`:\r\n\r\n```sh\r\ncurl -sS --output - -H 'accept: application/signed-exchange;v=b3' -H 'amp-cache-transform: google;v=\"1..100\"' https://amp.dev/\r\n# SXG response\r\n```\r\n\r\n(You need both headers because there's no reason for origins to return SXGs to browsers--the URL is already \"correct\" and there's some overhead to processing SXGs.)\r\n\r\nThis should work the same way when Cloudflare is the origin, but testing just now there seem to be a few issues with the `1800flowers.com` server.\r\n\r\nBoth of these SXG responses can be piped into the [`dump-signedexchange` binary](https://github.com/WICG/webpackage/tree/master/go/signedexchange#dump-a-signed-exchange-file) to verify the response:\r\n\r\n```sh\r\n$ curl -sS --output - -H 'accept: application/signed-exchange;v=b3' -H 'amp-cache-transform: google;v=\"1..100\"' https://amp.dev/ | dump-signedexchange -verify\r\nformat version: 1b3\r\nrequest:\r\n  method: GET\r\n  uri: https://amp.dev/\r\n  headers:\r\n...\r\n```",
          "createdAt": "2019-10-05T18:59:34Z",
          "updatedAt": "2019-10-05T18:59:34Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Some documentation on signed exchanges in AMP is available at https://amp.dev/documentation/guides-and-tutorials/optimize-and-measure/signed-exchange/. For future such questions, AMP's [support page](https://amp.dev/support/) recommends Stack Overflow with the [amp-html tag](https://stackoverflow.com/questions/tagged/amp-html). If that fails, you can try #signed-exchanges on http://bit.ly/amp-slack-signup.",
          "createdAt": "2019-10-05T19:12:54Z",
          "updatedAt": "2019-10-05T19:12:54Z"
        },
        {
          "author": "coventry",
          "authorAssociation": "NONE",
          "body": "Thank you both very much for your help!",
          "createdAt": "2019-10-05T19:38:16Z",
          "updatedAt": "2019-10-05T19:38:16Z"
        }
      ]
    },
    {
      "number": 507,
      "id": "MDU6SXNzdWU1MTA2OTg2MTQ=",
      "title": "Specs rely on expired versions of Structured Headers draft",
      "url": "https://github.com/WICG/webpackage/issues/507",
      "state": "OPEN",
      "author": "clelland",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`draft-yasskin-httpbis-origin-signed-exchanges-impl.md` appears to be pinned to Structured Headers draft 10, which expired in April. `parser.go` looks like it references version 9. draft-yasskin-http-origin-signed-responses.md is not pinned to any particular version, and so generates references to the latest draft (13) when built, but references concepts which do not exist in that draft.\r\n\r\nCurrent versions do not use 'Parameterised List' any more, but the general 'List' structure should suffice for signed-exchanges, likely without any effective syntax changes.\r\n\r\n",
      "createdAt": "2019-10-22T14:33:13Z",
      "updatedAt": "2019-10-22T14:33:13Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 522,
      "id": "MDU6SXNzdWU1MTk3NTQyMzE=",
      "title": "js/bundle: Cannot generate large bundle",
      "url": "https://github.com/WICG/webpackage/issues/522",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "irori"
      ],
      "labels": [
        "bug"
      ],
      "body": "This generates broken bundle:\r\n\r\n```JavaScript\r\nconst wbn = require('wbn');\r\nconst builder = new wbn.BundleBuilder('http://example.com/');\r\nbuilder.addExchange('http://example.com/', 200,\r\n                    {'content-type': 'application/octet-stream'},\r\n                    new Uint8Array(1024*1024));  // 1MB content\r\nconst buf = builder.createBundle();\r\n```\r\n\r\nThe CBOR encoder we use is implemented using Node streams. It [chokes if it is given large (>16kB) input synchronously](https://github.com/hildjj/node-cbor#highwatermark), and generates truncated output.\r\n",
      "createdAt": "2019-11-08T05:03:00Z",
      "updatedAt": "2019-11-12T01:16:10Z",
      "closedAt": "2019-11-12T01:16:10Z",
      "comments": []
    },
    {
      "number": 526,
      "id": "MDU6SXNzdWU1MjA5NTU2NTg=",
      "title": "WebBundle for sub-resources",
      "url": "https://github.com/WICG/webpackage/issues/526",
      "state": "CLOSED",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Current Spec seems based on top level url(html) + subresouces.\r\nbut I think it can use for bundling subresource like JS modules.\r\n\r\nin current real world, JS modules are depends on tiny modules in npm.\r\nif you write correct import maps and serve node_modules directory on server will solve dependencies\r\non the browser.\r\n\r\nbut npm modules are so tiny (substack way), so there cause tons of fetch likely over 100.\r\nand Chrome Team reports this will cause IPC bottle neck.\r\n\r\nhttps://docs.google.com/document/d/1ds9EEkcDGnt-iR8SAN-_7nsOfw7gsMfhZjzZ_QAIyjM/edit\r\n\r\nfinally they recommend to use webpack and make them in single bundle.js. and developers doing that.\r\n\r\nthis means we don't use ES modules directory, even if spec has done, and impl has almost done in browser. `import` notation is only a keyword for webpack, and `<script type=text/javascript src=bundle.js>`. too sad to see them.\r\n\r\nif we can use WebBundles for bundling npm modules and fetch them in one time.\r\nand also browser extract and handle them as if they are fetched each-by-each.\r\nbrowser can cache as separated req/res pare, we can use them via `import`.\r\n\r\nwebbundle for subresources are also fine for WebFont(multi weight), CSS Sprite(bundle images), Favicon(apple-touch-icon, favicon.ico etc).\r\n\r\nso I believe webbundle will change our web content deployment.",
      "createdAt": "2019-11-11T13:14:04Z",
      "updatedAt": "2020-04-17T23:42:59Z",
      "closedAt": "2020-04-17T23:42:59Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think this issue is fixed by #565, which documents that we think it's an important use case to solve.",
          "createdAt": "2020-04-17T23:42:59Z",
          "updatedAt": "2020-04-17T23:42:59Z"
        }
      ]
    },
    {
      "number": 527,
      "id": "MDU6SXNzdWU1MjEwMjU0Nzg=",
      "title": "variation based on content-language ?",
      "url": "https://github.com/WICG/webpackage/issues/527",
      "state": "CLOSED",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "on 3.3.1. Parsing the index section\r\nhttps://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#index-section\r\n\r\n> For example, given a variants-value of Accept-Encoding;gzip;br, Accept-Language;en;fr;ja, the list of location-in-responses pairs will correspond to the VariantKeys:\r\n\r\nit seems based on Content-Encoding/Language instead of Accept-Encoding/Language ?",
      "createdAt": "2019-11-11T15:23:30Z",
      "updatedAt": "2019-11-14T20:11:19Z",
      "closedAt": "2019-11-14T20:11:19Z",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "What makes you think it should be based on Content instead of Accept? AFAIK Variant is based on request headers. See, for instance: https://tools.ietf.org/html/draft-ietf-httpbis-variants-05#appendix-A.2",
          "createdAt": "2019-11-11T22:12:53Z",
          "updatedAt": "2019-11-11T22:12:53Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "This example is correct. Variants header field values are request header based, as @twifkak mentioned.\r\n\r\nhttps://tools.ietf.org/html/draft-ietf-httpbis-variants-05#section-2\r\n\r\n>  The Variants HTTP response header field indicates what\r\n>  representations are available for a given resource at the time that\r\n>  the response is produced, by enumerating the request header fields\r\n>  that it varies on, along with the values that are available for each.\r\n",
          "createdAt": "2019-11-14T20:11:19Z",
          "updatedAt": "2019-11-14T20:11:19Z"
        }
      ]
    },
    {
      "number": 528,
      "id": "MDU6SXNzdWU1MjEwMzQ1MzI=",
      "title": "file format detection",
      "url": "https://github.com/WICG/webpackage/issues/528",
      "state": "OPEN",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "in https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.3.3\r\n\r\n> 2. If reading 10 bytes from stream returns an error or doesn\u2019t return the bytes with hex encoding \u201c86 48 F0 9F 8C 90 F0 9F 93 A6\u201d (the CBOR encoding of the 6-item array initial byte and 8-byte bytestring initial byte, followed by \ud83c\udf10\ud83d\udce6 in UTF-8), return a \u201cformat error\u201d.\r\n\r\nI think this will cause implements like below\r\n\r\n```js\r\nhead = read_first_10_byte(path)\r\n\r\nif (head == [86 48 F0 9F 8C 90 F0 9F 93 A6]) {\r\n  // this is web bundle\r\n  switch (parse_cbor(path)['version']) {\r\n    // version switch\r\n  }\r\n} else {\r\n  // this is not web bundle\r\n}\r\n```\r\n\r\nbut if webbundle format will change like below in the future. and also version ++.\r\n\r\n```js\r\nwebbundle = [\r\n  magic\r\n  version // *2*\r\n  primary-url\r\n  section-lengths\r\n  sections\r\n  extension // *new*\r\n  length\r\n]\r\n```\r\n\r\nthe length of array will increase and first 10 byte will change.\r\n\r\nthis cause previous code not working, should be like this\r\n\r\n```js\r\nhead = read_first_10_byte(path)\r\n\r\nif (head == [86 48 F0 9F 8C 90 F0 9F 93 A6]) {\r\n  // this is web bundle\r\n  switch (parse_cbor(path)['version']) {\r\n    // version switch\r\n  }\r\n} else if (head == [*87* 48 F0 9F 8C 90 F0 9F 93 A6]\r\n  // this is also new web bundle\r\n  switch (parse_cbor(path)['version']) {\r\n    // version switch\r\n  }\r\n} else {\r\n  // this is not web bundle\r\n}\r\n```\r\n\r\nso, this version model is not allow adding meta-section to webbundle cbor array.\r\nif you think *cbor array should not change from 6 forever*, it works.\r\nbut I think it seems better to find other way to \r\n\r\n1. magic number should usable for file detection\r\n2. cbor structure update could detect by version, and not affect to 1\r\n\r\nfor example\r\n\r\n```js\r\nwebbundle = [\r\n  magic\r\n  body\r\n  length\r\n]\r\n\r\nbody = [\r\n  version\r\n  primary-url\r\n  section-lengths\r\n  sections\r\n]\r\n```",
      "createdAt": "2019-11-11T15:39:36Z",
      "updatedAt": "2019-12-11T02:58:51Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 531,
      "id": "MDU6SXNzdWU1MjEzOTYzNTg=",
      "title": "<base href=\"/\" /> breaks request URLs from web bundle",
      "url": "https://github.com/WICG/webpackage/issues/531",
      "state": "CLOSED",
      "author": "lacolaco",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "`go/bundle` cannot make a valid bundle for HTML which includes `<base href=\"/\" />`. In the case, `.wbn` file will be actually created but HTTP requests from the document are broken. These URLs start with `file://` schema. \r\n\r\n![image](https://user-images.githubusercontent.com/1529180/68654082-0cace980-04e2-11ea-9ce4-3f80c8528ace.png)",
      "createdAt": "2019-11-12T08:20:19Z",
      "updatedAt": "2019-11-12T20:52:39Z",
      "closedAt": "2019-11-12T20:52:39Z",
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "This is an issue of Chromium's experimental implementation.\r\nCould you please file a bug in https://crbug.com ?",
          "createdAt": "2019-11-12T19:37:27Z",
          "updatedAt": "2019-11-12T19:37:27Z"
        },
        {
          "author": "lacolaco",
          "authorAssociation": "NONE",
          "body": "@horo-t I've filed. https://bugs.chromium.org/p/chromium/issues/detail?id=1023929",
          "createdAt": "2019-11-12T20:07:49Z",
          "updatedAt": "2019-11-12T20:07:49Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you.\r\nClosing this issue.",
          "createdAt": "2019-11-12T20:52:38Z",
          "updatedAt": "2019-11-12T20:52:38Z"
        }
      ]
    },
    {
      "number": 532,
      "id": "MDU6SXNzdWU1MjIzNDUxNTU=",
      "title": "Bundle replay as alternative to 'Save Page As...'",
      "url": "https://github.com/WICG/webpackage/issues/532",
      "state": "OPEN",
      "author": "ikreymer",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It's great to see the initial bundle replay implementation in Chrome 80!\r\n\r\nI wanted to suggest an archival use case, from perspective of individual users.\r\nI think web bundles could provide alternative to the existing 'Save Page As...' functionality, which is essentially broken for many modern websites. The idea would be to allow users to 'save' a page as a bundle, and replay the page as best as possible. \r\n\r\nThe goal would be to make this work without requiring sites having to become more bundle-friendly or require signing.\r\n\r\nFor bundles to work as a 'generic' save page alternative, I think two extensions would be really useful:\r\n\r\n- Support for non-GET requests, because many sites use other methods during normal operation. I see that this has been closed in #70. Unfortunately, many sites currently use\r\nPOST in normal operation. An example: Twitter uses POST during normal operation. If a user were to save a Tweet, then a critical POST request would be missed, and shows up as an error.\r\n\r\n- Support for custom request/response resolution, perhaps via a 'bundle scoped service worker' that could override fetch() and handle domain-specific requests. Replaying of network traffic is necessarily non-deterministic as often timestamps are added, so a request for `https://example.com/?_=123` might be replayed as `https://example.com/?_124`. If there was a way for a 'worker' in a site to handle fetch(), it could then resolve these in a bundle-specific way.\r\n\r\nA bit more background: I've been working on a project called Webrecorder, which allows users to capture network traffic and replay it back (though a server proxy). In a way, it is designed to be as close as possible to a working 'save page as...'. This implementation uses a backend server.\r\n\r\nI've also have a service-worker based prototype, https://wab.ac/ which allows replay of HAR, WARC and now bundle WBN files in any browser that supports service workers.\r\nIt uses the 'wayback-machine style' URL rewriting approach, but of course it would be better if it could be done 'natively' in the browser, and bundles provide an exciting possibility for that.\r\n\r\nI've wondering if there is any interest, perhaps down the road, in expanding bundles to be able to support features needed to 'fix' Save Page As... for users? Or expanding the bundle spec so that extensions could be implemented to facilitate better replay of 'saved' pages?",
      "createdAt": "2019-11-13T16:49:57Z",
      "updatedAt": "2019-11-13T16:50:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 533,
      "id": "MDU6SXNzdWU1MjM5MTA1ODY=",
      "title": "Add display mode for web bundles",
      "url": "https://github.com/WICG/webpackage/issues/533",
      "state": "CLOSED",
      "author": "AshleyScirra",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "It might be interesting to support other display modes in web bundles, e.g. \"standalone\", much like the manifest can set for PWAs.\r\n\r\nThen you could end up in the situation where you have a .wbn file you double click and it runs in an app-like window without the browser address bar - much like an Electron/NW.js app, but actually running in the browser.",
      "createdAt": "2019-11-16T23:38:20Z",
      "updatedAt": "2019-11-17T06:48:19Z",
      "closedAt": "2019-11-17T06:48:03Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Bundles have a [\"manifest\" section](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#manifest-section) which is intended to point to an App Manifest inside the bundle, which in turn can set the [display mode](https://www.w3.org/TR/appmanifest/#display-member). So I think this is already done and am closing the issue, but feel free to reopen with more explanation of what's missing. \ud83d\ude42",
          "createdAt": "2019-11-17T06:48:01Z",
          "updatedAt": "2019-11-17T06:48:19Z"
        }
      ]
    },
    {
      "number": 535,
      "id": "MDU6SXNzdWU1MjM5OTgxNjk=",
      "title": "Example not working for me",
      "url": "https://github.com/WICG/webpackage/issues/535",
      "state": "CLOSED",
      "author": "kohlerm",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The preact-todomvc example at https://web.dev/web-bundles/ \r\ndoes not work for me. \r\nI get an error at the end. \r\n\r\n../go/bin/gen-bundle -dir build -baseURL https://preact-todom.vc -primaryURL https://preact-todom.vc -o todomvc.wbn\r\n2019/11/17 15:58:06 Creating exchange: build -> https://preact-todom.vc/\r\n2019/11/17 15:58:06 Creating exchange: build/app.js -> https://preact-todom.vc/app.js\r\n2019/11/17 15:58:06 Creating exchange: build/index.html -> https://preact-todom.vc/index.html\r\n2019/11/17 15:58:06 Creating exchange: build/todomvc-common/base.css -> https://preact-todom.vc/todomvc-common/base.css\r\n2019/11/17 15:58:06 Creating exchange: build/todomvc-common/base.js -> https://preact-todom.vc/todomvc-common/base.js\r\n2019/11/17 15:58:06 Creating exchange: build/todomvc.css -> https://preact-todom.vc/todomvc.css\r\n2019/11/17 15:58:06 Failed to write exchange. err: bundle: No exchange for primary URL https://preact-todom.vc\r\n",
      "createdAt": "2019-11-17T15:04:15Z",
      "updatedAt": "2019-11-20T10:44:25Z",
      "closedAt": "2019-11-19T01:48:42Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for trying it out.\r\n\r\nThere was an error in the command line. The correct command is:\r\n```\r\n./go/bin/gen-bundle -dir build -baseURL https://preact-todom.vc/ -primaryURL https://preact-todom.vc/ -o todomvc.wbn\r\n```\r\n(note the trailing '/' in the URLs)\r\n\r\nThe web.dev article is already [fixed](https://github.com/GoogleChrome/web.dev/pull/1888).\r\n",
          "createdAt": "2019-11-19T01:48:42Z",
          "updatedAt": "2019-11-19T01:48:42Z"
        },
        {
          "author": "kohlerm",
          "authorAssociation": "NONE",
          "body": "Thanks works fine now!",
          "createdAt": "2019-11-20T10:44:25Z",
          "updatedAt": "2019-11-20T10:44:25Z"
        }
      ]
    },
    {
      "number": 544,
      "id": "MDU6SXNzdWU1MzcyNjcyMDI=",
      "title": "Ensure watermarked signed bundles don't allow user ID transfer",
      "url": "https://github.com/WICG/webpackage/issues/544",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "Pending Security + Privacy Review",
        "bundled-exchanges"
      ],
      "body": "@MattMenke2 pointed out that if a server can get a large number of unique packages generated for two different origins (either by having signing keys for both origins or by getting those origins to cooperate), it can build a bundle that will transfer a user ID between those two origins, given our current idea of how bundle loading will work. That is:\r\n\r\n1. When client C fetches `https://evil.example/the_bundle`, evil.example puts signed HTML files from the two origins into the bundle, each embedding a unique ID. (If the IDs are different, evil.example just records that they refer to the same user.) At this point, https://github.com/WICG/webpackage/blob/master/explainers/anti-tracking.md says evil.example doesn't have access to its own user ID, but this doesn't save us.\r\n1. C redirects to `origin1.example/index.html`, which has access to both `origin1.example`'s online storage and the embedded unique ID, so it reports that `origin1.example`'s user ID is associated with the unique ID.\r\n1. The user now navigates C to `origin2.example/index.html`. Our current notion of how bundles should work says that this doesn't go back to the network, since the user has already downloaded the content and shouldn't need to fetch it again. However, at this point, the new page has access to both `origin2.example`'s online storage and the embedded unique ID, so it reports that association, and learns that origin2's user ID is associated with origin 1's user ID.\u220e\r\n\r\nThe simplest fix is to [remove](https://www.w3.org/TR/security-privacy-questionnaire/#drop-feature) the ability to include multiple signed top-level origins in the same bundle. Or, similarly, declare that the top-level origin of the entire bundle is the one identified in its start URL, so no other origins within the bundle can access their online storage.\r\n\r\nA requirement that signatures are X minutes old, as suggested in #422, doesn't help here, since evil.example can just stockpile unique IDs for that long.\r\n\r\nIf we can find a way to identify the a large number of different resources are available at the same URL, we could use that mechanism to re-allow multiple top-level resources.",
      "createdAt": "2019-12-12T23:25:23Z",
      "updatedAt": "2019-12-12T23:25:23Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 550,
      "id": "MDU6SXNzdWU1NTM0OTI0MDQ=",
      "title": "Sort order example for map keys in canonical CBOR may be incorrect",
      "url": "https://github.com/WICG/webpackage/issues/550",
      "state": "CLOSED",
      "author": "casey",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I was just reading through [the Signed HTTP Exchanges draft](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#name-canonical-cbor-serializatio), and I think the given example for how keys in a CBOR map should be sorted is incorrect.\r\n\r\nThe example reads:\r\n\r\n```\r\nThe keys in every map MUST be sorted in the bytewise\r\nlexicographic order of their canonical encodings. For example,\r\nthe following keys are correctly sorted:\r\n\r\n1. 10, encoded as 0A.\r\n2. 100, encoded as 18 64.\r\n3. -1, encoded as 20.\r\n4. \"z\", encoded as 61 7A.\r\n5. \"aa\", encoded as 62 61 61.\r\n6. [100], encoded as 81 18 64.\r\n7. [-1], encoded as 81 20.\r\n8. false, encoded as F4.\r\n```\r\n\r\nHowever, section 3.9 of [RFC 7049](https://www.rfc-editor.org/rfc/rfc7049.txt) states:\r\n\r\n```\r\n   o  The keys in every map must be sorted lowest value to highest.\r\n      Sorting is performed on the bytes of the representation of the key\r\n      data items without paying attention to the 3/5 bit splitting for\r\n      major types.  (Note that this rule allows maps that have keys of\r\n      different types, even though that is probably a bad practice that\r\n      could lead to errors in some canonicalization implementations.)\r\n      The sorting rules are:\r\n\r\n      *  If two keys have different lengths, the shorter one sorts\r\n         earlier;\r\n\r\n      *  If two keys have the same length, the one with the lower value\r\n         in (byte-wise) lexical order sorts earlier.\r\n```\r\n\r\nIt's a little odd, but this reads to me as if keys should be sorted by key length first, and only then should keys with the same length be lexically sorted. This would give the sorting:\r\n\r\n```\r\n1. 10, encoded as 0A.\r\n2. -1, encoded as 20.\r\n3. false, encoded as F4.\r\n4. 100, encoded as 18 64.\r\n5. \"z\", encoded as 61 7A.\r\n6. [-1], encoded as 81 20.\r\n7. \"aa\", encoded as 62 61 61.\r\n8. [100], encoded as 81 18 64.\r\n```",
      "createdAt": "2020-01-22T11:55:07Z",
      "updatedAt": "2020-01-23T07:16:23Z",
      "closedAt": "2020-01-22T21:09:06Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is something that's changing between RFC 7049 and [CBORbis](https://cbor-wg.github.io/CBORbis/draft-ietf-cbor-7049bis.html#core-deterministic-encoding-requirements), where the new version defines two possible key orderings for individual protocols to pick between. We're using the newer one, that doesn't mix values of different major types. We're still compatible with RFC 7049, which says \"Those protocols are free to define what they mean by a canonical format and what encoders and decoders are expected to do.\"",
          "createdAt": "2020-01-22T21:09:06Z",
          "updatedAt": "2020-01-22T21:09:06Z"
        },
        {
          "author": "casey",
          "authorAssociation": "NONE",
          "body": "Ah, gotcha, thank you for the clarification!",
          "createdAt": "2020-01-23T07:16:23Z",
          "updatedAt": "2020-01-23T07:16:23Z"
        }
      ]
    },
    {
      "number": 551,
      "id": "MDU6SXNzdWU1NTY0NzQ0ODE=",
      "title": "Correct / real URLs should be enforced, to avoid breaking adblockers",
      "url": "https://github.com/WICG/webpackage/issues/551",
      "state": "OPEN",
      "author": "pes10k",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "discuss",
        "privacy-tracker"
      ],
      "body": "Currently there is no enforced relationship between the URL used to look up resources in the package, and where the resource came from online.  Consistent URLs are an imperfect, but extremely useful signal for privacy protecting tools (filter lists, adblockers, disconnect, Firefox and Edge built in protections, safe browsing, etc.).  \r\n\r\nThe current proposal would allow for all WebPackage'd sites to circumvent all URL based tools by simply randomizing URLs as a post processing step in [amppackager](https://github.com/ampproject/amppackager) or similar.  This could even be done per-request per page.  Since URLs are effectively just indexes into the package (and not keys for decision making, caching, etc), they can be changed arbitrarily w/o affecting how the package loads, but preventing the URL-based privacy preserving tools from running.\r\n\r\nA (partial) possible solution to the problem is to play a [cut-and-choose](https://www.usenix.org/conference/usenixsecurity16/technical-sessions/presentation/zhu), commitment-auditing style games with the URLs.  At package time, the packager has to make commitments about which URL each resource came from, and the size, shape etc of the resource.  These can be made / mixed with the URL of the page being packaged. \r\n\r\nThe client can then, w/ some probability, audit some number of the URLs in the package.  If the commitments fail, deterring counter measures can be taken against the packing origin (e.g. global decaying block list of misbehaving packagers, etc).",
      "createdAt": "2020-01-28T21:18:35Z",
      "updatedAt": "2021-02-16T10:21:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Because this is an issue where the potential attackers may not have thought of all the attacks we want to defend against, I don't want to discuss this issue in public. I'm going to try to discuss it in https://github.com/WICG/webpackage/security/advisories/GHSA-g5qv-3cw4-38gv instead. Send me an email with an aspect of the problem that isn't yet discussed here in order to be added to that discussion.",
          "createdAt": "2020-02-05T20:09:21Z",
          "updatedAt": "2020-02-05T20:09:21Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "just wanted to check in on this, has anything changed / any updates?\r\n\r\n",
          "createdAt": "2020-04-01T01:34:13Z",
          "updatedAt": "2020-04-01T01:34:13Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "Copying comments over from the closed PR thread in https://github.com/WICG/webpackage/pull/573, and editing slightly given the new context\r\n\r\nIn general, i'm happy to continue discussing point by point above, but lets not loose the forest for the trees.  The general claim is that:\r\n\r\n1) consistent, descriptive URLs are useful for adblocking (edit, and content blocking in general)\r\n2) this proposal reduces the consistency and descriptiveness of URLs by changing them into arbitrary, opaque indexes into an archive.\r\n\r\nAre we disagreeing about either of the above points?\r\n\r\nSince rollup got mentioned above, its a perfect example here.  Before rollup-and-the-link world, content blocking was ideal; URLs described (both conceptually, and frequently) one resource, and the user agent could reason about each URL independently.  Post rollup-world, URLs are less useful (though not useless), since JS URLs now describe (often) many resources, about which its increasingly difficult for the UA to reason individually about.  (on going research here, etc).  URLs represent multiple interests, the user will often feel differnetly about, but which UA's are (generally) forced into an all or nothing position about.\r\n\r\nThis proposal does the same thing, _but for websites entirely_!  The UA effectively gets just one URL to reason about (the entire web package), but looses the ability to reason about sub resources.  This is very (very!) bad if we intend the web to be an open, transparent, user-first system!\r\n\r\nOkie, now, replying to individual points, but eager to not loose site of the above big picture\u2026\r\n\r\n@jyasskin \r\n> #573 (comment) is wrong about the performance implications\r\n\r\nThis is not correct.  Its _partially_ correct in v8, bc in some cases v8 will defer the parsing of function bodies, but (i) even then there are exceptions, and (ii) I have even less familiarity with how other JS engines do this.  I know that, for example, spidermonkey does not _not_ defer parsing in cases where v8 will (e.g. JS in HTML attributes, onclick=X), but I dont have enough information to say in general (and I know even less about JavaScriptCore).  But, point is\r\n\r\n1. there is in all cases some difference, because there is at lease _some_ additional parsing and executing going on\r\n2. there may be significant difference in other platforms\r\n3. caching makes all this even more different, as platforms may differ on how and when they cache inline script\r\n4. none of this difference hangs on standards defined behavior, and so is not a sound basis for this standard to rely on\r\n\r\n@twifkak \r\n> can't the site choose not to include the 3p script in the bundle\r\n\r\nSure, a site could choose this, but i'm not sure I follow the point.  My point isn't that sites _have_ to evade content blockers in the proposal, its that it gives them new options to circumvent the user's goals / aims / wishes.\r\n\r\n> As for collisions between bundles and the unbundled web\u2026\r\n\r\nAgain, im not sure I follow you here.  My point is that it'd be simple to change URLs during \"bundling\" so that they're (i) impossible for content blockers to reason about, and (ii) ensure they don't collide with real world urls.  Say, every bundled resource has its URL changed to be a random domain 256 character domain and path.\r\n\r\n> My example involves changes that would mostly be internal to the CMS, and hence the cost amortized across its customers\r\n\r\nNeeding to update the large number of existing CMS's seems like a perfect example of why this is difficult for sites!  Let alone other costs (loosing cache, in your hash guessing scheme paying an extra network request and on some platform OS thread or process, making static sites unworkable, etc etc etc). \r\n\r\nTL;DR as much as possible, \r\n\r\n1. Yes URLs _can_ be opaque on the web no2\r\n2. they are never the less still useful (see Google safe browsing, EasyList, disconnect, caching policies etc etc etc)\r\n3. the claim isn't that this proposal does something to fundamentally change URLs, its that it (i) takes something expensive and possible for the server to do now, and makes it free and trivial, and (ii) makes (for packages) the entire package into a single yes / no decision for the UA, where before the UA had far more information and ability to choose / advocate on behalf of the user\r\n",
          "createdAt": "2020-04-20T23:49:06Z",
          "updatedAt": "2020-04-20T23:49:06Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "> 2. this proposal allows reduces the consistency and descriptiveness of URLs by changing them into arbitrary, opaque indexes into an archive.\r\n\r\n\"Disagreeing\" implies 100% confidence to me, so let's just say I'm skeptical of this. I'm certainly counter-arguing the point.\r\n\r\n> This proposal does the same thing [as rollup]\r\n\r\nExcept that it establishes distinct boundaries between resources. It may be easier to detect matching JS subresources inside a bundle than inside a rollup, since they are distinct and the publisher has less incentive to mangle them (no need to avoid JS global namespace conflicts).\r\n\r\nIt could include rollup'd JS payloads that contain a mix of 1p and 3p content, but I don't see how doing so helps evade detection over unbundled rollup.\r\n\r\n> > can't the site choose not to include the 3p script in the bundle\r\n> \r\n> Sure, a site could choose this, but i'm not sure I follow the point. My point isn't that sites _have_ to evade content blockers in the proposal, its that it gives them new options to circumvent the user's goals / aims / wishes.\r\n\r\nI was responding to your comment \"web bundles give sites a new way of delivering code to users... in a way that has zero additional marginal cost... since the code is already delivered / downloaded as part of the bundle, there is no additional cost to making it an async request vs inlining it\".\r\n\r\nWe're somewhat in subjective space here, but I'd argue that the apples-to-apples comparison is:\r\n - unbundled: link to 3p script _vs_ rollup or inline or 1p mirror\r\n - bundled: link to 3p script _vs_ rollup or inline or 1p mirror or bundle\r\n\r\nRegarding bytes delivered over the network from edge server to browser, bundling doesn't appear to change the cost relative to baseline. I haven't thought through bytes at rest, or between various layers of serving hierarchy. I wonder the degree to which such a cost is the limiting factor right now.\r\n\r\nIt does offer another option for 1p-ifying the script in order to evade detection, but one that doesn't seem to offer the site any reduced marginal cost.\r\n\r\n> > As for collisions between bundles and the unbundled web\u2026\r\n> \r\n> Again, im not sure I follow you here. My point is that it'd be simple to change URLs during \"bundling\" so that they're (i) impossible for content blockers to reason about, and (ii) ensure they don't collide with real world urls. Say, every bundled resource has its URL changed to be a random domain 256 character domain and path.\r\n\r\nI was arguing that it might not be so simple, depending on the circumstances. HTTP cache and ServiceWorker might offer spaces for collision between bundled URLs and unbundled URLs. Thus, making random paths undetectable seems similarly hard in both the unbundled and bundled world.\r\n\r\nYour point about random domains is interesting. In order to be undetectable, the random domain+paths have to look real. Given that servers may vary their responses to different requestors, it's impossible to know that a real-looking 3p URL doesn't name a real resource (and that it won't over the length of the bundled resource's lifetime). However, it's probably sufficient to assert no collision on the cache (e.g. double- or triple-) key. A bundle generator need only an avoid-list of 3p URLs the site uses. I'm not sure if this allows an easier implementation than [my proposed path randomizer](https://github.com/WICG/webpackage/pull/573#issuecomment-614260542), though.\r\n\r\n> Needing to update the large number of existing CMS's seems like a perfect example of why this is difficult for sites!\r\n\r\nIsn't an update also necessary for adding bundle support?\r\n\r\n> Let alone other costs (loosing cache, in your hash guessing scheme paying an extra network request and on some platform OS thread or process, making static sites unworkable, etc etc etc).\r\n\r\nIn these aspects, it would be interesting to compare the costs between bundled and unbundled blocklist-avoidance in more detail.",
          "createdAt": "2020-04-20T23:56:40Z",
          "updatedAt": "2020-04-20T23:56:40Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "> It could include rollup'd JS payloads that contain a mix of 1p and 3p content, but I don't see how doing so helps evade detection over unbundled rollup.\r\n\r\nThere are big differences.  You can't roll up 3p scripts (easily), and you can't roll up the other kinds of resources folks might want to block (images, videos, etc etc).\r\n\r\nI didn't mean to suggest that this is just like rollup on a technical level; only that it further turns websites into black boxes that UA's can't be selective about / advocate for the user in, and in that way was similar to rollup.\r\n\r\n> It does offer another option for 1p-ifying the script in order to evade detection, but one that doesn't seem to offer the site any reduced marginal cost.\r\n\r\nThe difference here is that to get the kind of evasion you can get in a web bundle, you'd need to roll into an existing script, inline the code, or pull it into a 1p URL (that could itself be targeted by filter lists, etc).  In a WebBundle world, the bundler has the best option for evading, without having to do the more difficult work (i.e. zero marginal cost).\r\n\r\nI'm fine to say _small_ marginal cost if that gets us by this point, but the general point is that sites get new evasion capabilities at-little-to-no-cost.\r\n\r\n> A bundle generator need only an avoid-list of 3p URLs the site uses. I'm not sure if this allows an easier implementation than my proposed path randomizer, though.\r\n\r\nIts easier bc\r\n\r\n1. You have to just write the evasion in one place (the bundler) instead of changing ever app on the web!\r\n2. You get the evasion / opaque URL without needing to do network guess games, etc, which can be expensive (think Drupal plus apache!) or straight up impossible (static site generators)\r\n\r\n> Isn't an update also necessary for adding bundle support?\r\n\r\nI can't see why.  At least for sites where the bundle content is static (AMP like pages), I have all the information I need to build the bundle just by pointing at an existing site / URL, no changing of CMS needed (you might want to add options for excluding certain domains, resources, etc, but thats all equally easy and do-once-for-the-whole-web)\r\n",
          "createdAt": "2020-04-21T00:11:09Z",
          "updatedAt": "2020-04-21T00:11:09Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "> > Isn't an update also necessary for adding bundle support?\r\n> \r\n> I can't see why. At least for sites where the bundle content is static (AMP like pages), I have all the information I need to build the bundle just by pointing at an existing site / URL, no changing of CMS needed (you might want to add options for excluding certain domains, resources, etc, but thats all equally easy and do-once-for-the-whole-web)\r\n\r\nBy \"I\" in your second sentence, who do you mean? If \"a distributor\" or \"the site's CDN\", why would they limit such a technique to unsigned bundles? The argument that pulling content into a 1p URL is difficult enough to impede adoption doesn't seem to apply in this case. (edit: Likewise with a \"2p\" subdomain dedicated to mirroring content of a given 3p.)\r\n\r\nThe degree to which the HTML is amenable to static analysis seems to affect the feasibility of such an implementation, but not along the bundled-or-not axis.",
          "createdAt": "2020-04-21T01:07:44Z",
          "updatedAt": "2020-04-21T01:13:18Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "in that particular case, i just meant a site maintainer looking to create a web bundle.  You were making the argument (if i understood correctly) that it would be the same amount of work to rewrite a CMS to create web bundles, as it would be to rewrite a CMS to do other kinds of URL-based filtering evasion.  My point was just that no CSM rewriting would be needed at all to web bundle.  I can treat the server side code as a blackbox, poke at it with automation, and create a bundle from the results (i.e. if I can create a record-replay style HAR of the site, i can create a web bundle of the site).\r\n\r\n(I also think this is not the right way to think about the comparison, since rewriting the CMS is just one of many things you'd need to change to do filter list evasion: caching, performance concerns, etc etc etc)",
          "createdAt": "2020-04-21T01:25:17Z",
          "updatedAt": "2020-04-21T01:25:17Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, I see. I lack sufficient awareness of sites and their owners, to judge whether \"update my CMS version\" or \"install an HTTP middlebox\" is harder, on average (including auxiliary changes such as you mention, in both cases). I could see it going both ways.",
          "createdAt": "2020-04-21T01:35:55Z",
          "updatedAt": "2020-04-21T01:35:55Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "I don't think its likely useful for us to speculate about which is easier in general, but at the least I think / hope we can agree on:\r\n\r\n1) Web packaging would allow new categories of folks to obscure URLs that currently can't, bc they're not in a position to run middleware, like static site generators, people on shared hosting that scrapes down to apache and (S)FTP, people with heavy cache needs because of DDOS or other concerns, etc\r\n2) It would allow them to do so w/o having to pay the costs they'd pay to do something similar on live websites (again caching, handling extra requests due to hash-misses in the scheme you proposed, etc)\r\n",
          "createdAt": "2020-04-22T02:30:49Z",
          "updatedAt": "2020-04-22T02:30:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I appreciate the focus on the high-level problem, but I need you to be precise about a single situation where web packaging would hurt ad blocking, so we can figure out if that's actually the case. If I answer the first situation, and your response is to bring up a second without acknowledging that you were wrong about the first, we're not going to make progress.\r\n\r\nFor example, take a static site running on apache with no interesting modules, where the author can run arbitrary tools to generate the files they then serve statically. That author wants to run fingerprint.js hosted by a CDN, but it's getting blocked by an ad blocker. So they download the script to their static site, naming it `onIhE6oDT7A7LKUj.js` so as not to be obvious about it, and refer to that instead. They lose caching on browsers without partitioned caches. Putting it in a web package doesn't get them that caching back, and might lose same-site caching.\r\n\r\nSo what's the most compelling situation where web packaging does help the author avoid an ad blocker?",
          "createdAt": "2020-04-23T18:03:43Z",
          "updatedAt": "2020-04-23T18:03:43Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "> I appreciate the focus on the high-level problem, but I need you to be precise about a single situation where web packaging would hurt ad blocking, so we can figure out if that's actually the case. If I answer the first situation, and your response is to bring up a second without acknowledging that you were wrong about the first, we're not going to make progress.\r\n\r\nWhich point are you referring to?  About defer?  I referred to that at length above.  What did i miss?\r\n\r\n> So they download the script to their static site, naming it onIhE6oDT7A7LKUj.js\r\n\r\nI similarly feel like we've discussed this several times. Its problem enough to have to create a rule per site (static site copies file locally and serves from one or a fixed number of URLs), but with packaging you can easily create a new URL for the same resource _per page_ (or even _per bundle_, or _per request_).\r\n\r\nThe point isn't that you can't do these things on the web today, its that packing makes them trivial and free to do.  I really feel like this point has been made as well as it can be made, and that the gap between whats _possible_ on the web today, and what web packaging would make _easy and free_, is large and self evident.\r\n\r\nI don't think arguing about this same point further is productive.  If I haven't made the case already, more from me is not likely to be useful.  If you're curious how other filter list maintainers or content blockers would feel about it, it'd be best to bring them back into the conversation.",
          "createdAt": "2020-04-23T18:14:58Z",
          "updatedAt": "2020-04-23T18:14:58Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ok, so you're claiming it's difficult for the static site to have `foo.html` refer to `onIhE6oDT7A7LKUj.js`, but `bar.html` refer to `GBtTuFJWnrLgXMs6.js` with the same content? Why is that?\r\n\r\nHaving it different per request breaks your assumption that this is a static site running no interesting middleware, so can't happen.",
          "createdAt": "2020-04-23T18:18:58Z",
          "updatedAt": "2020-04-23T18:18:58Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "Im saying that each step like that is additional work, all of which makes it more difficult for sites to do, and so less likely.\r\n\r\nAgain, you're arguing its possible, im happy to ceed that; im arguing that your proposal makes it much easier.  As evidence, you keep suggesting extra work sites could do (some easy, some costly) to get a weaker form of what your proposal gives them. Thats making my point twice.\r\n\r\nPut differently, there are expensive services sites subscribe to that use dynamic URL tricks to avoid their unwanted resources winding up on filter lists (as said before Admiral is the highest profile, but not the only one).  Your proposal gives a _stronger_ ability to avoid content blocking tools (or security and privacy tools like ITP, ETP, disconnect), to all sites for free.\r\n\r\n> Having it different per request breaks your assumption that this is a static site running no interesting middleware, so can't happen.\r\n\r\nLike i said in https://github.com/WICG/webpackage/issues/551#issuecomment-616895088, I can build a bundle by pointing a web crawler at my site, (a la catapult or record-replay or anything else) and then turn that into a bundle; there is no middleware needed.\r\n\r\nSincerely, I've explained these points fully and to the best of my ability.  If there are new points of disagreement, lets move the conversation to those.  Otherwise, i think we've hit stalemate and it'd be best to either bring in other opinions from folks who have a strong interest in content blocking, and / or to just move the disagreement to another forum (the larger web community, TAG, etc)",
          "createdAt": "2020-04-23T18:38:45Z",
          "updatedAt": "2020-04-23T18:38:45Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "> I don't think its likely useful for us to speculate about which is easier in general\r\n\r\nHappy to discuss a different aspect. I think we got to this place because we were trying to address [your earlier comment](#issuecomment-616868985) that:\r\n\r\n> this proposal reduces the consistency and descriptiveness of URLs by changing them into arbitrary, opaque indexes into an archive.\r\n\r\nI think we agree that it changes URLs into arbitrary, opaque indexes only to the extent that they aren't already. Obviously they can be used that way today:\r\n\r\n 1. URLs may be arbitrary indexes; my [sha example](https://github.com/WICG/webpackage/pull/573#issuecomment-614260542) tried to demonstrate an example of something that looks as arbitrary as possible to the outside user, while being stateless.\r\n 2. Servers may even Vary by Referer, or by some server-side user fingerprint (e.g. IP plus low-precision timestamp plus header order). Given that, one could imagine a stateful implementation that generates entirely arbitrary URLs.\r\n\r\nSo it's more gray-area than that. It's about prevalence. That's where ease of adoption came into the discussion. If you think there are other axes that affect prevalence (e.g. ease of revenue generation), we should discuss those as well.\r\n\r\nStill, it seems like your [recent comment](https://github.com/WICG/webpackage/issues/551#issuecomment-618580286) discusses ease/difficulty of adoption, so I'm guessing your comment was narrower in scope. You're just saying the relative ease of CMS upgrade vs gateway install is not worth discussing because not all site owners run CMSes. That's fair, but I think it should also be fair that \"# of site owners who meet this constraint\" is a relevant variable. For instance, \"bundles make it easier to avoid adblockers when running a site in [Unlambda](http://www.madore.org/~david/programs/unlambda/)\" is uninteresting, unless it leads to a broader issue.\r\n\r\n> 1. Web packaging would allow new categories of folks to obscure URLs that currently can't, bc they're not in a position to run middleware, like static site generators, people on shared hosting that scrapes down to apache and (S)FTP, people with heavy cache needs because of DDOS or other concerns, etc\r\n\r\nI when you say \"folks [who can't] run middleware\", I assume you're not including commercial CDNs in your definition of middleware, but rather custom software running in their internal stack, even though \"heavy cache needs\" are usually met through the addition of edge infrastructure, usually provided by CDNs.\r\n\r\nOn the one hand, I think that's a limiting definition, because if this technique is profitable enough to become prevalent, then it's likely that either at least one CDN would add support for this, or at least one person would publish how to do it on existing edge compute services provided by popular CDNs.\r\n\r\nOn the other hand, I'll try to stick with the constraint. Both [nginx](http://nginx.org/en/docs/http/ngx_http_core_module.html#error_page) and [Apache](https://httpd.apache.org/docs/2.4/custom-error.html) provide support for custom error pages. So any URL that's not generated by the static site generator could be served fingerprint.js. (Might be able to further restrict this with an [if](http://nginx.org/en/docs/http/ngx_http_rewrite_module.html#if) [directive](https://httpd.apache.org/docs/2.4/mod/core.html#if) on some header that distinguishes navigations from subresource fetches, so that users still see normal 404 pages.)\r\n\r\n> 2. It would allow them to do so w/o having to pay the costs they'd pay to do something similar on live websites (again caching, handling extra requests due to hash-misses in the scheme you proposed, etc)\r\n\r\nI believe many popular CDNs provide some means of manipulating the cache key. For instance, [here's varnish](https://varnish-cache.org/docs/trunk/users-guide/vcl-hashing.html). I'm not familiar enough with vcl to know how expressive that language is, so this is just speculation:\r\n\r\nMake the cache key based on hash(url) mod N. Make N high enough to guarantee ~no collisions on real pages. Make N low enough that you can deliberately generate enough fake URLs that all have the same hash mod N.\r\n\r\nIf this sounds a bit like my old scheme, it's because I'm not very clever. Forgive the lack of creativity. :)",
          "createdAt": "2020-04-23T19:14:57Z",
          "updatedAt": "2020-04-24T07:39:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "\"For free\" is not true since it's not like the bundling tool we write is going to rename subresources to obfuscated strings, but I agree that we need some other folks involved to figure out who's confused here. We'll send a TAG review soon, and the privacy consideration about this should help them know to think about it.",
          "createdAt": "2020-04-23T21:10:37Z",
          "updatedAt": "2020-04-23T21:10:37Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm sorry but when I read this:\r\n\r\n> I don't think its likely useful for us to speculate about which is easier in general, but at the least I think / hope we can agree on\r\n\r\nand this:\r\n\r\n> Again, you're arguing its possible, im happy to ceed that; im arguing that your proposal makes it much easier. \r\n\r\n... it seems hard to reconcile. \r\n\r\nI may have missed it but was there a solid explanation, not a speculation or belief, of why it's \"much easier\" with the proposal vs. without?",
          "createdAt": "2020-04-24T01:54:34Z",
          "updatedAt": "2020-04-24T01:54:34Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "I'll going to attempt to summarize my case here one last time, and then stop, because i really think we're retreading the same points over and over. If the following doesn't express the concern, more words from me aren't going to help.\r\n\r\n1. The proposal turns the package *and all the contents in the package* into an all or nothing decision.  It's trivially easy for the packager to randomize the URLs or otherwise strip all information out of the URL.\r\n2. Even worse, the bundler can change the URLs of the bundled resources to be ones that it knows wont be blocked, because they're needed for other sites to work.  E.g. say i want to bundle `example.org.com/index.html`, which has some user-desirable code called `users-love-this.js`, and some code people def don't want called `coin-miner.js`.  Assume filter lists make sure to not block the former, and intentionally block the latter. When I'm building my bundle, i can rename `coin-miner.js` to be `users-love-this.js`, while leaving the \"real web\" `example.org/{users-love-this.js,coin-miner.js}` resources unmodified.  So its worse than URLs having no information, URLs in bundles can have _negative_ information; URLs can be misleading, by pointing to something different in the bundle than outside the bundle (or having the same URL point to different resources in different bundles)\r\n3. All the above can be done treating the page / site being bundled as a black box.\r\n4. Sites _can_ currently play games with urls, but the non-web-bundle world constrains this in many ways.  Current sites are constrained in how much URL obfuscation they can play by some combination of the below costs (partial list):\r\n    (i) additional network requests (the hash guessing games mentioned above)\r\n    (ii) maintaining additional state somewhere to map between the different names for the same file (on disk, in db, somewhere).  This is especially difficult if you expect most of your requests to be fulfilled from CDNs / edge caches\r\n    (iii) the high performance / caching / etc costs from inlining resources\r\n    (iv) all sorts of costs from moving from static sites to dynamic sites\r\n    (v) breaking existing references to existing pages\r\n    (vi) sinking cache hit rates\r\n    (vii) implementation complexity\r\n5. Even if all the costs described in #4 went to zero, it would at the very least require modifications to the millions of sites / applications on the web.  With web bundles, you just need to write one tool once to turn the entire web into arbitrary URLs\r\n6. Given you're going to build a web bundle with of a set of resources, obfuscating the URLs in the bundle has exactly the same cost / performance characteristics as honest URLs (i.e. zero marginal cost).  This is not true of any of the suggested ways of obfuscating URLs in an application\r\n7. Examples that involve any level of cleverness between multiple parties (e.g. custom CDN modifications), increasing the number of non-cacheable responses, etc are making my point.  Much more of the web looks like \"install wordpress on hostmonster, copy paste your tracking script snippit in the template, done\" then Google-level dynamic web applications who can reason differently about the core application, middleware, reverse proxies, and CDNs.\r\n8. Anyone who maintains a filter list or similar can easily testify that websites / trackers / etc play these kinds URL games all the time, and will do much more if given the opportunity (there are businesses who do exactly this as their entire business model).  Things like those mentioned in 4 are important, practical, real world constraints that keep things from getting worse.\r\n\r\nSo, i stand by my original claim: the proposal turns something that is currently possible (but constrained by the points in #4) into something that can be done at no additional cost to the bundler (once the approach is implemented, once, in any bundling tool).\r\n\r\nPut differently, put yourself in the shoes of someone who runs a drupal or wordpress site on godaddy or pantheon or wpengine (so cheap-as-possible hosting to real-money-PAS deployments).  Which is the easier task: \r\n1) implementing and paying for a way to do URL obfuscation from your drupal or wordpress application\r\n2) do URL obfuscation when building a web bundle?",
          "createdAt": "2020-04-24T03:05:35Z",
          "updatedAt": "2020-04-24T03:05:35Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It's just fundamentally confused to write \"With web bundles, you just need to write one tool once [to rewrite the source and destination of URLs]\" but deny \"With Wordpress, you just need to write one plugin once\". I think other reviewers will understand that.",
          "createdAt": "2020-04-24T03:27:58Z",
          "updatedAt": "2020-04-24T03:27:58Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "thats not the claim at all, anywhere @jyasskin.\r\n\r\nThe claim is that 1) there are more types of sites on the web than wordpress, 2) you would not do that in most wordpress applications because you need to cache everything aggressively in wordpress to keep it from falling over, 3) if you did that in wordpress you would have all the costs mentioned in 4.",
          "createdAt": "2020-04-24T03:31:28Z",
          "updatedAt": "2020-04-24T03:31:28Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "> i really think we're retreading the same points over and over.\r\n\r\nI think there is a fair bit of repetition in the discussion, but some new stuff over time, too. I still believe that we could resolve this difference of opinion (either by convincing one of us, or revealing the underlying axiomatic difference), but yeah it would take a lot of time that maybe neither of us has.\r\n\r\nFWIW, I don't think you're being disingenuous by not \"acknowledging you were wrong\" about anything. I think its a classic problem of conversations (especially textual ones) in whether to treat silence as concurrence. Whenever discussing, my primary goal is to convince myself (in any direction); thus, I'm happy to keep my prior beliefs until an update. As for convincing others, I believe they have to do the hard work of wanting to be convinced (in any direction), and from that will follow the right questions.\r\n\r\nThat said, I'll respect your decision to stop.\r\n\r\nJust wanted to make one comment. :)\r\n\r\n> 5. Even if all the costs described in #4 went to zero, it would at the very least require modifications to the millions of sites / applications on the web.  With web bundles, you just need to write one tool once to turn the entire web into arbitrary URLs\r\n\r\nI focused on a non-middleware solution in my [last comment](#issuecomment-618604536) because you had suggested that as the case to focus on in your [previous comment](#issuecomment-617511154).\r\n\r\nI also believe it would be feasible to write a gateway that randomizes unbundled URLs (rewriting HTML minimally) using a stateless method as I proposed earlier. It might even be possible to serve the unwanted JS at URLs that are otherwise used for navigational HTML, by varying on headers. A quick inspection of DevTools shows that Chrome varies `Accept` and `Upgrade-Insecure-Requests` between navigation and subresource requests. AFAICT, this could be deployed in one place, as an edge worker, and thus have minimal impact on cache hit ratio.",
          "createdAt": "2020-04-24T20:41:13Z",
          "updatedAt": "2020-04-24T20:48:31Z"
        },
        {
          "author": "mikesherov",
          "authorAssociation": "NONE",
          "body": "Leaving my comment here, as a follow up to my tweet, at the risk of rehashing points already made here. \r\n\r\nI do believe WebBundles and Signed Exchanges are a net positive, but it's important to discuss the tradeoffs. The crux of the argument in this issue in favor of Signed Exchanges / WebBundles is \"this is not a new threat\". @pes10k has been making the argument \"while it's not a new *kind* of threat, it's feasibility is dramatically increased once you build a web standard that allows the threat\". His arguments ultimately boil down to: literal economic cost and universality of the exploit.\r\n\r\n1. economic cost: while the cost of servers is rapidly approaching zero, it's still a non-zero cost to run a reverse proxy somewhere. @slightlyoff dismisses this on twitter as a \"20 line cloudflare worker\" to underscore the ease of implementation, but it ignores the non-zero cost associated with doing that... including having to give CF a credit card. Yes, free tier server hosting also exists, but the limits of free servers are still much much lower than limits of free static hosting. I can provide many examples of this, but I don't want to belabor the point. It should suffice to say that moving the exploit client side opens up a much wider distribution surface.\r\n\r\n2. Universality of exploit: by allowing for this exploit in a web standard, we're canonicalizing the machinery required to weaken Same Origin Policy, and give the entire web a single way to do this. Yes, Wordpress powers a huge swath of the net, but there is no single language / implementation that is a web standard backend language. What that means in practice *today*, is if you want to install anti ad block tech for your site you need to install a Wordpress plugin, or a drupal plugin, or a 20 line cloudflare worker, or a lambda on edge function, or a.... you get the point. By building a web standard that is essentially a client side reverse proxy, we're creating a single surface area in a standardized set of technologies. This means a single piece of code can be written that handles this for all cases.... because the web makes it easy and standard!\r\n\r\nIt's worth noting that in either case, URL allowlists/blocklists aren't a great way to block ads and tracking anyway, but we can't ignore that It's all that is still available to Chrome Extension Developers as of Manifest V3, which removed more powerful features for extension devs to block ads under the banner of performance. We should consider whether this proposal is yet another cut in the death by 1000 cuts of ad blocking tech.\r\n\r\nUltimately I believe in WebBundles and Signed Exchanges, but should not write this off as a non-concern simply because this is also exploitable server side.",
          "createdAt": "2020-08-26T12:28:48Z",
          "updatedAt": "2020-08-26T12:29:25Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@mikesherov Thanks for chiming in! I think the part I'm missing is how the cost of dynamically generating bundles to avoid blocked URLs, is less than the cost of dynamically picking which URLs to reply to.\r\n\r\nIf someone just replaces a static URL on a server with a (different) static URL inside a bundle, it seems straightforward for the URL blocker to block the one that's inside the bundle, so putting the bundles on a static host won't actually break URL-based blockers. And once you have to write code to dynamically generate the bundles, you're back at the economic cost and non-universality of the existing circumvention techniques.",
          "createdAt": "2020-08-26T16:38:12Z",
          "updatedAt": "2020-08-26T16:38:12Z"
        },
        {
          "author": "mikesherov",
          "authorAssociation": "NONE",
          "body": "> @mikesherov Thanks for chiming in! I think the part I'm missing is how the cost of dynamically generating bundles to avoid blocked URLs, is less than the cost of dynamically picking which URLs to reply to.\r\n\r\n@pes10k laid it out as such: \"Even worse, the bundler can change the URLs of the bundled resources to be ones that it knows wont be blocked, because they're needed for other sites to work. E.g. say i want to bundle example.org.com/index.html, which has some user-desirable code called users-love-this.js, and some code people def don't want called coin-miner.js. Assume filter lists make sure to not block the former, and intentionally block the latter. When I'm building my bundle, i can rename coin-miner.js to be users-love-this.js, while leaving the \"real web\" example.org/{users-love-this.js,coin-miner.js} resources unmodified. So its worse than URLs having no information, URLs in bundles can have negative information; URLs can be misleading, by pointing to something different in the bundle than outside the bundle (or having the same URL point to different resources in different bundles)\"\r\n\r\n> If someone just replaces a static URL on a server with a (different) static URL inside a bundle, it seems straightforward for the URL blocker to block the one that's inside the bundle, so putting the bundles on a static host won't actually break URL-based blockers. And once you have to write code to dynamically generate the bundles, you're back at the economic cost and non-universality of the existing circumvention techniques.\r\n\r\n\"it seems straightforward for the URL blocker to block the one that's inside the bundle\" I think this is the thing that remains to be seen. What would resolve this (for me at least), is a description and POC on how ad blockers that are chrome extensions with the limitations of Manifest V3 will be able to function in a post Signed Exchanges world. Perhaps I'm lacking imagination in the solution space, but I think this is where a lot of the questions come from.",
          "createdAt": "2020-08-26T18:16:33Z",
          "updatedAt": "2020-08-26T18:16:33Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ah, I think I see. We're proposing [a way to name resources inside of bundles](https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md) ([discussion on wpack@ietf.org](https://www.ietf.org/mailman/listinfo/wpack)), so if you have a bundle at `https://example.org/tricky.wbn` which contains `https://example.org/users-love-this.js` (with the content of coin-miner.js), the ad blocker could block that particular resource by naming `package:https%3a%2f%2fexample.org%2ftricky.wbn$https%3a%2f%2fexample.org/users-love-this.js`.\r\n\r\nWe'll have to make sure that Chrome Manifest V3 lets that block even [\"authoritative\"](https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md#non-goals) subresources.",
          "createdAt": "2020-08-26T18:38:25Z",
          "updatedAt": "2020-08-26T18:38:25Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Also, Signed Exchanges contain just one resource, so the blocker would just block the SXG itself. Only bundles (possibly containing signed exchanges or signatures for groups of resources to make them authoritative) have this risk.",
          "createdAt": "2020-08-26T18:43:18Z",
          "updatedAt": "2020-08-26T18:43:18Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "What about the user's bandwidth? Will ad-blockers be able to reliable prevent fetching `giant-banner-ad-generator.js` to save bandwidth? It sounds like the answer is no because it will come as part of the bundle. Bandwidth saving is one of the major use-cases for ad-blockers, especially on mobile.",
          "createdAt": "2020-08-30T09:56:05Z",
          "updatedAt": "2020-08-30T09:56:05Z"
        },
        {
          "author": "briankanderson",
          "authorAssociation": "NONE",
          "body": "> What about the user's bandwidth? Will ad-blockers be able to reliable prevent fetching `giant-banner-ad-generator.js` to save bandwidth? It sounds like the answer is no because it will come as part of the bundle. Bandwidth saving is one of the major use-cases for ad-blockers, especially on mobile.\r\n\r\nThis is critical for low-bandwidth/high-latency links as well (VSAT). I used to manage a handful-of-megabits sat connection for several hundred users and the only way to actually make anything work was through extensive selective blocking (coupled with local caching). The approach being developed here would eliminate any possibility of this and have huge impact for such users. When each 1Mbps costs upwards of $10K USD PER MONTH, \"just buying more bandwidth\" isn't a solution. As such, it seems that this would mainly benefit those in the developed world and have very real consequences for those who are not.\r\n\r\nI strongly suggest that the authors consider the impact of these \"fringe\" cases not as \"fringe\", but actually how the *majority of the people* in the world access and use the Internet.",
          "createdAt": "2020-08-30T10:32:05Z",
          "updatedAt": "2020-08-30T10:32:05Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "For that matter will it be compatible with browser settings such as \"disable images\". The expectation is that images won't be downloaded. Or \"disable JavaScript\" for that matter.",
          "createdAt": "2020-08-30T13:07:27Z",
          "updatedAt": "2020-08-30T13:07:27Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Speculation about how this project is an evil plot belongs somewhere else. I'll reopen this issue tomorrow.\r\n\r\nTo the extent that sites have a local `giant-banner-ad-generator.js` today, instead of compiling it into the rest of their Javascript, they can equally well have a separate bundle for the ad-related things tomorrow. Doing so improves their user experience even for high-bandwidth users, since it improves caching and everyone's sensitive to loading latency.\r\n\r\nThe low-bandwidth/high-latency case is one of the [core use cases](https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-offline-installation) for the overall web packaging project, but we need signing (or [adoption](https://martinthomson.github.io/wpack-content/draft-thomson-wpack-content-origin.html)) to let the local cache distribute trusted packages, in addition to the bundles discussed in this issue.",
          "createdAt": "2020-08-30T18:26:07Z",
          "updatedAt": "2020-08-30T18:26:07Z"
        },
        {
          "author": "ron-wolf",
          "authorAssociation": "NONE",
          "body": "Thread is long as hell, so I haven\u2019t read it all; perhaps what I\u2019m about to say has already been addressed. All I\u2019ll say is I think there are other (possibly better) reasons to enforce single canonical resources for URLs, besides preserving ad-blocking functionality. In short: the scope of this issue is broader than its title suggests.\r\n\r\n@jyasskin, thanks for unlocking the issue! I hope the discussion will be thoughtful and civil.",
          "createdAt": "2020-08-31T23:25:07Z",
          "updatedAt": "2020-08-31T23:26:09Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@ron-wolf I think this thread has focused on the use case of blocking resources, rather than other reasons to encourage resources to live at just one URL or for each URL to have just one representation. I think it'll be easier to discuss your other use case(s) in a new issue, just to prevent them from getting lost in the noise here. Could you elaborate what use cases you're hoping to preserve, and how you see bundles causing problems for those use cases?",
          "createdAt": "2020-09-01T00:05:18Z",
          "updatedAt": "2020-09-01T00:05:18Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin would you mind filing a new issue to discuss the bandwidth / disable X use case brought up by @briankanderson and @kuro68k ? This feels different enough from the original issue.",
          "createdAt": "2020-09-01T04:08:42Z",
          "updatedAt": "2020-09-01T04:08:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@KenjiBaheux Done: #594.",
          "createdAt": "2020-09-01T04:23:05Z",
          "updatedAt": "2020-09-01T04:23:05Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "@jyasskin I think anything which relies on the kindness of the site operator is a bad idea.\r\n\r\nWhile it is possible to inline JS ads it's unusual because of the way ad networks work and their desire for metrics.",
          "createdAt": "2020-09-01T08:05:18Z",
          "updatedAt": "2020-09-01T08:05:18Z"
        },
        {
          "author": "ocumo",
          "authorAssociation": "NONE",
          "body": "I am a bit appalled.\r\n\r\nThe elephant in the room is the argument that because evil exists and thrives anyway despite costs or existing countermeasures, then the \"obvious\" solution would be to go ahead and make it the standard.\r\n\r\nIn other words: Because, say, theft will always happen, no matter what society does to prevent it, then society should make it legal, providing thiefs with a set of free and standard tools and means to commit the perfect crime. That way society saves the hassle of investigations, arresting, judging, etc.  On top of that, good citizens would also always find cool ways to use those tools too. Clever, huh?\r\n\r\nKind of akin the freedom of gun possession talk. Yeah, it'd be a cool thing to have brutally powerful automatic weapons cheaply available in the nearest news kiosk, bakery, or gas station.  I would love to have one, to shoot at cans and impress girls into what a wonderful and heroic male I am for mating. On the other hand, all kind of crooks, nuts, inferiority complex wackos and other psychosocial lunatics, perverts, criminals and troglodites would also love it. But not exacly to shoot at cans.\r\n\r\nI watch the news. There is a reason why God didn't give donkeys horns.\r\n\r\nAs a developer, I am extremely excited to use this extremely cool technology. I can't wait to learn the (soon-to-be?) \"new standard\".  And, boy, do I already have ideas of how to use it, dude!\r\n\r\nAs a responsible citizen and father, and as a simple user myself, I feel totally different, though.  The geek kid inside me can't convince the mature man that worries about a rare, dying concept: ethics. Society can't be all about technology and code details, without the faintest high level concerns about boundaries, purposes and consequences framing it.  Without that frame, all this is nothing but juvenile. Cool, but juvenile. Sorry.\r\n\r\nThat blurred and now very alien concept (\"ethics\") still matters to me, more than the excitement of debating geekie latency details or implementations of countermeasures against countermeasures of \"clever\" pieces of code.\r\n\r\nIn the contest of \"who is more clever\": the geek who wants to do a thing just because he can, vs. the geek who disagrees on details of the implementation, the winner is...\r\n\r\n...definitely not society or civil rights, let alone ethics, decency or intelligency itself.\r\n\r\nI trust that in Google there should certainly be senior management willing to look at this from high above the nuts and bolts, variables, arrays, classes, functions, if/then, semi-colons, O(N) and so forth, and give it a truly responsible thought, purpose and direction for the sake of the Internet for the Good of the Society.",
          "createdAt": "2020-09-01T16:17:32Z",
          "updatedAt": "2020-09-01T16:17:32Z"
        },
        {
          "author": "tauin",
          "authorAssociation": "NONE",
          "body": "Frankly this is going to ruin the web",
          "createdAt": "2020-12-08T05:13:15Z",
          "updatedAt": "2020-12-08T05:13:15Z"
        },
        {
          "author": "qertis",
          "authorAssociation": "NONE",
          "body": "We need to stop webpackage",
          "createdAt": "2021-01-27T17:44:51Z",
          "updatedAt": "2021-01-27T17:44:51Z"
        },
        {
          "author": "EternityForest",
          "authorAssociation": "NONE",
          "body": "@ocumo  I very much respect your position on ethics, but with anything like this we need to look at the positives.\r\n\r\nSigned bundles may give access to resources in places with no, or heavily censored internet.  They may \r\n\r\nWhen most people think privacy, they probably think PRISM at some point.  Making it harder to track you may keep some commercial entities from tracking you, but it will not stop someone with full access to all the fiber and 83974 other ways to track you.  \r\n\r\nPrivacy may be a human right, but it has to be balanced against the what many consider the right to education and other benefits of the internet, and it has to be real privacy, of the kind that actually benefits people.\r\n\r\n\r\nThe increase in bandwidth is a very real concern.  Advertisers can, and will, and do, crap down your connection.\r\n\r\nSo what if we just limit the scope of these things? Web bundles have some amazing possible benefits, but they mostly have to do with offline functionally, sharing them via email, and things like that.\r\n\r\nWhy do we need to allow a behind-the-scenes web bundle at all?   Why can these not be under full and absolute user control?\r\n\r\nWeb bundles could be installable \"apps\".  Browsable in a list, offline searchable, installable from file, exportable to file, or just viewable by double clicking the file just like .html.\r\n\r\nThis would provide the feeling of control you might hope to get from an online app, without allowing anyone to waste your bandwidth behind the scenes.\r\n\r\nThis would cover all the best use cases, and in fat cover them a little better, giving users explicit visibility into their apps.\r\n\r\nBundles could even have their own top level origin, based on a unique public key just for that bundle, allowing them to have a persistent identity across updates without needing to have a domain name to make one.\r\n\r\n\r\nAnother possibility is \"Support Bundles\" which area explicitly marked as being accessible from other pages.   If a site wants to embed resources from a bundle, it says \"Foo.com would like to use a resource pack. Need to download 50MB\".\r\n\r\nSome other site could come in and ask for resource pack support using a meta tag, The UA would then say \"Foo.com would like to access your existing resources packs\", allowing large libraries to be shared, while warning users about fingerprinting.\r\n\r\nIf the user accepts, the existing resource packs are used to serve any resources requested in the rest of that page.\r\n\r\nIf the user declines, those resources are fetched one-by-one as normal.\r\n\r\nBut this is ultimately still a small niche use case.\r\n\r\nThe real beauty of web bundles, I think, is in offline apps which a user can redistribute, back up, or delete, and in proposals like the self-modifying PDF Forms like features.",
          "createdAt": "2021-02-16T01:12:30Z",
          "updatedAt": "2021-02-16T01:20:27Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "If we are talking balancing privacy then I'd make two points.\r\n\r\n1. People must be able to choose the balance they want, and not be penalised for it. That's actually the law in GDPR jurisdictions.\r\n\r\n2. The benefits of web bundles are so vanishingly small that it seems unlikely this trade off would be worth it in almost all cases.\r\n\r\nBy the way, the idea that this will be censorship resistant is unfortunately misguided. I suggest speaking to some people living in such countries about it, you will find that op-sec is the issue, not access. Clearly an opaque bundle of data that the browser has more limited ability to pre-screen is not going to help.",
          "createdAt": "2021-02-16T09:03:25Z",
          "updatedAt": "2021-02-16T09:03:25Z"
        },
        {
          "author": "EternityForest",
          "authorAssociation": "NONE",
          "body": "@kuro68k  Assuming Web Bundles are used in (what I consider to be) their most useful configuration, which is as manually downloaded, shared, or remixed bundles, I don't see how this in any way limits the browser's ability to filter anything.\r\n\r\nThey may be shared monolithically,  but the browser is completely free to pretend that a certain resource does not exist.  The individual requests in a bundle can still be discarded after download by the same blocker APIs.\r\n\r\nI'm being generous and thinking from the perspective of a proper implementation, regardless of current proposals. Perhaps bad things can be done in some nonsense implementation where URLs are random and meaningless and can be freely changed regardless of the original source.\r\n\r\nBut in a properly designed system, web bundles are essentially just enabling a sneakernet or cache proxy based transport, that does the same thing HTTP does now.  If adblock can't catch jdnekndiwjkfinrjrPrivacyViolator.js in a bundle, why would it catch exactly the same URL served over HTTPS?\r\n\r\nThe current proposal may have issues, what bothers me is that people seem to be more interested in killing the project entirely than fixing them.\r\n\r\nThere is of course still a bandwidth issue, many of us can't afford the data to download the bad content in the first place even if blockers make them inert.\r\n\r\nBut that issue largely goes away if we just disallow transparently navigating to a webbundle.  If they are instead treated as installable apps, publishers won't want to hide content behind a manual download and install process any more than they would with current app store apps.\r\n\r\nBundles do seem problematic when used as originally proposed, downloaded a bandwidth wasting crapload in the background.  But much less so when used as sharable offline apps, just like a lightweight APK.",
          "createdAt": "2021-02-16T09:30:44Z",
          "updatedAt": "2021-02-16T09:32:57Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "Being able to email someone a browser exploit doesn't sound like a good idea. Or for that matter something that could reveal their true location, e.g. unmask their IP address using other APIs.\r\n\r\nThink about how heavily HTML email is sanitised.\r\n\r\nAnd really, what the benefit to the user? It seems extremely small.",
          "createdAt": "2021-02-16T10:11:21Z",
          "updatedAt": "2021-02-16T10:11:21Z"
        },
        {
          "author": "EternityForest",
          "authorAssociation": "NONE",
          "body": "I still don't see how a properly implemented bundle can be more dangerous\nthan emailing a regular link, except in that it might encourage more use of\nthe internet in general rather than paper, by making things more convenient.\n\nAs signed bundles currently don't exist, they could even be safer than a\nstandard website.\n\nBeing more like an app or document than a site,  and having self contained\nresources, there's technically no reason to even allow the bundle to fetch\nanything or access the internet at all without explicit permission.\n\n\nOn Tue, Feb 16, 2021, 2:11 AM kuro68k <notifications@github.com> wrote:\n\n> Being able to email someone a browser exploit doesn't sound like a good\n> idea. Or for that matter something that could reveal their true location,\n> e.g. unmask their IP address using other APIs.\n>\n> Think about how heavily HTML email is sanitised.\n>\n> And really, what the benefit to the user? It seems extremely small.\n>\n> \u2014\n> You are receiving this because you commented.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/WICG/webpackage/issues/551#issuecomment-779731548>,\n> or unsubscribe\n> <https://github.com/notifications/unsubscribe-auth/AAFZCH4J24FZAZ5L27R77D3S7JAFRANCNFSM4KMZN6OQ>\n> .\n>\n",
          "createdAt": "2021-02-16T10:21:13Z",
          "updatedAt": "2021-02-16T10:21:13Z"
        }
      ]
    },
    {
      "number": 555,
      "id": "MDU6SXNzdWU1NjM3OTI3MjI=",
      "title": "loading spec: Content sniffing prevention steps are missing in Parsing b3 algorithm",
      "url": "https://github.com/WICG/webpackage/issues/555",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#354 added two steps in the [Parsing b2 CBOR headers](https://wicg.github.io/webpackage/loading.html#parse-b2-cbor-headers) algorithm:\r\n\r\n> 7. If responseHeaders does not contain `Content-Type`, return a failure.\r\n> 8. Set `X-Content-Type-Options`/`nosniff` in responseHeaders.\r\n\r\nBut it did not add them into the [Parsing **b3** CBOR headers](https://wicg.github.io/webpackage/loading.html#parse-cbor-headers) algorithm.\r\n",
      "createdAt": "2020-02-12T06:56:11Z",
      "updatedAt": "2020-02-12T06:56:11Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 556,
      "id": "MDU6SXNzdWU1NjQ1NTYyNDU=",
      "title": "\"These are encoded so that the normal algorithm for computing an origin from a URL works\" is false",
      "url": "https://github.com/WICG/webpackage/issues/556",
      "state": "CLOSED",
      "author": "annevk",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/WICG/webpackage/blob/master/explainers/navigation-to-unsigned-bundles.md#urls-for-bundle-components is incorrect as due to the scheme you'll get an opaque origin.",
      "createdAt": "2020-02-13T09:40:10Z",
      "updatedAt": "2020-04-07T00:12:42Z",
      "closedAt": "2020-04-07T00:12:42Z",
      "comments": []
    },
    {
      "number": 562,
      "id": "MDU6SXNzdWU1NzcyNTg1MjI=",
      "title": "Unclear error processing model for mismatched types",
      "url": "https://github.com/WICG/webpackage/issues/562",
      "state": "OPEN",
      "author": "domenic",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "(Forked from https://github.com/WICG/origin-policy/issues/87#issuecomment-596029083)\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#name-the-signature-header specifies types for various parameters, but from what I can tell the processing model in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#section-3.5-7.1.1 does not explain what to do when the types mismatch.\r\n\r\nIt seems like maybe the intention is to return \"invalid\", but if so I'd expect an explicit step, like \"If integrity is not a string, return \"invalid\".",
      "createdAt": "2020-03-07T02:03:38Z",
      "updatedAt": "2020-07-10T21:27:09Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#name-signature-validity has \"If an error is thrown during this parsing or any of the requirements described there aren't satisfied, the exchange has no valid signatures.\" Is that what you're looking for?",
          "createdAt": "2020-07-10T19:18:17Z",
          "updatedAt": "2020-07-10T19:18:17Z"
        },
        {
          "author": "domenic",
          "authorAssociation": "NONE",
          "body": "I guess? It'd be much clearer to locate that after the parsing, however, instead of the monkeypatch-from-a-distance.\r\n\r\nThat is, consider what happens if expires is not a number. A straightforward reading gets to step 3 of https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#section-3.5-7.1.1 and says \"??? what do I do, is the letter 'a' greater than _date_ + 7 days, or is it less than that?\". What I'm hearing is that after step 1 there's an invisible \"If expires is not a number, return a special value that's not only invalid, but forces all other signatures to become invalid\". But this is pretty confusing...",
          "createdAt": "2020-07-10T19:46:11Z",
          "updatedAt": "2020-07-10T19:48:05Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ah, but step 1 is already after parsing, which happens in the very first sentence of the section. I no longer remember why I put part of the algorithm in text instead of putting it all in numbered steps ... It could have been something about IETF formatting not accepting sufficiently-nested lists, or some reason I couldn't call algorithms well, or something that no longer exists in the document at all.\r\n\r\nSo the TODO here for me is to try to put all of the actual steps into numbered steps.",
          "createdAt": "2020-07-10T20:22:28Z",
          "updatedAt": "2020-07-10T20:22:28Z"
        },
        {
          "author": "domenic",
          "authorAssociation": "NONE",
          "body": "Ah, nice! So there'd be some \"real step 1\" that parses the header field into a list (which would fail if that didn't work), then step 2 would be a loop that runs the current algorithm for each list item. That would make perfect sense.",
          "createdAt": "2020-07-10T21:27:09Z",
          "updatedAt": "2020-07-10T21:27:09Z"
        }
      ]
    },
    {
      "number": 564,
      "id": "MDU6SXNzdWU1ODYwMzQ2ODE=",
      "title": "go/signedexchange: gen-certurl should fail on invalid OCSP",
      "url": "https://github.com/WICG/webpackage/issues/564",
      "state": "OPEN",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "irori"
      ],
      "labels": [
        "go"
      ],
      "body": "Currently, `dump-certurl` warns if the input has an invalid OCSP response, but `gen-certurl` happily creates such cert chains.\r\n\r\n`gen-signedexchange` refuses to create an invalid SXG unless `-ignoreErrors` flag is given. `gen-certurl` should behave similarly.\r\n",
      "createdAt": "2020-03-23T08:50:18Z",
      "updatedAt": "2020-03-23T08:50:18Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 568,
      "id": "MDU6SXNzdWU1OTUxNDg4MDc=",
      "title": "Chrome refuses to load generated bundles",
      "url": "https://github.com/WICG/webpackage/issues/568",
      "state": "CLOSED",
      "author": "mgissing",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I have been trying to create my own web bundles (with both gen-bundle and the JS encoder)\r\nand I noticed that sometimes Chrome (both 80 release and 83.0.4102.0 Win x64) rejects the bundle with ERR_INVALID_WEBBUNDLE (no further info in console or devtools)\r\n\r\nAfter fiddling with it a bit, it seems that Chrome is very picky about the order the exchanges appear in.\r\nI am sure that its not the content, since it is reproducible with just changing a single file name.\r\nIf I sort the result URLs first by length and then lexically everything works fine.\r\n\r\nNot sure if this is the right location to report this since it might be Chromium related - but if anyone is interested I can provide more details and a minimal example\r\n",
      "createdAt": "2020-04-06T14:08:39Z",
      "updatedAt": "2020-04-10T08:09:31Z",
      "closedAt": "2020-04-10T08:09:30Z",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "The [`index` section](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#name-parsing-the-index-section) must be a deterministically encoded CBOR map, which means its entries must be sorted. The order of responses in the `responses` section is arbitrary.\r\n\r\nWould you file a Chromium bug (with example `.wbn` if possible) from http://crbug.com/new with `Blink>Loader>WebPackaging` component? Chromium should at least output detailed error message in console.\r\n\r\nThanks!",
          "createdAt": "2020-04-07T00:07:43Z",
          "updatedAt": "2020-04-07T00:07:43Z"
        },
        {
          "author": "mgissing",
          "authorAssociation": "NONE",
          "body": "Filed chromium issue https://bugs.chromium.org/p/chromium/issues/detail?id=1068481\r\nAfter looking a bit further into the issue it seems that both the JS encoder and the gen-bundle get the sort order wrong. \r\nBoth go \"bytes.compare(..)\" and Buffer.compare() in node do not sort by length first but only by byte values and then length\r\n\r\nhttps://github.com/WICG/webpackage/blob/7412e313f959808ed927cfd4156acffb8bbd9420/go/signedexchange/cbor/encoder.go#L228\r\n\r\n",
          "createdAt": "2020-04-07T08:30:20Z",
          "updatedAt": "2020-04-07T08:46:03Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "`encoder.go` sorts map keys by CBOR-encoded bytes of keys, i.e. \"z\" (encoded as `61 7A`) comes before \"aa\" (encoded as `62 61 61`). See the unit test of the encoder:\r\n\r\nhttps://github.com/WICG/webpackage/blob/7412e313f959808ed927cfd4156acffb8bbd9420/go/signedexchange/cbor/encoder_test.go#L188\r\n\r\nEffectively it sorts keys by length and then by value.\r\n\r\nHow did you create your bundle file? Was it created by `gen-bundle`, the `wbn` JS library, or any other tool?\r\n",
          "createdAt": "2020-04-08T02:09:24Z",
          "updatedAt": "2020-04-08T02:09:24Z"
        },
        {
          "author": "mgissing",
          "authorAssociation": "NONE",
          "body": "Sorry I missed the part were the sort includes the length prefix - thats fine.\r\nI have written my own encoder on top of CBOR and with sorting that works fine now.\r\n\r\nRegarding gen-bundle - maybe I'm using it wrong:\r\nThis is the file structure:\r\n\r\n```\r\nDummyPage/index.html\r\n          test.jpg\r\n          unused.jpg\r\n          unused2.jpg\r\n```\r\n\r\nThis doesnt work:\r\n`gen-bundle -baseURL http://example.org/ -primaryURL http://example.org/index.html -dir  DummyPage -o notworking.wbn`\r\n\r\nThis does:\r\n`gen-bundle -baseURL http://example.org/ -primaryURL http://example.org/ -dir  DummyPage -o working.wbn`\r\n\r\n[bundle-working-dump.txt](https://github.com/WICG/webpackage/files/4449270/bundle-working-dump.txt)\r\n[bundle-notworking-dump.txt](https://github.com/WICG/webpackage/files/4449271/bundle-notworking-dump.txt)\r\n\r\nAlso I was wondering if  \"Content-Encoding: gzip\" in responses is supposed to work in Chrome right now - currently Chrome seems to ignore that\r\n",
          "createdAt": "2020-04-08T08:44:37Z",
          "updatedAt": "2020-04-08T08:44:37Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "For `index.html`, `gen-bundle` generates a redirect (301) resposnse to `./` (as you can see in [bundle-notworking-dump.txt](https://github.com/WICG/webpackage/files/4449271/bundle-notworking-dump.txt)). But currently Chromium cannot handle it. This is tracked at https://crbug.com/1040831.\r\n\r\nWe'd like to support `Content-Encoding: gzip` in bundled respohnses in the future, but it doesn't work currently. This is tracked at https://crbug.com/1063738.\r\n\r\nI think this WICG/webpackage issue can be closed. Please watch the Chromium issues for progress.",
          "createdAt": "2020-04-10T08:09:30Z",
          "updatedAt": "2020-04-10T08:09:30Z"
        }
      ]
    },
    {
      "number": 569,
      "id": "MDU6SXNzdWU1OTU2OTIzMTI=",
      "title": "Question about compressed content",
      "url": "https://github.com/WICG/webpackage/issues/569",
      "state": "CLOSED",
      "author": "mgissing",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Is it an intended use case to allow \"Content-Encoding: gzip\" or similar in the the web bundle and have a compressed body?\r\nI know you could zip the whole bundle but for passing it around as a compact file it would really be useful",
      "createdAt": "2020-04-07T08:33:42Z",
      "updatedAt": "2020-04-07T16:44:31Z",
      "closedAt": "2020-04-07T16:44:31Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yes. https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-compress-stored-packages says this indirectly.",
          "createdAt": "2020-04-07T16:44:28Z",
          "updatedAt": "2020-04-07T16:44:28Z"
        }
      ]
    },
    {
      "number": 575,
      "id": "MDU6SXNzdWU2MDc0ODM5NjA=",
      "title": "Supporting TWAs and like cases",
      "url": "https://github.com/WICG/webpackage/issues/575",
      "state": "OPEN",
      "author": "kenchris",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In Play Store you can currently publish your PWA as a TWA, but if you launch the app the first time and are offline then you will be met with the offline dinosaur.\r\n\r\nIt would be great if bundled packages can serve as a way to solve this by letting the TWA distribute a webpackage with the initial required resources",
      "createdAt": "2020-04-27T11:51:03Z",
      "updatedAt": "2020-04-27T11:51:03Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 576,
      "id": "MDU6SXNzdWU2MDc0ODk2MTA=",
      "title": "Network access",
      "url": "https://github.com/WICG/webpackage/issues/576",
      "state": "OPEN",
      "author": "kenchris",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Reading this:\r\n\r\n![image](https://user-images.githubusercontent.com/1101339/80369842-39399f80-888f-11ea-9a9a-fe030b25772e.png)\r\n\r\nIt made me realize that Google Play is currently disallowing TWAs distributed to kids (Family Policy), it seems to have to do with the fact that websites might be able to replace the content as they have full network access, so it might make sense to take this into considerations and maybe disallow network traffic or restrict it somehow.",
      "createdAt": "2020-04-27T12:00:06Z",
      "updatedAt": "2021-04-06T13:30:16Z",
      "closedAt": null,
      "comments": [
        {
          "author": "craigfrancis",
          "authorAssociation": "NONE",
          "body": "I'd like WebPackages to have a way to clearly request/show it has no network access.\r\n\r\nThis would make a perfect replacement for many PDF's (invoices, reports, terms and conditions, etc), which need to be completely self contained, stored/archived, forwarded; and would resolve several issues with PDF's (easier to author, layout responsive to screen size, accessible by default, etc)... [more info](https://github.com/craigfrancis/wdoc/).\r\n\r\nI have an [example invoice](https://craig.dev/misc/webPackage/changingContent.wbn) that clearly returns remote content.",
          "createdAt": "2020-09-02T09:52:25Z",
          "updatedAt": "2020-09-02T09:52:25Z"
        },
        {
          "author": "EternityForest",
          "authorAssociation": "NONE",
          "body": "@craigfrancis Honestly I think this this is the only way Bundles can succeed.  As it is, the privacy advocates don't trust them.\r\n\r\nIf they're not onboard, the platfom will basically always be in danger of being removed from some browsers and will become inconvenient to use.\r\n\r\nI think that bundles should never be allowed internet access without explicit user permission, regardless of where they came from.\r\n\r\nThe most compelling use case of bundles is for installable apps, and as a PDF Forms  replacement.  If something is meant to be edited and shared, and created without a domain name, people will be happy to know it can't phone home without a popup prompt.",
          "createdAt": "2021-02-16T21:04:06Z",
          "updatedAt": "2021-02-16T21:10:43Z"
        },
        {
          "author": "abflow",
          "authorAssociation": "NONE",
          "body": "In (https://github.com/whatwg/html/issues/6553), was introduced a declarative way for web developers to easily reason about network permissions without having to deal with HTTP headers, via the `allow-net` attribute in insecure HTML tags. This declarative approach for defining network policies would be more in line with the HTML specification than current network policies approaches, while offering: \r\n\r\n- no network access by default (offline-first documents and applications)\r\n- enhanced, fine-grained network permissions, \r\n- the possibility to gain network isolation for critical parts of the document/application (https://github.com/whatwg/html/issues/6547) \r\n- the possibility to define and even extend declarative cross-origin communication scenarios, by leveraging the Shared Worker technology (https://github.com/whatwg/html/issues/6555).",
          "createdAt": "2021-04-06T11:00:01Z",
          "updatedAt": "2021-04-06T13:30:16Z"
        }
      ]
    },
    {
      "number": 577,
      "id": "MDU6SXNzdWU2MTIxNzE0NDI=",
      "title": "Serialization format optimized for streaming",
      "url": "https://github.com/WICG/webpackage/issues/577",
      "state": "CLOSED",
      "author": "jeffkaufman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "The current web bundle serialization has the index at the beginning, and so requires you to know the sizes and urls of all the resources the bundle will contain up-front.  If a bundle is being generated dynamically, however, it would be nice to be able to start sending out the part of the response that is ready before you necessarily know the full contents of the bundle.\r\n\r\nPre-declaring resources, when possible, is still useful, however, because it allows the consumer of the bundle to know that the bundle will contain a given resource and it shouldn't start independent efforts to acquire it.  Similarly, being able to say that a resource is not in a bundle, either by disclaiming a specific resource or by saying that no more resource declarations will follow, would let the consumer know that it should look elsewhere.\r\n\r\nIf at some point nested web bundles are supported, being able to stream out part of a nested bundle before the whole bundle is ready without blocking the whole stream would be nice.\r\n\r\nFor context, I'm looking into whether dynamically generated web bundles could at some point be used for serving a single ad response for multiple ad slots.  Streaming the bundle would allow returning a response for a slot that will soon be visible to the user as soon as it's ready, while allowing more time to complete auctions for ads lower down the page.  I expect a streaming-focused serialization format would be useful to many people who end up dynamically generate web bundles, however.",
      "createdAt": "2020-05-04T21:12:11Z",
      "updatedAt": "2020-07-31T14:25:06Z",
      "closedAt": "2020-07-31T14:25:06Z",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the concrete use case! We discussed this in #6, where the lack of a concrete use case led me to say we shouldn't support this kind of streamed generation, so now's a good time to reopen the question.\r\n\r\nIn some ways, MHTML could be the streamed-generation version of the [random-access bundles format here](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html), but I think there's appetite to replace the text bits of MHTML with a binary format, and we can re-use the header representations from the random-access one. MHTML also doesn't have a native way to promise that particular responses will be available later.\r\n\r\nAnother possible design would be as a sequence of [HTTP/2 frames](https://httpwg.org/specs/rfc7540.html#FrameTypes). (They'd be serialized into a file format rather than actually being in an HTTP/2 connection.) PUSH_PROMISE serves as a way to say that a particular URL will eventually arrive. I don't think there's a way to disclaim a resource, but 1) we could invent one, and 2) I suspect we don't actually need it: the default should be to assume arbitrary resources _aren't_ in any bundle. I suspect we'll want to at least customize this a bit so it embeds fewer assumptions that it's living in a real-time connection.\r\n\r\nAnd, of course, there's the option of matching the random-access bundle format as much as possible and just pulling smaller amounts of inspiration from the above two options.",
          "createdAt": "2020-05-07T22:14:16Z",
          "updatedAt": "2020-05-07T22:14:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We discussed this briefly at the IETF 108 WPACK meeting, and there wasn't support in the room to add a variant of the format that supports streamed generation. It seemed like people were open to being convinced by measurements that it'll actually help, so anyone should feel free to re-open this bug with more evidence that it'll pay off.",
          "createdAt": "2020-07-31T14:25:06Z",
          "updatedAt": "2020-07-31T14:25:06Z"
        }
      ]
    },
    {
      "number": 580,
      "id": "MDU6SXNzdWU2MTY0NzQzOTk=",
      "title": "Consider dropping declarative scope for subresource loading.",
      "url": "https://github.com/WICG/webpackage/issues/580",
      "state": "OPEN",
      "author": "koto",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "security-tracker"
      ],
      "body": "https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md declares how, essentially, adding a link tag will change how, and if, some scripts on the page are being loaded.\r\n\r\nAdding that primitive to the platform makes it harder to protect existing applications from XSS, as it bypasses existing methods that guard script loading (and likely server-side XSS mitigations like XSS filters are unaware of those new vectors as well). \r\n\r\nFor example, right now there's no requirement to have a CSP nonce in `<link rel=\"webbundle\">`, and modifying the bundle scope in javascript does not require a [Trusted Type](https://github.com/w3c/webappsec-trusted-types), and yet adding that element may, IIUC, cause arbitrary scripts to get loaded, or prevent them from being loaded.\r\n\r\nNew mechanisms that alter script loads should be programmatic, and not declarative. \r\n\r\n/ cc @arturjanc @mikewest @lweichselbaum",
      "createdAt": "2020-05-12T08:43:57Z",
      "updatedAt": "2020-12-08T18:21:47Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I was thinking of a `<link rel=\"webbundle\">` as just providing a different way to retrieve a script, whose execution, XSS resistance, integrity, CSP, etc. are provided by the `<script>` tag that actually executes the script. Any script provided by a bundle would still need to be [authoritative](https://github.com/WICG/webpackage/blob/master/explainers/navigation-to-unsigned-bundles.md#authoritative) for the URL that loads it, or else the script  would fall back to a network fetch. So, I'm struggling to think of how an attacker who can insert HTML tags would be able to use a new `<link rel=\"webbundle\">` to run script they couldn't run by inserting a `<script src=\"...\"> tag.\r\n\r\nThere's a suggestion in https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md#link-based-api that a `<link rel=\"webbundle\">` with an overbroad scope could *prevent* scripts from loading, and this may be a good argument that we should instead go to the network.\r\n\r\nI would appreciate more opinions from security folks. :)",
          "createdAt": "2020-05-21T20:13:22Z",
          "updatedAt": "2020-05-21T20:13:22Z"
        },
        {
          "author": "koto",
          "authorAssociation": "NONE",
          "body": "> I was thinking of a `<link rel=\"webbundle\">` as just providing a different way to retrieve a script, whose execution, XSS resistance, integrity, CSP, etc. are provided by the `<script>` tag that actually executes the script. Any script provided by a bundle would still need to be [authoritative](https://github.com/WICG/webpackage/blob/master/explainers/navigation-to-unsigned-bundles.md#authoritative) for the URL that loads it, or else the script would fall back to a network fetch. So, I'm struggling to think of how an attacker who can insert HTML tags would be able to use a new `<link rel=\"webbundle\">` to run script they couldn't run by inserting a `<script src=\"...\"> tag.\r\n\r\nThe problem here is that this introduces another declarative way of altering the script loads like `<base>` or import maps. Whoever can control these elements in the DOM gets to decide how and if scripts are loaded -- and in a way that's not obvious. This is an important capability, and I argue that we should *not* be creating it - especially if it doesn't require already controlling the JS code that executes. \r\n\r\nIt's not very clear that, for example this code:\r\n```javascript\r\nconst foo = document.createElement('link')\r\nfoo.rel = userparams.rel\r\nfoo.href = '//legitimate.example/' + userparams.bar;\r\ndocument.head.appendChild(foo)\r\n```\r\nis a gadget that used to be OK, but now can alter how the scripts are loaded on the page. This is surprising to code reviewers, introduces new attack surface that existing security tools don't cover -- and might lead to security bugs. \r\n\r\nIt's not expected for `link` elements to interfere with script loads. The last remaining, bad examples of this pattern were [link rel=serviceworker](https://www.chromestatus.com/feature/5682681044008960) and `<link rel=\"import\">`; both deprecated (after having led to numerous XSSes, and filter bypasses - [even in Chrome](https://bugs.chromium.org/p/chromium/issues/detail?id=485198)). I argue we should not add novel ways of how scripts are loaded (directly, or indirectly) and instead rely on primitives that already exist and security consequences of which are well understood. Even adding `<base>` tag,  has led to numerous bugs, HTML sanitizer bypasses etc.\r\n\r\nOn the other hand, import maps use a `<script>` element, because one would expect that  control over `<script>` nodes gives total control over the application. Perhaps a `<script>` based API should be used instead of `<link>`.\r\n\r\nAn even better solution would be to require Javascript execution to alter script loading via bundles - either partially, for example like outlined in https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md#no-declarative-scope, or fully, by only allowing to fetch a webbundle from Javascript. That gives guarantee that a limited HTML injection (e.g. if the attacker can only insert certain tags, as others are filtered out) cannot lead to a security issue via webbundles.\r\n\r\n> \r\n> There's a suggestion in https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md#link-based-api that a `<link rel=\"webbundle\">` with an overbroad scope could _prevent_ scripts from loading, and this may be a good argument that we should instead go to the network.\r\n\r\nThat is one way of how the code that is executed in the document is altered by web bundles - this one without a need to access to any signing keys. Being able to disable selective script loads is problematic, as some scripts might perform additional security checks, workaround bugs, polyfill Web APIs etc. - and in general it gives the attacker another lever to trigger [xs-leaks](https://github.com/xsleaks/xsleaks).\r\n\r\n",
          "createdAt": "2020-05-25T16:45:11Z",
          "updatedAt": "2020-05-25T20:24:15Z"
        },
        {
          "author": "jeffkaufman",
          "authorAssociation": "NONE",
          "body": "Thinking about how bundles could be used, I think it's possible that they don't need to be loadable declaratively. In any case where you might want to reference a web bundle in the HTML which would contain a resource which you are authoritative for, you could instead serve a web bundle as the top level page. So perhaps we would not be losing any important functionality if we made these be only loadable through JavaScript?",
          "createdAt": "2020-05-25T19:50:54Z",
          "updatedAt": "2020-05-25T19:50:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It looks like adding a `<link rel=preload>` element with an incorrect `integrity` attribute can also prevent script from loading, so folks do have to be at least a bit careful with gadgets that let folks add `<link>` elements.\r\n\r\nHowever, I'm gradually getting more worried about sites that:\r\n\r\n1. Let users upload content to an origin.\r\n1. Serve actual scripts from the same path or a subpath of the user-provided content. (Ew, but might not already be exploitable?)\r\n1. Add the application/web-bundle mime type.\r\n1. Have the gadget that lets an attacker add that arbitrary `<link>`.\r\n\r\nNo matter whether the `<link>` can define its scope, there's at least a race condition that would let the attacker replace script. I'd been [planning](https://github.com/WICG/webpackage/blob/master/explainers/navigation-to-unsigned-bundles.md#loading-an-authoritative-unsigned-bundle) to restrict the scope to the bundle's path or a subpath, and require a header like [`Service-Worker-Allowed`](https://w3c.github.io/ServiceWorker/#service-worker-allowed) to loosen that restriction, but because `<link>` headers are currently safer to inject than script, I'm now thinking we may want to require a response header to make the response authoritative at all.\r\n",
          "createdAt": "2020-08-25T02:55:52Z",
          "updatedAt": "2020-08-25T02:55:52Z"
        },
        {
          "author": "koto",
          "authorAssociation": "NONE",
          "body": "Don't these issue go away if there's no `<link rel=\"webbundle\">`?",
          "createdAt": "2020-08-25T11:09:29Z",
          "updatedAt": "2020-08-25T11:09:29Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "They would, but we'd wind up with a preloading interface that's very different from what HTML has used in the past. I'll [ask](https://lists.w3.org/Archives/Public/public-web-perf/2020Aug/0027.html) the webperf mailing list for opinions.",
          "createdAt": "2020-08-27T18:51:14Z",
          "updatedAt": "2020-08-27T20:06:54Z"
        },
        {
          "author": "terjanq",
          "authorAssociation": "NONE",
          "body": "Bumping this up, did we achieve any consensus on this? @koto @jyasskin \r\n\r\nwebbundle seems indeed very similar to `rel=import`, although it also seems much more restrictive than the import. This could potentially cause breakages of the CSP, which might need some compromises (loopholes) to be able to load the bundle in the first place. \r\n\r\nBut strictly from the security perspective, we've also had (still have actually) a similar mechanism `app cache manifest`, which had a similar permission system and still was widely abused (https://www.slideshare.net/fransrosen/attacking-modern-web-technologies). \r\n\r\nI am more leaning towards @koto statement that this is just too risky, even with these strict conditions because it was proven in the past that these restrictions can often be fulfilled. \r\n\r\n> 1. Let users upload content to an origin.\r\n> 2. Serve actual scripts from the same path or a subpath of the user-provided content. (Ew, but might not already be exploitable?)\r\n> 3. Add the application/web-bundle mime type.\r\n> 4. Have the gadget that lets an attacker add that arbitrary `<link>`.\r\n",
          "createdAt": "2020-12-08T12:50:53Z",
          "updatedAt": "2020-12-08T17:44:09Z"
        },
        {
          "author": "terjanq",
          "authorAssociation": "NONE",
          "body": "I was thinking more about the issue and I thought about a potential solution. `<script>` tags by default already implement `type` attribute and we could potentially require every script to have `type=\"bundle\"` to be able to access the resource from the bundle. That would require changing both `<link>` and `<script>` in that case. Not sure what to do with `<link rel=stylesheet href=xxx>` since these should probably be also protected against being controlled by an attacker.\r\n\r\nWhat do you think? Are `<script>` and `<link>` tags the only concern for bypassing the HTML sanitizers? \r\n\r\n",
          "createdAt": "2020-12-08T13:30:14Z",
          "updatedAt": "2020-12-08T13:30:40Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "NONE",
          "body": "I'm a little worried about disabling header-based resource hints when it comes to bundle-based subresource loading. Wouldn't it be most useful if we had a serialization which worked for both HTML and HTTP headers, so that the fetch to the bundle could run ASAP? We could do this by using Link: headers but disabling the `<link>` tag and using a separate `<script>` tag format for that case, for example.",
          "createdAt": "2020-12-08T17:59:38Z",
          "updatedAt": "2020-12-08T17:59:38Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We haven't found consensus on this yet. I believe the path-based restrictions alluded to [here](https://github.com/WICG/webpackage/blob/master/explainers/navigation-to-unsigned-bundles.md#loading-an-authoritative-unsigned-bundle) and [here](https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md#link-based-api) convinced @koto that this wasn't a blocking issue, so the plan was to do an origin trial with `<link>` tags and re-evaluate from there.\r\n\r\nThe webperf list was [friendly](https://lists.w3.org/Archives/Public/public-web-perf/2020Aug/0032.html) to using `<script>` or `<base>` tags for declarative bundle declarations inside the document, which seems fine to me. The list didn't discuss how to do the same in response headers, but `Link` seems fine there?\r\n\r\n`<link rel=stylesheet href=url_inside_bundle>` seems like not a new risk if the site already allows the attacker to inject arbitrary `<link>` tags. \ud83d\ude09   But if we attach bundles using `<script type=a_bundle_is_declared_here>` or similar, this is protected too.",
          "createdAt": "2020-12-08T18:10:20Z",
          "updatedAt": "2020-12-08T18:10:20Z"
        },
        {
          "author": "terjanq",
          "authorAssociation": "NONE",
          "body": "> `<link rel=stylesheet href=url_inside_bundle>` seems like not a new risk if the site already allows the attacker to inject arbitrary `<link>` tags. \ud83d\ude09 But if we attach bundles using `<script type=a_bundle_is_declared_here>` or similar, this is protected too.\r\n\r\nI know sanitizers that allow `<link>` elements because these are usually not harfmul, e.g. `<link rel=\"icon\">` is commonly allowed. They usually block `stylesheet`, `import`, etc. but rest seems to be allowed. So I would argue that this is something to solve. ",
          "createdAt": "2020-12-08T18:21:31Z",
          "updatedAt": "2020-12-08T18:21:47Z"
        }
      ]
    },
    {
      "number": 581,
      "id": "MDU6SXNzdWU2MTY0OTIwODc=",
      "title": "<link>-based API should be subject to CSP",
      "url": "https://github.com/WICG/webpackage/issues/581",
      "state": "OPEN",
      "author": "lweichselbaum",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Since `<link rel=\"webbundle\" ..>` can be used to load or redirect loads of scripts it should be subject to CSPs `script-src` directive. \r\nEspecially the CSP nonce attribute should be verified in case a CSP restricts script loading based on nonces.\r\n\r\nI.e. in the presence of a `Content-Security-Policy script-src 'nonce-random123'` header only `<link rel=\"webbundle\" nonce=\"random123\" ..>` should be allowed to execute.\r\nSame holds true for `<script type=\u201dmodule\u201d ..>` or similar declarative script loading mechanisms. \r\n\r\n/ cc @mikewest @arturjanc  @koto\r\n",
      "createdAt": "2020-05-12T09:10:13Z",
      "updatedAt": "2020-05-13T07:37:08Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "It surprises me that we'd directly execute script via `<link rel=\"webbundle\" ...>`. Is that the case?",
          "createdAt": "2020-05-12T11:31:37Z",
          "updatedAt": "2020-05-12T11:31:37Z"
        },
        {
          "author": "koto",
          "authorAssociation": "NONE",
          "body": "I don't think it is *directly*. Web bundles `<link>` [proposal](https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md#link-based-api) aims to hijack subsequent fetches for subresources, and direct them to the URLs that tentatively are part of the bundle - instead of to the network. In that regard, it's similar to a declarative service worker. ",
          "createdAt": "2020-05-12T11:36:41Z",
          "updatedAt": "2020-05-12T11:36:41Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "/cc @jyasskin @horo-t ",
          "createdAt": "2020-05-12T12:32:17Z",
          "updatedAt": "2020-05-12T12:32:17Z"
        },
        {
          "author": "lweichselbaum",
          "authorAssociation": "NONE",
          "body": "I think we have similar restrictions for `<link rel=preload as=script ..>` which are subject to CSP nonces as well. ",
          "createdAt": "2020-05-12T14:10:38Z",
          "updatedAt": "2020-05-12T14:10:38Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "<link rel=\"webbundle\" ...> isn't supposed to directly execute scripts or anything, right.  So when <script ...> executes a script from it should respect to script-src CSP.",
          "createdAt": "2020-05-13T05:32:10Z",
          "updatedAt": "2020-05-13T05:32:10Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "> isn't supposed to directly execute scripts or anything, right. So when <script ...> executes a script from it should respect to script-src CSP.\r\n\r\nThanks, @kinu! I have a few questions:\r\n\r\n1. Which directive controls the request that `<link rel=\"webbundle\" ...>` generates?\r\n2. How is the `<script>` evaluation performed? Against the URL in the `src` attribute? Against the URL of the resource that's actually being used?\r\n3. I'm assuming that the mechanism here only works with signed bundles, and not unsigned?",
          "createdAt": "2020-05-13T07:37:08Z",
          "updatedAt": "2020-05-13T07:37:08Z"
        }
      ]
    },
    {
      "number": 582,
      "id": "MDU6SXNzdWU2MTg5Mzc5ODU=",
      "title": "sh-param-list does not exist in draft-ietf-httpbis-header-structure-18",
      "url": "https://github.com/WICG/webpackage/issues/582",
      "state": "OPEN",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-15T12:39:46Z",
      "updatedAt": "2020-05-21T20:20:13Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks for the ping. I think I last updated the use of structured headers to match -10, so it's not surprising that it doesn't match anymore.",
          "createdAt": "2020-05-21T20:20:13Z",
          "updatedAt": "2020-05-21T20:20:13Z"
        }
      ]
    },
    {
      "number": 583,
      "id": "MDU6SXNzdWU2MzUxOTE4NzI=",
      "title": "Bundled subresource origins.",
      "url": "https://github.com/WICG/webpackage/issues/583",
      "state": "OPEN",
      "author": "mikewest",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "Following on a conversation in  https://chromium-review.googlesource.com/c/chromium/src/+/2226248, I'd like to understand where y'all are coming down on the origins of subresources from unsigned bundles. From conversations with @kinu and team, I'd understood that unsigned packages directly delivered from `https://example.com/` would contain resources that all acted as though they were delivered from `https://example.com/`, and packages whose provenance was indeterminate would be treated as having opaque origins.\r\n\r\nThe scheme proposed in https://github.com/WICG/webpackage/blob/master/explainers/navigation-to-unsigned-bundles.md#urls-for-bundle-components is quite a bit more complicated, both in terms of parsing, and in meaning. My understanding is that it aims to give a persistent origin to resources in the bundle that's distinct from the entity that delivered the bundle. Can you help me understand the benefits of that model so we can weigh them against the complexity it introduces?\r\n\r\n",
      "createdAt": "2020-06-09T07:45:18Z",
      "updatedAt": "2020-10-22T21:30:14Z",
      "closedAt": null,
      "comments": [
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "(For a bit more context: splitting the origin based on the distributor and the declared origin of a given resource reminds me a lot of https://w3c.github.io/webappsec-suborigins/. If we're going to create such a thing, I'd like for us not to do it accidentally, but to build it out in a way that's workable for more than packages. /cc @arturjanc)",
          "createdAt": "2020-06-09T07:47:38Z",
          "updatedAt": "2020-06-09T07:47:38Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think your new understanding matches what I'm hoping to do, and you're right that this is a [new way to get suborigins](https://github.com/WICG/webpackage/blob/master/explainers/navigation-to-unsigned-bundles.md#process-of-loading-a-bundle). Your original thought that maybe these should only hold resources on the origin that delivered the package match @annevk's comments and some questions in the [TAG review](https://github.com/w3ctag/design-reviews/issues/509).\r\n\r\nhttps://docs.google.com/document/d/1BYQEi8xkXDAg9lxm3PaoMzEutuQAZi1r8Y0pLaFJQoo/edit#heading=h.wwozqa5gouqp and #498 mention some use cases for using a non-opaque origin: in general if the package contains anything more interesting than a static HTML file, it ought to have some non-ephemeral storage.",
          "createdAt": "2020-06-10T20:13:22Z",
          "updatedAt": "2020-06-10T20:13:22Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me clarify my understanding.\r\n\r\nIf we use non-special, non-generic URLs without `//` such as `package:https:,,distributor.example,package.wbn;q=query$https:,,otherpublisher.example/page.html?q=query`, this URLs don't have authority component as @sleevi [commented](https://chromium-review.googlesource.com/c/chromium/src/+/2226248/7#message-0a3efda5aff84770a1729422a5b26aeca3ee4e80). So [1] we can't have any storage for the URL. [2] There is no way to safely communicate within the pages in the same package. (Using postMessage() without any authority (origin) check may be possible but it is dangerous.) [3] And also `new Worker('worker.js')` will fail because the page and worker.js can't be in the same authority (origin).\r\n\r\nCurrently Chrome (with chrome://flags/#web-bundles enabled) loads local file web bundles [using file: scheme](https://chromium.googlesource.com/chromium/src/+/8878baa236d4dbb3dc2ebb565670dc7c301a4088/content/browser/web_package/using_web_bundles.md#Dealing-with-Common-Problems-in-Unsigned-Bundles). [1] We can use some storage APIs under file: scheme now. But this is not an ideal behavior because the storages are shared by all pages under file: scheme ([crbug.com/794098](https://crbug.com/794098)). And both [2][3] limitations exist in the file: scheme. I would be happy if we can also solve these limitations with the new URL scheme.",
          "createdAt": "2020-06-11T07:58:07Z",
          "updatedAt": "2020-06-11T07:58:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@horo-t An \"authority\" isn't the same thing as an \"origin\". For example, [`blob:` URLs](https://w3c.github.io/FileAPI/#blob-url) have no authority, but there's still an [algorithm to assign them an origin](https://url.spec.whatwg.org/#origin).\r\n\r\nWe'll patch the definition of origins to say that for a `package:` URL `package:https:,,distributor.example,package.wbn;q=query$https:,,otherpublisher.example/page.html?q=query`, the origin is (`package`, `https:,,distributor.example,package.wbn;q=query$https:,,otherpublisher.example`, null, null), where the big string is an [opaque host](https://url.spec.whatwg.org/#opaque-host).",
          "createdAt": "2020-06-11T18:19:55Z",
          "updatedAt": "2020-06-11T18:19:55Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Ah, now I understood. Thank you for the explanation.",
          "createdAt": "2020-06-12T04:16:24Z",
          "updatedAt": "2020-06-12T04:16:24Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "I have a few concerns with this scheme, especially for unsigned bundles (I haven't thought through this as much as y'all obviously have, so apologies if I retread ground that you've already been over and over). In no particular order:\r\n\r\n1.  In the `package:` scheme discussed above, it's not clear to me which portions of the origin are controlled by the bundle, and which the browser verifies. In the case in which the browser downloads a bundle directly from `https://distributor/bundle.wbn`, I'm assuming that the browser is responsible for that part of the origin, and the bundle itself contains resources that make assertions about their own ostensible URLs, which form the other part of the origin? Or does the bundle contain an independent assertion of provenance?\r\n\r\n    What happens if that bundle is downloaded for offline use? Does the browser stamp it in some way with the URL from which it was downloaded, which is then used in origin calculations going forward? Does the origin shift to treat `file://~/Downloads/bundle.wbn` as the initial part of the origin (and thereby both lose access to the initial data stored in the initial `(https://distributor/bundle.wbn, ...)` origin (note that I separately would love to remove privileges like storage from `file:` URLs))?\r\n\r\n2.  However we answer the question above, the `package` origin described above contains the bundle's full path. That information will be directly exposed in a few places, both to the page directly (`window.origin`), and to other servers (`Origin` header for CORS/WebSocket handshakes, `postMessage`'s `event.origin`, etc.). It seems like that will have privacy implications, as we're moving away from exposing path information by default in `referer` (see w3c/referrer-policy#124 and w3c/referrer-policy#125, along with various vendors' independent experiments).\r\n\r\n3.  It will probably surprise no one to learn that I don't think non-secure contexts should have storage in the long term. https://github.com/mikewest/scheming-cookies will (I hope!) start us down the road of removing storage from unauthenticated/unencrypted contexts entirely, with a time-based carveout for existing devices/sites that are unable or unwilling to upgrade. It's not clear to me that we should consider unsigned bundles to be secure contexts, given that they're not signed.\r\n\r\n    If we know that the bundle was delivered securely from `https://distributor/` (because, for example, we just downloaded it), then there's a reasonable justification to tie its origin to the origin that sent us the bundle, just as we would for an HTML document delivered over the same connection. A suborigin-like scheme to tighten the scope of that bundle's origin to something distinct from the distributor itself seems reasonable to explore, as the bundled content is likely not authored by that origin.\r\n\r\n    I'm less convinced of that justification in the case of an unsigned bundle the browser just found lying around somewhere. Because the bundle is unsigned, the assertions it makes about its provenance and contents are untrustworthy. It seems like this would eventually lead to leakage of data between bundles authored by distinct parties (B builds a package that asserts to be delivered by A), which seems bad.\r\n\r\n4.  Have you considered how we'd render the origin in browser-generated contexts? The address bar representation, permission prompts, modals like `alert()`, page info dialogs, site data settings pages, etc. all seem hard.\r\n\r\n5.  Is there a \"site\" concept to speak of for `package:` domains? I'm wondering how things like cookies, `document.domain`, HSTS' `includeSubdomains`, and so on will work for the hosts asserted by resources in the bundle (and for the distributor).\r\n\r\nI think it's possible to find reasonable answers to the above, and I would like to support the kinds of use cases documented in the links above. I worry, though, that folks really do want something more powerful than the harmless \"storing a list of quizzes/games which have already been done so that it doesn\u2019t reset every time you open the publication\" use cases that seem reasonable to want to support even for unsigned bundles. Someone, somewhere, has a great idea for an amazing, totally-off-the-grid bitcoin wallet or something, and this is going to look like a great fit. It doesn't seem to me that we can make the kinds of guarantees around storage isolation in these packages that we can make with signed packages, and it may be dangerous to pretend that we can.",
          "createdAt": "2020-06-16T06:44:17Z",
          "updatedAt": "2020-06-16T06:44:17Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md hopefully answers the questions above. Specifically:\r\n\r\n1. In `package:bundle-url$claimed-url`, the browser verifies the `bundle-url` part, and the contents of the bundle provide the `claimed-url`. If the bundle is downloaded for offline use, by default it has a new origin and no access to the old storage, but #588 adds a couple options for how to keep the old storage. As you pointed out, just using the Mark Of The Web is vulnerable to malicious SD cards.\r\n\r\n2. [Within a single bundle, we should present only the claimed URL.](https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md#same-bundle-introspection ) Outside of the bundle, we should apply the referrer policy to both the [origin](https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md#origins) and [referrer](https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md#referer-headers) information in order to strip unwanted bundle-path information out of the presented subresource origin. I *think* those don't conflict in bad ways, but it's possible I'm wrong.\r\n\r\n3. Bundles on a local filesystem satisfy the \"secure context\" criterion of \"being able to explain to a user where the bytes came from\", so I think that doesn't exclude them from getting storage. There's the general move to remove capabilities from `file:` URLs, but bundles remove some of the problems that raw files have, so maybe it's more acceptable for them to keep capabilities.\r\n\r\n4. I've written down thoughts on [URL rendering](https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md#rendering-the-url-bar) and [permission prompts](https://github.com/WICG/webpackage/blob/master/explainers/bundle-urls-and-origins.md#permissions). I'm not certain they're good thoughts. :)\r\n\r\n5. I think sites would be groups of claimed URLs with matching domains within a single bundle. This may interact badly with anti-tracking restrictions, for which we might want to allow communication between a site and its bundles. The new \"party\" concept in First-Party-Sets might help with this. My uncertainty here isn't yet described in the explainer.",
          "createdAt": "2020-07-10T21:59:20Z",
          "updatedAt": "2020-07-10T21:59:20Z"
        }
      ]
    },
    {
      "number": 585,
      "id": "MDU6SXNzdWU2NDMwNjQ0MjA=",
      "title": "Demote `validity-url` to optional",
      "url": "https://github.com/WICG/webpackage/issues/585",
      "state": "OPEN",
      "author": "tomokinat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "`validity-url` has many good aspects as mentioned in the spec and as we do know, but it is usually hard to manage them in a very disciplined manner at scale. Ultimately there's one `validity-url` per SXG, and even if not we still need a kind of solid system to handle `validity-url`s to take real advantages of them. After all what we see today are publishers having only one `validity-url` which returns an empty CBOR map:\r\n\r\namppackager: \r\nhttps://github.com/ampproject/amppackager/blob/bf061bede4b0280654c25b19fc3cc34e25d13cf0/packager/validitymap/validitymap.go#L31\r\n\r\nreddit:\r\n```\r\n$ curl -s 'https://amp.reddit.com/amppkg/validity' | hexdump -C\r\n```\r\n\r\n```\r\n00000000  a0                                                |.|\r\n00000001\r\n```\r\n\r\nEven after SXGs infiltrated there might be a non-trivial amount of publishers doing like this. This would simply be a burden to publishers and especially to browsers as they make one extra fetch which essentially does nothing.\r\n\r\nIt'd be awesome if there's a way to explicitly and officially tell \"we don't serve any validity for this SXG\" to avoid these extra work.",
      "createdAt": "2020-06-22T13:17:55Z",
      "updatedAt": "2020-06-22T13:17:55Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 589,
      "id": "MDU6SXNzdWU2NjI5OTcyMTA=",
      "title": "Efficient incremental bundle updates",
      "url": "https://github.com/WICG/webpackage/issues/589",
      "state": "OPEN",
      "author": "quasicomputational",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Nice-to-have use-case: Serving a bundle of many pages for offline use. Think, e.g., downloading a large slice of Wikipedia.\r\n\r\nAssociated requirement: Updating bundles without needing to re-write the entire bundle, so that (e.g.) a single 100 kB response changing, being added or deleted doesn't result in needing to also re-write the 10 GB of 100,000 unchanged responses.\r\n\r\nNon-goal: Updating only part of a single large response incrementally.\r\n\r\nThe alternative is to accept that updating a bundle can't be done incrementally; presumably the work-around would be to instead serve many bundles that are small enough that re-writing them isn't painful, and instead suffer the pain of dealing with many bundles instead of just one. Even in that case, I'd like to see the use case & requirement written down as something that was explicitly declined as part of a trade-off, rather than just not considered.\r\n\r\nThis is *almost* supported by the spec as is, but blocked by two things: first, how the index can't be placed last in the stream (because the responses section must be the last); and, second, CBOR does not allow padding around responses (though the spec, as written, doesn't break if padding is added - the section is never parsed as CBOR and finding responses is all done with offsets).\r\n\r\nIf I squint and imagine that these are non-issues, to create an incrementally-updatable bundle, place the index section after the responses section, and make sure that the section lengths are written as bignums with plenty of leading bits; to update the bundle append the new responses to the end of the responses section and then append the new index section and re-write lengths/offsets as needed.\r\n\r\nThere's a security consideration here, though: the above procedue will leave old responses in the bundle, which could be an information leak. Zeroing redundant responses out is a partial solution, but still leaks response length; aligning responses to, e.g., 1 KiB boundaries would reduce the length leak. The need for padding would also mean that a bundle wouldn't be a valid CBOR document.\r\n\r\nThe updater could keep track of zeroed-out ranges and opportunistically place new responses there, but a dumber append-only strategy should work pretty well in most situations, trading implementation simplicity & reduced state for (uncompressed) bundle size.\r\n\r\nImplementations might also get clever with opportunistic use of sparse files, so there should be at least a SHOULD on using zero bytes specifically to enable that.\r\n",
      "createdAt": "2020-07-21T13:03:58Z",
      "updatedAt": "2021-02-15T23:59:55Z",
      "closedAt": null,
      "comments": [
        {
          "author": "EternityForest",
          "authorAssociation": "NONE",
          "body": "If it were up to me, everything would probably be using SQLite3 for exactly this reason.\r\n\r\nOne really nice benefit to this is that P2P becomes possible.\r\n\r\nImagine that every record in a bundle has both a modification time, and a local modifications time that tracks when that particular node received the new record.\r\n\r\nA sync tool can then be designed (Which doesn't need to be part of the official spec at all) which asks \"Have you got any updates since last I checked?\".\r\n\r\nMeaning that caching proxies become a whole lot more standardized and easy to set up.   This would have huge benefits for Linux package management.",
          "createdAt": "2021-02-15T23:59:55Z",
          "updatedAt": "2021-02-15T23:59:55Z"
        }
      ]
    },
    {
      "number": 590,
      "id": "MDU6SXNzdWU2NjQ4ODM5NjM=",
      "title": "Primary URL for Bundle Subresources",
      "url": "https://github.com/WICG/webpackage/issues/590",
      "state": "OPEN",
      "author": "Jxck",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "In case of Bundle Subresources, what is correct value for primaryURL ?",
      "createdAt": "2020-07-24T03:00:54Z",
      "updatedAt": "2020-07-27T10:55:11Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@horo-t was suggesting that we ought not to require a primaryURL when a bundle's being used to preload subresources.",
          "createdAt": "2020-07-27T10:55:00Z",
          "updatedAt": "2020-07-27T10:55:00Z"
        }
      ]
    },
    {
      "number": 594,
      "id": "MDU6SXNzdWU2ODk3OTU4Nzk=",
      "title": "Ensure bundling subresources doesn't cost extra bandwidth",
      "url": "https://github.com/WICG/webpackage/issues/594",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "In #551, @briankanderson and @kuro68k worried that once folks are putting their subresources in bundles, it will be more difficult for browsers or extensions to avoid transferring a subset of those resources in order to save time or money. For example, browsers' \"disable images\" and \"disable javascript\" options should be able to block just those kinds of subresources without preventing the enabled kinds of subresources from loading. It sounds like there are also kinds of resources beyond \"all scripts\" that folks on satellite links want to block, although \"ads\" is adequately covered by #551.\r\n\r\nSome of @yoavweiss' ideas around having the browser express which resources are already cached, and having the server adaptively generate a subset of the bundle, could be helpful here, but\r\n1. We have to make sure the default is good even for servers that can't dynamically subset bundles, and\r\n2. I think we need more information than just the list of resource URLs. Maybe we also provide the `preload` `as` value?",
      "createdAt": "2020-09-01T04:22:54Z",
      "updatedAt": "2020-10-23T00:19:31Z",
      "closedAt": null,
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there are 2 separate cases here. There's \"bundles as a way to optimize subresource delivery\" and \"bundles as a way to deliver whole sites\".\r\nI think this problem may be more related to the former.\r\n\r\nWhen using bundles as an optimization, we could encourage (and maybe even enforce) that subresources would be for a certain destination (e.g. using an \"as\" attribute), so that if they need to be blocked based on their type, the browser can easily do that. Similarly, the browser would be able to block individual resources based on their URL (using the \"resources\" attribute).\r\nWhile the latter bit would only work for dynamic servers, the former would work for static ones as well.\r\n\r\nAll this falls apart when we want to deliver full applications in web bundles, as we'd now need both an `as` attribute *per-resource* and a dynamic server.\r\n\r\nSo I guess my question is: is it enough to cover the \"subresource optimization\" case? Or do we need to cover the \"app delivery\" case as well? And if we need to cover both, are we willing to take an RTT hit for the latter?",
          "createdAt": "2020-09-01T04:34:31Z",
          "updatedAt": "2020-09-01T04:34:31Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "Even one bundle per resource type wouldn't really help because the site operator will likely bundle all the images that get blocked anyway. Not just ads, some browsers/add-ons block images over a certain size (say 50k bytes).\r\n\r\nThe only way this can be mitigated is if the browser is presented with a complete manifest of all resources with enough detail to decide which ones it wants, and then the bundle is dynamically generated based on its decision.",
          "createdAt": "2020-09-01T08:28:46Z",
          "updatedAt": "2020-09-01T08:28:46Z"
        },
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes, this could be an option. Another option (a short term one): disable WBN support if any of the \"don't load resource of type X\" is enabled.\r\n\r\n@kuro68k do you have examples for the \"add-ons blocking images over a certain size\"? I'm wondering how it's done in practice.\r\n\r\nFor the \"app delivery\" scenario, I'm wondering if this could be based on client-hints. @yoavweiss is that what you had in mind given the \"one extra RTT\" hint?",
          "createdAt": "2020-09-01T09:30:07Z",
          "updatedAt": "2020-09-01T09:30:07Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "@KenjiBaheux uBlock Origin supports blocking all resources over X bytes.\r\n\r\nThere are other dangers here, e.g. if the browser says \"don't bother sending that ad image\" the site could refuse to let the user view other content. It's possible to do now but usually implemented in Javascript where it can be blocked, while this makes having the server do it much easier.",
          "createdAt": "2020-09-01T09:39:01Z",
          "updatedAt": "2020-09-01T09:39:01Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "> @KenjiBaheux uBlock Origin supports blocking all resources over X bytes.\r\n\r\nI'm curious how they do that technically. The browser is not aware of the size of the resources it is about to download until they are downloaded, and in many cases (e.g. resources without content length) exceeding said quota.\r\n\r\nOtherwise, it seems rather unsafe to apply that to no-cors fetched cross-origin resources, as that can reveal information about the user's state. See [my talk](https://youtu.be/xVtli3mmBc4?t=1092) about this for more details.",
          "createdAt": "2020-09-01T12:51:22Z",
          "updatedAt": "2020-09-01T12:51:22Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "> > @KenjiBaheux uBlock Origin supports blocking all resources over X bytes.\r\n> \r\n> I'm curious how they do that technically. The browser is not aware of the size of the resources it is about to download until they are downloaded, and in many cases (e.g. resources without content length) exceeding said quota.\r\n> \r\n> Otherwise, it seems rather unsafe to apply that to no-cors fetched cross-origin resources, as that can reveal information about the user's state. See [my talk](https://youtu.be/xVtli3mmBc4?t=1092) about this for more details.\r\n\r\nAccording to the [documentation ](https://github.com/gorhill/uBlock/wiki/Per-site-switches#no-large-media-elements)it does contact the server to fetch the size of the object, it just then doesn't download it if it exceeds the threshold.",
          "createdAt": "2020-09-01T13:48:29Z",
          "updatedAt": "2020-09-01T13:48:29Z"
        },
        {
          "author": "jjdelc",
          "authorAssociation": "NONE",
          "body": "Serving an all or nothing bundle of a site would break many of important HTML bw saving features, for example\r\n\r\n* How does this play at all with the `img` tag's `loading=lazy` attribute?\r\n* In the case of responsive images, which one should be downloaded? or all of them?\r\n* What about file format support? The `<video>` tag that could provide multiple format sources depending on the browser's support, mp4, webm, av1\r\n* How does this affect browser caching for resources between pages. All bundles need to ship all its deps everytime, rendering etags, expire headers useless and all those smarts useless.\r\n* On top of the client's bandwidth, this seems to also increase the server's bandwidth if resources need to be uploaded on every page that the client requests? `article_a.html`, `article_b.html`",
          "createdAt": "2020-09-20T05:21:01Z",
          "updatedAt": "2020-09-20T05:21:01Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "A bundle doesn't *have* to include all of the site's resources.\r\n\r\n\r\n\r\n> * How does this play at all with the `img` tag's `loading=lazy` attribute?\r\n\r\nOne can imagine a bundle excluding all out-of-viewport images, or adding them to the end of it, if an offline scenario is likely.\r\n\r\n\r\n> * In the case of responsive images, which one should be downloaded? or all of them?\r\n\r\nOne can imagine Client Hints being used to subset non-required media on the server side.\r\n\r\n\r\n\r\n> * What about file format support? The `<video>` tag that could provide multiple format sources depending on the browser's support, mp4, webm, av1\r\n\r\nContent negotiation (e.g. the `Accept` header) can be used to subset unneeded file formats.\r\n\r\n\r\n> * How does this affect browser caching for resources between pages. All bundles need to ship all its deps everytime, rendering etags, expire headers useless and all those smarts useless.\r\n\r\nSee https://docs.google.com/document/d/11t4Ix2bvF1_ZCV9HKfafGfWu82zbOD7aUhZ_FyDAgmA/edit# for a proposal on that front.\r\n\r\n\r\n\r\n> * On top of the client's bandwidth, this seems to also increase the server's bandwidth if resources need to be uploaded on every page that the client requests? `article_a.html`, `article_b.html`\r\n\r\nI'm not sure I get your point here.",
          "createdAt": "2020-09-21T06:28:53Z",
          "updatedAt": "2020-09-21T06:28:53Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "Does it seem at all likely that sites will generate a custom bundle for every browser request based on what specific resources that browser would like to receive? And if so will it end up being any better than not using a bundle?\r\n\r\nAs it stands it looks likely that any kind of content filtering system (ad blocker, privacy settings in the browser, disabling auto-play videos, bandwidth saving proxies or disabling large object downloading in browser settings etc.) will require completely disabling the use of bundles.\r\n\r\nFurthermore they break one of the most fundamental concepts of the World Wide Web: that the client is responsible for selecting resources and displaying them as the user desires. It gives control of the user's software, of their network connection, to the server operator which requires a level of trust that many users are unwilling to give, even before considering the cost and bandwidth ramifications.",
          "createdAt": "2020-09-21T07:52:47Z",
          "updatedAt": "2020-09-21T07:52:47Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "You seem to be assuming that the main and only use of bundles is sending the entire contents of the site with them. I don't think that's an accurate assumption.\r\n",
          "createdAt": "2020-09-21T07:56:04Z",
          "updatedAt": "2020-09-21T07:56:04Z"
        },
        {
          "author": "kuro68k",
          "authorAssociation": "NONE",
          "body": "No such assumption, but in any case the onus is on those promoting this idea to demonstrate that it won't cause these kinds of issues and so far nobody has proposed a solution that allows for the current level of fine-grained control that browsers have.",
          "createdAt": "2020-09-21T08:14:34Z",
          "updatedAt": "2020-09-21T08:14:34Z"
        },
        {
          "author": "jjdelc",
          "authorAssociation": "NONE",
          "body": "> I'm not sure I get your point here.\r\n\r\nFor the server's case, if they need to serve the bundle for say all articles, they would need to serve the same CSS/JS/Imgs files every time when the browser can have them cached. Increasing server's bandwidth consumption.\r\n\r\nI read the GDoc linked, it looks like a lot of dynamic machinery is needed to generate on the fly bundles according to each of the cached states the client could be in. It starts to look a lot like a more complex version of HTTP2 with pipelining. \r\n\r\nBy having the bundles being dynamic it sounds like the idea of being able to have a neat bundle weakens, would this be a HTTP server plugin? ",
          "createdAt": "2020-09-22T01:25:41Z",
          "updatedAt": "2020-09-22T01:25:41Z"
        }
      ]
    },
    {
      "number": 595,
      "id": "MDU6SXNzdWU2ODk4MTE2NzA=",
      "title": "signature should be first",
      "url": "https://github.com/WICG/webpackage/issues/595",
      "state": "CLOSED",
      "author": "shynome",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "If we have signature, we can generate a namespace from signature, then we can use history api and IndexedDB when we are offline.\r\nBut how to combine the online website and the offline wbn data store?  I have a resolution, add a new http header let the website  tell browser it wether like using the wbn resources, if response has the http header like `wbn-signature: /.well-know/my-website-signature?version=20200502`, hold doucument parse, let's get the signature firstly then create or bind the exist namespace and the website domain, if the wbn version is not the same browser get resources from the website, if the wbn version is the same use the wbn exist resources. Maybe the wbn version as a new http header is better",
      "createdAt": "2020-09-01T05:02:57Z",
      "updatedAt": "2020-09-01T05:56:09Z",
      "closedAt": "2020-09-01T05:56:09Z",
      "comments": []
    },
    {
      "number": 596,
      "id": "MDU6SXNzdWU2OTQzNzc4NDQ=",
      "title": "I want some of files in bundle be serverd external, does Web Bundle currently support this?",
      "url": "https://github.com/WICG/webpackage/issues/596",
      "state": "OPEN",
      "author": "chenzx",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I'm writing a tech demo for AIoT scene: cloud server transfers a single-page web app in a bundle file(which i'm considering use Webpack tool to do this package work) to a edge-side gateway/broker, who then serve the web app to user's mobile phone.\r\n\r\nMy current requirements: some of files in bundle is already in my demo's runtime which is pre-installed in IoT devices, and some is very-BIG binary tensorflow.js model files which may be served via external URLs, i guess webpackage spec. can specify them as `external`?",
      "createdAt": "2020-09-06T13:16:18Z",
      "updatedAt": "2020-09-09T18:57:57Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The resources inside a bundle can refer to resources outside of the bundle just using those resources' URLs. There's been some discussion of blocking external access from bundles that are being loaded from offline URLs (like `file:`), but I don't think there's a reason to do that for bundles that were themselves loaded over the internet.\r\n\r\nWe've also talked a bit about \"external\" dependencies, which would be mentioned in the bundle's metadata, and if the bundle is actually a signed package, might have their versions included in the top-level signatures. I haven't thought much about what that should look like, and it doesn't sound like you need it.",
          "createdAt": "2020-09-09T18:57:56Z",
          "updatedAt": "2020-09-09T18:57:56Z"
        }
      ]
    },
    {
      "number": 597,
      "id": "MDU6SXNzdWU2OTYyMDA1NzI=",
      "title": "7 day SXG expiration? Why?",
      "url": "https://github.com/WICG/webpackage/issues/597",
      "state": "OPEN",
      "author": "rektide",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "Hello. One of my core interests in webpackage is to allow offline use cases. For example, I think of the [100 rabbits](https://100r.co/site/about_us.html) interactive creative design team. They sail around the world, & sometimes make multiple week crossings. I had hoped WebBundles would make using web systems valid for these sorts of trips, & it felt confirmed when I saw that the use case document contained [offline browsing](https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-offline-browsing) as a primary objective.\r\n\r\nTo my chagrin, I recent read that there appears to be an arbitrary [7 day](https://github.com/WICG/webpackage/blame/bfd16402098add7dd5b39e99f7baac1d15407f73/draft-yasskin-httpbis-origin-signed-exchanges-impl.md#L443) limit after which Signed HTTP Exchanges (SXG) will return as \"invalid\". And that is from the time of signing, not the time of downloading. This short expiration window very much calls into question whether or not webpackage/webbundles signed exchanges support the offline browsing use case.\r\n\r\n## 1. \u231b\ud83d\udca3\r\n\r\n> the offline ticking time bomb\r\n\r\nLet's talk further to the sailing model. One day you are sailing the sea, looking at your offline charting webpage, and the next day you wake up and all of a sudden the browser & page you are relying on to get you to land have decided that the signed http exchanges they rely upon are now no longer valid, and your page no longer can access the offline resources you both expected it to read. This is an extreme hazard, introduced by dual problems of lack of awareness to this ticking self-destruct clock, & an extremely fickle & short fuse before offline content reaches this self-destruction. Hikers, travelers, boaters, spacemen, disaster-survivors, & other perhaps connection-starved folk will all be enormously encumbered by this short self-destruction fuse that burns within their browser.\r\n\r\nThis problem is particularly pernicious for those with inconsistent connectivity. If you live somewhere that experience multi-day internet or power outages a couple times a year, the chance for SXG to be able to help you is highly questionable, & dependent all too much on how recently you happened to visit a site. For example if you read novels in, say for example, a Project Gutenberg offline book reader, but hadn't opened the site in 4 days, and you lose power, you will very quickly lose the ability to access or [share](https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-save-and-share-a-web-page) the books you thought you were carrying with you. You couldn't predict or guess when you might need to re-download your content (unchanged for hundreds of years but requiring a re-download none-the-less, to freshen the SXG signature date) with new signatures.\r\n\r\nIn the ideal case, If I refresh my content (say it's a lengthy download), go to sleep (while the download runs), wake up & hop on a 12 hour flight, and the sys-op did everything in their power to give me as much time as possible, I've already potentially used up 15%+ of my offline time granted by SXG's remarkably short self-destruct fuse before I land. This is the ideal scenario, fully planned ahead of time, the best case.\r\n\r\n## 2. \u27f3\u221e\r\n\r\n> the fear-driven never-ending redownload cycle trap\r\n\r\n[+4 hours edit: I was not aware signatures could be updated, which resolves the download-cost. I am relieved to hear this. I do still have reservations about the user-cost of maintaining fresh data, that we will be driving people to a behavior that makes them compulsively connect & update. And I feel like there are anti-user privacy aspects that are highly concerning lurking here.]\r\n\r\nThe case of losing internet access unexpectedly highlights a problem even bigger & worse than than content unavailability: we are trapping the user in an endless cycle of redownloading content, creating a sense of fear that the content they choose to bring with them is forever only days away from expiring.\r\n\r\nUsing service-workers, a user might safely read a book at their leisure. But with SXG, a user now has a new expectation for their web experience, that they can share their content too. Alas, to do so, they must continually re-download content. Not just 52 times a year, once a week, when the content expires, but ahead of time, so that if they do want to share the book they are reading, the band website they are enjoying, they can give those they are sharing a gift that will last as long as possible before it self destructs. Rather than freeing users from connectivity, we have now created a new cycle that insists we regularly reconnect & refresh, generating enormous fear that the content we cherish most is ever expiring, that we must re-download, or face negative consequences, find ourselves stripped of this new ability that they have grown to enjoy.\r\n\r\nThis is so striking, so remarkable an end scenario for the current version of SXG. The very users most in need, with fickle or periodic connectivity & likely also costly connections, who we claimed to be helping, are now instead bound into a vicious cycle of continually re-downloading the same content regularly that, pre-WebBundles, they could rely on to be cached, in order to enjoy the ability to share content.\r\n\r\n## 3. \ud83d\udca2\ud83d\udcbb\r\n\r\n> radically increased demands on small operators\r\n\r\n[+4 hours edit: i had missed/forgotten that sxg is not required for a SecureContext-approved WebBundle, which makes sxg \"voluntary\", albeit still a thing i think most users will i believe want. none the less, it is not in the critical stream for operators: i continue to wish small/indie operators had a less demanding time-scale to operate sxg on, but my alarm here is significantly less than the already fairly-mild concern i originally felt.]\r\n\r\nMy third concern is for operators. Outside of all offline concerns, WebBundles are also a tool for [bundling](https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-building-packages-from-mult) and uh [bundling](https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-subresource-bundling). This fills a desperately needed hole in the JS ecosystem in particular, where EcmaScript 6 / EcmaScript-2015 modules have been the official language specification, but there has been no way to get many modules to a browser ([effectively](https://blog.khanacademy.org/forgo-js-packaging-not-so-fast/) short of rewriting EcmaScript modules into something different & not modules.\r\n\r\nTo this end, we have created tools like Browserify & Webpackage, which perform long complex operations to convert our sea of EcmaScript modules into concatenated non-module JS, such that they can be shipped effectively & with 'cross-file' compression.\r\n\r\nWebBundles use-cases talk about these bundling concerns, describing these needs & desires. And the hope of many is that has been the WebBundle would free us from these complex & obfuscating machines, & give us a path to enjoy transporting bundled JS modules without weighty transpilation that turns these modules we coders & webmasters work with every day into not-modules that when run behave very much alike modules but which are something completely different, supported by their own purpose built execution systems outside of the browser's own module loading & running systems. Which sounds wonderful, like exactly the answer we've been desperately looking for: finally, it sounds like we can actually directly bring EcmaScript modules on to the web.\r\n\r\nExcept for the operational disadvantages. Historically these bundlers could produce static bundles that could be served easily & readily. Now, with this new 7 day expiration, instead of building a site, & publishing it, operators have to either rebuild their bundles regularly with freshened signatures, or hand over their private keys to webhosts that will rebuild the signatures for them.\r\n\r\nAt a minimum, this means rebuilding your bundles every 7 days. That alone imposes a great burden on those who enjoy \"static\" websites, something web operators used to be able to create & publish & forget about. But a weekly cron job to rebundle is not the end of the story for operators. If an operator wants to allow users to share the website, then it's up to the operator to regenerate the cycle more frequently, such that the expiration date remains 7 days in the future even as time passes.\r\n\r\nI see no reason why the operators should have to face such sharply increased demands to continue serving content as they switch from WebPack to WebBundles. In many cases, I fear small websites will opt to turn over their most treasured most private keys to external operators, to offload the complexity, at great cost of the privacy & security of their own site, which they now no longer retain cryptographic responsibility for. This seems like a deep regression for the web as a whole, and one that a much longer expiration would radically ease.\r\n\r\n---\r\n\r\nHow and where did this 7 day expiration arrive in the spec? What justifies this?\r\n\r\nOn three accounts, this fantastically short expiration seems like a dangerous & arbitrary limitation. In the first of scenario, offline users are suddenly being cut off, frozen, after a short window, from the offline content that kept them from being dashed into rocks or left adrift at sea. In the second scenario, far more prevalent, many users, in fact the most vulnerable & needing of robust offline access users, become addicted to a tragic tragic & enormously costly & energy-intensive never-ending ceaseless-redownloading cycle that they can never escape from, a- and I'm serious here- new technocratic limitation introduced to the web that feeds a vicious cycle of addiction & need & want & overall fear of the computing world. In the 3rd case, we see enormous operational complexity introduced to being & remaining on the web, particularly cumbersome to smaller websites that have enjoyed static hosting for decades & who now have to check their cron jobs at a minimum 52 times a year. I've known there was an expiration in webbundles, but you know: I always assumed it was reasonable. All three of these scenarios seem like critically unhealthy & short scenarios that users & sites will face with great pain on a regular & day to day time-frame imposed by the day-to-day time-scale of this 7 day expiration.\r\n\r\nI do not feel safe at all describing webbundles or SXG as an offline browsing technology under these conditions. If operators wish to make content available longer, let them. If users wish to not keep content as long as an operator allows, let them. Yes, it would be good for sites to be able to freshen themselves, to not rely on aged content, but a short expiration does not seem like the appropriate way to enable that. I am terrified to know what answers might come, because I am not prepared to accept any counter-reply to issue #2 the redownload trap in particular, but I must ask: why? Why so short? This seems outright cruel to all involved; why would we not want a user to be able to offline browse a site a month latter, or even a year latter, if no other options are available & on hand for the user to turn to & the certificate chain is good & the content sits there on their drives or on a flash drive nearby? Surely we can [act in the interest of the user here](https://www.rfc-editor.org/rfc/rfc8890.html), help them to continue to benefit from the use of their assets, for as long as the signing certificate chain is good for, versus leaving them with no alternatives & without?\r\n\r\nAs a small indie systems operator I had hoped for WebBundles to help reduce some of my systems operating complexity by letting me package my JS modules effectively, but the price has become radically higher with these very short-lived expirations. But far more so, discovering this critically short expiration leaves me in a state of critical mourning for the user, the user I thought we were about to be helping. The offline use cases seem not merely weakened, but so unreliable & short as to be an anti pattern, as to be actively dangerous to folks wishing to use offline web systems. But a system that forces ongoing regular multiple-times-a-week re-downloading to enjoy the benefits of knowing that you can keep or share the data you want, that is meaningful to you, actively enslaves & degrades the human spirit in unconscionable ways, and which will radically penalize the less connected folks of this earth who could otherwise best & most truly benefit from this technology.\r\n\r\nTechnology should have our back. It should permit, allow, enable. This expiration sets a time horizon forever near at hand, forever a trap we must watch ready to spring shut on us.\r\n\r\n---\r\n\r\nI have been radically hopeful that an offline web where we don't need regular connectivity could come. I have hoped we could simplify the experience of sites by giving them good systems to ship modules without mangling. For these reasons, I have been a longstanding avid fan & supporter of webbundles, deep in my heart, & in countless places online ([recently](https://news.ycombinator.com/item?id=24391321)). Webbundles has been an endless source of inspiration that the future is about to get radically better, and I have believed fully in the use cases & webbundles ability to serve them.\r\n\r\nThis one constraint though, it has me falling apart completely. I am shattered. I have tried to maintain some distance from my opinions above, but in purely my own humble opinion, forgive me, I intend no personal injury nor attack, but my assessment is that with this present 7 day expiration, \ud83c\udf10\ud83d\udce6 is grossly antithetical to the web, to sites, & to, most of all & our shared greatest concern so say we all, the user. I beg, even a month is scant time when the clock is ticking. I would like us to better \ud83c\udfc4 the offline \ud83c\udf10 together, for longer, much longer.",
      "createdAt": "2020-09-08T21:50:42Z",
      "updatedAt": "2021-02-16T10:01:21Z",
      "closedAt": null,
      "comments": [
        {
          "author": "dauwhe",
          "authorAssociation": "NONE",
          "body": "Why do you need signed exchanges? A bundle of unsigned exchanges would not expire. ",
          "createdAt": "2020-09-08T22:35:58Z",
          "updatedAt": "2020-09-08T22:35:58Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> How and where did this 7 day expiration arrive in the spec? What justifies this?\r\n\r\nThis is a critical component for the security of signed exchanges. In the online case of TLS, you have an online TLS negotiation (using client and server exchanged nonces), delivered over a fresh TCP (or UDP, if using QUIC+H/3, but I digress) connection, negotiated using a relatively fresh DNS response, and itself routed through fresh and stable BGP information. The notion of an \u201corigin\u201d rests on this very concept of \u201capproximate freshness\u201d. The choice of 7 days was not arbitrary; it was the effective upper-bound of detection in the event of a revoked certificate. CRLs and OCSP, which populate browser revocation data directly or in aggregate, have been defined at 7 days by browsers.\r\n\r\nIt\u2019s easy to see that the entire security premise of signed exchanges, namely the signed part, disappears if that window is extended. A malicious entity could compromise the security of the origin beyond the current capabilities of the Web Platform if that 7 days were extended. Conversely, if browsers were to take steps to further reduce OCSP and CRL validity periods, it would also be reasonable to expect signed exchanges to similarly be reduced.\r\n\r\nAlternatively, it\u2019s possible to imagine creating fully unique origins, that have no bearing whatsoever to the domain name system, if things needed to be extended longer. It is precisely because signed exchanges try to assert a DNS based origin, which today is negotiated via TLS, that it is necessary to preserve the properties of the platform today. Solving [Zooko\u2019s Triangle](https://en.m.wikipedia.org/wiki/Zooko%27s_triangle) for such exchanges would be a sizable challenge, but it would also have the benefit of no longer needing to rely on CAs to issue certificates, as CAs are used only for authority of the DNS, and are not needed if not using that naming.\r\n\r\nHowever, that\u2019s a rather significant task, and almost an entire exercise in its own right. Without foreclosing on the possibility, because it is a use case desired to be supported, it was not the current primary use case, and the current tradeoff, of requiring fresh authorization within a window that is no-less-secure than TLS today, was and is acceptable, for now.",
          "createdAt": "2020-09-08T23:48:08Z",
          "updatedAt": "2020-09-08T23:48:08Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "My apologies, I have restructured & expanded my concerns. I believe I have completed all major revising. Thank you for your quick comments, which I now attend to.\r\n\r\n@dauwhe Many of my works require a SecureContext to function. for example, the first \u231b\ud83d\udca3 scenario hypothesizes a course-charting page, which would undoubtedly rely upon geolocation services to function. My understanding is that for this page to work, it would need signed resources.\r\n\r\n[Edit+4: i'm still trying to understand this better, but it seems like bundled unsigned resources belong to a distinct suborigin: https://github.com/WICG/webpackage/issues/583. I don't know whether this suborigin retains a secure context or no, but it certainly imposes a big barrier & complexity, if not having sxg. still trying to understand better!!] \r\n\r\n@sleevi As ever, thank you for your enormously hard work securing the web. And double thanks for your fast & speedy reply. And a whole round of thanks for your comprehensiveness & thoroughness in reply. [edit+4: \r\n\r\nI still find the answer you give to be somewhat impossible. It rings true & sound, & yet the collision of this immovable wall you cite seems like no defense against the obvious & clearly necessary & vital exceptions that must be made for unstoppable force of users & their lives, which we must somehow bend to.\r\n\r\nHow do we allow the user the freedom to step outside of normal regular operating territory of the connected, well behaved internet, when they must? When no other options are available, when they are far away from the warm glowing noosphere we all rely on so heavily: are those users to be abandoned? I answer no, they are not. The internet must serve users, even when they find themselves adrift from it.",
          "createdAt": "2020-09-09T00:18:45Z",
          "updatedAt": "2020-09-09T03:13:03Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "It\u2019s a bit harder to track what changed and see whether the response above addressed your primary concern (or at least, what was originally presented).\r\n\r\nA few small notes and corrections, rather than a full response:\r\n\r\n1. In your remarks re: timebombs, you position 12 hours as 15% of the available time, as well as mention 4 day windows. However, I\u2019m having trouble reconciling that with the 7 day window, which is 168 hours. Did I still miss something explicit after re-reading several times?\r\n\r\n2. In the download loop, it\u2019s stated:\r\n    > Alas, to do so, they must continually re-download content.\r\n\r\n    Signed Exchanges explicitly do not require redownloading the content. The client downloads an updated signature, which acts as a fresh verification that the origin has continued to authorize the signed exchange, both in terms of content (effectively serving as a form of cache invalidation, which is essential to mitigating risks like bundled XSS), and in terms of the certificate itself (unrevoked, still authorized by the origin). Content itself can entirely remain unmodified, and is not transmitted over the wire; only the fresh signature metadata is.\r\n\r\n3. In increasing demands for small operators, you write:\r\n    > In many cases, I fear small websites will opt to turn over their most treasured most private keys to external operators, to offload the complexity, at great cost of the privacy & security of their own site, which they now no longer retain cryptographic responsibility for.\r\n\r\n    However, I\u2019m having trouble squaring that statement as one being a regression from the current platform. The described scenario is no different than the use of, say, TLS by a CDN, or perhaps more relevant to your recent interests, Delegated Credentials for TLS. Both entrust a third-party with key management as a way of greatly simplifying the tasks involved for small site operators.\r\n\r\n    That is, I don\u2019t disagree in principle that signed exchanges are more complex than concattening all your JS files together and using a minifier, as some do today. However, given that any use of them is truly voluntary, and given that any complexity is inherent not to the solution, but to the very problem space, I\u2019m not sure I can make sense of this criticism. Much like it being easy to write a new HTTP server, but hard to make it efficiently serve pages, complex problems beget complex solutions. Delegating complexity, whether to common HTTP servers or to content delivery networks whose entire business models are \u201coptimization as a service\u201d, is already a well-established practice that signed exchanges don\u2019t radically alter or change.",
          "createdAt": "2020-09-09T00:35:15Z",
          "updatedAt": "2020-09-09T00:36:21Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "@sleevi your reply was good. i mostly expanded & edited. thanks, apologies.\r\n\r\n1. Timebomb scenario only called out the flight time, without documenting other time-factors:\r\n    * user begins download (0 hours),\r\n    * immediately goes to sleep (9 hours),\r\n    * wakes & travels to gate (3 hours),\r\n    * flies (12 hours).\r\n  \r\n    This brings us to 24 hours, or 14.285% of the maximum expire window. I rounded up a little from there (perhaps tag on some further \ud83e\udd6f-eating-time).\r\n\r\n2. On,\r\n    > Signed Exchanges explicitly do not require redownloading the content.\r\n    \r\n    This is largely relieving to hear. The people who need & can benefit most from webbundles, I feel confident now, can reap their benefits without enormous data-consumption costs.\r\n    \r\n    There are still some negative forces at work that concern me,\r\n    * A user on a modem, for example (a semi-connected user), is still driven to multiple times a week have to dial in to the net, in order to maintain their system; they are still trapped in a not-data-intensive but data-connective infinite loop, that entails the same sort of addicted/fear driven behavior that keeps them day-after-day having to tend to the machine, for fear that the next day they lose connection & the content has already begun to spoil.\r\n     * I am still uninformed/concerned about how this plays out from a privacy standpoint, if not download cost perspective? Users are incentivized to retain regular close & frequent contact with their sites now, updating signatures regularly. My sense is that it means a site could literally follow my changing IP address around the world as I travel while I am refreshing, and that I am now forced to weigh how badly I want to refresh my rapidly spoiling content against giving away the day's location/IP address. Having to remain in close contact with a service like this to retain the content I perceive as carrying with me feels a high price, and not in me the user's interest or to be what the internet ought be designed for.\r\n\r\n3. On treasured private keys,\r\n    > However, I\u2019m having trouble squaring that statement as one being a regression from the current platform. The described scenario is no different than the use of, say, TLS by a CDN, or perhaps more relevant to your recent interests, Delegated Credentials for TLS. \r\n\r\n    The current viable site-operation scenario as I see it is as such: \r\n    * install apache httpd\r\n    * turn on [mod_md](https://letsencrypt.org/2017/10/17/acme-support-in-apache-httpd.html),\r\n    * [check site](https://github.com/icing/mod_md#monitoring) every 2-3 months to insure renewals went through ok,\r\n    * and if a renewal fails, there's usually a month to figure out what happened & fix it before the cert fully expires & site becomes unusable (mod_md attempts to renew after 60 days, & gets a 90 day cert, leaving a 30 day grace period)\r\n    * as such, many indie operators feel comfortable doing things like going on vacation\r\n\r\n    Can we assume SXG succeeds, works, becomes adopted by browsers, sites, & goes on to become well automated in a manner reasonably alike mod_md? That seems somewhat straight-forward. But I do not wish to fully discount the contrasting downsides:\r\n    * our mod_sxg can only generate signatures for 7 days ahead, before the site potentially becomes inoperable (depending on how webbundle is used), 7.8% of the \"grace period\" mod_md has\r\n    * in contrast to certificates which are just as good when they expire in 90 days as when they expire in 2 days, any sxg unfreshness at all comes at the direct expense of user. if a user is used to seeing 7 day expiration signatures for their Gutenberg book, and the signing system has been not updating for 4 days, the user may already be panic'ed & alarmed. i think it's safe to say mod_sxg has a 1 day grace period, or 0.011% of the mod_md grace period.\r\n    * whereas mod_md requires very minimal system resources & runs every couple months, mod_sxg ought update signatures (as per above) ideally at least daily, & potentially may need to read/write every byte of the site & perform checksum operations. this should not be too hard, but i do not wish to completely ignore it.\r\n    * whereas ACME is a stateless means to request certificates, webbundling depends entirely on reviewing state, which is something automation *ought* handle seamlessly & without external depedencies, but, if issues are encountered, requires more comprehensive analysis, more time, & is complected with other concerning build issues operators face, whereas ACME is decoupled from most other content-related concerns. the potential for screw up is far higher, and checking for assurance is far more difficult,\r\n\r\n    On the plus side, sxg automation ought be reliable enough to \"just work\" & has no external dependencies. \r\n\r\n    As someone operating an even fairly good sized indie site today, a perfectly legit & viable hosting platform may require only a couple times a year check up to feel like the core webserver things that need to be updated are updating, and there's a pretty good grace period with low overhead. I do believe sxg is highly automateable, at an overall fairly minor but comparatively massive computational upkeep cost, but what concerns me is that there is, as I see it, a 1 day grace period, for a piece of the serving stack must reassess & review & re sign the entire site, successfully. With good automation I do think many operators will be able to forget about this process, take it for granted, but the high stakes, short grace/expiry windows, more intensive processing- it's a notable & significant shift away from the \"static\" web that has made hosting websites easy & fun since Apache released 25 years ago.\r\n\r\n    I would strike \"radical\" from my \"radically increased demands on small operators\", while still confirming my core belief that 7 days is an awfully small high-pressure window in which to monitor/analyze/repair a dynamic soon-to-be core component of web hosting, especially when users are actively watching their content's deadline marching closer, whereas unto now our timescales have been on the order of months, relying on significantly less dynamic/intensive processes, with less pressure to update proactively in those time frames.\r\n\r\n    > However, given that any use of them is truly voluntary, \r\n\r\n    Unsigned bundles were mentioned before as a possible solution, but I'd been under the impression that to bundle a bunch of JS modules in a way that created a SecureContext, one needed sxg. I think I may have fabricated this need? If an unsigned bundle (of the present origin, &c) is transmitted over secure tls, one still has a SecureContext? That would make sense too. [edit: oof, sounds like unsigned bundled content gets suborigin treatment, which will impose a fairly significant barrier & reasonably strong incentive for developers to want sxg; https://github.com/WICG/webpackage/issues/583 . still trying to understand!!]\r\n\r\n    That would make sxg more optional. Yet my expectation is that users will want & expect sxg over time, that it behooves us to use sxg, & that we should design & specify for sxg to include small/indie operators, folks who today turn to static web hosting. It's good that sxg does not have to play a role in bundling JS modules too; that will definitely help webbundle get to serving this large ecosystem need quickly.",
          "createdAt": "2020-09-09T02:40:09Z",
          "updatedAt": "2020-09-09T03:16:08Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": ">    * A user on a modem, for example (a semi-connected user), is still driven to multiple times a week have to dial in to the net, in order to maintain their system;\r\n\r\nI\u2019m not sure how this follows from validity windows of signatures being 7 days? You can still batch update.\r\n\r\nHowever, I do think this is veering into the \u201cusable offline\u201d (e.g. a train or a plane) and more into the \u201cpersistently offline\u201d (e.g. a peer-to-peer/sneakernet web). Ultimately, I suspect progress here may require more definition around the \u201coffline\u201d scenarios.\r\n\r\nIt would also stand to reason that this is a constituency today that the Web doesn\u2019t address; that is, users on modems will have a bad time on the Web writ large, period, where a single article on a news site can be 5-50mb of traffic.\r\n\r\n>    * I am still uninformed/concerned about how this plays out from a privacy standpoint, if not download cost perspective? Users are incentivized to retain regular close & frequent contact with their sites now, updating signatures regularly.\r\n\r\nThe signatures can be delivered from anywhere, and URLs extended for sourcing signatures, IIRC. @jyasskin can confirm.\r\n\r\nThis is relevant in that if your threat model is \u201cwebsite knows my IP address as I visit it from different locations\u201d, which today is a given by virtue of TLS, then SXG are a strict improvement over that by allowing an anonymizing intermediary to deliver the SXG and signature to you directly. This is a form of \u201cprivacy preserving preload\u201d\r\n\r\n> Having to remain in close contact with a service like this to retain the content I perceive as carrying with me feels a high price, and not in me the user's interest or to be what the internet ought be designed for.\r\n\r\nThis seems like it might be worth splitting out as a different issue. The internet is, by current design, fairly end-to-end, and so when you access a server, it learns how to route a response back to you. SXG doesn\u2019t change that, and the validity period of a signature seems orthogonal to the discussion of \u201cIf I browse a website, it learns how to route back to me, and if I use SXG, it could... also learn how to route back to me\u201d.\r\n\r\nIf this is your threat model, it seems also relevant to disable HTTP caches and service workers, at a minimum, since those also involve degrees of revalidation. Not trying to be glib or dismissive, just that I suspect this is something very different than the validity period discussion, and might be either fundamentally about things like distributed web or particular use cases.\r\n\r\n\r\n>    Can we assume SXG succeeds, works, becomes adopted by browsers, sites, & goes on to become well automated in a manner reasonably alike mod_md?\r\n\r\nBetter, and without risks that `mod_md` et-al pose. This is because there are fewer dependencies: the server only needs to obtain a fresh OCSP response, which servers already do today (as part of OCSP stapling). While some servers (Caddy, IIS) are much better at this task than others (Nginx, Apache), the important comparison is that the OCSP response is \u201cjust\u201d public data; it doesn\u2019t require obtaining any new certificates whatsoever. Signatures are generated on the server, and so it\u2019s easy for this to be automated; the comparison is not to certificates, but to E-Tags and Last-Modified dates, because it\u2019s \u201cjust\u201d that simple.\r\n\r\nUnlike CDNs, which require you to canonically configure the CDN as authoritative via DNS, and thus serve your users directly through the CDN, SXGs can also be packaged externally by a provider, by giving them an SXG certificate. This isn\u2019t necessarily \u201cmore secure\u201d, since they still have signing keys, but is remarkably \u201cless complex\u201d, because your server and configuration are still directly controlled by you. The SXG-DN (for lack of a better word) just packages your content, if you do delegate to them.\r\n\r\nThe validity window, while reasonable to think of in absolute terms of \u201cdowntime\u201d, is somewhat misleading, precisely because SXG requires good automation. If automation is constantly a source of anxiety or failure, it\u2019s not good automation, and SXG can\u2019t be blamed for that. Further, the failure mode, of going back to authoritative, limits the harm caused in general.\r\n\r\nIt\u2019s only for the \u201ctruly, persistently offline\u201d case that this becomes problematic. Like I mentioned, for that case, it\u2019s likely that we\u2019d need a separate certificate policy entirely, to go with a separate (non-DNS based) origin, just like unsigned bundles. Granting access or the ability to serve on behalf of a DNS origin and for a period greater than 7 days, however, would be a serious security regression.",
          "createdAt": "2020-09-09T04:19:18Z",
          "updatedAt": "2020-09-09T04:21:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Also note that once a particular user has loaded a signed web package, it can install a service worker that can outlive the expiration of the original signature, in the same way that a service worker or HTTP cache entry can outlive the expiration of the TLS certificate that protected the connection that delivered it. The 7-day limit \"only\" hurts the ability to share the content with a new user.\r\n\r\n\r\n\r\n",
          "createdAt": "2020-09-09T17:03:17Z",
          "updatedAt": "2020-09-09T17:03:17Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "I have a more fully reply I have been working through, but it's taking some time. There is one point that I do wish to put out here asap,\r\n\r\n> > * A user on a modem, for example (a semi-connected user), is still driven to multiple times a week have to dial in to the net, in order to maintain their system;\r\n\r\n> However, I do think this is veering into the \u201cusable offline\u201d (e.g. a train or a plane) and more into the \u201cpersistently offline\u201d (e.g. a peer-to-peer/sneakernet web). Ultimately, I suspect progress here may require more definition around the \u201coffline\u201d scenarios. [...] It would also stand to reason that this is a constituency today that the Web doesn\u2019t address; that is, users on modems will have a bad time on the Web writ large, period, where a single article on a news site can be 5-50mb of traffic.\r\n\r\nI used the modem as one example of a person who is not persistently online, someone who is \"semi-connected\". Even at their trickle slow speeds, the modem user actually has a _radically_ better experience than the other semi-connected folks who the sxg 7-day limit will grievously degrade: those who have to bus, bike, walk, ride-share, or [rickshaw](https://timesofindia.indiatimes.com/city/chandigarh/Riding-the-internet-highway-with-special-e-rickshaw/articleshow/55926972.cms) their way to an internet uplink. We're seeing the impact of this right now very strongly with Corona-virus, seeing families that can't afford internet connections suffering radical hardship as their children must go to extraordinary lengths to \"attend\" school, sometimes by commuting to the same school to attend from the parking lot!\r\n\r\nThese users are torn between having content that, if they share, might not be shareable or in many cases even usable to the sendee for very long (it depends on whether there's a full blown js framework powering an offline capable web experience for the content), and the time-consuming manual slow process of establishing a connection. The semi-connected folk of the world deserve to keep the web content they treasure & want to share with them for longer, without us (sxg) imposing on them a chore to have to renewing it every couple days. I was incorrect in 2. \u27f3\u221e being a redownload trap, thanks to updateable signatures, but 2. is a \u27f3\u221e update signatures trap, and one that, in the span of a week while actively degrading in usefulness, is quite the burden to these many many users that webbundle very explicitly seems to be intent to serve & help.\r\n\r\nThis does not seem like a persistently offline issue to me. A hard-fast 7-day sxg limit seems like something the most direct beneficiary of this technology will feel the impact of every day of their lives, with nervous, frightened energy.",
          "createdAt": "2020-09-10T20:35:07Z",
          "updatedAt": "2020-09-10T20:41:10Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I agree that the 7-day signature-expiration upper-bound is likely to be a usability problem in practice. It's a compromise between usability, as you've noted, and security, as Ryan noted. Several folks want to shift the balance even more toward security, by requiring an online connection in order to verify the source of the content. Other folks want to let content authors pick any expiration time, and trust that they'll pick something that adequately protects their users.\r\n\r\nSo far, I haven't seen a compelling argument to change in either direction (including this thread), but I'm also not firmly convinced that 7 days is The Right Choice. To change it, I think we'll need someone other than me to write an essay weighing the tradeoffs on both sides, and then a discussion on at least the wpack@ietf.org mailing list and probably at a live IETF meeting.\r\n\r\n(The IETF isn't the only plausible body for this decision \u2014 browsers might wind up imposing stricter limits for uses on the web \u2014 but we have a WG there, and a lot of the right people are involved there, so that's where I suggest we start.)",
          "createdAt": "2020-09-10T21:55:08Z",
          "updatedAt": "2020-09-10T21:55:08Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "> (The IETF isn't the only plausible body for this decision \u2014 browsers might wind up imposing stricter limits for uses on the web \u2014 but we have a WG there, and a lot of the right people are involved there, so that's where I suggest we start.)\r\n\r\nThis doesn't seem the right place to start, either? The IETF doesn't set policy, as a rule, and this is very much tied to certificate policies, right?\r\n",
          "createdAt": "2020-09-10T23:48:29Z",
          "updatedAt": "2020-09-10T23:48:29Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Good point. So it will wind up on the browser side, where we don't have automatic meetings or a mailing list. I'll be registering for a TPAC slot this year, so that's a good place to present any essays that arrive by then.",
          "createdAt": "2020-09-10T23:51:32Z",
          "updatedAt": "2020-09-10T23:51:32Z"
        },
        {
          "author": "quasicomputational",
          "authorAssociation": "NONE",
          "body": "I think there's another interesting possibility for intermittent/absent links, which is that the validity URLs with new signatures can be distributed as SXGs themselves, allowing a mostly/totally offline client to get its SXGs & bundles revalidated by push rather than pull, and reducing the burden on the publisher. In that situation, I think there'll be a demand for 'big' bundles, both for efficiency (making the revalidation SXG size smaller) and privacy (hiding what, specifically, you're interested in in a bigger set of resources).",
          "createdAt": "2020-09-11T11:49:10Z",
          "updatedAt": "2020-09-11T11:49:10Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "> I'll be registering for a TPAC slot this year, so that's a good place to present any essays that arrive by then.\r\n\r\nHow can I help? I can try to spend time cutting down my existing work to something of a manageable more direct size? I'm very concerned about giving users the power to take things with them, & them finding themselves surprisingly unexpectedly locked out. I don't think any level of warning or notification to the user is sufficient. I think the user has a rightful desire that we ought respect to access the signed offline content that they opt to trust.",
          "createdAt": "2020-10-24T00:22:43Z",
          "updatedAt": "2020-10-24T00:22:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@rektide We have some time [tomorrow](https://www.w3.org/2020/10/TPAC/breakout-schedule.html#web-packaging) to discuss this. Do you want to give a 5-minute presentation of the problem that folks can then discuss?",
          "createdAt": "2020-10-25T21:48:48Z",
          "updatedAt": "2020-10-25T21:48:48Z"
        },
        {
          "author": "rektide",
          "authorAssociation": "NONE",
          "body": "Crud, I missed it! I hope you all had a good session. Thank you so very much for the mention. I thought requirements for participation were much much higher.",
          "createdAt": "2020-10-26T18:38:29Z",
          "updatedAt": "2020-10-26T18:39:01Z"
        },
        {
          "author": "EternityForest",
          "authorAssociation": "NONE",
          "body": "My issue #621 may be related.\r\n\r\nAndroid Apps use signatures.  And your phone doesn't just decide that your app has expired (yet..).\r\n\r\nAllowing an overall signature for an \"unsigned\" bundle, which has no expiration requirements, would mean that you could safely publish something lasting.\r\n\r\nThe certificate used could either be domain based, giving the bundle a proper origin, or self-signed, giving the bundle a random hex string origin.\r\n\r\nThese bundles would not need to use the same certificate used by the web server.  The risk of ever needing to revoke them, or even expire them, is much lower when the key can be kept in a safe on a smart card.\r\n\r\nIf you can't trust them to keep a key that is only ever used under manual supervision safe, one might not want to trust them whatsoever.\r\n\r\nWith domain based certs, one can always revoke the traditional way, and create a new bundle(Although this could still cause lost access, if one got the revocation notice but did not have bandwidth for the new bundle).\r\n\r\nThese overall signed bundles also resolve the issue of picking and choosing legitimate resources to form a vulnerable combination.",
          "createdAt": "2021-02-16T10:01:21Z",
          "updatedAt": "2021-02-16T10:01:21Z"
        }
      ]
    },
    {
      "number": 599,
      "id": "MDU6SXNzdWU3MDMwMjE4NjQ=",
      "title": "Site might phish a site that archives it",
      "url": "https://github.com/WICG/webpackage/issues/599",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I've been designing as if we could have a page like https://web.archive.org/web/20200914192731/https://www.example.com/ serve a web bundle that it doesn't do a lot of work to vet because it winds up executing in a suborigin. However, @wycats pointed out that that could allow https://web.archive.org/web/20200914192731/https://attack.web.archive.evil.example/ to show a login form for https://web.archive.org, and because [the browser would emphasize the serving origin](https://github.com/wicg/webpackage/blob/master/explainers/bundle-urls-and-origins.md#rendering-the-url-bar), it would probably fool the user. See also some discussion on #560.\r\n\r\nA couple thoughts:\r\n* This is still better than the current situation, where an unvalidated archived site can just exfiltrate login cookies.\r\n* Some discussion in #576 suggests a way to mark a bundle as having no network access, which might prevent it from using any credentials it manages to phish. Is that sufficient?\r\n* This probably isn't a worry for bundles accessed as `file:`s?",
      "createdAt": "2020-09-16T19:35:12Z",
      "updatedAt": "2020-12-14T18:15:34Z",
      "closedAt": null,
      "comments": [
        {
          "author": "TimothyEBaldwin",
          "authorAssociation": "NONE",
          "body": "Prohibiting network access does not prevent exfiltrating the phished credentials by using a side channel, such as CPU, GPU and memory usage, electricity consumption, or displaying them possibly in a covert fashion.",
          "createdAt": "2020-12-10T21:10:17Z",
          "updatedAt": "2020-12-10T21:10:17Z"
        },
        {
          "author": "quasicomputational",
          "authorAssociation": "NONE",
          "body": "Is it too late in the day to suggest that unsigned bundles should always be an opaque suborigin unless the distributor explicitly sets a header requesting that it be treated as authoritative (in which case the browser will treat it as authoritative iff distributor origin == publisher origin, as the plan is now)?",
          "createdAt": "2020-12-12T22:07:37Z",
          "updatedAt": "2020-12-12T22:07:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@quasicomputational It's not too late in the day, but I think that's also orthogonal to the question of how to protect sites that want to serve bundled archives of cross-origin sites, which would always live in suborigins. The similar fix here might be to put bundles in completely opaque origins, giving users no indication of where the bundle comes from or what it claims to be a copy of when they're reading it.",
          "createdAt": "2020-12-14T18:15:34Z",
          "updatedAt": "2020-12-14T18:15:34Z"
        }
      ]
    },
    {
      "number": 600,
      "id": "MDU6SXNzdWU3MDY1OTcxNTY=",
      "title": "Updating a SXG via validity-url forces content negotiation on servers",
      "url": "https://github.com/WICG/webpackage/issues/600",
      "state": "OPEN",
      "author": "quasicomputational",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "needs spec"
      ],
      "body": "Section 3.6, 'Updating Signature Validity', says:\r\n\r\n> If the the update map is present, that indicates that a new version of the signed exchange is available at its effective request URI (Section 5.5 of [RFC7230]) and can give an estimate of the size of the updated exchange (update.size). If the signed exchange is currently the most recent version, the update SHOULD NOT be present.\r\n\r\nConsider a set-up where `main.html` is the actual resource of interest, and `main.html.sxg` is a signed exchange containing `main.html` (and hence `main.html.sxg` has an effective request URI of `main.html`). `main.html` can have a Link header pointing to `main.html.sxg` with `rel=alternate` and `type=application/signed-exchange` to allow clients to discover the signed exchange. Each of the representations is addressable and there's no need for content negotiation, which is often a big simplification in operation.\r\n\r\nHowever, if the server operator wants to use the `update` field of the validity URL's resource to signal that clients can download a new version of the signed exchange, the spec's current text forces that to be made available at `main.html`. This would force the server into content negotiation because `main.html` is now a name for both the direct representation *and* the signed exchange.\r\n\r\nIf, alternatively, the spec said to try re-downloading the signed exchange from wherever it was originally found, using content-addressing for the SXG would fail: they'll just download the old version again or run into a 410.\r\n\r\nI think that the spec would be better if it just dropped the 'at its effective request URI', and let clients look for the new SXG however they want to: the best thing would be to use the same mechanism to discover the updated SXG as they used to discover the SXG originally, but they could try content negotiation at the effective request URI if they think it's a good idea or if it's the best option they have (e.g., if the SXG wasn't discovered and actively pulled, but rather pushed to them out of band). It might be worth having a SHOULD here noting the pitfalls.",
      "createdAt": "2020-09-22T18:22:13Z",
      "updatedAt": "2020-09-23T23:48:35Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 602,
      "id": "MDU6SXNzdWU3MTk2OTcyMjU=",
      "title": "Signed-Headers or Signed-Fields",
      "url": "https://github.com/WICG/webpackage/issues/602",
      "state": "OPEN",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "## Question\r\n\r\n`Signed-Headers` is defined as a response header field. I was guessing whether:\r\n\r\n- constraining its usage to Headers might hinder the ability to evolve this specification in conjunction with other content-coding != mice. Ongoing `Digest` work for example [allows using `Digest` in trailers](https://github.com/httpwg/http-extensions/pull/1157/files), while there's an open discussion in http on [mid-stream trailers](https://github.com/httpwg/http-core/pull/439/files);\r\n- constraining its usage to responses could inhibit the integration between this specification and other signature-based specifications, eg. https://github.com/httpwg/http-extensions/issues/1181\r\n\r\nA more general approach (eg. Signed-Fields) could make sense.",
      "createdAt": "2020-10-12T22:01:44Z",
      "updatedAt": "2020-10-12T22:01:44Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 603,
      "id": "MDU6SXNzdWU3MzI1MDgwMjE=",
      "title": "How resource URL collisions will be handled?",
      "url": "https://github.com/WICG/webpackage/issues/603",
      "state": "OPEN",
      "author": "anforowicz",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "What should happen if there is a URL collision between URLs of resources contained in a bundle?  For example, a page may link to 2 cross-origin bundles that contain the same urn:uuid resource (accidentally or maliciously):\r\n\r\n```html\r\n<link rel=\u201dwebbundle\u201d href=\u201dhttps://a.com/bundle.wbn\u201d\r\n          resources=\u201durn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6\u201d>\r\n<link rel=\u201dwebbundle\u201d href=\u201dhttps://b.com/bundle.wbn\u201d\r\n          resources=\u201durn:uuid:f81d4fae-7dec-11d0-a765-00a0c91e6bf6\u201d>\r\n```\r\n\r\nA page may also link to 2 same-origin bundles can also carry the same http URL:\r\n\r\n```html\r\n<link rel=\u201dwebbundle\u201d href=\u201dhttps://a.com/bundle.wbn\u201d\r\n          resources=\u201dhttps://a.com/foo.js\u201d>\r\n<link rel=\u201dwebbundle\u201d href=\u201dhttps://a.com/bundle2.wbn\u201d\r\n          resources=\u201dhttps://a.com/foo.js\u201d>\r\n```\r\n\r\nI would expect that if *a single page* links to 2 bundles with conflicting resource names, then there should be some kind of an error (when loading the bundle?  when loading the conflicting resource?).  The situation seems more challenging when *2 separate pages* link to different bundles that contain the same resource URL - this scenario is especially interesting if these 2 separate pages are hosted in separate renderer processes (so the URL collision may not be obvious within each of the renderer process and may only become a problem from perspective of a network service process where the bundle contents may be hosted).\r\n\r\nIt seems that when linking a cross-origin bundle, the UUID needs to be coordinated between 1) the bundle contents (served from the bundle origin) and 2) the page elements linking to the bundle resources (with html served from the page origin).  Therefore, it might not be practical to generate a random UUID every time a bundle is served, or every time a `<link rel=\"webbundle\"` element is served.  Therefore, a malicious actor may try to serve bundles that collide with known uuid URLs.",
      "createdAt": "2020-10-29T17:21:38Z",
      "updatedAt": "2021-04-07T04:54:41Z",
      "closedAt": null,
      "comments": [
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "/cc @jeffkaufman",
          "createdAt": "2020-10-29T17:30:42Z",
          "updatedAt": "2020-10-29T17:30:42Z"
        },
        {
          "author": "jeffkaufman",
          "authorAssociation": "NONE",
          "body": "> it might not be practical to generate a random UUID every time a bundle is served\r\n\r\nYou should only use UUIDs if you will generate them fresh on every use.  Can you say more about why you don't think this would be practical?\r\n\r\nFor example, here is a way that cross-origin communication could happen:\r\n\r\n1. JS running on the page and a web bundle link, and includes in that link a UUID\r\n2. JS on the page attempts to execute JS from the UUID\r\n3. When the bundle returns, it includes a script index under that UUID\r\n4. That script knows about other UUID is in the same bundle, and can do what it likes with them",
          "createdAt": "2020-10-29T17:38:17Z",
          "updatedAt": "2020-10-29T17:38:17Z"
        },
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "Thanks @jeffkaufman - that makes sense!  Having the uuid (or uuid seed) embedded in the link to the bundle should work.\r\n\r\nSo, is the plan to:\r\n1. Document what happens if there is a collision\r\n2. Discourage hardcoding uuids",
          "createdAt": "2020-10-29T17:43:20Z",
          "updatedAt": "2020-10-29T17:43:20Z"
        },
        {
          "author": "anforowicz",
          "authorAssociation": "NONE",
          "body": "BTW: It seems that I missed that bundle resources are identified not only by their URL, but also by the identity of the frame that linked to the bundle.  Therefore cross-page collisions should not be possible / should not be a concern.",
          "createdAt": "2020-10-29T17:44:54Z",
          "updatedAt": "2020-10-29T17:44:54Z"
        },
        {
          "author": "jeffkaufman",
          "authorAssociation": "NONE",
          "body": "That sounds like a good plan, though I would say \"strongly discourage hardcoding uuids\" ;)",
          "createdAt": "2020-10-29T17:46:56Z",
          "updatedAt": "2020-10-29T17:46:56Z"
        }
      ]
    },
    {
      "number": 606,
      "id": "MDU6SXNzdWU3NDUyOTUxODQ=",
      "title": "Form use cases",
      "url": "https://github.com/WICG/webpackage/issues/606",
      "state": "OPEN",
      "author": "dgp1130",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "# Forms as files\r\n\r\nToday, there are countless companies around the world which send simple forms as files to collect information from customers. The use case essentially works like:\r\n\r\n1. Business creates a form document requesting some information.\r\n1. Business sends the form to a customer.\r\n1. Customer fills out their personal info.\r\n1. Customer sends the form back to the business.\r\n1. Business opens the form to read the information the customer has provided.\r\n\r\nThis general user flow has existed for a long time and has often been satisfied by PDF files. However, PDFs have a lot of their own problems, such as (but not limited to):\r\n* Ownership: While [PDF 2.0 is a standard](https://en.wikipedia.org/wiki/History_of_the_Portable_Document_Format_(PDF)#ISO_Standardization:~:text=deprecated.-,ISO%20Standardization), it has several issues.\r\n    * The standard has only been updated once and its latest version is 3 years old.\r\n    * The latest version of the standard is not free.\r\n    * Due to historical reasons, Adobe Reader is often [considered the *de facto* standard](https://talkingpdf.org/is-pdf-an-open-standard/) which can contradict the published standard.\r\n    * Adobe still holds patents used in the standard and [may revoke them](https://www.pdfa.org/adobe-resolves-patent-questions-on-iso-32000/) due to legal arbitration.\r\n* Software requirements: Requires custom software to create, modify, or fill out.\r\n    * Actions as simple as rearranging pages or combining multiple PDFs together can often required paid tools.\r\n    * Historically, Adobe Reader was required just to view a document, but these days most browsers and OS' can at least display PDFs.\r\n* Scripting: PDF forms are mostly static, although they do allow limited JavaScript/ExtendScript.\r\n    * I'm honestly unable to determine exactly what ECMAScript version is currently supported, but at least [one resource](https://community.adobe.com/t5/indesign/extendscript-javascript-language-specification/td-p/8634763?page=1#bodyDisplay_131ae9bf863bcb:~:text=clipboard-,Third%20Edition%20(ECMA%2D262%2C%20old%20stuff).) says it was using ES3 back in 2016, which would definitely be way out of date.\r\n* Accessibility: Special tools are often required to use PDFs for those with physical impairments.\r\n* Security: Malicious PDFs are capable of compromising users and systems.\r\n\r\nWhile web-based forms and products like Google Forms have provided alternatives to PDFs, these are generally server-based systems, requiring a software developer to implement the form or trust in a third-party to keep the form service available and secure. Historically, \"email a form to a customer\" is simply not possible with existing web technologies.\r\n\r\n# Using Web Bundles\r\n\r\nWith Web Bundles however, this is now possible. I can build a simple web form using existing web technologies and package it into a `*.wbn` file. I can email this file to a customer, and when they double-click it (and Web Bundles are fully supported by most web browsers), it can open in the user's browser and display my form for them to fill out.\r\n\r\nHowever, there is one critical limitation, a user cannot \"save\" their information into the form and pass it back to me, because Web Bundles (as I understand them) are effectively immutable to users. I think this could be solved by a simple JavaScript API. Consider the following strawman API usage:\r\n\r\n```javascript\r\n// HTML contains `<input type=\"text\" id=\"first-name\" />`\r\nconst firstNameInput = document.querySelector('input#first-name');\r\n\r\n// When the user clicks a \"Save\" button...\r\ndocument.querySelector('button#save').addEventListener('click', async () => {\r\n  // Serialize form data to a `user-data.json` file stored in the `*.wbn` file.\r\n  await webbundle.writeAppDataFile('./user-data.json', JSON.stringify({\r\n    firstName: firstNameInput.value,\r\n  }));\r\n});\r\n\r\n// When the `*.wbn` file is opened...\r\ndocument.addEventListener('load', async () => {\r\n  // Deserialize form data from the `user-data.json` file previously written to the `*.wbn` file.\r\n  const data = await webbundle.readAppDataFile('./user-data.json');\r\n  const json = JSON.parse(data);\r\n\r\n  // Update the UI with the loaded data.\r\n  firstNameInput.value = json.firstName;\r\n});\r\n```\r\n\r\nThis would allow a customer to fill out a `*.wbn`-based form with their information and save it back to the original file. The user could then send the changed file back to the business (via email for example), and when the business opens it, they will see all the original user's information. This is effectively equivalent to modern PDF-based workflows, and unlocks a whole suite of file-based possibilities that were previously impossible with web-based tooling.\r\n\r\nThere's a discussion to be had about whether LocalStorage/IndexedDB/etc. should also serialize to the `*.wbn` file. I'm using a distinct API here for demonstration/clarity purposes, see the Security section for more discussion about this.\r\n\r\nIn this example, `webbundle.readAppDataFile()` and `webbundle.writeAppDataFile()` will allow devs to read/write virtual files stored inside the `*.wbn` file. The files could have any name, directory structure, or format. In this case, we're writing a JSON file, but you could use any serialization mechanism. Binary versions of these functions would also be useful for reading/writing binary data such as photos, videos, or even [protocol buffers](https://developers.google.com/protocol-buffers).\r\n\r\n# Benefits of using *.wbn\r\n\r\nUsing web technologies can provide many improvements to the problems with existing document formats (PDFs):\r\n\r\n1. Ownership: Being a free and open web standard democratizes this feature. There is no conflicting implementation like Adobe Reader that might confuse implementations of the standard. Important updates like the ECMAScript version can be decoupled and provided implicitly by the browser.\r\n1. Software requirements: Only a browser is required to view and fill out a web form, a piece of software already used by the vast majority of users. Software to *build* web forms already exists and could easily be tweaked to provide Web Bundle functionality.\r\n    * Imagine SquareSpace, Wix, Google Forms, or any other \"build your own website/web form\" tool with an \"Export as *.webn\" button. These tools could cover all skill levels from a business user making a trivial form to a web developer building a complex Angular application.\r\n1. Scripting: Browsers already support and maintain a standardized and up-to-date ECMAScript implementation. Developers benefit from more consistent API interfaces and any additional features provided by browsers that may not be supported by PDFs out of the box.\r\n1. Accessibility: Browsers and the web already have an extensive a11y model and tooling, working well with screen readers and other a11y tools. Developers also have common and well-known patterns for building accessible sites which would also apply to `*.wbn` files.\r\n1. Security: Browsers provide a comprehensive sandbox for executing code safely and can provide much stronger security guarantees. The web also already has privacy patterns for using various APIs via appropriate permissions, allowing `*.wbn` files to safely take advantage of features like geolocation, file pickers, network requests, Bluetooth, WebUSB, etc. without compromising user privacy.\r\n\r\n# Example use cases\r\n\r\nModeling forms as a web application provides all the power that comes with such technology to the form itself, allowing these forms to do a lot more for users than a traditional PDF. Take a few examples:\r\n\r\n1. A \"Fill out with LinkedIn\" button which allows a user to perform a federated sign on to their LinkedIn account and then click a single button to auto-populate all their employment information directly into the form. This could even be a library provided by LinkedIn and integrated with web form builders to make it trivial to add for non-technical users creating a simple job application.\r\n1. A form input which autocompletes itself based on a query to some (possibly authenticated) backend service. Network requests can provide cookies as appropriate in order to call a protected service and allow a user to choose options from it.\r\n    * For example: \"Which of your reports would you like to promote?\" can verify the name given is *actually* your report and fetch related info like employee ID and salary information to auto-fill other parts of the form.\r\n1. A \"Sign with X\" service that allows a user to authenticate with an identity provider (Google, Microsoft, Government systems, ...) and click a \"Sign\" button to digitally attribute all the information to the current user securely.\r\n    * This one may have security/legal hurdles, but I personally hate the \"print out a form, sign it, and then scan it back\" workflow and would really love to find a way to do this digitally.\r\n1. A video embedded in the form (that is, hosted externally but embedded via a `<video />` tag) which describes the form and how to fill it out.\r\n\r\n# Tooling\r\n\r\nAdditional tooling could be built to extract user data from the file and process it in an automated fashion, perhaps writing to a database, generating a spreadsheet, or performing analytics. Since user data is stored in a virtual file system within the `*.wbn` file, tools and libraries could be built to easily extract all or part of this file system. This can also allow businesses to scale up, starting with a simple `.wbn` form created by some drag and drop editor, then later creating a more comprehensive, hosted web application and migrating all the existing Web Bundle data into the new database. In fact, database systems could have an \"Import from *.wbn\" feature similar to \"Import from *.csv\", to easily extract user data and drop all the web resources.\r\n\r\nIt may also be beneficial to have a more structured API and file format. The `webbundle.writeAppDataFile()` API allows creation of individual files of any format, which is very flexible but would likely make it difficult to implement a useful \"Import from *.wbn\" feature without knowledge of the specific form being imported. A more structured API might provide something like:\r\n\r\n```javascript\r\n// Write the following key-value pairs to a \"metadata\" file in the Web Bundle.\r\nawait webbundle.writeMetadata({\r\n  'firstName': 'Douglas',\r\n  'lastName': 'Parker',\r\n  'age': 26,\r\n  'email': 'dgp1130@noreply.users.github.com',\r\n  // ...\r\n});\r\n\r\n// Write all key-value pairs from the metadata file in the Web Bundle.\r\nconst { firstName, lastName, age, email } = await webbundle.readMetadata();\r\n```\r\n\r\nThis works as a simple key-value data store, and could write to a special location in the Web Bundle file. This could be extracted by automated tooling in a generic fashion, easily populating a database or a spreadsheet based on the keys. This more structured API could certainly grow over time to satisfy more use cases, such as storing photos or scanned pages of a document.\r\n\r\nThis model also maps to existing HTML form semantics. Most existing web forms are a bunch of `<input type=\"...\" />` elements inside a `<form />` with implied serialization mechanisms. This API could be extended with a new attribute: `<form action=\"webbundle\" />`. This would tell browsers to interpret `<button type=\"submit\" />` as a \"Save\" button, which serializes the form data into this Web Bundle metadata format based on the `name` attribute of the form elements. This is exactly like submitting a web form, except using Web Bundle metadata rather than an HTTP GET or POST request to a server. This would also support `<noscript />` users and allow form generator tools to emit a complete form without a bunch of custom JavaScript embedded.\r\n\r\n# Security\r\n\r\nThere are a couple security caveats to consider, and likely more that I have not considered. I'm also not totally familiar with the expected security model of Web Bundles, but these are some initial thoughts I have.\r\n\r\nWhile I'm not totally familiar with Signed HTTP Exchanges, if a `*.wbn` file is somehow signed, user data would need to be kept separate from the signed application and the file format would need to account for that. This way, a user can fill out a form with their own information without removing the signature on the actual application data.\r\n\r\nWhile user data is stored in the `*.wbn` file much like the original web application resources, it should **not** be accessible via XHR, or else malicious users could attempt to inject or rewrite existing application resources to compromise others. Applications should explicitly call `webbundle.readAppDataFile()` to access and sanitize user data while trusting local application resources.\r\n\r\nExisting client-side storage mechanisms like IndexedDB, LocalStorage, and cookies should be private to a single user and **not** serialized to the `*.wbn` file. This allows a browser to store private user information (such as authentication tokens) without leaking them into the document and whomever might view it next. It also protects common libraries from accidentally storing information into the `*.wbn` file without considering the use case.\r\n\r\nThe form use case is a possible malware vector. A business could send an innocuous form to a customer, who sends it back with some additional malware provided. This is already a problem with PDFs, however they tend to be more clear about when they are running scripts within a document, possibly having users explicitly enable scripts before executing them. With a `*.wbn` file, JavaScript is likely to be much more common than PDF scripts and more likely for users to enable it. While browsers already have `<noscript />` support, it may be prudent to more prominently display options for users to configure script execution. Signed `*.wbn` files could prevent malicious users from modifying the contents, however many tools and non-technical users may create legitimate forms that are not signed and open to abuse by malicious users. Enabling/requiring tools that generate `*.wbn` files to sign their outputs easily (via signed exchanges or other mechanisms) and surfacing unsigned files just like non-HTTPS sites would be the best way to mitigate potential problems here.\r\n\r\n# Other Thoughts\r\n\r\nI'm honestly not that familiar with PDFs from a technical perspective, so please fact check me on statements there. All I know is that every interaction I have with PDFs is painful and I find existing web technologies to be far more convenient and usable. The prevalence of web forms already shows this, however PDFs still have an effective monopoly on representing a form as a simple file. I believe that conceptual model and its ease of use are the main lacking feature of the web ecosystem. Web Bundles provide a direct answer to that problem, and with only a few simple tweaks, I think this use case could be served much better than existing tools on the market.\r\n\r\nI'm not sure if the Web Bundles specification has an explicit \"goal\", but I'm guessing form use cases like this aren't really included there. This idea is likely a bit of a tangent from the original intent of Web Bundles, but I think the technology is 95% of the way there already and I hope this is something which is considered to be worth exploring. The only real proposal here is to add an API to write user data to a Web Bundle. The rest of this is justification and speculation about the impact and use cases for such a feature.\r\n\r\nFrom a technical perspective, I think supporting form use cases with `*.wbn` is relatively straightforward as web specs go. As with any user-facing disruptive technology, the trickiest part with landing this idea is getting existing infrastructure and tools to support this file format to enable non-technical users to be as comfortable creating and filling out a Web Bundle form as they are today with a PDF form. Overcoming the 27-year head start of PDFs and achieving cultural parity is the most difficult challenge here.",
      "createdAt": "2020-11-18T03:26:00Z",
      "updatedAt": "2021-02-16T01:25:45Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I like the use case overall.\r\n\r\nThe existing bundles proposal has the building blocks to have the `form.wbn` be able to save and load `.json` (or whatever format) files that would live next to the form, rather than changing the form itself. I guess PDF forms do constitute an existence proof that people have a use for form data embedded into the form file itself, which we'd need this new API to allow.\r\n\r\nI'm inclined to treat this as a V2 problem: once we've shipped bundles that can be downloaded as an offline form, then we can talk to groups that use fillable PDFs and see if they'd be interested in switching to a more web-enabled format.",
          "createdAt": "2020-11-18T23:18:57Z",
          "updatedAt": "2020-11-18T23:18:57Z"
        },
        {
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin in Italy we are interested in this perspective and we are already experimenting with projects like jsonforms. We have not already planned any PoC related to webpackage though. cc: @sebbalex @bfabio ",
          "createdAt": "2020-11-19T14:55:41Z",
          "updatedAt": "2020-11-19T14:55:41Z"
        },
        {
          "author": "EternityForest",
          "authorAssociation": "NONE",
          "body": "I absolutely love this idea.   In my opinion, Excel is one of the most important pieces of software of all time not because 2D grids are all that great, but because it let anyone make (theoretically) safe bundles of app and data.\r\n\r\nThis has use cases far beyond thee obvious PDF forms replacement, because it can also be used as a way to configure an offline-first app, and then distribute that configuration.  The power isn't so much as a forms replacement, but as an \"App in a box\" for pretty much any purpose.\r\n\r\nImportantly, self-updating offline catalogs become possible, along with P2P chat and other distributed applications where your \"account\" is just a file that you have full control over\r\n\r\n\r\nBut the downside of Excel is that you *can't* easily separate logic/forms and the actual data, so I very much like the idea of separate files that live \"next to\" the bundle.\r\n\r\n\r\nI wonder if there might be some advantages to using a database, rather than a JSON file though.   There seems to be a discomfort with ever including SQLite3 in a web standard, for fear of  \"Codifying it's quirks\", but it is, ultimately, and insanely reliable, free, and near universally trusted system.\r\n\r\nA JSON file must be completely rewritten, to save.  We already see a problem with various files frequently rewritten being a cause of high disk activity.\r\n\r\nA basic key/value store with JSON values would be far more flexible for making small updates.\r\n\r\nThen again, this kind of thing can already be done via local storage APIs, so JSON files, or even just embedding everything right into the file, offers a very simple way to cover the obvious PDF forms use case.\r\n\r\n\r\nPerhaps modifications could be written back to the bundle itself, for maximum drop-in effectiveness at being a PDF form, but with the UA having a notification that the site uses customized data, along with save/save as/clear custom data functionality, or even export/import custom data functions.\r\n\r\nThis would preserve the exact document model people are used to from any other site.\r\n\r\n\r\nOne problem with the whole thing though, is  origins. If anything like cookies or local storage gets used, it will totally break, because two different filled out copies of the same form will share an origin, and probaby confuse everything.\r\n\r\nThat could discourage anyone from using it for anything more interesting, along with the fact that one could accidentally share a customized version when they meant to share an uncustomized version.\r\n\r\n\r\nPerhaps form-supporting bundles should be treated completely differently.  Whenever you hit save, it should jump to a new file with a new extension, so it is clear that this is no longer a clean copy.\r\n\r\nTo get *really* fancy, the browser could generate a new keypair just for that modified bundle (I think people would get uncomfortable with global keypairs by default) stored in a file, and use it to sign the new modified bundle.\r\n\r\nWhen loading the file, the origin of that document would become <PUBKEYHASH>.originaldomain.com\r\n\r\nThis gives every document it's own namespace for local APIs and the like.   It puts a big scary blob of nonsense in the URL bar, preventing someone from distributing bad content in a modified form and convincing people that it came from the original source.\r\n\r\nIt also gives documents a persistent identity that can be preserved across new versions of the same document.\r\n\r\nIt provides some minimal level of authentication, someone who believes they have received a bogus update to a document can prove it, even though people probably won't be routinely checking the URLs.\r\n\r\n\r\nThere's no reason to limit this to just basic forms, when all kinds of interactive, offline first apps can be done this way.  \r\n\r\nThe old TiddlyWiki is a perfect example.   It used to use self-modifying HTML for exactly this kind of thing.  ",
          "createdAt": "2021-02-15T23:53:34Z",
          "updatedAt": "2021-02-15T23:53:34Z"
        },
        {
          "author": "dgp1130",
          "authorAssociation": "NONE",
          "body": "> This has use cases far beyond thee obvious PDF forms replacement, because it can also be used as a way to configure an offline-first app, and then distribute that configuration.  The power isn't so much as a forms replacement, but as an \"App in a box\" for pretty much any purpose.\n\nI really like this \"App in a box\" mentality. In my original thought process, I was trying to come up with an existing alternative technology that provides the same features as PDFs. I came to realize that PDFs aren't just strictly forms, but rather more complex applications that happen to target form use cases. In many cases, a user didn't want a simple form, they wanted an application that passes structured information from one person to another. Hence, the alternative application platform I identified was the web, and just filled in the blanks from there.\n\nAs you mentioned though, this isn't unique to forms and really applies to any file-based app. You could take any app and put it in a WebBundle box to gain many of the advantages mentioned previously. This can be a much broader and more generic idea than just forms.",
          "createdAt": "2021-02-16T01:25:45Z",
          "updatedAt": "2021-02-16T01:25:45Z"
        }
      ]
    },
    {
      "number": 609,
      "id": "MDU6SXNzdWU3ODQwMDk2NzQ=",
      "title": "Clarify how CORS behaves for Subresource Loading with WebBundles",
      "url": "https://github.com/WICG/webpackage/issues/609",
      "state": "CLOSED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It would be better to clarify how CORS behaves for [Subresource Loading with WebBundles](\r\nhttps://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md).\r\n\r\nI'm trying to write WPT [here](https://chromium-review.googlesource.com/c/chromium/src/+/2617167/), however, the explainer should be also updated to clarify how CORS works.",
      "createdAt": "2021-01-12T08:05:20Z",
      "updatedAt": "2021-04-07T04:43:44Z",
      "closedAt": "2021-04-07T04:43:43Z",
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's close this. PR #622 updated the explainer.",
          "createdAt": "2021-04-07T04:43:43Z",
          "updatedAt": "2021-04-07T04:43:43Z"
        }
      ]
    },
    {
      "number": 612,
      "id": "MDU6SXNzdWU3OTk2MTc0NzM=",
      "title": "Should content negotiation be part of the webpackage format?",
      "url": "https://github.com/WICG/webpackage/issues/612",
      "state": "OPEN",
      "author": "littledan",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "All of the applications on the Web that I know of will do content negotiation to decide which bundle to send, not within the bundle on the client side. I'm wondering whether the format should include client-side declarative content negotiation.",
      "createdAt": "2021-02-02T19:42:07Z",
      "updatedAt": "2021-02-02T19:42:07Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 613,
      "id": "MDU6SXNzdWU3OTk3ODg4OTA=",
      "title": "OID for signed certificate timestamp",
      "url": "https://github.com/WICG/webpackage/issues/613",
      "state": "CLOSED",
      "author": "iesiyok",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "Hello,\r\n\r\nI think the SCT code given in \r\n```\r\nopenssl x509 -req -days 90 -in cert.csr -signkey priv.key -out cert.pem \\\r\n  -extfile <(echo -e \"1.3.6.1.4.1.11129.2.1.22 = ASN1:NULL\\nsubjectAltName=DNS:example.org\")\r\n```\r\nis wrong. That's why gen-certurl throws \"Warning: Neither cert nor OCSP have embedded SCT list. Use -sctDir flag to add SCT from files.\" for my case.\r\nI think the OID code should be \"1.3.6.1.4.1.11129.2.4.2\"\r\nhttp://oid-info.com/cgi-bin/display?oid=1.3.6.1.4.1.11129.2.4.2&a=display ",
      "createdAt": "2021-02-02T22:54:01Z",
      "updatedAt": "2021-02-03T00:50:41Z",
      "closedAt": "2021-02-03T00:50:40Z",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "That\u2019s not the OID for SCTs, which cannot be embedded for self-signed certs. It\u2019s the OID for the `CanSignHttpExchanges` extension, which is listed in the comment on the line immediately preceding in the README.",
          "createdAt": "2021-02-02T22:57:24Z",
          "updatedAt": "2021-02-02T22:57:24Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Feel free to reopen if something still turns out to be wrong in the docs.",
          "createdAt": "2021-02-03T00:50:40Z",
          "updatedAt": "2021-02-03T00:50:40Z"
        }
      ]
    },
    {
      "number": 614,
      "id": "MDU6SXNzdWU4MDEyMjIyNzc=",
      "title": "Packaging subresources link is broken",
      "url": "https://github.com/WICG/webpackage/issues/614",
      "state": "CLOSED",
      "author": "codehag",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In the read me there is a link on the text Packaging subresources pointing to https://github.com/WICG/webpackage/blob/master/subresource-loading.md, but this file appears to be missing.",
      "createdAt": "2021-02-04T12:05:01Z",
      "updatedAt": "2021-02-04T18:06:05Z",
      "closedAt": "2021-02-04T18:06:04Z",
      "comments": [
        {
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "With this PR, you can find the links: https://github.com/WICG/webpackage/pull/615",
          "createdAt": "2021-02-04T16:01:08Z",
          "updatedAt": "2021-02-04T16:01:08Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Whoops, thanks! I've merged the PR.",
          "createdAt": "2021-02-04T18:06:04Z",
          "updatedAt": "2021-02-04T18:06:04Z"
        }
      ]
    },
    {
      "number": 616,
      "id": "MDU6SXNzdWU4MDM4OTc0NTc=",
      "title": "Should the primary URL be included in the bundle format?",
      "url": "https://github.com/WICG/webpackage/issues/616",
      "state": "OPEN",
      "author": "littledan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Primary URL does not make much sense as a concept for some uses of resource bundles (e.g., for subresource loading). I'd propose that it be a separate, optional section (like `manifest`), not a required field for all usages.",
      "createdAt": "2021-02-08T20:12:13Z",
      "updatedAt": "2021-04-08T05:10:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for filing an issue!\r\n+1 to make primary URL optional because it doesn't make sense in some use cases.",
          "createdAt": "2021-04-08T05:10:59Z",
          "updatedAt": "2021-04-08T05:10:59Z"
        }
      ]
    },
    {
      "number": 620,
      "id": "MDU6SXNzdWU4MDc1MTM2OTU=",
      "title": "Better caching for Web bundles using Cache Digests for HTTP/2",
      "url": "https://github.com/WICG/webpackage/issues/620",
      "state": "OPEN",
      "author": "dunglas",
      "authorAssociation": "NONE",
      "assignees": [
        "yoavweiss"
      ],
      "labels": [
        "subresource-loading"
      ],
      "body": "[Cache Digests](https://tools.ietf.org/html/draft-ietf-httpbis-cache-digest) could be practical for Web bundles: using them, it could be possible to \"Server Push\" the web bundle, and the server could include in the pushed bundle only what isn't already in the cache of the browser. So we (theoretically) could have the best of both approaches; a good compression, one less RTT and a good hit rate.\r\n\r\nIs it something we should investigate? (I initially discussed this privately with @KenjiBaheux in discussions related to the removal of Server Push from Chrome.)",
      "createdAt": "2021-02-12T20:05:56Z",
      "updatedAt": "2021-04-07T04:55:27Z",
      "closedAt": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "There are a number of security and privacy concerns with Cache Digests that make them unlikely to be implemented.",
          "createdAt": "2021-02-12T20:18:39Z",
          "updatedAt": "2021-02-12T20:18:39Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@yoavweiss and @littledan are working on a way to serve just the parts of the bundle that aren't in cache. I'll let them point at their latest design sketches.",
          "createdAt": "2021-02-17T19:14:25Z",
          "updatedAt": "2021-02-17T19:14:25Z"
        }
      ]
    },
    {
      "number": 621,
      "id": "MDU6SXNzdWU4MDg5MjgzODc=",
      "title": "Overall signature for the entire bundle, which is not linked to the signatures for the individual requests",
      "url": "https://github.com/WICG/webpackage/issues/621",
      "state": "OPEN",
      "author": "EternityForest",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "I propose that bundles should have an overall signature, which is done with a key specific to that particular bundle.\r\n\r\nWe see this kind of thing with Android APKs,  and one of the best use cases for bundles is essentially \"APKs for web apps\".\r\n\r\nWhen  downloading a bundle, we should be able to download an update to that bundle from a third party source, and know that it is a legitimate replacement.  This allows auto-updates from multiple sources with fallbacks.\r\n\r\nAs offline apps ideally have a lifetime much longer than the standard certificate expiry, it may be desirable to publish an app that does not rely on the same certificate used in web requests.\r\n\r\nW feature like this would allow for centralized blacklists of bad bundles to be compiled, meaning that a bundle could potentially be used in some contexts, or even updated, without the original domain still being valid.\r\n\r\n\r\nIt also has benefits for the PDF forms use case mentioned in other issues, as modified versions of documents will carry a signature, and authors will be able to send updated versions more securely, meanwhile it will be possible to clearly distinguish between original and unmodified documents.\r\n\r\nOn top of that, it allows bundles that would otherwise be unsigned to have a unique origin that is not tied to the filesystem, enabling local storage and the like to work properly, or even allowing users to grant access to powerful features like web serial, without a domain name.\r\n\r\nThis could potentially have benefits for the IoT, as no-name devices could ship with their apps and drivers in web bundle format.\r\n\r\nAs it would be a complete new thing, security could also be much stricter.   These self signed web apps could even be totally blocked from making any external web requests without explicit user permission.\r\n\r\nOf course traditional web bundles are best for most apps, but this expands the range of possibilities into domains traditionally covered by an excel spreadsheet.\r\n\r\n",
      "createdAt": "2021-02-16T02:09:14Z",
      "updatedAt": "2021-02-16T20:58:17Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This sort of thing is supported by the same mechanism that supports domain-trusted signatures. Making it work is primarily a matter of having a client that will define the implications of the bundle being signed by a particular kind of X.509 certificate. For a browser to be that client, we'd need a good answer to \"what appears in the URL bar?\"",
          "createdAt": "2021-02-16T17:05:56Z",
          "updatedAt": "2021-02-16T17:05:56Z"
        },
        {
          "author": "EternityForest",
          "authorAssociation": "NONE",
          "body": "@jyasskin That really is the big question. What goes in the URL bar?\r\n\r\nFiles create a bit of a conflict, because we want the actual file path to be obvious, but it's not really a unique consistent identifier for the document.  A new browser icon letting us know the whole thing was served from a file might be needed for this kind of thing.\r\n\r\nI commented about this in the PDF forms thread (#606), but in short, I think the advantage of allowing certificate-based names based on the overall signature, in the forms use case, is that you can persist form data directly into a bundle file, and it will be immediately obvious to a viewer that this a modified version, in addition to giving it an isolated origin.\r\n\r\nIn the other thread, I suggested that the origin could be a synthetic URL along the lines of \"OverallSignatureHash.originalSXGBasedName.com\", thus authenticating both the modifications, and the original document template.\r\n\r\nSuppose a more advanced web app were distributed as a bundle that could have self-modifying form data.   If the web app asked me to sign in to decrypt something, and my browser stored that password, I would NOT want any of those credentials to also apply to some other modified file created from that same form.\r\n\r\n\r\nGoing further, with the synthetic domain approach that also authenticates that the HTML template came from the original source, it would prevent me from creating my own bundle with malicious JS code to do something the original form publisher didn't intend.\r\n\r\nIf someone sent me an app which was some kind of calculator spreadsheet, that had been customized with some formulas to handle some engineering process (let's say keyhash692nsiNsirhni82.spreadsheet.example), then I would feel a lot more comfortable knowing that the app can only do what spreadsheet.example intends, so I don't have to purely trust the modified version.\r\n\r\n\r\n ",
          "createdAt": "2021-02-16T20:58:17Z",
          "updatedAt": "2021-02-16T20:58:17Z"
        }
      ]
    },
    {
      "number": 623,
      "id": "MDU6SXNzdWU4MDkyNzY5NzA=",
      "title": "Consider separating opaque-origin iframes from subresource loading",
      "url": "https://github.com/WICG/webpackage/issues/623",
      "state": "OPEN",
      "author": "littledan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "In https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md#link-based-api , there is an idea of `urn:uuid:` URLs which can be present in the bundle, which will be treated as a new opaque origin.\r\n\r\nI really like the idea of adding a new web platform feature that makes it easier to create an opaque-origin iframe. This seems genuinely useful for increasing isolation (potentially helping privacy), where there are often multiple units of code that need to be treated with different trust levels. Existing solutions do have problems:\r\n- Blobs can achieve the same semantics, but require that all of the HTML be downloaded, and then put in a blob, and then in an iframe. This blocks important browser optimizations like starting the render before the whole network fetch is done.\r\n- `<iframe sandbox>` can be used declaratively, without this overhead of indirection of storing to and loading from blobs, but its semantics are quite different. Sometimes you don't want these additional restrictions, and you just want an opaque-origin iframe.\r\n\r\nAt the same time, I'm skeptical of the API surface here being linked to URLs inside bundles, for a couple reasons:\r\n- It seems like opaque-origin iframes are useful outside of bundles (and in omit-credentials contexts), even if there are some use cases where it is useful to load their HTML from a bundle.\r\n- There are some annoying edge cases that would have to be defined one way or another, e.g., if multiple bundles define the same UUID.\r\n- There is a kind of \"semantics\" that the URL has--e.g., you can see which origin it comes from--which is more visible if it's not mapped through a UUID.\r\n- There's no way to map loading these opaque URLs to an \"underlying\" URL for potential verification, as suggested in #551\r\n\r\nI want to suggest that, rather than defining UUID URLs to make opaque-origin iframes, a separate attribute is used in the iframe tag, to make the origin opaque, regardless of what the `src` is. For example, we could call it `<iframe opaque>`. [This example](https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md#the-main-document) could instead be written as:\r\n\r\n```html\r\n<link rel=\"webbundle\"\r\n  href=\"https://example.com/dir/subresources.wbn\"\r\n  resources=\"https://example.com/dir/a.js\r\n             https://example.com/dir/b.js\r\n             https://example.com/dir/c.png\r\n             https://example.com/dir/page.html\"\r\n/>\r\n\r\n<script type=\u201dmodule\u201d src=\u201dhttps://example.com/dir/a.js\u201d></script>\r\n<img src=https://example.com/dir/c.png>\r\n<iframe src=\"https://example.com/dir/page.html\" opaque>\r\n```",
      "createdAt": "2021-02-16T12:39:50Z",
      "updatedAt": "2021-04-06T09:42:02Z",
      "closedAt": null,
      "comments": [
        {
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "In a discussion with @jeffkaufman, @yoavweiss, @WebReflection and others, it was pointed out that this `<iframe opaque>` idea would need some additional protections to maintain the integrity of this opacity, that various parties don't make it ineffective:\r\n- Once an `opaque` attribute is added, it cannot be removed.\r\n- The HTML needs to be required to have a matching header indicating the opacity. If you have just the header, or just `opaque`, but not the other, then it is some kind of error.\r\n\r\nIf people are interested in moving this idea forward, I guess it's a bit outside the scope of this repository, and it might make sense to develop further in an HTML PR or even a separate WICG effort preceding that.",
          "createdAt": "2021-02-17T22:33:09Z",
          "updatedAt": "2021-02-17T22:33:09Z"
        },
        {
          "author": "clelland",
          "authorAssociation": "NONE",
          "body": "> * `<iframe sandbox>` can be used declaratively, without this overhead of indirection of storing to and loading from blobs, but its semantics are quite different. Sometimes you don't want these additional restrictions, and you just want an opaque-origin iframe.\r\n\r\nYou could get *just* an opaque subframe with\r\n\r\n```html\r\n<iframe sandbox=\"allow-top-navigation allow-forms allow-scripts allow-popups allow-pointer-lock allow-modals\r\n                 allow-popups-to-escape-sandbox allow-orientation-lock allow-presentation\r\n                 allow-top-navigation-by-user-activation allow-storage-access-by-user-activation\">\r\n```\r\n\r\nBut of course you'd have to update that if a new sandbox feature is added.\r\n\r\nI've proposed a couple of different measures for controlling sandbox flags individually, so that just the opaque origin bit could be controlled independently, but none of them have been satisfying. Something of the flavour\r\n\r\n```html\r\n<iframe policy=\"same-origin=?0\">\r\n```\r\n\r\nwould use Document Policy to that effect, for instance.\r\n\r\nI think that the biggest semantic difference between that and the WebPackage proposal, though, and the biggest question I would have about your proposal, is what happens in further nested frames:\r\n\r\nThe sandbox mechanism ensures that any nested frames have their own unique opaque origins, regardless of the original URLs of their contents, and even get new origins on navigation.\r\n\r\nIn contrast, WebPackage UUIDs would allow an opaque-origined frame to have same-origin children, allowing composite documents to be embedded in an opaque frame and stilll work as originally intended. I suspect (though I haven't checked) that they would also be able to further nest or navigate to URLs which don't have an opaque origin, which sandboxing doesn't allow. By making the opaque-ness part of the URL, rather than the containing `<iframe>` element, it doesn't necessarily apply to any and all content within the frame.",
          "createdAt": "2021-02-19T13:41:12Z",
          "updatedAt": "2021-02-19T13:41:12Z"
        },
        {
          "author": "jeffkaufman",
          "authorAssociation": "NONE",
          "body": "> WebPackage UUIDs would allow an opaque-origined frame to have same-origin children\r\n\r\nThis is also how `data:` and `blob:` URLs are handled today.",
          "createdAt": "2021-02-19T13:58:51Z",
          "updatedAt": "2021-02-19T13:58:51Z"
        },
        {
          "author": "jeffkaufman",
          "authorAssociation": "NONE",
          "body": "A common scenario for ads on the web today is that a page A creates an iframe B which creates an iframe C, where the desired origins are:\r\n\r\nA - B: xorigin\r\nA - C: xorigin\r\nB - C: same origin\r\n\r\nToday this is handled with having B be a safeframe.  UUIDs allow this model (B is `urn:uuid`), while sandbox does not (C inherits the `sandbox`).  I was hoping that `<iframe opaque>` would allow this model?",
          "createdAt": "2021-02-19T14:02:33Z",
          "updatedAt": "2021-02-19T14:02:33Z"
        }
      ]
    },
    {
      "number": 624,
      "id": "MDU6SXNzdWU4MDkzNTQwMTA=",
      "title": "WebBundles for Ad Serving",
      "url": "https://github.com/WICG/webpackage/issues/624",
      "state": "OPEN",
      "author": "jeffkaufman",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "Bundles are a promising way of serving ads. Ad javascript could fetch multiple ads in a single request and host each on its own origin. This would ensure that malicious ads can't read or modify either the publisher page or other ads, and that malicious parties also can't read or modify the ads. While these protections are technically possible today, in a convoluted and inefficient manner, bundles provide them in a clear and natural way, and more efficiently than current web APIs.\r\n\r\n## What's Possible Today\r\n\r\nWhen publishers load Google ads on their pages, they start by including some JavaScript. This ad JS is responsible for sending requests to a server, which decides what ads to show. After the ad server makes its decision it responds with the HTML for each ad, and the ad JS renders the ad HTML to the page. When deciding which ads to return, the server can generally make the best decision if it can consider the whole page simultaneously. For example, one advertiser may not be willing to have their ad appear next to competitors', or the publisher may want to serve a large ad only if the remaining ads are smaller. This means the server should receive a single ad request for the HTML for all the ads on the page.\r\n\r\nThe best we can do today is with `XHR` or `fetch`. The ad JS sends a request, receives a list of the HTML to be written for each ad, creates individual iframes, and finally writes the ad HTML into the iframes. Traditionally, the ad JS created these frames on the same origin as the publisher page. While this is very simple and efficient, it does not offer any security protection. For example, scripts within an ad inserted this way can easily read and modify the publisher page.\r\n\r\n![wbn-doc-1](https://user-images.githubusercontent.com/262566/108074649-75650900-7037-11eb-8c29-cdacbfb09f28.png)\r\n\r\n*ads' HTML fetched with XHR and rendered same-origin*\r\n\r\nTo protect the publisher from potentially harmful ads, the ad JS generally wraps third-party ad HTML in \"[SafeFrames](https://www.iab.com/guidelines/safeframe/)\", an [IAB](https://www.iab.com/) standard way of rendering ads. The ad JS injects an iframe pointing to a container HTML document, hosted by the publisher\u2019s ad server on an isolated subdomain. Ad HTML is then passed into the container through the iframe's name attribute. The container sees this, and overwrites itself with the ad's HTML. Additionally, preventing the ads from interfering with each other requires every ad on the page to use a container loaded from a unique origin, so they will all be cross-origin from each other. Hosting containers on unique origins, however, adds substantial latency, since none of these containers can be cached. Slower loading ads mean worse user experience, primarily due to increased [layout shift](https://web.dev/cls/), and less money for publishers. \r\n\r\n![wbn-doc-2](https://user-images.githubusercontent.com/262566/108074671-7bf38080-7037-11eb-8682-356f7f73fb3a.png)\r\n\r\n*ads' HTML fetched with XHR and rendered via SafeFrame*\r\n\r\nWhile the publisher is now protected, this approach does not protect the ad HTML from the page. The publisher or other third-party scripts on the page can make arbitrary modifications to the HTML before it is passed into the SafeFrame. Similarly, they can read the HTML and extract identifiers that can help bypass click fraud detection. It is possible to protect against this by sending the ad request from a fetching iframe on the ad network domain, and then postMessaging the HTML to receiver iframes. A fetching frame approach, however, imposes both a network round trip and a delay waiting for the container to postMessage that it's ready, which is a large amount of latency.\r\n\r\n![wbn-doc-3](https://user-images.githubusercontent.com/262566/108074716-86157f00-7037-11eb-87ac-46e2fa147e35.png)\r\n\r\n*ads' HTML fetched with XHR in a fetching frame and rendered in a receiver frame*\r\n\r\n## What's Possible with Web Bundles\r\n\r\nWeb Bundles with [subresources](https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md) offer a solution to all of these problems. The ad JS can send a request for a bundle, and the response can contain each ad's HTML as a resource on its own distinct, opaque origin. The ad JS can render an ad by setting the src of an iframe to a resource that's inside the bundle, but nothing on the client can read or modify the ad HTML because the resources are opaque. Similarly, because the origins are distinct, the ads are not able to read or modify each other or the publisher page.\r\n\r\n![wbn-doc-4](https://user-images.githubusercontent.com/262566/108074754-8f9ee700-7037-11eb-9f57-7e6474dabba3.png)\r\n\r\n*ads' HTML fetched as a bundle and rendered via setting the iframe src*\r\n\r\nOverall this is more efficient, in terms of network, CPU, and latency, because it removes the need to load iframes that overwrite themselves with the ad HTML. Bundles allow the ad server to, essentially, say what it means: here are multiple resources that should each be rendered on a unique origin.\r\n\r\nSpecifically, what makes bundles useful for ad serving is that they provide:\r\n\r\n* A way to make a single fetch that loads several cross-origin HTML resources into a staging area for the page.\r\n  * There's no harm in putting these resources into the global cache, but it also doesn't help because they're never re-used.\r\n* A way to load an iframe whose src is one of those resources.\r\n  * It's ok if the iframes wind up with opaque origins instead of re-usable origins.\r\n  * The iframes don't need to load their own subresources from the bundle.\r\n* The surrounding page can't read or modify the resources.\r\n  * A process that starts with `fetch`, for example, is not sufficient because the page can override `fetch`.",
      "createdAt": "2021-02-16T14:21:40Z",
      "updatedAt": "2021-04-06T09:42:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jeffkaufman Thanks for the writeup. Would the mechanism suggested in #623 work for your use case?",
          "createdAt": "2021-02-16T15:47:17Z",
          "updatedAt": "2021-02-16T15:47:17Z"
        },
        {
          "author": "jeffkaufman",
          "authorAssociation": "NONE",
          "body": "Sort of: either `<iframe src=\"urn:uuid:...\">` and `<iframe opaque src=\"https://...\">` would work for this use, but the \"There's no way to map loading these opaque URLs to an 'underlying' URL for potential verification, as suggested in #551\" aspect doesn't.  These ads are ephemeral, and there wouldn't really be any sort of 'underlying' URL.",
          "createdAt": "2021-02-16T17:07:28Z",
          "updatedAt": "2021-02-16T17:07:28Z"
        },
        {
          "author": "WebReflection",
          "authorAssociation": "NONE",
          "body": "hi @jeffkaufman , I have a question regarding this point:\r\n\r\n> These ads are ephemeral, and there wouldn't really be any sort of 'underlying' URL.\r\n\r\ncould you please expand a bit on *how* extensions will see these iframes? more specifically:\r\n\r\n  * will extensions *run* within these kind of iframes?\r\n  * if the answer is yes, what would be the origin in there?\r\n  * if the answer (to the first point) is yes, do these iframes allow extensions to understand at least the original bundle they come from?\r\n\r\nThanks in advance for any kind of help in clarifying more these aspects of the `urn:` proposal: I see benefits, as you mentioned, and not ads related only, but I'd like to fully understand what's the idea behind.",
          "createdAt": "2021-02-16T18:53:15Z",
          "updatedAt": "2021-02-16T18:53:52Z"
        },
        {
          "author": "jeffkaufman",
          "authorAssociation": "NONE",
          "body": "@WebReflection It sounds like you're asking a broader question about https://github.com/WICG/webpackage/blob/master/explainers/subresource-loading.md, and not about the aspects that make it a good fit for ad loading? I think your questions might make more sense as a top level issue? ",
          "createdAt": "2021-02-16T20:15:39Z",
          "updatedAt": "2021-02-16T20:15:39Z"
        },
        {
          "author": "jeffkaufman",
          "authorAssociation": "NONE",
          "body": "@littledan Actually, I'm not sure `<iframe opaque>` does work, at least on its own since we have to trust the publisher not to remove the `opaque`.  Would a response header work?",
          "createdAt": "2021-02-17T18:33:47Z",
          "updatedAt": "2021-02-17T18:33:47Z"
        }
      ]
    },
    {
      "number": 630,
      "id": "MDU6SXNzdWU4MjE4NjU0MTA=",
      "title": "Subresource loading: Add a section to explain how resource-bundles are related.",
      "url": "https://github.com/WICG/webpackage/issues/630",
      "state": "OPEN",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "We should spell out how \"Subresource loading with Web Bundles\" are related to [WICG/resource-bundles](https://github.com/WICG/resource-bundles/) in its [explainer](https://github.com/WICG/webpackage/blob/main/explainers/subresource-loading.md).\r\n\r\nThe context: https://github.com/w3ctag/design-reviews/issues/616#issuecomment-790395734\r\n",
      "createdAt": "2021-03-04T07:53:21Z",
      "updatedAt": "2021-04-06T09:42:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We should also update the [alternate designs](https://github.com/WICG/webpackage/blob/main/explainers/subresource-loading.md#alternate-designs) with some of the ideas from [resource-bundles](https://github.com/WICG/resource-bundles/blob/main/subresource-loading.md#example) and [MT's post](https://lowentropy.net/posts/bundles/#indirection-for-identifiers).",
          "createdAt": "2021-03-05T00:34:40Z",
          "updatedAt": "2021-03-05T00:34:48Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "A good point. Some of alternative designs have not been updated, and I'm feeling a bit outdated.\r\nWe should collect alternative designs and summarize them in the explainer.",
          "createdAt": "2021-03-05T03:40:04Z",
          "updatedAt": "2021-03-05T03:40:04Z"
        }
      ]
    },
    {
      "number": 638,
      "id": "MDU6SXNzdWU4MzM0ODg5MDA=",
      "title": "Content Addressable Bundles",
      "url": "https://github.com/WICG/webpackage/issues/638",
      "state": "OPEN",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "Let me file an issue to discuss a proposal: [Resource Loading with Content Addressable Bundles](https://github.com/WICG/webpackage/blob/main/explainers/content-addressable-bundles.md).\r\n\r\nThis is a strawperson proposal at very early stage, and this can be positioned as \"my personal proposal\", as of now.\r\n\r\nI've put it in `explainer` directory, however, if that is inappropriate and confusing, I'll move it to somewhere. Maybe we can have `proposals` directory, as [WICG/webcomponenets has](https://github.com/WICG/webcomponents/tree/gh-pages/proposals).  I am not sure what is the best practice in this repository. \r\n\r\nI hope we can use this issue to discuss and get early feedback.\r\nI've observed that PRs are not a good place to discuss overall design and ideas because we are likely to lose the discussion history. An issue might be a better place to discuss.\r\n\r\ncc: @littledan @jyasskin @yoavweiss ",
      "createdAt": "2021-03-17T07:35:07Z",
      "updatedAt": "2021-04-06T09:42:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for filing this issue. As I mentioned at today\u2019s meeting, the goal of this proposal is still unclear for me.\r\n\r\n> - This proposal aims to support Code Splitting, as webpack or other bundlers\r\n   already support as a user-land solution. Smaller bundles, if used correctly,\r\n   can have a major impact on load time.\r\n\r\nAs written in this page (https://webpack.js.org/guides/code-splitting/), the purpose of Code Splitting is to \u201c[have a major impact on load time](https://webpack.js.org/guides/code-splitting/#:~:text=have%20a%20major%20impact%20on%20load%20time)\u201d. It would be helpful if you can write more precisely how this proposal can support this purpose, and why it is better than just using the existing proposal \"[Subresource loading with Web Bundles](https://github.com/WICG/webpackage/blob/main/explainers/subresource-loading.md)\".\r\n\r\n\r\n> - Non-opinionated about bundle granularity. There are trade-offs how a site\r\n  composes their resources into bundles in order to balance various factors like\r\n  total bytes transferred, loading latency, or cache granularity. Instead of a\r\n  _all-or-nothing_ bundle, this proposal aims to provide a way to express a\r\n  dependency graph of bundles. The use of bundlers is an established practice in\r\n  Web development. Bundlers, such as webpack, skypack, would know much about\r\n  which resources should be grouped as a bundle, and might want to express their\r\n  intent as a dependency graph of bundles, considering various trade-offs. They\r\n  wouldn't want to lose this information in building an all-or-nothing bundle,\r\n  and a browser wants to know it to improve a loading performance.\r\n\r\nI understand the importance of carefully maintaining the dependency graph of modules while developing.\r\nBut I don't know why it is important to keep the dependency graph inside bundle format while serving the codes to browsers. Who will be happy if the precise dependency graph is provided to the browser via bundle format? Could you please explain the use cases of it?\r\n\r\n> - The proposal aims to give a browser an opportunity to improve their cache\r\n  efficiency by introducing _immutability_ to a bundle. If a bundle's URL\r\n  doesn't change, we assume the bundle's contents are _exactly_ same. This is\r\n  not an effort by a convention. The proposal aims to _force_ immutability by\r\n  introducing a Content-Addressable Hash, which is conceptually similar to a\r\n  Git's commit ID you might be familiar with. Content-Addressability gives web\r\n  developers reproducible builds as well as giving a browser an opportunity to\r\n  improve their cache efficiency.\r\n\r\nI don't understand how other browsers work. But in Chromium, the code cache generated by V8 engine is stored in the HTTPCache. And the code cache will be used when the cached HTTP response is still valid. So I'm not clear how this forced  immutability can improve the cache efficiency, especially when the HTTPCache is split per Origin. Could you please write more detailed explanation? \r\n",
          "createdAt": "2021-03-17T12:36:27Z",
          "updatedAt": "2021-03-17T12:36:27Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Note: I'm working on updating the proposal at  https://github.com/WICG/webpackage/pull/639, answering the questions. Thanks!",
          "createdAt": "2021-03-23T07:29:17Z",
          "updatedAt": "2021-03-23T07:29:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Some overall thoughts:\r\n\r\n1. I think it would help to create an `explainers/proposals/` directory to distinguish things that we're pretty confident are a good direction from things that we're just exploring.\r\n\r\n1. The Introduction and Goals sections don't explain to me why this proposal exists. \"there is no mechanism to fetch the partial content of the bundle.\" makes me think that it's going to be an alternative to the subsetting options in @littledan's https://github.com/WICG/resource-bundles/blob/main/subresource-loading.md, but I don't see anything about the request headers to let the server know which subset to request, or anything about when to request a byte range from a bundle. \r\n\r\n1. https://github.com/WICG/webpackage/issues/40 discusses the goal to let bundles declare that they depend on another bundle. Is that actually what this is about?\r\n\r\n1. \"Content-addressable\" makes me think these items will be identified purely by their hashes, but it looks like they pair a real URL with a hash of the content that's expected to be there, and reject the content if it doesn't match. That makes them more similar to subresource integrity.\r\n\r\n1. I thought through ways to refer to sub-packages in [draft-yasskin-dispatch-web-packaging](https://tools.ietf.org/id/draft-yasskin-dispatch-web-packaging-00.html#rfc.section.2.4.1). Those were all embedded into the overall package, rather than external URLs, but some of the same considerations apply. In particular, do we always want to refer by exact hash, or does it make sense to also allow a minimum timestamp, or more complete [semver](https://semver.org/)-ish version compatibility?\r\n\r\n1. I'm not sure it makes sense to designate a \"main resource\" for subresource bundles. e.g. if we want to bundle a bunch of images together, or a stylesheet with a script, they're all peers. It's only trees of scripts and stylesheets that have a notion of an entrypoint. This is part of @littledan's motivation for https://github.com/WICG/webpackage/pull/617.\r\n\r\n",
          "createdAt": "2021-03-24T21:26:06Z",
          "updatedAt": "2021-03-24T21:26:06Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @jyasskin! I really appreciate your feedback!\r\n\r\nLet me reply for some of feedback if I can answer to them briefly. For other feedback, let me take that into consideration and improve the proposal based on the feedback.\r\n\r\nRe 1:\r\nSounds good! Let me put a proposal into `explainers/proposals`. I'm thinking of splitting the current proposal into two proposals: 1) Declare dependencies to external bundles, and 2) Content Addressable Bundles, in order to make each proposals more understandable and  their use cases and goals more clear.  Let me put them into  `explainers/proposals` once I finish splitting. That might take some time.\r\n\r\nRe 3, 5:\r\nI didn't know #40. Thanks! That seems to share a common goal. Let me mention #40, and use #40 for further discussion.\r\n\r\nRe 6:\r\nThat's one of TODO items. I'm still exploring how *entry points* should be. I'm now looking how `webpack` works to learn what they have been doing. Yes, #617 is related. Thanks! \r\n\r\n\r\nI'll keep this issue up-to-date once I have more insights.\r\n\r\n\r\n\r\n\r\n",
          "createdAt": "2021-03-29T04:00:02Z",
          "updatedAt": "2021-03-29T04:00:02Z"
        }
      ]
    },
    {
      "number": 641,
      "id": "MDU6SXNzdWU4Mzk0OTA3OTA=",
      "title": "Split the Subresource Loading with Web Bundles Explainer into two parts 1) core part and 2) extension parts.",
      "url": "https://github.com/WICG/webpackage/issues/641",
      "state": "OPEN",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "It would be better to split the [Subresource Loading with WebBundles](https://github.com/WICG/resource-bundles/blob/main/subresource-loading.md) Explainer into two parts 1) core part and 2) extension parts.\r\n\r\n- Core part, which explain the common basic APIs for Subresource Loading\r\n- Extension parts:\r\n  -  Support urn::uuid resources and opaque origins (for use case #624)\r\n  - Any other extensions...\r\n\r\nWe might want to split an explainer into two files, physically, so that separation (and API boundary) would become clear.\r\n\r\nBy having a core part, we hope we can find a common part in various proposals, and we can write extension parts on the top of it and discuss separately.\r\n\r\nRelated issue: #623\r\n",
      "createdAt": "2021-03-24T08:45:52Z",
      "updatedAt": "2021-04-06T09:42:03Z",
      "closedAt": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Do we think subsetting belongs in the core, or as https://lowentropy.net/posts/bundles/ suggests, should we treat it as one of the first extensions?",
          "createdAt": "2021-03-24T17:55:37Z",
          "updatedAt": "2021-03-24T17:55:37Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "A good question. That's what we have to explore and decide, however, my current rough thinking (based on my early impression) is:\r\n\r\n## Core:\r\n- Explainer: Subresource Loading with Web Bundles (Define a basic loading semantics from a bundle)\r\n\r\n## Extensions:\r\n- Dynamic Web Bundles  (subsetting; resource batch preloading). (We need a server side support as an extension)\r\n- Support urn:uuid resources and opaque origins (for use case #624)\r\n- [Just proposal] Declare dependencies to external bundles (should be separated from Content Addressable Bundles proposal)\r\n- [Just proposal] Content Addressable Bundles\r\n- Any others...\r\n\r\nJust my idea as a starting point of a discussion.\r\n",
          "createdAt": "2021-03-25T02:42:38Z",
          "updatedAt": "2021-03-25T02:42:38Z"
        }
      ]
    },
    {
      "number": 642,
      "id": "MDU6SXNzdWU4Mzk4NzEyMDg=",
      "title": "Clarify how to handle using sub resource web bundles when browsers support it, and traditional bundlers when they dont",
      "url": "https://github.com/WICG/webpackage/issues/642",
      "state": "OPEN",
      "author": "SinZ163",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "Title is a bit verbose but gets the point across.\r\n\r\nWith script tags, when module support was added, nomodule was also added so you could have both in your markup and the browsers that knew modules loaded modules and intentionally didn't load nomodules, I feel a similar pattern is needed for WebBundles.\r\n\r\nIn the chromium Origin Trial, it is mentioned that its possible in JS to do feature detection for this, but that would require having web app developers to effectively polyfill webbundles ourselves and only add the JS bundle script tag at runtime once feature detection has happened, increasing the size of the html body and adding latency when instead this feature can ship with polyfill mechanisms baked in.",
      "createdAt": "2021-03-24T15:53:50Z",
      "updatedAt": "2021-04-06T09:35:26Z",
      "closedAt": null,
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Introducing `<script nowebbundle type=text/javascript src=bundle.js></script>` could be a solution for this.\r\n\r\nCurrently we are using link elements for subresource web bundles in the Origin Trial.\r\nBut there is a discussion to use `<script>` elements for security reason.\r\nSo if we introduce`<script type=webbundle>` elements instead of `<link rel=webbundle>`, introducing `<script nowebbundle>` sounds plausible.\r\n",
          "createdAt": "2021-03-29T04:30:09Z",
          "updatedAt": "2021-03-29T04:30:09Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "CC: @littledan ",
          "createdAt": "2021-03-29T04:31:36Z",
          "updatedAt": "2021-03-29T04:31:36Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "We don't have any special support for an unsupported environment yet. So I guess a workaround would be a general one, such as:\r\n\r\n```js\r\n<script>\r\nif (!feature_detection()) {\r\n  const script = document.createElement('script') ;\r\n  script.src = \".../traditional-bundle-runtime.js\";\r\n  document.body.appendChild(script);\r\n  ...\r\n}\r\n</script>\r\n```\r\n\r\nThis might add *latency*, as you mentioned.",
          "createdAt": "2021-03-29T04:41:32Z",
          "updatedAt": "2021-03-29T04:41:49Z"
        }
      ]
    },
    {
      "number": 644,
      "id": "MDU6SXNzdWU4NDQwODM1NjE=",
      "title": "Define how CORP and COEP should work for subresource loading",
      "url": "https://github.com/WICG/webpackage/issues/644",
      "state": "OPEN",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "- CORP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Cross-Origin_Resource_Policy_(CORP)\r\n- COEP: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cross-Origin-Embedder-Policy\r\n\r\nWe need to figure out how CORP and COEP should work for Subresource loading with WebBundles.\r\n\r\nChromium side issue is [here](https://bugs.chromium.org/p/chromium/issues/detail?id=1163788).\r\n",
      "createdAt": "2021-03-30T05:17:01Z",
      "updatedAt": "2021-04-06T09:33:20Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me start to figure out what is a desired behavior at pretty high level, as a starting point of a discussion.\r\n\r\n### For the bundle:\r\nCORP and COEP are irrelevant because a browser always use CORS to fetch the bundle.\r\n\r\n### For the resources within the bundle:\r\nA browser **must** check a response header of a resource in a bundle.\r\n e.g.  The resources within the bundle need \"Cross-Origin-Resource-Policy: cross-origin\" response header if they are intended for the cross-origin page which has \"Cross-Origin-Embedder-Policy: require-corp\", and so on.\r\n",
          "createdAt": "2021-03-30T05:39:49Z",
          "updatedAt": "2021-03-30T05:39:49Z"
        },
        {
          "author": "abflow",
          "authorAssociation": "NONE",
          "body": "Related in whatwg/html\r\nProposal: Deprecation of \"cross-origin-policy\" in favor of a declarative network isolation of insecure HTML tags ([#6553](https://github.com/whatwg/html/issues/6553))",
          "createdAt": "2021-04-03T08:10:59Z",
          "updatedAt": "2021-04-03T08:10:59Z"
        }
      ]
    },
    {
      "number": 647,
      "id": "MDU6SXNzdWU4NTMwNjA4MjI=",
      "title": "Support a relative URL of a resource in a bundle.",
      "url": "https://github.com/WICG/webpackage/issues/647",
      "state": "OPEN",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "It might be worth considering to support a relative URL in the bundle format.\r\n\r\nI've heard this feature request from several people. I've searched an existing issue, but I couldn't find one so let me file an issue.\r\n\r\nUse cases:\r\n\r\nRegarding [subresource loading](https://github.com/WICG/webpackage/blob/main/explainers/subresource-loading.md) use case, we use the following syntax in the main doc:\r\n\r\n```html\r\n<link rel=webundle href=https://example.com/app/bundle.wbn resources=\".....\">\r\n```\r\n\r\nBecause we have *path restriction*, the resources in the bundle *must* start with `https://example.com/app/`, such as:\r\n\r\n- https://example.com/app/top.js\r\n- https://example.com/app/util1.js\r\n- https://example.com/app/util2.js\r\n- ...\r\n\r\nIt seems a bit redundant.  If we support a relative URL, each subresource doesn't have to include a redundant common prefix, and can be:\r\n\r\n- ./top.js\r\n- ./util1.js\r\n- ./util2.js\r\n- ...\r\n\r\nWe have to decide on which `base` a relative URL should be resolved. For subresource loading use cases, it's clear. \r\nFor other use cases, TBD. \r\n\r\nThe other benefits are:\r\n\r\n- A bundle can be more portable. For example, we can move `bundle.wbn` from https://example.com/app/ to https://example.com/other/, freely, without re-creating a bundle.\r\n- The size of a bundle can be reduced.  \r\n\r\n",
      "createdAt": "2021-04-08T05:00:23Z",
      "updatedAt": "2021-04-08T17:27:59Z",
      "closedAt": null,
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/WICG/webpackage/pull/617 can be related. We need to make primary URL optional.",
          "createdAt": "2021-04-08T05:13:44Z",
          "updatedAt": "2021-04-08T05:14:17Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yep, I think we do this by either\r\n1. putting the base URL in a section (possibly one holding a map of several metadata values), or\r\n2. using the bundle's URL as the base.",
          "createdAt": "2021-04-08T17:27:58Z",
          "updatedAt": "2021-04-08T17:27:58Z"
        }
      ]
    },
    {
      "number": 648,
      "id": "MDU6SXNzdWU4NTQzNzg3MzY=",
      "title": "[Meta] A long term plan for subresource loading",
      "url": "https://github.com/WICG/webpackage/issues/648",
      "state": "OPEN",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "subresource-loading"
      ],
      "body": "Hi folks!\r\n\r\nLet us share the current status and a future plan about [Subresource Loading with Web Bundles].\r\n\r\n## Status:\r\n\r\n- We're starting an origin trial in Chrome (M90 - M92). [Landing page].\r\n\r\nIf we don't find any significant issue in OT and this feature is promising, as the next step, we'll work on addressing any\r\nblocking issues or support feature requests, considering feedback from OT, so that we can ship\r\nMVP (*v1*).\r\n\r\n## Tentative plan (No ETA):\r\n\r\nNote: The following mentions only *features*. Any standard works or other tasks are not included.\r\n\r\n### v1 (We consider MVP should be shipped with these features)\r\n\r\n- [ ] The core part: [Subresource Loading with Web Bundles]\r\n- [ ] The extension: [Support opaque origin iframes]\r\n  - [ ] Change urn:uuid to other scheme (TODO: File an issue)\r\n- [ ] Make primary URL optional (#616)\r\n  - [ ] Needs to update the bundle format.\r\n- [ ] Support a relative URL of a resource in a bundle (#647)\r\n  - [ ] Needs to update the bundle format?\r\n- [ ] New syntax: Use `<script>` tag and define its scheme\r\n  - [ ] TODO: File an issue.\r\n- [ ] CORP and COEP (#644)\r\n- [ ] Increment the bundle format version?\r\n\r\n### v2 (We consider these are important, but not absolutely required for shipping MVP)\r\n\r\n- [ ] Subsetting ([Resource Batch Preloading], [Resource Bundles])\r\n  - [Chromium side design doc](https://docs.google.com/document/d/159wbsjWh13xpwZbK-4LNNHcbtRROiXAJSabunJXWEzs/edit), based on [Resource Bundles] proposal.\r\n\r\n### v3 (Strawperson ideas, which are not triaged well yet)\r\n\r\n- [ ] Use the index section as an alternative of a \u201cresources=\u201d attribute value\r\n  ([cab] mentions this)\r\n  - [ ] TODO: File an issue on GitHub.\r\n- [ ] Declare dependencies to external bundles (#596, #40, [cab])\r\n  - [ ] Needs to update the bundle format\r\n- [ ] Resource Hints with webbundle\r\n  - `<link rel=prefetch-for-navigation href=\u201d//example.com/nextpage.wbn\u201d page=\u201d//example.com/nextpage.html\u201d>`\r\n  - [ ] Needs a concrete proposal.\r\n- [ ] [Content Addressable Bundles]\r\n\r\nWe'll try to keep this plan up-to-date.\r\n\r\n[subresource loading with web bundles]:\r\n  https://github.com/WICG/webpackage/blob/main/explainers/subresource-loading.md\r\n[support opaque origin iframes]:\r\n  https://github.com/WICG/webpackage/blob/main/explainers/subresource-loading-opaque-origin-iframes.md\r\n[landing page]:\r\n  https://chromium.googlesource.com/chromium/src.git/+/refs/heads/main/content/browser/web_package/subresource_loading_origin_trial.md\r\n[cab]:\r\n  https://github.com/hayatoito/webpackage/blob/content-addressable-bundles/explainers/content-addressable-bundles.md\r\n[content addressable bundles]:\r\n  https://github.com/hayatoito/webpackage/blob/content-addressable-bundles/explainers/content-addressable-bundles.md\r\n[resource batch preloading]:\r\n  https://gist.github.com/littledan/e01801001c277b0be03b1ca54788505e\r\n[resource bundles]: https://github.com/WICG/resource-bundles\r\n",
      "createdAt": "2021-04-09T10:06:41Z",
      "updatedAt": "2021-04-09T10:13:07Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 1,
      "id": "MDExOlB1bGxSZXF1ZXN0OTIzODcxMTE=",
      "title": "Adds a few example pack files and component files.",
      "url": "https://github.com/WICG/webpackage/pull/1",
      "state": "CLOSED",
      "author": "mrdewitt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also defines a \".attributes\" file for those files that should be\r\nincluded with either specific headers or from subpackages.",
      "createdAt": "2016-11-04T17:54:51Z",
      "updatedAt": "2016-12-02T23:38:29Z",
      "closedAt": "2016-12-02T23:38:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzI1Mzc1MQ==",
          "commit": {
            "abbreviatedOid": "727697f"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2016-11-04T17:57:49Z",
          "updatedAt": "2016-11-04T17:57:49Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Would be nice to avoid base64 from the start... would guthub barf if it was just a binary image?\n",
              "createdAt": "2016-11-04T17:57:49Z",
              "updatedAt": "2016-12-02T23:38:29Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d0d3a32a80c80663f5011671b3445fead44b4e30",
      "headRepository": "mrdewitt/webpackage",
      "headRefName": "master",
      "headRefOid": "d0d3a32a80c80663f5011671b3445fead44b4e30",
      "mergeCommit": null
    },
    {
      "number": 4,
      "id": "MDExOlB1bGxSZXF1ZXN0OTQyMTgwOTg=",
      "title": "readme: tiny typo fix",
      "url": "https://github.com/WICG/webpackage/pull/4",
      "state": "MERGED",
      "author": "isaacs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "s/subresourcves/resources/",
      "createdAt": "2016-11-17T17:57:26Z",
      "updatedAt": "2016-11-17T21:54:18Z",
      "closedAt": "2016-11-17T21:54:18Z",
      "mergedAt": "2016-11-17T21:54:18Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyNjA3Nw==",
          "commit": {
            "abbreviatedOid": "0418647"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2016-11-17T21:50:09Z",
          "updatedAt": "2016-11-17T21:50:09Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e0653f1674e4909cc7a2a8f835d8ce669113e26f",
      "headRepository": "isaacs/webpackage",
      "headRefName": "patch-1",
      "headRefOid": "0418647ef0d19d6d1453b0c87865ff2f139d0a55",
      "mergeCommit": {
        "oid": "0418647ef0d19d6d1453b0c87865ff2f139d0a55"
      }
    },
    {
      "number": 5,
      "id": "MDExOlB1bGxSZXF1ZXN0OTQyMTgzMzU=",
      "title": "readme: tiny typo fix",
      "url": "https://github.com/WICG/webpackage/pull/5",
      "state": "MERGED",
      "author": "isaacs",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "s/tot he/to the/",
      "createdAt": "2016-11-17T17:58:43Z",
      "updatedAt": "2016-11-17T21:49:30Z",
      "closedAt": "2016-11-17T21:49:30Z",
      "mergedAt": "2016-11-17T21:49:30Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyNTg2OQ==",
          "commit": {
            "abbreviatedOid": "11ad43b"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!\n",
          "createdAt": "2016-11-17T21:49:18Z",
          "updatedAt": "2016-11-17T21:49:18Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e0653f1674e4909cc7a2a8f835d8ce669113e26f",
      "headRepository": "isaacs/webpackage",
      "headRefName": "patch-2",
      "headRefOid": "11ad43b3b57f0468512d389865e093d6cb0196eb",
      "mergeCommit": {
        "oid": "e8d05ee8af8a8ecdcb01b6be2a6f468ee5999a96"
      }
    },
    {
      "number": 18,
      "id": "MDExOlB1bGxSZXF1ZXN0OTYzNzcxMjM=",
      "title": "Adds a comment about relative indexing.",
      "url": "https://github.com/WICG/webpackage/pull/18",
      "state": "MERGED",
      "author": "mrdewitt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes Issue #17.",
      "createdAt": "2016-12-03T00:37:02Z",
      "updatedAt": "2016-12-06T23:18:06Z",
      "closedAt": "2016-12-06T02:53:06Z",
      "mergedAt": "2016-12-06T02:53:06Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d0d3a32a80c80663f5011671b3445fead44b4e30",
      "headRepository": "mrdewitt/webpackage",
      "headRefName": "nested-relative-indexes",
      "headRefOid": "45bf2223ef53764c5b42ae614744267aa7fe90ed",
      "mergeCommit": {
        "oid": "4749434e67297a3c839399dd4d1fceb1ac334f31"
      }
    },
    {
      "number": 19,
      "id": "MDExOlB1bGxSZXF1ZXN0OTY2MTY0ODM=",
      "title": "Adds an initial version of a packager script.",
      "url": "https://github.com/WICG/webpackage/pull/19",
      "state": "MERGED",
      "author": "mrdewitt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This script can be updated alongside the explainer to give a concrete\r\nanswer to many format-related questions, and to uncover and resolve\r\nambiguities in the proposed spec.\r\n\r\nMany parts of the spec are unimplemented as yet.",
      "createdAt": "2016-12-05T21:52:18Z",
      "updatedAt": "2016-12-06T02:50:50Z",
      "closedAt": "2016-12-06T02:50:50Z",
      "mergedAt": "2016-12-06T02:50:50Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Great! This looks like a good start, looking forward for the rest of it.",
          "createdAt": "2016-12-06T02:50:14Z",
          "updatedAt": "2016-12-06T02:50:14Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d0d3a32a80c80663f5011671b3445fead44b4e30",
      "headRepository": "mrdewitt/webpackage",
      "headRefName": "packager",
      "headRefOid": "4d2cc42fc43b720ba4918673f960457d399138a1",
      "mergeCommit": {
        "oid": "d6f7649ed47a2c55796ffc780aedd4eb0f91531f"
      }
    },
    {
      "number": 21,
      "id": "MDExOlB1bGxSZXF1ZXN0OTg5NTM3NTU=",
      "title": "Explicitly note Content Index Entries content boundaries",
      "url": "https://github.com/WICG/webpackage/pull/21",
      "state": "MERGED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Just explicit bound checking.",
      "createdAt": "2016-12-21T15:37:00Z",
      "updatedAt": "2017-01-04T01:45:50Z",
      "closedAt": "2017-01-04T01:45:50Z",
      "mergedAt": "2017-01-04T01:45:50Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwNDY3MDc=",
          "commit": {
            "abbreviatedOid": "0a169b3"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-01-04T01:45:43Z",
          "updatedAt": "2017-01-04T01:45:43Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4749434e67297a3c839399dd4d1fceb1ac334f31",
      "headRepository": "bmeck/webpackage",
      "headRefName": "oob",
      "headRefOid": "0a169b3bfbaed53e455b10525dbd771ea3e98318",
      "mergeCommit": {
        "oid": "5ab2bc15915e53043085a76cd42680ba7b91aa7e"
      }
    },
    {
      "number": 22,
      "id": "MDExOlB1bGxSZXF1ZXN0OTk1NTY3NzY=",
      "title": "No need for algorithm header, fixes #14",
      "url": "https://github.com/WICG/webpackage/pull/22",
      "state": "MERGED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes #14 ",
      "createdAt": "2016-12-28T14:48:53Z",
      "updatedAt": "2017-01-05T02:08:54Z",
      "closedAt": "2017-01-05T02:08:54Z",
      "mergedAt": "2017-01-05T02:08:54Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Yes, X.509 certs always have the algorithm.  What are types of certs are\nyou thinking - (Open)PGP?\n\nOn Wed, Jan 4, 2017 at 10:04 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> *@bmeck* commented on this pull request.\n> ------------------------------\n>\n> In README.md <https://github.com/dimich-g/webpackage/pull/22>:\n>\n> > @@ -185,13 +185,14 @@ The example contains an HTML page and an image. The package is signed by the exa\n>  Important notes:\n>\n>  1. The very first header in Package Header section of the package is **Package-Signature**, a new header that contains a signed hash of the Package Header section (not including Package-Signature header) and Content Index. It also contains a reference (via cid: UUID-based URL) to the part that contains the public key certificate (or if needed, a chain of certificates to the root CA).\n> -2. The **algorithm** attribute contains a type of hash and signature algorithm used ('sha384-with-ECDSA' in this case) and the encrypted hash of the Content Index. It is encoded as [Integrity Metadata in SRI spec](https://www.w3.org/TR/SRI/#integrity-metadata). *Should there be '-with-ECDSA' since certificate specifies the key's algorithm?*\n> -2. The Content Index contains hashes of all parts of the package, so it is enough to validate the index to trust its hashes, then compute the hash of the each part upon using it to validate each part. Hashes have hash algorithm specified in front.\n> -3. The inclusion of certificate makes it possible to validate the package offline (certificate revocation aside, this can be done out-of-band when device is actually online).\n> -4. Certificate is included as one of standard the DER-encoded resource (with proper Content-type).\n> +2. The **algorithm** must be encoded within the certificate that signed the package.\n> +3. The Content Index contains hashes of all parts of the package, so it is enough to validate the index to trust its hashes, then compute the hash of the each part upon using it to validate each part. Hashes have hash algorithm specified in front.\n> +4. Content Index Entry `part-location` and `part-size` must not refer to locations outside of the package which contains the entry or locations within nested packages. They may refer to the boundaries of a nested package.\n>\n> if we only have X.509 I think it will always contain a Signature\n> Algorithm, but I might want to investigate other cert types to see if they\n> also always carry that.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/22>, or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNW6WNocVAy99JuZEOG0Zj2IbmGqHks5rO7URgaJpZM4LW92->\n> .\n>\n",
          "createdAt": "2017-01-04T15:24:01Z",
          "updatedAt": "2017-01-04T15:24:01Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol PGP in real world scenarios I could see being a candidate. I once heard of npm modules potentially being signed for publish using developer SSH keys, but I don't want that.",
          "createdAt": "2017-01-04T15:28:45Z",
          "updatedAt": "2017-01-04T15:28:45Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol PGP Version3 appears to mandate the hash algorithm as well, but only in the signature packet https://tools.ietf.org/html/rfc4880#section-5.2.2, not in the key packet https://tools.ietf.org/html/rfc4880#section-5.2.2 . To remove the algorithm in `Package-Signature` we would also need to mandate a signature packet which somewhat defeats the purpose here.",
          "createdAt": "2017-01-04T17:41:27Z",
          "updatedAt": "2017-01-04T17:41:27Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Or we decide that signing of web packages via PGP key isn't a goal.  And\nwhile I love many things about PGP (having worked with Phil and the\noriginal team back in the 90's) - it unfortunately never reached wide\nadoption.  I think we would better served with an X.509-only based solution\nthat is simpler.\n\nOn Wed, Jan 4, 2017 at 12:41 PM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> PGP Version3 appears to\n> mandate the hash algorithm as well, but only in the signature packet\n> https://tools.ietf.org/html/rfc4880#section-5.2.2, not in the key packet\n> https://tools.ietf.org/html/rfc4880#section-5.2.2 . To remove the\n> algorithm in Package-Signature we would also need to mandate a signature\n> packet which somewhat defeats the purpose here.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/22#issuecomment-270434932>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNdbNTK2scugXzM1WV7POZGlhh5k7ks5rO9nHgaJpZM4LW92->\n> .\n>\n",
          "createdAt": "2017-01-04T18:33:02Z",
          "updatedAt": "2017-01-04T18:33:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5ODAzODc=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "this change lgtm pending small adjustment for clarity",
          "createdAt": "2017-01-03T18:10:00Z",
          "updatedAt": "2017-01-03T18:14:19Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "For clarity, could you change \"locations within nested packages\" to \"to locations within nested packages\"",
              "createdAt": "2017-01-03T18:10:00Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUwNDczOTU=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-04T01:56:23Z",
          "updatedAt": "2017-01-04T01:56:24Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@mrdewitt I'm separately merging your suggestion since it was a part of another pr, thanks!\r\n@bmeck There should at least be an algorithm used for the hash, right? While the encryption algorithm is specified in the certificate, the specific form of hash used here can vary (not a part of cert) so needs to be mentioned.\r\n",
              "createdAt": "2017-01-04T01:56:24Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxMjQ3NjM=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-04T14:55:03Z",
          "updatedAt": "2017-01-04T14:55:03Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "@dimich-g ah yes, that is a good point the I was just looking at how Content Index Entry has its own algorithm and missed that we still need the hash-algorithm in the Package-Signature. I put the hash algorithm back in Package-Signature, but we can still drop the cert one.",
              "createdAt": "2017-01-04T14:55:03Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxMjU3ODE=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-04T14:59:59Z",
          "updatedAt": "2017-01-04T14:59:59Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "fixed.",
              "createdAt": "2017-01-04T14:59:59Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxMjY3ODg=",
          "commit": {
            "abbreviatedOid": "c5dafa2"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-04T15:04:49Z",
          "updatedAt": "2017-01-04T15:04:49Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "if we only have X.509 I think it will always contain a Signature Algorithm, but I might want to investigate other cert types to see if they also always carry that.",
              "createdAt": "2017-01-04T15:04:49Z",
              "updatedAt": "2017-01-05T02:04:23Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e8447a71176ac69fef0f73e848d9dc1e104b6641",
      "headRepository": "bmeck/webpackage",
      "headRefName": "no-algorithm",
      "headRefOid": "b5c3ec15533e0b3f2d51b1424486c47621f22777",
      "mergeCommit": {
        "oid": "a9d9999aba630130beb65a2f841df21a143fe7a6"
      }
    },
    {
      "number": 23,
      "id": "MDExOlB1bGxSZXF1ZXN0OTk2Njg0NjQ=",
      "title": "[do not merge] MIME boundary => chunked encoding",
      "url": "https://github.com/WICG/webpackage/pull/23",
      "state": "CLOSED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This allows for:\r\n\r\n* streaming without worrying about collision and without the need to pre-parse the file\r\n* signatures to be preserved even if chunk sizes differ due to streaming\r\n\r\nfixes #6",
      "createdAt": "2016-12-29T15:37:47Z",
      "updatedAt": "2017-03-29T14:20:52Z",
      "closedAt": "2017-03-29T14:20:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "marked [do not merge]\r\n\r\nneed to discuss the outer boundaries more in depth so that package level header and trailer are clear.",
          "createdAt": "2016-12-30T14:07:54Z",
          "updatedAt": "2016-12-30T14:07:54Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I am thinking you mean \"part\" to be body of a resource within the package.\r\n\r\nThis does allow encoding resources into multiple chunks. Individual chunk lengths are not related to total size of a resource.",
          "createdAt": "2017-01-03T18:58:58Z",
          "updatedAt": "2017-01-03T18:58:58Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "After a while of thinking I cannot easily preserve nesting packages while maintaining streamking via normal chunked encoding. A variant seems possible, but the problem comes from:\r\n\r\n```\r\n... outer webpackage ...\r\n<- no delimiter for declaring entering nested package\r\n<- would need add extra wrapping header + chunked encoding content\r\ninner package <- all chunked (even headers :( )\r\n<- extra `0\\r\\n` is a bit odd\r\n... outer webpackage ...\r\n```\r\n\r\nI will investigate some other framing mechanism which can support streaming nested packages without this problem.",
          "createdAt": "2017-01-16T22:31:30Z",
          "updatedAt": "2017-01-16T22:31:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Could you update this to use `\\n` line endings? Right now git thinks every line is changed.\r\n\r\nDo we need to be able to stream the nested packages? It'd be a little weird for the main server to be reflecting a stream served from another server, since it couldn't then take over and serve part of its own content if the nested server pauses. That ... makes me think we should actually be using something from HTTP2 directly for the streaming case and only use a packaging format for serializing the content.",
          "createdAt": "2017-01-25T22:44:37Z",
          "updatedAt": "2017-01-25T22:44:37Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin for streaming onto a disk (from any source) we don't have the guarantees of a HTTP/2 style multiplexing stream.",
          "createdAt": "2017-01-25T23:11:30Z",
          "updatedAt": "2017-01-25T23:11:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think that mixes two use cases.\r\n1. Server sends content as it's generated, rather than waiting for a whole file to be ready at once. For this, you have HTTP2.\r\n2. Serialize content to disk and share it to peers. At this point, you've downloaded the whole thing and can use an encoding that needs lengths up front. You might have to do a second pass over the data.\r\n\r\nI could be missing something.",
          "createdAt": "2017-01-25T23:17:42Z",
          "updatedAt": "2017-01-25T23:17:42Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@jyasskin \r\n\r\n1) Content can be served via means other than HTTP, and HTTP2 is still very far from having even a small penetration.  We need something that works over any protocol.\r\n\r\n2) But if you modify the stream/data - you break the signatures.  That's not good.",
          "createdAt": "2017-01-25T23:19:34Z",
          "updatedAt": "2017-01-25T23:19:34Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I don't think the packaging format needs to solve problems that new transports have already solved. People who don't upgrade to the new transports just have to deal with the problems of the transports they're using.\r\n\r\nI do think there's a problem with including offsets in the signed data, but I need to double-check with security folks that it's safe to avoid it.",
          "createdAt": "2017-01-25T23:21:23Z",
          "updatedAt": "2017-01-25T23:21:23Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "I agree that we don't need to solve problems already solved - and I don't think we are doing that here.  Instead, we are designing a protocol and storage system neutral solution.\r\n\r\nActually the opposite - if the offsets aren't signed, you have a big hole in your signature model.",
          "createdAt": "2017-01-25T23:24:58Z",
          "updatedAt": "2017-01-25T23:24:58Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "closing due to newer PR and the move to CBOR",
          "createdAt": "2017-03-29T14:20:52Z",
          "updatedAt": "2017-03-29T14:20:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5ODMxMzM=",
          "commit": {
            "abbreviatedOid": "52476a7"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Does this change merge the concept of chunk length and part length?  It might be that for streaming the server won't even know the length of individual parts, meaning that it'd need to send down a part as multiple chunks.",
          "createdAt": "2017-01-03T18:25:56Z",
          "updatedAt": "2017-01-03T18:25:56Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4749434e67297a3c839399dd4d1fceb1ac334f31",
      "headRepository": "bmeck/webpackage",
      "headRefName": "chunked-encoding",
      "headRefOid": "52476a76e65f65ccf63ef0b836a5410293c07a9f",
      "mergeCommit": null
    },
    {
      "number": 24,
      "id": "MDExOlB1bGxSZXF1ZXN0OTk2NzgwNDU=",
      "title": "[WIP][DO-NOT-MERGE] extracting binaries",
      "url": "https://github.com/WICG/webpackage/pull/24",
      "state": "CLOSED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Will update as discussion on https://github.com/dimich-g/webpackage/issues/20 evolves.",
      "createdAt": "2016-12-29T17:11:58Z",
      "updatedAt": "2017-05-30T17:13:40Z",
      "closedAt": "2017-05-30T17:13:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "fixed",
          "createdAt": "2017-05-30T17:13:40Z",
          "updatedAt": "2017-05-30T17:13:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTkzMzA=",
          "commit": {
            "abbreviatedOid": "2ff5310"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T23:41:48Z",
          "updatedAt": "2017-02-08T23:41:48Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Dumb question: why do you want an executable signature in the package? OSes wouldn't generally know to check it before running the executable, and once it's running, it can also ignore its own signature. ",
              "createdAt": "2017-02-08T23:41:48Z",
              "updatedAt": "2017-02-08T23:41:48Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4749434e67297a3c839399dd4d1fceb1ac334f31",
      "headRepository": "bmeck/webpackage",
      "headRefName": "extracting-bins",
      "headRefOid": "2ff5310b6a5b74daad8a320b8273def85c86856f",
      "mergeCommit": null
    },
    {
      "number": 25,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAwNzE2NjU4",
      "title": "avoid colliding MIME for Content Index",
      "url": "https://github.com/WICG/webpackage/pull/25",
      "state": "MERGED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes https://github.com/dimich-g/webpackage/issues/9 by using a sub tree of `application/package.index`",
      "createdAt": "2017-01-09T16:34:57Z",
      "updatedAt": "2017-01-24T02:08:05Z",
      "closedAt": "2017-01-24T02:07:46Z",
      "mergedAt": "2017-01-24T02:07:46Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I am neutral on this topic overall given how UA generally treat MIME type as opaque strings.",
          "createdAt": "2017-01-13T19:57:35Z",
          "updatedAt": "2017-01-13T19:57:35Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks a lot, this is a good suggestion!",
          "createdAt": "2017-01-24T02:08:05Z",
          "updatedAt": "2017-01-24T02:08:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzU4MjE=",
          "commit": {
            "abbreviatedOid": "9d0019f"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I wonder if it can be a new tree ('package.') or if it should be something like vnd.package.index",
          "createdAt": "2017-01-13T19:35:10Z",
          "updatedAt": "2017-01-13T19:35:10Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "883f7bee23b3a3d8440f4a1edfbf140bb56b6c37",
      "headRepository": "bmeck/webpackage",
      "headRefName": "colliding-mime",
      "headRefOid": "9d0019feba773ed4762944b148c3606319bdb1ea",
      "mergeCommit": {
        "oid": "9fef4ca261df9b77f3b9a219061ad3f84d67c547"
      }
    },
    {
      "number": 27,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAxMzgzODYw",
      "title": "Explicitly mandate X.509 cert and leave verification to host",
      "url": "https://github.com/WICG/webpackage/pull/27",
      "state": "MERGED",
      "author": "bmeck",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "fixes https://github.com/dimich-g/webpackage/issues/16",
      "createdAt": "2017-01-13T03:31:41Z",
      "updatedAt": "2017-01-13T19:19:02Z",
      "closedAt": "2017-01-13T19:19:02Z",
      "mergedAt": "2017-01-13T19:19:02Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY2MzI0MzI=",
          "commit": {
            "abbreviatedOid": "882eef6"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-01-13T19:18:41Z",
          "updatedAt": "2017-01-13T19:18:41Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "883f7bee23b3a3d8440f4a1edfbf140bb56b6c37",
      "headRepository": "bmeck/webpackage",
      "headRefName": "cert-type",
      "headRefOid": "882eef62af96f08a2d05d18b5cb0c80f7bb2ef19",
      "mergeCommit": {
        "oid": "24296e8d47a82adcaeff2d195a2a0a0627e5981a"
      }
    },
    {
      "number": 28,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAyODM0MjE4",
      "title": "Fix a bunch of typos and missing links.",
      "url": "https://github.com/WICG/webpackage/pull/28",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I'm not sure I've got the right fix for each of these; feel free to say anything should be different.",
      "createdAt": "2017-01-24T01:06:12Z",
      "updatedAt": "2017-01-26T22:36:47Z",
      "closedAt": "2017-01-26T00:55:36Z",
      "mergedAt": "2017-01-26T00:55:36Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2017-01-26T00:55:57Z",
          "updatedAt": "2017-01-26T00:55:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNjUxNzA=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-24T01:08:47Z",
          "updatedAt": "2017-01-24T01:10:41Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "It seems from the FAQ that this link is wrong. I'd strongly suggest using a scheme that doesn't collide with anything that already has a definition.",
              "createdAt": "2017-01-24T01:08:47Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            },
            {
              "originalPosition": 53,
              "body": "#25 handles this better.",
              "createdAt": "2017-01-24T01:09:59Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            },
            {
              "originalPosition": 75,
              "body": "Please double-check this paragraph.",
              "createdAt": "2017-01-24T01:10:22Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzM2MzI=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-24T02:28:53Z",
          "updatedAt": "2017-01-24T02:28:53Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Right. The cid: schema is not really the right one here. Chrome uses URLs like cid:[uuid] in MHTML generation and this is apparently not standard, but then again MHTML is not well formed standard either... I've picked the cid: schema after Chrome's MHTML implementation, but perhaps urn:uuid: would work better, and it is standard:  http://www.ietf.org/rfc/rfc4122.txt\r\nIf you think it is better here, please feel free to change to it or let me know and I'll change after merging this PR.",
              "createdAt": "2017-01-24T02:28:53Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzM2NDE=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-24T02:28:56Z",
          "updatedAt": "2017-01-24T02:28:56Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Indeed. I've merged #25.",
              "createdAt": "2017-01-24T02:28:56Z",
              "updatedAt": "2017-01-25T17:55:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNzM3MDU=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Great, thanks a lot for reading and fixing those!\r\nI want to merge it, there are 2 comments...",
          "createdAt": "2017-01-24T02:29:42Z",
          "updatedAt": "2017-01-24T02:29:42Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NjE2MjQ=",
          "commit": {
            "abbreviatedOid": "7b730b1"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-25T17:56:22Z",
          "updatedAt": "2017-01-25T17:56:22Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "I'm happy to use `urn:uuid:` for UUIDs. I've made that a separate commit since it touches several parts of the document.",
              "createdAt": "2017-01-25T17:56:22Z",
              "updatedAt": "2017-01-25T17:56:22Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9fef4ca261df9b77f3b9a219061ad3f84d67c547",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "typos",
      "headRefOid": "2e42c9aaa693e74400180f679ff189cc6e6a9423",
      "mergeCommit": {
        "oid": "10f02278862c18e65d60c20327ef8a00931ec0cf"
      }
    },
    {
      "number": 31,
      "id": "MDExOlB1bGxSZXF1ZXN0MTAzMzkzNzYy",
      "title": "Add some discussion of the security issues.",
      "url": "https://github.com/WICG/webpackage/pull/31",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "* Outdated certificates and packages.\r\n* That there may not be a single certificate chain.\r\n\r\n@estark37",
      "createdAt": "2017-01-26T21:32:47Z",
      "updatedAt": "2017-06-08T18:34:00Z",
      "closedAt": "2017-06-08T00:08:13Z",
      "mergedAt": "2017-06-08T00:08:13Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "This conversation has also taken place as part of #16. where its been pointed out that TLS-based certs won't work (as @sleevi says here).  Other types of certs - that aren't tied to domains, but instead of orgs or individuals - will need to be used.\r\n\r\nBut regardless, the set of valid and/or trusted roots needs to come from somewhere that may (or may not) be able to be mandated as part of the standardization.  And as part of that, you need to consider other standards in this area such as the [EUTL](https://ec.europa.eu/digital-single-market/en/eu-trusted-lists-trust-service-providers).",
          "createdAt": "2017-01-27T19:06:56Z",
          "updatedAt": "2017-01-27T19:06:56Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@lrosenthol That's not an accurate statement - that is, that other types of certs _will_ need to be used, or more generally, that certificates not bound to domains should be used. And the EUTL should absolutely be ignored in this space - not even bothered with.\r\n\r\n@dimich-g I think the question was worded incorrectly; that is, you don't want to get a \"second\" TLS certificate that you use for signing, because as far as design goes, you're setting people up to fail if they have two certificates, interchangable, but one should be used for TLS and one not. To reduce the risk of cross-protocol attacks, you want to ensure that Certificate A (which can/should/is bound to a domain) cannot be used in Protocol B, and that Certificate B (which can/should/is bound to a domain) should not be used in Protocol A.\r\n\r\nI don't anticipate being able to provide a more thorough review of the cryptography in the next few days, but there are definitely red flags with what's currently specified - ranging from the discussion of Key Usage to these issues of cross-protocol confusion. The signature design also doesn't account for the ability to perform counter-signatures, which is generally seen as a necessary scheme in document/code signing solutions (in Authenticode, it's used for timestampping; in Chrome extensions, it's used to vet that it's a Google WebStore delivered extension; in Android APKs, it's used to comply with local laws). ",
          "createdAt": "2017-01-27T19:13:41Z",
          "updatedAt": "2017-01-27T19:13:41Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@sleevi \r\n>And the EUTL should absolutely be ignored in this space - not even bothered with.\r\n>\r\nThen you and I are going to have to agree to disagree.  The EUTL is a requirement for adoption of signatures within the URL for various business processes.  In the context of the use of this technology for publications, it would be necessary to be allow compatibility with it.  I am **not** suggesting mandating, just compatibility.\r\n\r\n>doesn't account for the ability to perform counter-signatures\r\n>\r\nI don't believe that the current design prevents counter sigs, but I agree that it's not called out - and you are right, it should be as it is an important technology.  It's also going to be important for publications where the author may sign the original publication with the publisher adding theirs at the final release stage.",
          "createdAt": "2017-01-27T19:20:08Z",
          "updatedAt": "2017-01-27T19:20:21Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@sleevi At the moment, we don't have a specification, just a sketch. Would you prefer that we non-cryptographers come up with a draft specification that you can review, or would you rather we write down a list of requirements and wait for a real cryptographer to design the right system?",
          "createdAt": "2017-01-27T19:34:37Z",
          "updatedAt": "2017-01-27T19:34:37Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin Either way, knowing your goals clearly will help make sure whatever solution meets those goals - whether it's starting from a point in the draft where you're trying to accomplish those goals, or whether it's starting from scratch to build something to achieve those goals. Knowing, for example, whether you're exclusively targeting UAs or whether, as it seems suggested both here and the draft, you're imagining things like JS packaging or document delivery, is itself a useful aspect.",
          "createdAt": "2017-01-27T19:47:18Z",
          "updatedAt": "2017-01-27T19:47:18Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "@sleevi - there are at least three different groups that are looking to\npotentially leverage this work\n- Browsers (which I assume you meant when you said UA, but is just one\nclass of UA for the OWP)\n- Application environments (eg. Node+Electron)\n- Documents & Publications (eg. Web Publications)\n\nThis to me means a common model and file format.  However, I see no reason\nwhy the types of certificates allowed/used couldn't be different in each\ncase.\n\nOn Fri, Jan 27, 2017 at 2:47 PM, sleevi <notifications@github.com> wrote:\n\n> @jyasskin <https://github.com/jyasskin> Either way, knowing your goals\n> clearly will help make sure whatever solution meets those goals - whether\n> it's starting from a point in the draft where you're trying to accomplish\n> those goals, or whether it's starting from scratch to build something to\n> achieve those goals. Knowing, for example, whether you're exclusively\n> targeting UAs or whether, as it seems suggested both here and the draft,\n> you're imagining things like JS packaging or document delivery, is itself a\n> useful aspect.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/31#issuecomment-275756952>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNTKdgi9WOU5pXoSFrmb4-VWDM0b0ks5rWknHgaJpZM4LvKkh>\n> .\n>\n",
          "createdAt": "2017-01-27T19:51:10Z",
          "updatedAt": "2017-01-27T19:51:10Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "To clarify, I would expect Node and Electron to use Code Signing based x.509 certs rather than regular TLS certs. In particular, the origin of applications might not be tied to a specific WWW domain but an app store submission (like Android APK).",
          "createdAt": "2017-03-31T13:39:58Z",
          "updatedAt": "2017-03-31T13:39:58Z"
        },
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "Points by @mrdewitt addressed, merged.",
          "createdAt": "2017-06-08T00:09:52Z",
          "updatedAt": "2017-06-08T00:09:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4NzA5NzU=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T16:06:54Z",
          "updatedAt": "2017-01-27T16:06:54Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "@sleevi, @estark37 said I should ask you if packagers are going to cause problems by including the certificates needed to chain to the roots of multiple different clients. She referenced https://groups.google.com/a/chromium.org/d/msg/net-dev/H-ysp5UM_rk/TqoyjV1eDAAJ as an example of servers choosing to make the client download some intermediates, which won't work as well for offline verification.",
              "createdAt": "2017-01-27T16:06:54Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MDEwMjI=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T18:31:31Z",
          "updatedAt": "2017-01-27T18:31:32Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "@jyasskin I'll read up on the full proposal, but it sounds like you're suggesting using CA-rooted certificates, possibly even TLS certificates, for the packaging. That's not ideal for a number of reasons - this included - so I'll take a scan through and see what alternatives might be worth suggesting.",
              "createdAt": "2017-01-27T18:31:31Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MDQ5Mjg=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T18:50:28Z",
          "updatedAt": "2017-01-27T18:50:28Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Thanks. The main constraint that I think leads us to use CA-rooted certificates is that we need the packages to be trusted as coming from particular web origins. I'm happy with anything else that proves an origin to the displaying browser.",
              "createdAt": "2017-01-27T18:50:28Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MDU3ODk=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T18:54:53Z",
          "updatedAt": "2017-01-27T18:54:53Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "Right, unfortunately, this introduces subtle-but-significant cross-protocol attacks when you re-use a TLS certificate to sign this data, unfortunately, so this is going to be quite difficult to get what you want.",
              "createdAt": "2017-01-27T18:54:53Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MDgyNjI=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-01-27T19:06:54Z",
          "updatedAt": "2017-01-27T19:06:55Z",
          "comments": [
            {
              "originalPosition": 105,
              "body": "@sleevi is this true even if the publisher of the package obtains a separate TLS certificate for signing packages? Sort of similar to how code-signing certificates are separate form TLS ones.",
              "createdAt": "2017-01-27T19:06:54Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1OTk1MTc=",
          "commit": {
            "abbreviatedOid": "42eb8d2"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-04-03T18:41:52Z",
          "updatedAt": "2017-04-03T18:46:00Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'm confused - local sharing doesn't typically have per-byte costs.  Storage and downloading do.",
              "createdAt": "2017-04-03T18:41:52Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 7,
              "body": "Seems to me that rewording this without the numbered list would be clearer.  \"It may be feasible to periodically check for OCSP notification that a package's certificate has been revoked.  Other channels for notifying about vulnerable packages have not yet been discussed/designed.\"",
              "createdAt": "2017-04-03T18:43:30Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 22,
              "body": "This makes me think that analogue to the HEAD request where the client could fetch only the manifest/index and revalidate stale portions would be useful.",
              "createdAt": "2017-04-03T18:44:36Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 42,
              "body": "s/is/must be/",
              "createdAt": "2017-04-03T18:45:20Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE2MTMxMTI=",
          "commit": {
            "abbreviatedOid": "e72aa6e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-04-07T17:04:42Z",
          "updatedAt": "2017-04-07T17:36:16Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Indeed, that was worded badly. I meant that the use case happens where global connectivity is expensive, and have now updated the PR wording.",
              "createdAt": "2017-04-07T17:04:42Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 7,
              "body": "Done.",
              "createdAt": "2017-04-07T17:05:36Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 22,
              "body": "Yeah. We should define an optimized update mechanism, although validation might be simpler.",
              "createdAt": "2017-04-07T17:09:23Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 42,
              "body": "I'm going to undo the change to this section until we can update all the use cases.",
              "createdAt": "2017-04-07T17:25:55Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            },
            {
              "originalPosition": 105,
              "body": "#44 takes agl's advice to use the same signing format as TLS (and I used a different context string to distinguish package signatures from handshake signatures). I'd like to postpone the question of exactly what origin-trusted certificates will convince browsers to load a package until a later PR.\r\n\r\nThe current format even looks like it'll represent packages that have only signatures that aren't origin-trusted. Although web browsers would refuse to load those packages, they're useful for Node and Publishers.",
              "createdAt": "2017-04-07T17:28:48Z",
              "updatedAt": "2017-05-24T00:28:13Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "50eac842a351cd0a73db38de191bf374e3965f51",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "use-cases",
      "headRefOid": "5f43c6daece6ab863db8e21c863c64affd3de8ff",
      "mergeCommit": {
        "oid": "27145384836a1ea3f410663f0aaf1fe1ce55bcba"
      }
    },
    {
      "number": 34,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA0NTk3MTE2",
      "title": "Add some open questions, and refine a same-origin use case.",
      "url": "https://github.com/WICG/webpackage/pull/34",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-02-03T19:34:39Z",
      "updatedAt": "2017-04-07T17:41:54Z",
      "closedAt": "2017-04-07T17:41:51Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think this PR is obsolete after some of the other PRs were merged. Sorry for not catching that before you reviewed it.",
          "createdAt": "2017-04-07T17:41:51Z",
          "updatedAt": "2017-04-07T17:41:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1OTg5NTI=",
          "commit": {
            "abbreviatedOid": "18061fb"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-04-03T18:40:00Z",
          "updatedAt": "2017-04-03T18:40:42Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Can you clarify what \"the implementation has to be secure against even signed content\" means?  Do you mean that we have to verify signatures?",
              "createdAt": "2017-04-03T18:40:00Z",
              "updatedAt": "2017-04-03T18:40:42Z"
            },
            {
              "originalPosition": 29,
              "body": "This only proves anything for same-origin content, right?",
              "createdAt": "2017-04-03T18:40:36Z",
              "updatedAt": "2017-04-03T18:40:42Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4b873d2811c09c8b0756e63375a1ba685c402863",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "add-open-questions",
      "headRefOid": "18061fb33569c5864518a70d08db1b121e184020",
      "mergeCommit": null
    },
    {
      "number": 36,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA1MDk3NzQ5",
      "title": "Sketch an update to the package format and its signatures.",
      "url": "https://github.com/WICG/webpackage/pull/36",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I haven't updated the Use Cases yet, but here are some thoughts on how we should update the format to deal with #33 (@bmeck), Ryan's security concerns in #31, #29 (@jianli-chromium), and #10, #11, and #12 (@lrosenthal). I've tried to mark all the places that still need work with \"TODO\", but I may have missed some.",
      "createdAt": "2017-02-07T21:28:52Z",
      "updatedAt": "2017-03-30T17:49:01Z",
      "closedAt": "2017-03-30T06:34:10Z",
      "mergedAt": "2017-03-30T06:34:09Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "This is a bit raw still, we'll need to clarify some topics, something that jumps at me:\r\n- subpackages. seems w/o signed manifest it's impossible to have them\r\n- subpackages - can they be external (by URL)\r\n- index and manifest seem to have duplicated list of resource uris\r\n- the COSI seems interesting but is it the right one?\r\n- obviously, the examples should be updated, etc.",
          "createdAt": "2017-03-30T06:37:34Z",
          "updatedAt": "2017-03-30T06:37:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDQ1ODc=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T19:21:37Z",
          "updatedAt": "2017-02-08T19:21:37Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "What makes the overall length of the package needed at the beginning?",
              "createdAt": "2017-02-08T19:21:37Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDU0MTQ=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T19:24:43Z",
          "updatedAt": "2017-02-08T19:24:43Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "As far as binary format goes, we might as well consider at least 32-bit alignment, since it may make memory-mapped files easier/faster to interpret.",
              "createdAt": "2017-02-08T19:24:43Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NDU5MjQ=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T19:26:53Z",
          "updatedAt": "2017-02-08T19:26:53Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "I'd remove TODO. If it's not right, it'll be obvious on review/registration.\r\nThe package does need a mime type as it requires a different parser/handler typically, so the only issue may be actual names.",
              "createdAt": "2017-02-08T19:26:53Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NTU0NDk=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:05:53Z",
          "updatedAt": "2017-02-08T20:05:53Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "It's not essential. I included it as a way to validate that the length at the end is actually referring to a package, but the other constraints here probably do that just fine. I can remove it.",
              "createdAt": "2017-02-08T20:05:53Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NTU3ODg=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:07:16Z",
          "updatedAt": "2017-02-08T20:07:16Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "I suspect that \"package\" is too general to suggest, and that we should suggest something more specific like `webpackage` or `httppackage` (since it holds HTTP responses).",
              "createdAt": "2017-02-08T20:07:16Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NTYxNjM=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:08:54Z",
          "updatedAt": "2017-02-08T20:08:54Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Right, I'm torn between allowing alignment for the binary parts, vs compressing the integers better. The amount of data here is pretty small, so I decided that decoding speed wasn't critical enough to worry about alignment. 'course, it's also not enough to really worry about the size.",
              "createdAt": "2017-02-08T20:08:54Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NjM5Mzc=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:45:32Z",
          "updatedAt": "2017-02-08T20:45:32Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "Signatures are also optional. Not-signed packages may have a lot of utility since they can be produced locally and shared easily. The limits on contents are obvious, but for many use cases (packaging a movie that has its own DRM schema embedded, or a static snapshot of a page) the signing is not needed.",
              "createdAt": "2017-02-08T20:45:32Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NjQ3NDY=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:49:16Z",
          "updatedAt": "2017-02-08T20:49:16Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "This makes it not clear what certificates and for what signature are included. The original idea went with a packages being authonomous units (since if signed, they most likely will be signed by separate domain owners, using separate certs etc). It's unclear why including certs needed to verify a subpackage is needed in a containing package, if that is what you meant.",
              "createdAt": "2017-02-08T20:49:16Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NjQ5MjM=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:50:02Z",
          "updatedAt": "2017-02-08T20:50:02Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "My thought is that unsigned packages would omit the manifest. Can you think of a reason to include a manifest without signing it? Note that the index is always unsigned.",
              "createdAt": "2017-02-08T20:50:02Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4NjU3OTA=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T20:53:44Z",
          "updatedAt": "2017-02-08T20:53:44Z",
          "comments": [
            {
              "originalPosition": 117,
              "body": "Again, not signed resources have their use and may be used even wider than signed, at least initially. Likely need to preserve optional nature of signing.",
              "createdAt": "2017-02-08T20:53:44Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTA0OTQ=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T22:47:12Z",
          "updatedAt": "2017-02-08T22:47:12Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "This needs to be clarified wrt subpackages. If a subpackage has its own index, it should not be duplicated. Realistically, the process of serving resources from the packages should include memory cache of indices of subpackages, so there is no need to flatten the index. If I understand the sentence correctly, of course.",
              "createdAt": "2017-02-08T22:47:12Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTMwOTE=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T23:01:40Z",
          "updatedAt": "2017-02-08T23:01:40Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "At the moment, I have a single block of certificates, which are used to validate all the signatures anywhere. If we want to send the sub-package's certificates with that sub-package, we'd need to include extra certificate blocks. That said, `application/pkcs7-mime` can actually wrap both certificates and signed data, so we could store the manifests in that format and avoid having any separate certificate block.",
              "createdAt": "2017-02-08T23:01:40Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA4OTM2ODI=",
          "commit": {
            "abbreviatedOid": "8c9ac34"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-08T23:05:13Z",
          "updatedAt": "2017-02-08T23:05:13Z",
          "comments": [
            {
              "originalPosition": 77,
              "body": "We could give the top-level index a way to refer to subpackage indices, but I think that would constrain subpackages to be contiguous, which might break the ability to deduplicate shared dependencies. It seems more straightforward to ask the top-level package to regenerate the sub-package's indices.",
              "createdAt": "2017-02-08T23:05:13Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNTQzMjU=",
          "commit": {
            "abbreviatedOid": "b097d44"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T22:17:35Z",
          "updatedAt": "2017-02-10T22:17:35Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "We met and decided to use 8-byte numbers everywhere here, and to ignore alignment everywhere else.",
              "createdAt": "2017-02-10T22:17:35Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQwMTczODA=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks fine, still need to revisit other issues on formatting of content. I have nits, but nothing blocking.",
          "createdAt": "2017-02-27T15:48:14Z",
          "updatedAt": "2017-02-27T15:56:02Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "I don't think this is needed as we are not requesting updates via this format.",
              "createdAt": "2017-02-27T15:48:14Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            },
            {
              "originalPosition": 201,
              "body": "This needs to be reworded, `The message to sign` is confusing, are we talking about the whole package, the manifest, or an individual resource. I assume we are only talking about the manifest.\r\n\r\nThe wording here makes it sound like after generating a manifest we put the signatures on the resources.",
              "createdAt": "2017-02-27T15:52:28Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            },
            {
              "originalPosition": 174,
              "body": "need to bikeshed the format here, HTTP Header on same line as other data seems an odd choice and hard to deal with.",
              "createdAt": "2017-02-27T15:53:18Z",
              "updatedAt": "2017-03-27T22:00:12Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMTM4OTA=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-27T22:01:16Z",
          "updatedAt": "2017-03-27T22:01:16Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "Yep, the new CBOR-based format avoids this problem.",
              "createdAt": "2017-03-27T22:01:16Z",
              "updatedAt": "2017-03-27T22:01:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMTM5MDA=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-27T22:01:18Z",
          "updatedAt": "2017-03-27T22:01:18Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "Works for me; removed.",
              "createdAt": "2017-03-27T22:01:18Z",
              "updatedAt": "2017-03-27T22:01:18Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjkzMTM5Mjc=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-27T22:01:23Z",
          "updatedAt": "2017-03-27T22:01:23Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "I was talking about the manifest, and this wording got replaced when I switched to the CBOR format. See if the new wording in https://github.com/jyasskin/webpackage/tree/sketch-new-signing#manifest makes sense?",
              "createdAt": "2017-03-27T22:01:23Z",
              "updatedAt": "2017-03-27T22:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MzYyNDg=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-29T14:22:44Z",
          "updatedAt": "2017-03-29T14:22:44Z",
          "comments": [
            {
              "originalPosition": 201,
              "body": "+1",
              "createdAt": "2017-03-29T14:22:44Z",
              "updatedAt": "2017-03-29T14:22:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjk3MzYzNTE=",
          "commit": {
            "abbreviatedOid": "d4b81dc"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-03-29T14:23:06Z",
          "updatedAt": "2017-03-29T14:23:06Z",
          "comments": [
            {
              "originalPosition": 174,
              "body": "+1",
              "createdAt": "2017-03-29T14:23:06Z",
              "updatedAt": "2017-03-29T14:23:06Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "10f02278862c18e65d60c20327ef8a00931ec0cf",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "sketch-new-signing",
      "headRefOid": "754f654596707f686ab533b83513dd8734b8625d",
      "mergeCommit": {
        "oid": "4b873d2811c09c8b0756e63375a1ba685c402863"
      }
    },
    {
      "number": 37,
      "id": "MDExOlB1bGxSZXF1ZXN0MTA1MjkwNDUz",
      "title": "Add a list of goals and non-goals.",
      "url": "https://github.com/WICG/webpackage/pull/37",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It's a fairly long list. Did I miss anything?",
      "createdAt": "2017-02-08T19:47:21Z",
      "updatedAt": "2017-05-19T21:58:24Z",
      "closedAt": "2017-03-30T03:10:43Z",
      "mergedAt": "2017-03-30T03:10:43Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "I lean towards \"self-extracting\" as required for Node. It really is just adding a `length` field at the end of the file as long as we can check file signature somehow, don't really need anything else.",
          "createdAt": "2017-02-27T15:39:45Z",
          "updatedAt": "2017-02-27T15:39:45Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Two things\n\n1 - To me, self-extracting implies that there is code in the package that\ncan extract its own contents.  I would actually find that to be an\nanti-goal.  In fact, it almost screams security problem.\n\n2 - For publication use cases, \"non-origin-identity\" is a\nrequirement/goal.  Do you want me to submit the PR on that?\n\nOn Mon, Feb 27, 2017 at 10:39 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> I lean towards \"self-extracting\" as required for Node. It really is just\n> adding a length field at the end of the file as long as we can check file\n> signature somehow, don't really need anything else.\n>\n> \u2014\n> You are receiving this because you are subscribed to this thread.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/37#issuecomment-282755705>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNU8QOYB3H4GpbFRs5YQfdykO9CU2ks5rgu5BgaJpZM4L7Ris>\n> .\n>\n",
          "createdAt": "2017-02-27T15:46:26Z",
          "updatedAt": "2017-02-27T15:46:26Z"
        },
        {
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "body": "@lrosenthol we can rename it to w/e else but that is the common name for archive formats that allow the behavior we have described. It is up to the runtime env to provide proper mechanics to load things safely. I just need the format to allow the archive to be concatenated on the end of a binary and find the start of the archive safely.",
          "createdAt": "2017-02-27T15:58:08Z",
          "updatedAt": "2017-02-27T15:58:08Z"
        },
        {
          "author": "lrosenthol",
          "authorAssociation": "NONE",
          "body": "Ah - it's not that the package itself is self-extracting - but that it can\nbe used in a self-extracting context.  Then maybe just add \"compatible\"\n(ie. self-extracting compatible)?\n\nOn Mon, Feb 27, 2017 at 10:58 AM, Bradley Meck <notifications@github.com>\nwrote:\n\n> @lrosenthol <https://github.com/lrosenthol> we can rename it to w/e else\n> but that is the common name for archive formats that allow the behavior we\n> have described. It is up to the runtime env to provide proper mechanics to\n> load things safely. I just need the format to allow the archive to be\n> concatenated on the end of a binary and find the start of the archive\n> safely.\n>\n> \u2014\n> You are receiving this because you were mentioned.\n> Reply to this email directly, view it on GitHub\n> <https://github.com/dimich-g/webpackage/pull/37#issuecomment-282761478>,\n> or mute the thread\n> <https://github.com/notifications/unsubscribe-auth/AE1vNRe4TAEgv2eiZQPa-e3F7IumdYBUks5rgvKQgaJpZM4L7Ris>\n> .\n>\n",
          "createdAt": "2017-02-27T18:26:52Z",
          "updatedAt": "2017-02-27T18:26:52Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've marked that Node requires the packages to be compatible with self-extraction, and I'm almost certain we can accommodate it, but I've left it in the Nice-to-have section because Node support *at all* is just nice-to-have.",
          "createdAt": "2017-03-21T22:40:20Z",
          "updatedAt": "2017-03-21T22:40:20Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Publication use cases are also nice-to-have, but packages with non-origin identities are hard enough to fit into web browsers that I think this PR is right to list it as a non-goal. We could explore it further in a separate issue/PR if you really want.",
          "createdAt": "2017-03-21T23:48:49Z",
          "updatedAt": "2017-03-21T23:48:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNTEzNTU=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T21:59:24Z",
          "updatedAt": "2017-02-10T21:59:24Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "The goal's name \"sub-packages\" refers to our current solution to the real goal which is \"multiple origins can make same-origin requests\"",
              "createdAt": "2017-02-10T21:59:24Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNjQyOTE=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T23:30:27Z",
          "updatedAt": "2017-02-10T23:30:27Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "TODO: Add DRM support as a non-goal.",
              "createdAt": "2017-02-10T23:30:27Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNjYwNTQ=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T23:46:02Z",
          "updatedAt": "2017-02-10T23:46:02Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Changed to \"multiple-origins\".",
              "createdAt": "2017-02-10T23:46:02Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNjYwNjE=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-10T23:46:05Z",
          "updatedAt": "2017-02-10T23:46:05Z",
          "comments": [
            {
              "originalPosition": 59,
              "body": "Done.",
              "createdAt": "2017-02-10T23:46:05Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNzQyODM=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-11T01:32:32Z",
          "updatedAt": "2017-02-11T01:32:32Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I think it can be simplified by dropping 'TLS' requirement since unsigned content also makes sense. The TLS can be used in lieu of signature verification (but even that is more complicated, with countersigning) - so lets just keep streamed-loading as a goal regardless trust issues. ",
              "createdAt": "2017-02-11T01:32:32Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIwOTQ1MDk=",
          "commit": {
            "abbreviatedOid": "adbb7e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-02-15T19:53:38Z",
          "updatedAt": "2017-02-15T19:53:38Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done, especially given the fact that TLS doesn't guarantee resources aren't dropped.",
              "createdAt": "2017-02-15T19:53:38Z",
              "updatedAt": "2017-03-21T22:38:58Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "10f02278862c18e65d60c20327ef8a00931ec0cf",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "non-goals",
      "headRefOid": "8b3f912fbf5bf17e686b6d5deecc1bb192ade93e",
      "mergeCommit": {
        "oid": "ce7a2ed31d00bb13ef01b19970505f2abebbf651"
      }
    },
    {
      "number": 44,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE0NjcyMjk4",
      "title": "Remove COSE and use TLS1.3's signing algorithm.",
      "url": "https://github.com/WICG/webpackage/pull/44",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "COSE is more complex than we need, and exposes us to any bugs in generic COSE\r\ntools.\r\n\r\nWe're not necessarily going to allow certificates that can be used for TLS\r\ntraffic, but using their signing format removes one thing that'd block it.\r\n\r\nThese are requests from @agl.",
      "createdAt": "2017-04-06T19:03:12Z",
      "updatedAt": "2017-05-04T16:27:33Z",
      "closedAt": "2017-05-03T19:53:50Z",
      "mergedAt": "2017-05-03T19:53:50Z",
      "mergedBy": "dimich-g",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4b873d2811c09c8b0756e63375a1ba685c402863",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "remove-cose",
      "headRefOid": "a0c3ffe43321cade6755bd8b1ca12584346592ea",
      "mergeCommit": {
        "oid": "76678469d459008a715ac72954a0ef401f2164b6"
      }
    },
    {
      "number": 46,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE1NjQ1Njg4",
      "title": "Consolidate resource-keys into the index.",
      "url": "https://github.com/WICG/webpackage/pull/46",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This requires the index where it used to be optional.\r\n\r\nFixes #41.",
      "createdAt": "2017-04-12T22:04:30Z",
      "updatedAt": "2017-05-11T00:02:11Z",
      "closedAt": "2017-05-11T00:02:03Z",
      "mergedAt": "2017-05-11T00:02:03Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NDY2NDU=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T18:21:02Z",
          "updatedAt": "2017-05-08T18:21:02Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I don't strictly need the nested array here: it could just be a list of alternating headers and bodies.",
              "createdAt": "2017-05-08T18:21:02Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NDY5MTU=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T18:22:13Z",
          "updatedAt": "2017-05-08T18:22:13Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I don't strictly need this array either, but it's a little more difficult to tease out where the next index entry starts with the optional length. (You'd use the bstr-ness of the resource-key.) I could require lengths, but that wastes some space when a package isn't expected to be downloaded using http range requests.",
              "createdAt": "2017-05-08T18:22:13Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4NzczNDY=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:32:25Z",
          "updatedAt": "2017-05-08T20:32:25Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Later the resource key is described with a particular order, should that be reflected here (or pulled out and referenced in both places)",
              "createdAt": "2017-05-08T20:32:25Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Nzc0MjU=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:32:44Z",
          "updatedAt": "2017-05-08T20:32:44Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "I think it makes sense and will make parser simpler.",
              "createdAt": "2017-05-08T20:32:44Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Nzc0NDk=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:32:51Z",
          "updatedAt": "2017-05-08T20:32:51Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Same here.",
              "createdAt": "2017-05-08T20:32:51Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Nzc1MjQ=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "in general this lgtm",
          "createdAt": "2017-05-08T20:33:14Z",
          "updatedAt": "2017-05-08T20:33:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4Nzc4MTQ=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:34:23Z",
          "updatedAt": "2017-05-08T20:34:23Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Having the array makes sense, or not-having it?",
              "createdAt": "2017-05-08T20:34:23Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODE1Njc=",
          "commit": {
            "abbreviatedOid": "d86363f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:49:33Z",
          "updatedAt": "2017-05-08T20:49:33Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Done, thanks.",
              "createdAt": "2017-05-08T20:49:33Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODE3MzM=",
          "commit": {
            "abbreviatedOid": "ab14fdd"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T20:50:12Z",
          "updatedAt": "2017-05-08T20:50:12Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Having the array.",
              "createdAt": "2017-05-08T20:50:12Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODQyNzc=",
          "commit": {
            "abbreviatedOid": "ab14fdd"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T21:00:43Z",
          "updatedAt": "2017-05-08T21:00:43Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "Could you add a comment explaining how the hashes are mapped to resources? Is it based on the order in the array?",
              "createdAt": "2017-05-08T21:00:43Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODQ5NDU=",
          "commit": {
            "abbreviatedOid": "ab14fdd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T21:03:56Z",
          "updatedAt": "2017-05-08T21:03:56Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "The idea is that we make a set of the allowed `hash-value`s, hash each resource, and then the resource is allowed if its hash appears in the set. I'll try to describe that more clearly.",
              "createdAt": "2017-05-08T21:03:56Z",
              "updatedAt": "2017-05-08T21:08:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY4ODYwMDM=",
          "commit": {
            "abbreviatedOid": "ab14fdd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-08T21:08:43Z",
          "updatedAt": "2017-05-08T21:08:43Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "How's this?",
              "createdAt": "2017-05-08T21:08:43Z",
              "updatedAt": "2017-05-08T21:08:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5MTk4OTc=",
          "commit": {
            "abbreviatedOid": "997f5db"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-09T00:42:35Z",
          "updatedAt": "2017-05-09T00:42:35Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "Is the mapping resource->hash done here by using the same order of the hash-values as resources in indexed content? It's not explicitly said anywhere I think...",
              "createdAt": "2017-05-09T00:42:35Z",
              "updatedAt": "2017-05-09T00:42:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY5NDE4NTg=",
          "commit": {
            "abbreviatedOid": "997f5db"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-09T05:12:50Z",
          "updatedAt": "2017-05-09T05:12:50Z",
          "comments": [
            {
              "originalPosition": 133,
              "body": "No, the list of hash values here is just a set. If the resource matches any of them, it's valid. I think https://github.com/dimich-g/webpackage/pull/46/files#diff-04c6e90faac2675aa89e2176d2eec7d8R316 says this.",
              "createdAt": "2017-05-09T05:12:50Z",
              "updatedAt": "2017-05-09T05:12:50Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "76678469d459008a715ac72954a0ef401f2164b6",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "remove-redundant-resource-keys",
      "headRefOid": "997f5dbe02b4453eeda0281dc379c7778b590d50",
      "mergeCommit": {
        "oid": "88ce441f15a73455027b646f24dd9d7be6aa03d0"
      }
    },
    {
      "number": 49,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE4NDU5MDUw",
      "title": "Update the packaging tool to generate CBOR packages from a text format.",
      "url": "https://github.com/WICG/webpackage/pull/49",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This doesn't yet support signed manifests, and it's not tested as thoroughly as\r\nI'd like, but it can generate packages for the first couple examples.\r\n\r\nIt assumes that #46 is accepted.",
      "createdAt": "2017-05-01T23:16:13Z",
      "updatedAt": "2017-05-11T00:04:29Z",
      "closedAt": "2017-05-11T00:04:26Z",
      "mergedAt": "2017-05-11T00:04:26Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDA1Mzc=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Hi, sorry for the extremely partial review, but this is a large PR :)  Will continue tomorrow.",
          "createdAt": "2017-05-03T21:14:01Z",
          "updatedAt": "2017-05-03T23:26:28Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Can you explicitly outline the major types in the comment? ",
              "createdAt": "2017-05-03T21:14:01Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 5,
              "body": "Do you just mean Additional information = 27 or something else?",
              "createdAt": "2017-05-03T21:18:34Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 12,
              "body": "Does this mean bignums?",
              "createdAt": "2017-05-03T21:45:41Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 12,
              "body": "Perhaps it should be better specified as we don't support tagging of items?",
              "createdAt": "2017-05-03T21:47:12Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 22,
              "body": "This is somewhat misleading since it's not a signed int but actually a negative one.",
              "createdAt": "2017-05-03T21:58:10Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjkzMTY=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-04T17:07:14Z",
          "updatedAt": "2017-05-04T17:07:14Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "No, not bignums. The Major Type 1 format supports numbers down to -2^64, but int64 only holds down to -2^63. I've clarified the comment.",
              "createdAt": "2017-05-04T17:07:14Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjkzNjY=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-04T17:07:26Z",
          "updatedAt": "2017-05-04T17:07:26Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Good point. Renamed to TypePosInt and TypeNegInt.",
              "createdAt": "2017-05-04T17:07:26Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjk0MjY=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-04T17:07:36Z",
          "updatedAt": "2017-05-04T17:07:36Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Just additional information=27.",
              "createdAt": "2017-05-04T17:07:36Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYzMjk0NDI=",
          "commit": {
            "abbreviatedOid": "79451c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-04T17:07:39Z",
          "updatedAt": "2017-05-04T17:07:39Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2017-05-04T17:07:39Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY0MDYwMjU=",
          "commit": {
            "abbreviatedOid": "4516174"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "In general this lgtm, I'm not sure that I'm able to fully cope with 1300 line patches so I might have missed something :)\r\n\r\nThanks!",
          "createdAt": "2017-05-04T22:46:45Z",
          "updatedAt": "2017-05-09T16:57:07Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "The range of numbers we claim to support (std::numeric_limits<int64_t>::min() through std::numeric_limits<uint64_t>::max() is a bit unusual.  Would the client of the parser need to explicitly expect a signed or unsigned integer?",
              "createdAt": "2017-05-04T22:46:45Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "it might not be very future-proof to read potentially large packages into memory like this.",
              "createdAt": "2017-05-04T22:48:11Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "Same with writing cbor to an array of bytes rather than bytestream.",
              "createdAt": "2017-05-04T22:49:57Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 41,
              "body": "nit: comment explaining the magic numbr",
              "createdAt": "2017-05-04T22:50:32Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 105,
              "body": "so all headers are in the resource key now, not just vary-enabled ones?\r\n\r\n(also there is no definition of resource key in the README)",
              "createdAt": "2017-05-04T23:09:50Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "int here turns into uint on line 21?",
              "createdAt": "2017-05-04T23:17:32Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 42,
              "body": "can you document why offset is used in this operation?",
              "createdAt": "2017-05-08T20:35:07Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzcwOTE1MzE=",
          "commit": {
            "abbreviatedOid": "4516174"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-09T17:03:55Z",
          "updatedAt": "2017-05-09T19:09:16Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I have an `AppendUint64` and an `AppendInt64` function, which let the client say whether they have a signed or unsigned integer.",
              "createdAt": "2017-05-09T17:03:55Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "Yeah, it's like this because the only call is from len(x), which returns an int. I think my use of `int` vs `int64` vs `uint64` is probably unconventional for Go. `int` seems to be `ssize_t`, which meant that I started second-guessing lots of places I used uint64 for sizes of things in packages: even if we want a package larger than `int`, the buffer used to hold the package can't be that big, so there's no point in using `uint64`. Do you have suggestions or preferences?",
              "createdAt": "2017-05-09T17:11:07Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 42,
              "body": "Done.",
              "createdAt": "2017-05-09T18:05:36Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 19,
              "body": "Yep. I'd like to use mmap, but https://godoc.org/golang.org/x/exp/mmap is experimental and doesn't actually let me extract byte slices from the file without copying them. Should I use https://github.com/edsrzf/mmap-go? For large packages, I think we're going to wind up in C++ (or Rust) anyway, since that's where the browsers are, so maybe it doesn't matter for this implementation.\r\n\r\nBecause of the indexes, it's hard to write the package to a bytestream in one pass. It would be possible to write the `resources` section to a file, then compose the index and read that file back to generate the final package. That approach might also let me delete the complexity around PendingInts.",
              "createdAt": "2017-05-09T18:33:27Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 41,
              "body": "Done.",
              "createdAt": "2017-05-09T18:37:27Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            },
            {
              "originalPosition": 105,
              "body": "I'm blindly copying headers from `part`, but it's up to the package author to make sure they only put `Vary`-enabled headers there. I've now checked this in text_format.go, and we should check it in the CBOR parser once it's implemented.\r\n\r\nhttps://github.com/jyasskin/webpackage/blob/remove-redundant-resource-keys/README.md#main-content has the definition of `resource-key`.",
              "createdAt": "2017-05-09T18:41:33Z",
              "updatedAt": "2017-05-11T00:03:06Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "88ce441f15a73455027b646f24dd9d7be6aa03d0",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "packaging-tool",
      "headRefOid": "df6d888c3a03444c13d62833e0dc94721854e969",
      "mergeCommit": {
        "oid": "b520f8dd864de18325e7bd2a2e8759d881bcaeba"
      }
    },
    {
      "number": 50,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE4NDYzNTcy",
      "title": "Update the unsigned examples for the new format.",
      "url": "https://github.com/WICG/webpackage/pull/50",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This uses the tool from #49.",
      "createdAt": "2017-05-02T00:01:38Z",
      "updatedAt": "2017-05-17T18:50:39Z",
      "closedAt": "2017-05-17T18:50:35Z",
      "mergedAt": "2017-05-17T18:50:35Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3NTA1Mzk=",
          "commit": {
            "abbreviatedOid": "3aa18c2"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-05-17T18:25:11Z",
          "updatedAt": "2017-05-17T18:25:11Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "76678469d459008a715ac72954a0ef401f2164b6",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-examples",
      "headRefOid": "3aa18c2fc6f64ea35f4d4ff5d25d637f65f6c971",
      "mergeCommit": {
        "oid": "3eedaa9534cd7141488aacc15c8ad7d50eca6541"
      }
    },
    {
      "number": 51,
      "id": "MDExOlB1bGxSZXF1ZXN0MTE5NTQxOTA1",
      "title": "Split the Local Sharing use case into shapshots and signed apps.",
      "url": "https://github.com/WICG/webpackage/pull/51",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Is there a more official link to the Chrome MHTML work than http://www.techgainer.com/enable-single-file-mhtml-support-chrome/?",
      "createdAt": "2017-05-08T21:44:44Z",
      "updatedAt": "2017-05-24T00:16:03Z",
      "closedAt": "2017-05-24T00:16:01Z",
      "mergedAt": "2017-05-24T00:16:01Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4OTcyOTI=",
          "commit": {
            "abbreviatedOid": "1cabbfe"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-05-23T23:54:37Z",
          "updatedAt": "2017-05-23T23:54:37Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "911bc99a1fd722f72a27cd53bf82effbb0f52d51",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "split-local-sharing-use-case",
      "headRefOid": "1cabbfe0b891c78c16287484c1eda74bccdceba0",
      "mergeCommit": {
        "oid": "9804f574a0b4ad23565aab489b58148cddc54d01"
      }
    },
    {
      "number": 53,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIwMDAzMTcy",
      "title": "Write a package in two passes, which lets me remove support for \"pending\" ints.",
      "url": "https://github.com/WICG/webpackage/pull/53",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It also removes the O(#parts^2) slowdown from inserting offsets one at a time, and makes it possible to build packages larger than fit in memory.\r\n\r\n@mrdewitt",
      "createdAt": "2017-05-11T00:06:12Z",
      "updatedAt": "2017-05-23T23:44:46Z",
      "closedAt": "2017-05-23T23:44:44Z",
      "mergedAt": "2017-05-23T23:44:44Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MTA4MzA=",
          "commit": {
            "abbreviatedOid": "f058b5d"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "No major problems with this patch, I think it does make the process a little more readable. \r\n\r\nNow that this repo is getting bigger, you may want someone with Go readability (or at least reasonable amounts of experience) to review this code.",
          "createdAt": "2017-05-16T20:58:58Z",
          "updatedAt": "2017-05-16T21:35:34Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Not a go expert, but any reason you have a block here?",
              "createdAt": "2017-05-16T20:58:58Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            },
            {
              "originalPosition": 9,
              "body": "nit: this would be clearer if the name reflected that it is temporary",
              "createdAt": "2017-05-16T21:00:39Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            },
            {
              "originalPosition": 24,
              "body": "nit: blank line above",
              "createdAt": "2017-05-16T21:32:14Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Mzc2NDg=",
          "commit": {
            "abbreviatedOid": "f058b5d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-05-18T03:52:54Z",
          "updatedAt": "2017-05-18T04:00:05Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Done.",
              "createdAt": "2017-05-18T03:52:54Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            },
            {
              "originalPosition": 73,
              "body": "It seemed easier to read. Maybe it's not because it makes readers wonder why there's a block?",
              "createdAt": "2017-05-18T03:57:16Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            },
            {
              "originalPosition": 24,
              "body": "Removed.",
              "createdAt": "2017-05-18T03:58:29Z",
              "updatedAt": "2017-05-23T23:44:37Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "911bc99a1fd722f72a27cd53bf82effbb0f52d51",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "two-pass",
      "headRefOid": "6919e07fabf59eb1f5e5ac33ecf81b486ec4e9a4",
      "mergeCommit": {
        "oid": "0b330a7077742c94ed9a51122e05200c861cfc4f"
      }
    },
    {
      "number": 54,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIwMTgwMTgx",
      "title": "Add a function to parse the text format from an inline manifest.",
      "url": "https://github.com/WICG/webpackage/pull/54",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This lets me write tests without adding a new file for each test.",
      "createdAt": "2017-05-11T19:12:44Z",
      "updatedAt": "2017-05-24T00:11:47Z",
      "closedAt": "2017-05-24T00:11:44Z",
      "mergedAt": "2017-05-24T00:11:44Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk4OTc1MjM=",
          "commit": {
            "abbreviatedOid": "8d021eb"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-05-23T23:56:22Z",
          "updatedAt": "2017-05-23T23:56:22Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0b330a7077742c94ed9a51122e05200c861cfc4f",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "parse-text-content",
      "headRefOid": "2e66e680dbcea425837718da3ae4d09c696bd1ba",
      "mergeCommit": {
        "oid": "d1e6a40a8ce7fbe257f558798c0f2a7c445c517e"
      }
    },
    {
      "number": 55,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIxNTg4MDAz",
      "title": "Parse manifests",
      "url": "https://github.com/WICG/webpackage/pull/55",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There's no support yet for serializing the text format including manifest data, or serializing and signing the CBOR format.",
      "createdAt": "2017-05-19T21:42:51Z",
      "updatedAt": "2017-06-26T15:47:04Z",
      "closedAt": "2017-06-26T15:47:01Z",
      "mergedAt": "2017-06-26T15:47:01Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "Does this need a rebase?  It looks like the 2 pass commit is part of this pull request.",
          "createdAt": "2017-05-23T23:53:26Z",
          "updatedAt": "2017-05-23T23:53:26Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Rebased.",
          "createdAt": "2017-05-24T00:11:11Z",
          "updatedAt": "2017-05-24T00:11:11Z"
        },
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "Any reason you haven't merged this?",
          "createdAt": "2017-06-26T15:41:50Z",
          "updatedAt": "2017-06-26T15:41:50Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I was waiting for an LGTM, but I guess you approved it in your first review. I'll merge.",
          "createdAt": "2017-06-26T15:46:41Z",
          "updatedAt": "2017-06-26T15:46:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMwMjQ0NDc=",
          "commit": {
            "abbreviatedOid": "d636b01"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This looks great in general!  Just a few comments.",
          "createdAt": "2017-06-08T21:54:46Z",
          "updatedAt": "2017-06-08T23:04:24Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Can this list be expanded?",
              "createdAt": "2017-06-08T21:54:46Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 73,
              "body": "Any reason you didn't just use crypto.Signer? https://golang.org/src/crypto/crypto.go?s=3217:4212#L97\r\n",
              "createdAt": "2017-06-08T22:22:18Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 16,
              "body": "nit: maybe LoadCertificatesFromFile?  Into reads more like into the file to me.",
              "createdAt": "2017-06-08T23:03:05Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTEzMzA=",
          "commit": {
            "abbreviatedOid": "85421cd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T15:47:12Z",
          "updatedAt": "2017-06-09T15:47:12Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Sure, done. I could also use just `LoadCertificates()`. I had `Into` to distinguish it from a function that I've since removed.",
              "createdAt": "2017-06-09T15:47:12Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTc5OTk=",
          "commit": {
            "abbreviatedOid": "d976a35"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T16:14:04Z",
          "updatedAt": "2017-06-09T16:19:39Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "want a new line at eof?",
              "createdAt": "2017-06-09T16:14:04Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 1,
              "body": "Can you please add tests for each type of private key that we support?",
              "createdAt": "2017-06-09T16:14:43Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 1,
              "body": "Can be in another patch.",
              "createdAt": "2017-06-09T16:14:50Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDk0MDA=",
          "commit": {
            "abbreviatedOid": "a841da4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T03:51:18Z",
          "updatedAt": "2017-06-14T03:57:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Whoops, added.",
              "createdAt": "2017-06-14T03:51:18Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            },
            {
              "originalPosition": 1,
              "body": "Yep, filed #72.",
              "createdAt": "2017-06-14T03:56:47Z",
              "updatedAt": "2017-06-14T18:50:43Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c216a89602e4402695ed93ec7b7ecac59f819ffb",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "manifest",
      "headRefOid": "8357c0f569142a5467d7640b9891d09656959347",
      "mergeCommit": {
        "oid": "73ee26a753e7d50b62f6e6e7ee01745048a4d036"
      }
    },
    {
      "number": 56,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIyMTIwODUx",
      "title": "Improve readability.",
      "url": "https://github.com/WICG/webpackage/pull/56",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I'll try to get some experienced Go programmers to review this and suggest other ways to improve readability, as requested in https://github.com/dimich-g/webpackage/pull/53#pullrequestreview-38510830.",
      "createdAt": "2017-05-24T00:09:34Z",
      "updatedAt": "2017-06-02T22:50:30Z",
      "closedAt": "2017-06-02T22:50:26Z",
      "mergedAt": "2017-06-02T22:50:26Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "50eac842a351cd0a73db38de191bf374e3965f51",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "readability",
      "headRefOid": "4cf34bf27fa6315d3b836db605e189b048cb3c78",
      "mergeCommit": {
        "oid": "24018caf61efd00310f0e20c296c38a6911b9003"
      }
    },
    {
      "number": 60,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIzODEzNTA1",
      "title": "Store URL and status in HTTP2 pseudoheaders.",
      "url": "https://github.com/WICG/webpackage/pull/60",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-06-02T22:49:44Z",
      "updatedAt": "2017-06-26T16:10:57Z",
      "closedAt": "2017-06-26T16:10:54Z",
      "mergedAt": "2017-06-26T16:10:54Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think that the requested changes have been factored out, so this should be good to go.",
          "createdAt": "2017-06-26T16:09:13Z",
          "updatedAt": "2017-06-26T16:09:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyNjc2OTc=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "state": "DISMISSED",
          "body": "",
          "createdAt": "2017-06-09T21:40:29Z",
          "updatedAt": "2017-06-26T16:10:16Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I feel I should have asked before, but what is potential purpose to keep 'method' here? It seems to add to confusion because it's unclear how would that be processed by UA and what the method would exactly mean.",
              "createdAt": "2017-06-09T21:40:29Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            },
            {
              "originalPosition": 14,
              "body": "Same question about 200 - do we need it as part of the format? If not, it's probably better to remove and add later if/when the need arises.",
              "createdAt": "2017-06-09T21:41:12Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTA4NjQ=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-10T05:27:32Z",
          "updatedAt": "2017-06-10T05:27:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I'm not sure we need `:method`: it's here because it's in HTTP2, but I don't know of any methods besides GET that we'd want to support. I think this is something the folks at the IETF might be able to give us useful feedback about. I've filed #70 to track this.",
              "createdAt": "2017-06-10T05:27:32Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMyOTA5NDI=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-10T05:32:44Z",
          "updatedAt": "2017-06-10T05:32:45Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I think we *do* have uses for other `:status`es: specifically, we should be able to store 301 and 302 redirections in the package. We could make 200 the default if the `:status` is omitted, but in HPACK it's a 1-byte overhead, so I didn't think omitting it was worthwhile.",
              "createdAt": "2017-06-10T05:32:44Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxOTk2MzA=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T16:21:19Z",
          "updatedAt": "2017-06-13T22:25:43Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "requestHeaders[4:] is sprinkled around this pull request, can you refactor it a bit so it's clearer what you are referring to?",
              "createdAt": "2017-06-09T16:21:19Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            },
            {
              "originalPosition": 37,
              "body": "Same with responseHeaders[1:]",
              "createdAt": "2017-06-09T16:21:28Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDg4NTM=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T03:44:53Z",
          "updatedAt": "2017-06-14T03:44:53Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Done.",
              "createdAt": "2017-06-14T03:44:53Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDkxNzY=",
          "commit": {
            "abbreviatedOid": "971ad18"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T03:48:30Z",
          "updatedAt": "2017-06-14T03:48:30Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Is it all right if I submit this PR and send a separate one to remove `:method`? I think that'll do better to focus discussion on whether it's a good idea to diverge from HTTP2 here.",
              "createdAt": "2017-06-14T03:48:30Z",
              "updatedAt": "2017-06-26T15:57:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMDg2Mzg=",
          "commit": {
            "abbreviatedOid": "3a8ab0d"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-26T16:08:49Z",
          "updatedAt": "2017-06-26T16:08:49Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "73ee26a753e7d50b62f6e6e7ee01745048a4d036",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "url-status-in-headers",
      "headRefOid": "c993f8b72435f4dd08d51a095491095ac6ae8d6f",
      "mergeCommit": {
        "oid": "cde34a929c65911b090c9df433aeb94e1180de31"
      }
    },
    {
      "number": 61,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIzODE4OTc0",
      "title": "Rearrange writing the resource body so it doesn't have to materialize in memory.",
      "url": "https://github.com/WICG/webpackage/pull/61",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Using a Writer makes it easier to hash the resource at the same time it's being written to the CBOR serialization.",
      "createdAt": "2017-06-02T23:55:40Z",
      "updatedAt": "2017-06-14T03:31:44Z",
      "closedAt": "2017-06-14T03:31:41Z",
      "mergedAt": "2017-06-14T03:31:41Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4ODA0Mzk=",
          "commit": {
            "abbreviatedOid": "1b764c4"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-13T23:19:15Z",
          "updatedAt": "2017-06-13T23:45:31Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "if bw.item.Write fails, is n negative?",
              "createdAt": "2017-06-13T23:19:15Z",
              "updatedAt": "2017-06-13T23:45:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM5MDc2MzM=",
          "commit": {
            "abbreviatedOid": "1b764c4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T03:31:17Z",
          "updatedAt": "2017-06-14T03:31:17Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "According to https://golang.org/pkg/bufio/#Writer.Write and https://golang.org/pkg/io/#Writer, no: Go uses the err return instead of negative lengths to convey errors.",
              "createdAt": "2017-06-14T03:31:17Z",
              "updatedAt": "2017-06-14T03:31:17Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "24018caf61efd00310f0e20c296c38a6911b9003",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "bytes-writer",
      "headRefOid": "1b764c4ab200233aff5f1281274ac8b5eb7aa2ed",
      "mergeCommit": {
        "oid": "c658e8d104bce788d383f6281951829db4fff1a8"
      }
    },
    {
      "number": 62,
      "id": "MDExOlB1bGxSZXF1ZXN0MTIzODIwMjkx",
      "title": "Write signed manifests to the CBOR format.",
      "url": "https://github.com/WICG/webpackage/pull/62",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This sits on top of #55, #60, #61, #63, #64, #65, and #66. Sorry that it's so long again.",
      "createdAt": "2017-06-03T00:16:13Z",
      "updatedAt": "2018-04-10T23:25:50Z",
      "closedAt": "2018-04-10T23:25:50Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYzMjc5MDk=",
          "commit": {
            "abbreviatedOid": "51fd9d3"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-26T17:26:19Z",
          "updatedAt": "2017-06-26T17:48:25Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "micro nit: process \"date\" first to match the order in the spec",
              "createdAt": "2017-06-26T17:26:19Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            },
            {
              "originalPosition": 38,
              "body": "is it more canonical to name the return value than to declare one in the first line of the function?",
              "createdAt": "2017-06-26T17:33:58Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            },
            {
              "originalPosition": 216,
              "body": "Does this actually verify that signingCert corresponds to a DNSName of \"example.com\"?  Does it make sense to add a test for attempts to sign a package with no signatures corresponding to the origin?",
              "createdAt": "2017-06-26T17:47:48Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NjI2NzI=",
          "commit": {
            "abbreviatedOid": "51fd9d3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-02T23:41:52Z",
          "updatedAt": "2017-08-02T23:41:52Z",
          "comments": [
            {
              "originalPosition": 235,
              "body": "Done.",
              "createdAt": "2017-08-02T23:41:52Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NjI2NzM=",
          "commit": {
            "abbreviatedOid": "51fd9d3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-02T23:41:54Z",
          "updatedAt": "2017-08-02T23:41:54Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I don't know, but I can do that instead.",
              "createdAt": "2017-08-02T23:41:54Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTM5NjI2NzY=",
          "commit": {
            "abbreviatedOid": "51fd9d3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-02T23:41:56Z",
          "updatedAt": "2017-08-02T23:41:56Z",
          "comments": [
            {
              "originalPosition": 216,
              "body": "Yes, and I've added an extra test with the wrong DNSName to check that.\r\n\r\nAnd I've added a check that at least one signature covers the package's origin.",
              "createdAt": "2017-08-02T23:41:56Z",
              "updatedAt": "2017-08-15T00:00:38Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "17a3460be2f276436addc8ba8176a6916ed53b91",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "sign-cbor",
      "headRefOid": "a7c49075a0771788f9ecd83821f3e5db3fa8e313",
      "mergeCommit": null
    },
    {
      "number": 63,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NDg5MDA4",
      "title": "Refine the algorithm for hashing a resource.",
      "url": "https://github.com/WICG/webpackage/pull/63",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Headers are decompressed before being hashed.",
      "createdAt": "2017-06-07T18:35:11Z",
      "updatedAt": "2017-06-14T03:33:42Z",
      "closedAt": "2017-06-14T03:33:39Z",
      "mergedAt": "2017-06-14T03:33:39Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to get these merged, and then send another PR to remove `:method`.",
          "createdAt": "2017-06-14T03:33:35Z",
          "updatedAt": "2017-06-14T03:33:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4ODQyMDM=",
          "commit": {
            "abbreviatedOid": "8f53788"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm pending the :method discussion.",
          "createdAt": "2017-06-13T23:46:30Z",
          "updatedAt": "2017-06-13T23:46:30Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "24018caf61efd00310f0e20c296c38a6911b9003",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "refine-hash",
      "headRefOid": "8f53788c1672c29d98bcfec04630326c2d8037cc",
      "mergeCommit": {
        "oid": "12d483b60a3c74e5ff54e9eca59c86507a79cc13"
      }
    },
    {
      "number": 64,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NDkwNzI0",
      "title": "Define how to pick a signing algorithm based on a certificate's public key.",
      "url": "https://github.com/WICG/webpackage/pull/64",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "And add some Go code to sign a message into a byte string.",
      "createdAt": "2017-06-07T18:43:49Z",
      "updatedAt": "2017-06-17T04:31:34Z",
      "closedAt": "2017-06-17T04:31:31Z",
      "mergedAt": "2017-06-17T04:31:31Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I checked with @sleevi, who thinks this set is ok. We may need to add RSA-4096 in the future, but because intermediates and roots tend to be 2048 bits, those don't actually add security.",
          "createdAt": "2017-06-17T04:30:36Z",
          "updatedAt": "2017-06-17T04:30:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODU4NzA=",
          "commit": {
            "abbreviatedOid": "33eef8b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T15:26:38Z",
          "updatedAt": "2017-06-09T15:28:30Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Moved @mrdewitt's comment from https://github.com/WICG/webpackage/pull/55#discussion_r121008410:\r\n\r\n> Can this list be expanded?",
              "createdAt": "2017-06-09T15:26:38Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 73,
              "body": "Moved @mrdewitt's comment from https://github.com/WICG/webpackage/pull/55#discussion_r121012844:\r\n\r\n> Any reason you didn't just use crypto.Signer? https://golang.org/src/crypto/crypto.go?s=3217:4212#L97",
              "createdAt": "2017-06-09T15:27:52Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODgxMDI=",
          "commit": {
            "abbreviatedOid": "33eef8b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T15:35:17Z",
          "updatedAt": "2017-06-09T15:35:17Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Yes, but the expansion can't be implemented in Go yet. e.g. ed25519 is an obvious extension, but it's missing from their crypto library. For now, it doesn't matter because there are no TLS certificates with public key types other than the ones here (except perhaps for really long RSA keys).",
              "createdAt": "2017-06-09T15:35:17Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDMxODkzNDM=",
          "commit": {
            "abbreviatedOid": "33eef8b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-09T15:39:59Z",
          "updatedAt": "2017-06-09T15:39:59Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "crypto.Signer requires that the caller hash the message, while this file incorporates the hash into the Sign() function. I could replace the rsa.SignPSS call with s.privKey.Sign(..., & PSSOptions{Hash:s.Hash}), but that doesn't seem any clearer, and the [documentation](https://golang.org/pkg/crypto/rsa/#PrivateKey.Sign) says \"Common uses should use the Sign* functions in this package.\"",
              "createdAt": "2017-06-09T15:39:59Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM4ODQ1MTQ=",
          "commit": {
            "abbreviatedOid": "33eef8b"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-13T23:49:12Z",
          "updatedAt": "2017-06-14T15:53:47Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "https://bugs.chromium.org/p/chromium/issues/detail?id=478225\r\n\r\nChrome doesn't appear to support secp521r1. Shall we omit this from this format as well?",
              "createdAt": "2017-06-13T23:49:13Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 12,
              "body": "Imports should probably be migrated to WICG",
              "createdAt": "2017-06-13T23:50:28Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 46,
              "body": "Is this actually inequality, or should we be listing explicit bit lengths that are accepted?",
              "createdAt": "2017-06-14T00:08:03Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 55,
              "body": "I wish these were pre-defined constants somewhere. But I didn't see that in a brief overview of crypto/elliptic",
              "createdAt": "2017-06-14T15:53:04Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 4,
              "body": "nit: link?",
              "createdAt": "2017-06-14T15:53:41Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjY1MjQ=",
          "commit": {
            "abbreviatedOid": "932f36b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "@sleevi, this patch now says the format only supports RSA2048, secp256r1, and secp384r1. Is that the right set, in order to capture nearly all existing TLS leaf certificates and avoid putting too much flexibility in the protocol?",
          "createdAt": "2017-06-14T16:01:39Z",
          "updatedAt": "2017-06-14T16:56:10Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Interesting. Sounds good, to reduce the amount of flexibility in the protocol.",
              "createdAt": "2017-06-14T16:01:39Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 46,
              "body": "Right now, it's actually inequality, but I think you're right that we should just list explicit lengths.",
              "createdAt": "2017-06-14T16:37:39Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 4,
              "body": "Added.",
              "createdAt": "2017-06-14T16:40:06Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 55,
              "body": "I could use elliptic.P256().Params().Name.",
              "createdAt": "2017-06-14T16:42:40Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            },
            {
              "originalPosition": 12,
              "body": "Thanks, done in b8ae7b5797550d28f94edcbf461e6d96ac9071eb.",
              "createdAt": "2017-06-14T16:44:39Z",
              "updatedAt": "2017-06-14T17:01:04Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c216a89602e4402695ed93ec7b7ecac59f819ffb",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "signing",
      "headRefOid": "2f8cdde24f0c24d498e8b7d034c77b7233a784f2",
      "mergeCommit": {
        "oid": "3a3aa5e40d575cb7371d324e82b899707d2f8c75"
      }
    },
    {
      "number": 65,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NDk2MzE3",
      "title": "Remove unused code from Package.",
      "url": "https://github.com/WICG/webpackage/pull/65",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-06-07T19:13:11Z",
      "updatedAt": "2017-06-14T15:58:32Z",
      "closedAt": "2017-06-14T15:58:29Z",
      "mergedAt": "2017-06-14T15:58:29Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjQyODg=",
          "commit": {
            "abbreviatedOid": "e2215ba"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-14T15:54:21Z",
          "updatedAt": "2017-06-14T15:54:21Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "12d483b60a3c74e5ff54e9eca59c86507a79cc13",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "simplify-package",
      "headRefOid": "e2215ba177eb467f737cff4fc8527906f2df7226",
      "mergeCommit": {
        "oid": "d4330c6625aa60ce735fee6de34ee7c5fc301273"
      }
    },
    {
      "number": 66,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NDk4OTEw",
      "title": "Add a simple CBOR parser to make it easier to test the CBOR writer.",
      "url": "https://github.com/WICG/webpackage/pull/66",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2017-06-07T19:26:32Z",
      "updatedAt": "2017-06-14T16:59:27Z",
      "closedAt": "2017-06-14T16:59:24Z",
      "mergedAt": "2017-06-14T16:59:24Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjUxODc=",
          "commit": {
            "abbreviatedOid": "f79658a"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-06-14T15:57:20Z",
          "updatedAt": "2017-06-14T16:03:29Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "nit: not clear what \"full\" is at first glance.",
              "createdAt": "2017-06-14T15:57:20Z",
              "updatedAt": "2017-06-14T16:58:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNjk2Njc=",
          "commit": {
            "abbreviatedOid": "f79658a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T16:12:52Z",
          "updatedAt": "2017-06-14T16:12:52Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Yeah, it's the full buffer that's being decoded. Does this just need a comment, or would you rather some other name?",
              "createdAt": "2017-06-14T16:12:52Z",
              "updatedAt": "2017-06-14T16:58:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwNzExOTc=",
          "commit": {
            "abbreviatedOid": "f79658a"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T16:18:27Z",
          "updatedAt": "2017-06-14T16:18:27Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "probably prefer something like cborBytes or cborBuffer but that might just be my verbose C++ history. I leave it up to you.",
              "createdAt": "2017-06-14T16:18:27Z",
              "updatedAt": "2017-06-14T16:58:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQwODE4OTk=",
          "commit": {
            "abbreviatedOid": "f79658a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-06-14T16:58:58Z",
          "updatedAt": "2017-06-14T16:58:58Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Sure, done.",
              "createdAt": "2017-06-14T16:58:58Z",
              "updatedAt": "2017-06-14T16:58:58Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "b8ae7b5797550d28f94edcbf461e6d96ac9071eb",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "cbor-reader",
      "headRefOid": "3f4aa44716785d1e78b9bcb0b4f49619d1d10b1a",
      "mergeCommit": {
        "oid": "c216a89602e4402695ed93ec7b7ecac59f819ffb"
      }
    },
    {
      "number": 67,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NTQxMzk5",
      "title": "Add support for encrypted and missing keys to wpktext2cbor.",
      "url": "https://github.com/WICG/webpackage/pull/67",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This depends on #62.",
      "createdAt": "2017-06-07T23:49:55Z",
      "updatedAt": "2018-04-10T23:26:01Z",
      "closedAt": "2018-04-10T23:26:01Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cde34a929c65911b090c9df433aeb94e1180de31",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "wpktext2cbor-with-encrypted-keys",
      "headRefOid": "4aab6972015ac3f21e5210cbc46779613fd6e7e5",
      "mergeCommit": null
    },
    {
      "number": 68,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI0NTQxNDU1",
      "title": "Update the signed one-origin example.",
      "url": "https://github.com/WICG/webpackage/pull/68",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This update was generated using #67, but we can commit it without all that code.",
      "createdAt": "2017-06-07T23:50:29Z",
      "updatedAt": "2017-06-26T16:23:04Z",
      "closedAt": "2017-06-08T23:46:43Z",
      "mergedAt": "2017-06-08T23:46:43Z",
      "mergedBy": "dimich-g",
      "comments": [
        {
          "author": "dimich-g",
          "authorAssociation": "COLLABORATOR",
          "body": "This looks good. Merging...",
          "createdAt": "2017-06-08T23:46:57Z",
          "updatedAt": "2017-06-08T23:46:57Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "24018caf61efd00310f0e20c296c38a6911b9003",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-signed-example",
      "headRefOid": "a87d12ce43bde679dc7cd98b18cab8edf26bb5fb",
      "mergeCommit": {
        "oid": "0abb3c10b6711d15d1a7a4947b9ac61c839b1c3d"
      }
    },
    {
      "number": 76,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI4NDY0NDk3",
      "title": "Write an internet draft",
      "url": "https://github.com/WICG/webpackage/pull/76",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #71. I'm going to submit the draft to the IETF before this is reviewed in order to make their July 3 deadline, but I definitely want y'all to point out problems so I can fix them in the next draft.\r\n\r\nI've pre-emptively removed the :method header (#70) and changed the `sections` map into an array, and I'll backfill those into the explainer and implementation when I get a bit more time.",
      "createdAt": "2017-06-30T23:07:58Z",
      "updatedAt": "2017-08-14T23:58:07Z",
      "closedAt": "2017-08-14T23:58:02Z",
      "mergedAt": "2017-08-14T23:58:01Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge this to make it easier for me to build on top of it. Feel free to send other comments or file bugs about what needs to change.",
          "createdAt": "2017-08-14T23:46:03Z",
          "updatedAt": "2017-08-14T23:46:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NDQ0MTk=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2017-07-06T19:50:18Z",
          "updatedAt": "2017-07-06T23:52:52Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "is it normal to use Chromium or Google addresses here?",
              "createdAt": "2017-07-06T19:50:18Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 34,
              "body": "nit: remove \"then\"",
              "createdAt": "2017-07-06T19:50:56Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 62,
              "body": "is \"web application\" well defined?",
              "createdAt": "2017-07-06T19:52:10Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 63,
              "body": "What is TLS-type?  Cryptographic?  PKI-based?",
              "createdAt": "2017-07-06T20:41:23Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 96,
              "body": "Do we envision tools other than browsers using this?  I can think possibly an \"explode to filesystem\" tool would be necesary as well",
              "createdAt": "2017-07-06T20:43:15Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 135,
              "body": "any reason overlap is allowed?",
              "createdAt": "2017-07-06T20:48:36Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 252,
              "body": "perhaps clearer if this said \"the HPACK dynamic table\"",
              "createdAt": "2017-07-06T22:43:40Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 252,
              "body": "Also, this is the first reference to the dynamic table, and is confusingly terse.",
              "createdAt": "2017-07-06T22:54:04Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 281,
              "body": "Have you thought about the issue with how (in loading a package) the browsers will generate requests with headers in a particular order?",
              "createdAt": "2017-07-06T22:56:17Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 373,
              "body": "\"as a subset\" isn't very clear to me, perhaps this is mathematician lingo though?",
              "createdAt": "2017-07-06T23:01:05Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 399,
              "body": "\"Try to find\" is unclear, perhaps something like \"iterate through signing-certificates until one is found that has an identity matching ...",
              "createdAt": "2017-07-06T23:04:17Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 422,
              "body": "Perhaps reorder this paragraph after the cddl defining a subpackage?",
              "createdAt": "2017-07-06T23:05:42Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 463,
              "body": "nit: Could use an example.",
              "createdAt": "2017-07-06T23:06:46Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            },
            {
              "originalPosition": 575,
              "body": "Does this mean that packages become unusable after 7-30 days offline?",
              "createdAt": "2017-07-06T23:51:39Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODA1MzM=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:22:11Z",
          "updatedAt": "2017-08-04T21:22:12Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Folks seem to vary. Several people use @google, but https://tools.ietf.org/html/rfc6797 uses a personal address.",
              "createdAt": "2017-08-04T21:22:11Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODA5ODA=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:24:30Z",
          "updatedAt": "2017-08-04T21:24:30Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I don't know a well-defined term for this. \"Install\" doesn't work well with \"websites\", which also isn't particularly defined. \"Service workers\" have a defined install step, but it's not obvious that we want to insist on service workers for these packages. Any suggestions?",
              "createdAt": "2017-08-04T21:24:30Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODE1NjM=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:27:46Z",
          "updatedAt": "2017-08-04T21:27:46Z",
          "comments": [
            {
              "originalPosition": 96,
              "body": "That's true, but I'm not sure it addresses the need for standardization?",
              "createdAt": "2017-08-04T21:27:46Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODE2NTg=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:28:12Z",
          "updatedAt": "2017-08-04T21:28:12Z",
          "comments": [
            {
              "originalPosition": 135,
              "body": "We can't prohibit overlap without forcing extra work onto parsers. ",
              "createdAt": "2017-08-04T21:28:12Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODMzMDg=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:37:34Z",
          "updatedAt": "2017-08-04T21:37:35Z",
          "comments": [
            {
              "originalPosition": 281,
              "body": "Yes! That'll appear in the W3C spec about browsers loading packages, but basically, we're not going to (can't) locate resources by looking for an exact match between the headers the browser would generate and the key in the index. Instead, the browser will have to use its request information to pick the best of the options provided by the package.",
              "createdAt": "2017-08-04T21:37:34Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY1OTc=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:58:24Z",
          "updatedAt": "2017-08-04T21:58:24Z",
          "comments": [
            {
              "originalPosition": 575,
              "body": "Yes, although there'll be a cheap way to update them and to distribute those updates offline. I can make an argument that we should let a package live forever on a given device as long as that device _never_ goes online, but I'm not sure it'll convince everyone.",
              "createdAt": "2017-08-04T21:58:24Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3ODA=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:28Z",
          "updatedAt": "2017-08-04T21:59:28Z",
          "comments": [
            {
              "originalPosition": 463,
              "body": "Done.",
              "createdAt": "2017-08-04T21:59:28Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3ODE=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:29Z",
          "updatedAt": "2017-08-04T21:59:29Z",
          "comments": [
            {
              "originalPosition": 422,
              "body": "Done.",
              "createdAt": "2017-08-04T21:59:29Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3ODU=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:31Z",
          "updatedAt": "2017-08-04T21:59:31Z",
          "comments": [
            {
              "originalPosition": 399,
              "body": "Great, thanks.",
              "createdAt": "2017-08-04T21:59:31Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3OTE=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:33Z",
          "updatedAt": "2017-08-04T21:59:33Z",
          "comments": [
            {
              "originalPosition": 373,
              "body": "Yes, derived from a function being a particular kind of [relation](https://en.wikipedia.org/wiki/Binary_relation), which is a set of pairs; but this document should be comprehensible to non-mathematicians, so I've changed it.",
              "createdAt": "2017-08-04T21:59:33Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY3OTk=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:35Z",
          "updatedAt": "2017-08-04T21:59:35Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "Yeah ... How about I delete this comment about the dynamic table and rely on the actual parsing described below.",
              "createdAt": "2017-08-04T21:59:35Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY4MDU=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:39Z",
          "updatedAt": "2017-08-04T21:59:39Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "How's this?",
              "createdAt": "2017-08-04T21:59:39Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0ODY4MTI=",
          "commit": {
            "abbreviatedOid": "955e2c3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-04T21:59:42Z",
          "updatedAt": "2017-08-04T21:59:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Done.",
              "createdAt": "2017-08-04T21:59:42Z",
              "updatedAt": "2017-08-14T23:54:42Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "93ddbd148e956b8b9d0c370befb03c0f21f8f348",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "internet-draft",
      "headRefOid": "17a3460be2f276436addc8ba8176a6916ed53b91",
      "mergeCommit": {
        "oid": "17a3460be2f276436addc8ba8176a6916ed53b91"
      }
    },
    {
      "number": 77,
      "id": "MDExOlB1bGxSZXF1ZXN0MTI4NDY3MDUw",
      "title": "Describe the TAG's draft as out-of-date.",
      "url": "https://github.com/WICG/webpackage/pull/77",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I've heard from at least two people who started reading the TAG's document instead of this one because of how prominently we highlight it.",
      "createdAt": "2017-06-30T23:41:37Z",
      "updatedAt": "2017-07-31T15:31:50Z",
      "closedAt": "2017-07-28T23:52:36Z",
      "mergedAt": "2017-07-28T23:52:36Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "body": "Can we also update the TAG document to point to this one? Their version is one of the top links when you search for \"web packaging\". \r\n\r\n/cc @triblondon",
          "createdAt": "2017-07-28T22:32:03Z",
          "updatedAt": "2017-07-28T22:32:03Z"
        },
        {
          "author": "triblondon",
          "authorAssociation": "NONE",
          "body": "That sounds like a sensible idea.  I'm happy to push that change.",
          "createdAt": "2017-07-28T22:35:05Z",
          "updatedAt": "2017-07-28T22:35:05Z"
        },
        {
          "author": "triblondon",
          "authorAssociation": "NONE",
          "body": "Oh, actually since the TAG version is also published in W3C TR space I think I will have to pass the buck to @ylafon",
          "createdAt": "2017-07-28T22:37:15Z",
          "updatedAt": "2017-07-28T22:37:15Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks @triblondon and @ylafon. And I've taken @KenjiBaheux's suggestion to strike out the link, although I'm not sure that's necessary.",
          "createdAt": "2017-07-28T22:58:46Z",
          "updatedAt": "2017-07-28T22:58:46Z"
        },
        {
          "author": "ylafon",
          "authorAssociation": "NONE",
          "body": "Yes, I already amended the README, and will fix both the old edcopy and in /TR/",
          "createdAt": "2017-07-31T12:35:54Z",
          "updatedAt": "2017-07-31T12:35:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks @ylafon!",
          "createdAt": "2017-07-31T15:31:50Z",
          "updatedAt": "2017-07-31T15:31:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg0NzkwODQ=",
          "commit": {
            "abbreviatedOid": "90b0e33"
          },
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "That's probably enough. If it's available, strike through or a footnote for the link, would make it more obvious or less prone to confusion.",
          "createdAt": "2017-07-06T22:19:32Z",
          "updatedAt": "2017-07-06T22:19:32Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cde34a929c65911b090c9df433aeb94e1180de31",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "discourage-tag-draft",
      "headRefOid": "6abae4d0e275cf9e70ca82ca2b6fba5ce96ad2c3",
      "mergeCommit": {
        "oid": "93ddbd148e956b8b9d0c370befb03c0f21f8f348"
      }
    },
    {
      "number": 80,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM1ODY5NTU0",
      "title": "An initial use-cases document for the web packaging proposal.",
      "url": "https://github.com/WICG/webpackage/pull/80",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/draft-webpackage-use-cases/draft-yasskin-webpackage-use-cases.html\r\n\r\n@mnot, you seemed to have some use cases for signing individual request/response/body triples, but I don't remember what they were. Could you list a couple so I can add them to this document?",
      "createdAt": "2017-08-15T19:09:33Z",
      "updatedAt": "2017-08-25T23:35:58Z",
      "closedAt": "2017-08-25T23:35:55Z",
      "mergedAt": "2017-08-25T23:35:55Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY0ODcwNzI=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "great doc!  Just a few comments.",
          "createdAt": "2017-08-15T22:21:33Z",
          "updatedAt": "2017-08-15T23:15:09Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "These requirements are associated but no explanation is given why they are associated.",
              "createdAt": "2017-08-15T22:21:33Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            },
            {
              "originalPosition": 344,
              "body": "Is this worth a little more enumeration?  Confidentiality comes up repeatedly in discussions and it'd be good to ensure that rehashing is minimized.",
              "createdAt": "2017-08-15T23:13:22Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            },
            {
              "originalPosition": 47,
              "body": "Is there some line in the list of priorities that we won't cross?  Is Http/2 push essential to this document? is offline browsing?",
              "createdAt": "2017-08-15T23:14:57Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3OTQxMDg=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-16T23:41:52Z",
          "updatedAt": "2017-08-16T23:41:52Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "I'd say that everything below https://jyasskin.github.io/webpackage/draft-webpackage-use-cases/draft-yasskin-webpackage-use-cases.html#security-review is nice-to-have. Do you think I should split the use-cases into \"essential\" and \"nice-to-have\" buckets to reflect that?",
              "createdAt": "2017-08-16T23:41:52Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3OTQyMzM=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-16T23:42:47Z",
          "updatedAt": "2017-08-16T23:42:47Z",
          "comments": [
            {
              "originalPosition": 344,
              "body": "How's this?",
              "createdAt": "2017-08-16T23:42:47Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY3OTQyNzU=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-16T23:43:06Z",
          "updatedAt": "2017-08-16T23:43:06Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I'll add a sentence to all the associated requirements. That's not done yet.",
              "createdAt": "2017-08-16T23:43:06Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMjAzNTE=",
          "commit": {
            "abbreviatedOid": "5db66ce"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-17T18:49:19Z",
          "updatedAt": "2017-08-17T18:49:19Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Done.",
              "createdAt": "2017-08-17T18:49:19Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTcwMjA4MDQ=",
          "commit": {
            "abbreviatedOid": "3c73dfe"
          },
          "author": "mrdewitt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "still lgtm",
          "createdAt": "2017-08-17T18:50:55Z",
          "updatedAt": "2017-08-17T18:51:21Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Thanks!",
              "createdAt": "2017-08-17T18:50:55Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            },
            {
              "originalPosition": 344,
              "body": "thanks, looks good",
              "createdAt": "2017-08-17T18:51:13Z",
              "updatedAt": "2017-08-25T23:31:07Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "17a3460be2f276436addc8ba8176a6916ed53b91",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "draft-webpackage-use-cases",
      "headRefOid": "83dc856f9a0f8854509f6861ab9b3d8f2b976538",
      "mergeCommit": {
        "oid": "df56bfd7a72fffccd7f97dddf6cc18330d865d5d"
      }
    },
    {
      "number": 81,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM3MzM5MTQy",
      "title": "Start an Internet Draft for signed single responses.",
      "url": "https://github.com/WICG/webpackage/pull/81",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/draft-yasskin-origin-signed-responses/draft-yasskin-http-origin-signed-responses.html\r\n\r\nThis doesn't yet have a design, just some use cases and constraints on the design. I also haven't yet worked out how this would fit into a bundling proposal. It's possible that it doesn't.\r\n\r\n@nyaxt @KenjiBaheux @mnot @mikewest",
      "createdAt": "2017-08-23T23:22:22Z",
      "updatedAt": "2017-08-31T19:40:29Z",
      "closedAt": "2017-08-31T19:40:26Z",
      "mergedAt": "2017-08-31T19:40:26Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to commit this so I can start discussion on the httpbis mailing list. Of course feel free to suggest more changes either here or there.",
          "createdAt": "2017-08-31T19:38:44Z",
          "updatedAt": "2017-08-31T19:38:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTg3ODYxNzM=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-26T00:00:24Z",
          "updatedAt": "2017-08-26T00:00:24Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "@igrigorik, could you check that these performance-related use cases for signed **single** responses make sense? (https://jyasskin.github.io/webpackage/draft-yasskin-origin-signed-responses/draft-yasskin-http-origin-signed-responses.html#use-cases)\r\n\r\nI added some explicit text to the [packaging use cases](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html) to discourage folks from thinking of them as a performance tool, but with fewer use cases overall for non-bundled signed responses, I'm left with the performance ones here.",
              "createdAt": "2017-08-26T00:00:24Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNjcyNjA=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-28T21:00:11Z",
          "updatedAt": "2017-08-28T21:00:11Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "The overall use case makes sense, but enumerating CDNs in markup is painful. Could this be elevated to a document-level opt-in (e.g. via response header or meta directive) that notifies UA that content on this origin can also be fetched from cdn.com? Specifically, say I detect that user is coming from Geo-region X, or mobile network Y, and I have edge caches optimized for each of those... I'd like to emit a header that notifies UA that it can fetch from X or Y; rewriting HTML is super painful.",
              "createdAt": "2017-08-28T21:00:11Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNjc3Mzg=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-28T21:02:10Z",
          "updatedAt": "2017-08-28T21:02:10Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "This may be out of scope, but.. is content-addressable caching something to consider? You note that we want to sign headers+body, but what about cases where I only care about body -- e.g. I don't particularly care which CDN you fetch jquery.v.1.2.3.js from, as long as its content signature matches. ",
              "createdAt": "2017-08-28T21:02:10Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwOTY5NzM=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-28T23:32:59Z",
          "updatedAt": "2017-08-29T00:07:02Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "A custom element could certainly do that sort of dispatching. Following the Extensible Web Manifesto though, I'm inclined to let folks actually write some custom elements for this before baking a URL transformation into browsers.",
              "createdAt": "2017-08-28T23:32:59Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            },
            {
              "originalPosition": 102,
              "body": "There are two separable features here:\r\n\r\n1. Content-addressed caching where the resource original author is willing to vouch for the resource's actual URL. That is, if you have content with the same logical URL and a good signature, you can use it without contacting the CDN. (But this isn't actually content-addressing; it's URL-addressing again.) I think this is safe from a same-origin perspective, but I'm not sufficiently current with the SRI folks' discussion of content-addressing to know if it solves their privacy worries. @mikewest?\r\n2. Cases where you only care about the content, and not its URL. I think this doesn't make sense for signed content: the point of a public keypair is that you can sign more than one thing with it, but then which data signed with the provided public key are you actually trying to use?\r\n\r\nSo ... I'm happy to consider content-addressing, but I think I don't understand what you mean by it in this context.",
              "createdAt": "2017-08-29T00:06:41Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxMDc1MDQ=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-29T00:55:13Z",
          "updatedAt": "2017-08-29T00:55:13Z",
          "comments": [
            {
              "originalPosition": 100,
              "body": "FWIW, I'm skeptical that's a scalable way to do this, or even required one for this use case.. What I'm describing is another iteration on base tag.",
              "createdAt": "2017-08-29T00:55:13Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxMDc4NjU=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-29T00:58:18Z",
          "updatedAt": "2017-08-29T00:58:19Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "My question is mostly as an exercise to identify whether this is in or out of scope of this proposal. Specifically, you call out signing headers+body, but signing body only may have merit in context of sharing responses -- that said, you're right in this case you cant be signing with your key, so perhaps that's out of scope.",
              "createdAt": "2017-08-29T00:58:18Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3MjczMjQ=",
          "commit": {
            "abbreviatedOid": "fc5de1e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-08-31T00:04:31Z",
          "updatedAt": "2017-08-31T00:04:31Z",
          "comments": [
            {
              "originalPosition": 102,
              "body": "I've added a link to https://github.com/mikewest/signature-based-sri/issues/5 arguing that it's unsafe to sign just-a-body, with any key. :smiling_imp: ",
              "createdAt": "2017-08-31T00:04:31Z",
              "updatedAt": "2017-08-31T19:38:14Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7d8054b44235ae18d865a7375694e14563c85d0d",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "draft-yasskin-origin-signed-responses",
      "headRefOid": "c43fab02391b39848ebfab9e1cc3aca18704887f",
      "mergeCommit": {
        "oid": "d68bc0c09117d51276aa3ae1ffc6fb55c8809868"
      }
    },
    {
      "number": 82,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM4MDMxOTE5",
      "title": "Add notes to requirements saying when they conflict with re-using MHTML or ZIP.",
      "url": "https://github.com/WICG/webpackage/pull/82",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview in https://jyasskin.github.io/webpackage/alex-changes/draft-yasskin-webpackage-use-cases.html.\r\n\r\nDid I miss anything obvious or say anything incorrect?\r\n\r\nThis also adds an explicit \"Implementations are hard to get wrong\" requirement.",
      "createdAt": "2017-08-28T20:36:47Z",
      "updatedAt": "2017-08-30T20:50:42Z",
      "closedAt": "2017-08-30T20:50:39Z",
      "mergedAt": "2017-08-30T20:50:39Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Hm, I omitted a date because I can't find a publication date in https://docs.oracle.com/javase/7/docs/technotes/guides/jar/jar.html. Its latest copyright is 2014, so maybe that's the right thing to use? Done.\r\n\r\nI don't see a way to write down a retrieval date in [`<reference>`](https://tools.ietf.org/html/rfc7749#section-2.30).",
          "createdAt": "2017-08-28T20:47:35Z",
          "updatedAt": "2017-08-28T21:03:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkwNjE4OTg=",
          "commit": {
            "abbreviatedOid": "fe40308"
          },
          "author": "bmeck",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm, but do we need a date on the JAR spec retrieval?",
          "createdAt": "2017-08-28T20:40:49Z",
          "updatedAt": "2017-08-28T20:40:49Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "df56bfd7a72fffccd7f97dddf6cc18330d865d5d",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "conflicts-with-mhtml-zip",
      "headRefOid": "1198858e1a82bea54010f9993507e248f894f064",
      "mergeCommit": {
        "oid": "d3417c9b96db45446fe80451a866a5b45a7dd518"
      }
    },
    {
      "number": 83,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM4MDMyMjA2",
      "title": "Add a distinct Web Publications use case.",
      "url": "https://github.com/WICG/webpackage/pull/83",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview in https://jyasskin.github.io/webpackage/alex-changes/draft-yasskin-webpackage-use-cases.html.\r\n\r\nThis also adds a \"Metadata\" requirement from https://www.w3.org/TR/pwp-ucr/#archmetadata, which is also used by the offline-installation use case.",
      "createdAt": "2017-08-28T20:38:14Z",
      "updatedAt": "2017-08-30T20:55:48Z",
      "closedAt": "2017-08-30T20:55:46Z",
      "mergedAt": "2017-08-30T20:55:46Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d3417c9b96db45446fe80451a866a5b45a7dd518",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "web-pub",
      "headRefOid": "d574e860a38be6ef3a67f34369df89e88e2dd435",
      "mergeCommit": {
        "oid": "0da0ee064187bf16a48bfee1e789ca2991fc3d34"
      }
    },
    {
      "number": 84,
      "id": "MDExOlB1bGxSZXF1ZXN0MTM5NjM2NDg5",
      "title": "Updates to the origin-signing draft in response to IETF comments.",
      "url": "https://github.com/WICG/webpackage/pull/84",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See the thread starting at https://lists.w3.org/Archives/Public/ietf-http-wg/2017JulSep/0385.html.\r\n\r\nPreview at https://jyasskin.github.io/webpackage/signed-responses-update/draft-yasskin-http-origin-signed-responses.html",
      "createdAt": "2017-09-06T18:43:46Z",
      "updatedAt": "2017-11-22T17:23:10Z",
      "closedAt": "2017-11-17T19:40:38Z",
      "mergedAt": "2017-11-17T19:40:38Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9d61909cd8889b9fd4e9f16918474fb6f58914f1",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "signed-responses-update",
      "headRefOid": "6016dada64dcfdc793af4eb42a4d31e2f6f729d0",
      "mergeCommit": {
        "oid": "6016dada64dcfdc793af4eb42a4d31e2f6f729d0"
      }
    },
    {
      "number": 85,
      "id": "MDExOlB1bGxSZXF1ZXN0MTQwMTQ1Njcz",
      "title": "Add a status to the README, and separate the Explainer.",
      "url": "https://github.com/WICG/webpackage/pull/85",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I hope this'll make it a little easier to follow along as things move into formal standards bodies.",
      "createdAt": "2017-09-08T23:57:57Z",
      "updatedAt": "2017-09-11T15:56:55Z",
      "closedAt": "2017-09-11T15:56:52Z",
      "mergedAt": "2017-09-11T15:56:52Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0d2afdc0b41b478ad78154e13defc597886ef4bc",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-links",
      "headRefOid": "f54a1b73ac6392dff3e21696d1f77f3912cb26d3",
      "mergeCommit": {
        "oid": "9d61909cd8889b9fd4e9f16918474fb6f58914f1"
      }
    },
    {
      "number": 87,
      "id": "MDExOlB1bGxSZXF1ZXN0MTUzNDExMzEx",
      "title": "Add a security consideration to revoke keys exposed by a signing oracle.",
      "url": "https://github.com/WICG/webpackage/pull/87",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "How's this, @agl, @sleevi?",
      "createdAt": "2017-11-17T22:48:27Z",
      "updatedAt": "2017-11-20T17:17:06Z",
      "closedAt": "2017-11-20T17:08:39Z",
      "mergedAt": "2017-11-20T17:08:39Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "agl",
          "authorAssociation": "COLLABORATOR",
          "body": "Makes sense. Coincidentally, [here's](https://support.f5.com/csp/article/K21905460) a vulnerability from F5, published yesterday, that lets attackers get signatures from an online TLS key.",
          "createdAt": "2017-11-18T19:17:33Z",
          "updatedAt": "2017-11-18T19:17:33Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks. I would not have guessed that an \"Adaptive Chosen Ciphertext attack\" would lead to a signing oracle, which makes me worry that folks won't know to revoke their key after this sort of vulnerability.",
          "createdAt": "2017-11-20T17:17:05Z",
          "updatedAt": "2017-11-20T17:17:05Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6016dada64dcfdc793af4eb42a4d31e2f6f729d0",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "revoke-on-signing-oracle",
      "headRefOid": "146a114a45b3b318e7dfe2d370fecfd2b4ce97bb",
      "mergeCommit": {
        "oid": "9362a5424bb36e4c76bc3a4fd23ffc1bd79150ab"
      }
    },
    {
      "number": 88,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0MDI2NzI2",
      "title": "A rough proposal for signing HTTP exchanges.",
      "url": "https://github.com/WICG/webpackage/pull/88",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "There's a preview at https://jyasskin.github.io/webpackage/design-signatures/draft-yasskin-http-origin-signed-responses.html#proposal\r\n\r\nWhat's clearly broken about this? Is the complexity of allowing either plain responses or encapsulated request headers worth it?\r\n\r\nI updated the validity algorithm to handle raw public keys and to return exactly which headers are trustworthy, but I did it quickly, so there could be mistakes there.",
      "createdAt": "2017-11-21T23:22:49Z",
      "updatedAt": "2017-12-05T19:32:25Z",
      "closedAt": "2017-12-05T19:32:21Z",
      "mergedAt": "2017-12-05T19:32:21Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge this and publish it as an IETF draft so we can start discussing on the httpbis mailing list. More comments are, of course, welcome, either here or there.",
          "createdAt": "2017-12-05T19:30:11Z",
          "updatedAt": "2017-12-05T19:30:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzgzMzQ2MDI=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-22T04:44:21Z",
          "updatedAt": "2017-11-22T04:44:21Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "@otherdaniel / @mikewest Does this look like it'll handle what https://github.com/mikewest/signature-based-sri needs? (The algorithm that uses it is at https://wicg.github.io/webpackage/design-signatures/draft-yasskin-http-origin-signed-responses.html#signature-validity)",
              "createdAt": "2017-11-22T04:44:21Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NzgzNDkzMDE=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-22T06:59:54Z",
          "updatedAt": "2017-11-22T06:59:54Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "In broad strokes, I think this would support the SRI proposal. I'm not sure about some details, but if we were designing something _just_ for the SRI use case, I think we'd end up with something sufficiently similar to this that we should just squint at it until it's the same. I'm willing to live with some \"cruft\" (from my feature's perspective) in order to not invent a custom new thing just for my use case. :)\r\n\r\nThat said, https://github.com/mikewest/signature-based-sri/issues/5#issuecomment-345212824 suggested looking into https://tools.ietf.org/html/draft-cavage-http-signatures-08, which does similar things to this proposal, with a different spelling, and somewhat different characteristics (no certs, for instance). It does tack headers into the message to be signed, which is appealing (binding the resource to a `Content-Type`, for instance, might be valuable).\r\n\r\nI know you've thought about that use case. What do you think about supporting it in this way?",
              "createdAt": "2017-11-22T06:59:54Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg1MjA5MDY=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-22T17:15:35Z",
          "updatedAt": "2017-11-22T17:15:35Z",
          "comments": [
            {
              "originalPosition": 173,
              "body": "This is definitely still open for tweaking. For example, I could replace the `ed25519Key=*base64` field with a CSP-style `key=ed25519-base64` [label](https://mnot.github.io/I-D/structured-headers/#label). I didn't because that takes an extra level of parsing to actually check the signature in this spec, but it's certainly possible.\r\n\r\nIt's plausible that we should have totally separate headers for the \"give extra assurance when the physical and logical request are the same\" case from the \"assert a request/response pair that my normal certificate doesn't cover\" case. Even for the extra-assurance case, draft-cavage-http-signatures has some problems:\r\n1. Specifying the algorithm next to the key is bad practice nowadays because it leads to things like https://auth0.com/blog/critical-vulnerabilities-in-json-web-token-libraries/.\r\n1. Using a keyId to have a higher-level protocol look up the key instead of having the header specify it leaves room for those protocols to shoot themselves in the foot. I assume SRI would make something like \"ed25519-base64\" the keyId, so you won't be affected, but it's a problem for adopting the header more broadly.\r\n1. Using the `Digest` header as the only way to sign the body seems risky: we'd have to make sure that every path through the browser notices the presence of a Digest header and avoids using the body until it's checked.\r\n1. I'm still pretty sure leaving the hostname out of the signed data is a mistake, even though it requires extra signatures for testing vs prod. This draft doesn't require people to specify the hostname either, but it doesn't hardcode omitting it.\r\n1. draft-cavage-http-signatures doesn't expire signatures, meaning a single signed resource with a vulnerability forces the server to rotate the key.\r\n1. New things should try to use mnot's structured headers, although that's probably easy to fix.",
              "createdAt": "2017-11-22T17:15:35Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg2NzY3OTI=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-23T10:36:46Z",
          "updatedAt": "2017-11-23T10:36:47Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "missing \"",
              "createdAt": "2017-11-23T10:36:46Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg2NzcyMDI=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-11-23T10:38:26Z",
          "updatedAt": "2017-11-23T10:38:26Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "Also: why do we need to reinvent `cache-control` here? Or do those have a different purpose?",
              "createdAt": "2017-11-23T10:38:26Z",
              "updatedAt": "2017-12-05T19:26:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODAzNzMxOTI=",
          "commit": {
            "abbreviatedOid": "70bb2d5"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-12-01T00:14:12Z",
          "updatedAt": "2017-12-01T00:14:13Z",
          "comments": [
            {
              "originalPosition": 183,
              "body": "0df5fe2 now describes why I'm reinventing cache-control.",
              "createdAt": "2017-12-01T00:14:12Z",
              "updatedAt": "2017-12-05T19:28:27Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6482c8917a8a2aa4df5caba0589571be7d770411",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "design-signatures",
      "headRefOid": "9a86849147de2afbb8bac9c594154a051f38a0ad",
      "mergeCommit": {
        "oid": "9a86849147de2afbb8bac9c594154a051f38a0ad"
      }
    },
    {
      "number": 89,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0MjQwODI1",
      "title": "Avoid use of \"CDN\", which implies a CNAME to many people.",
      "url": "https://github.com/WICG/webpackage/pull/89",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Use \"content distributor\" instead, in the hope that it only implies\r\ndistribution without authority.\r\n\r\nHow's this, @yoavweiss?\r\n\r\nPreviews in https://jyasskin.github.io/webpackage/clarify-cdn/.",
      "createdAt": "2017-11-22T19:42:13Z",
      "updatedAt": "2017-11-23T19:09:24Z",
      "closedAt": "2017-11-23T19:09:21Z",
      "mergedAt": "2017-11-23T19:09:21Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg2OTc3OTg=",
          "commit": {
            "abbreviatedOid": "b9adf91"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM :)",
          "createdAt": "2017-11-23T12:04:51Z",
          "updatedAt": "2017-11-23T12:04:51Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9362a5424bb36e4c76bc3a4fd23ffc1bd79150ab",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "clarify-cdn",
      "headRefOid": "b9adf91450c85192bb8f874ebfc156a59755b0e5",
      "mergeCommit": {
        "oid": "43aa29fec94a1a5964571f1cf353ca72ad452390"
      }
    },
    {
      "number": 90,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU0MjQ4NDU4",
      "title": "Turn the PUSH-replacement use case into a non-goal.",
      "url": "https://github.com/WICG/webpackage/pull/90",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/demote-push-ergonomics/draft-yasskin-webpackage-use-cases.html#push-replacement\r\n\r\n@slightlyoff @dglazkov: I included this as a goal because y'all keep talking about it, but the PUSH experts like @yoavweiss and @igrigorik think we should just stop talking about it and rely on the other benefits instead, so here's a PR to demote it.",
      "createdAt": "2017-11-22T20:25:23Z",
      "updatedAt": "2017-12-01T00:18:39Z",
      "closedAt": "2017-12-01T00:18:36Z",
      "mergedAt": "2017-12-01T00:18:36Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Nzg2OTYzMTg=",
          "commit": {
            "abbreviatedOid": "4cad429"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2017-11-23T11:58:12Z",
          "updatedAt": "2017-11-23T11:58:12Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "43aa29fec94a1a5964571f1cf353ca72ad452390",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "demote-push-ergonomics",
      "headRefOid": "4534d23abc083424135a50b81fbf709797107049",
      "mergeCommit": {
        "oid": "6482c8917a8a2aa4df5caba0589571be7d770411"
      }
    },
    {
      "number": 91,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU2NjExMzQy",
      "title": "Remove the worry about not signing the whole cert chain.",
      "url": "https://github.com/WICG/webpackage/pull/91",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@sleevi says this is ok.\r\n\r\nPreview at https://jyasskin.github.io/webpackage/remove-chain-signing-question/draft-yasskin-http-origin-signed-responses.html#signature-validity.",
      "createdAt": "2017-12-06T00:30:22Z",
      "updatedAt": "2017-12-11T21:00:43Z",
      "closedAt": "2017-12-11T21:00:41Z",
      "mergedAt": "2017-12-11T21:00:41Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "541db9ac18189c6fd1d2499919840cd463a66232",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "remove-chain-signing-question",
      "headRefOid": "4c2eb789ef7e3bb4d12eb1af43152ea48be0b2ad",
      "mergeCommit": {
        "oid": "bad2bb6e5ea9b763ee73e92a80a937a248ebc901"
      }
    },
    {
      "number": 92,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU2ODUxMDgz",
      "title": "Rewrite (X, section Y) to (Section Y of X).",
      "url": "https://github.com/WICG/webpackage/pull/92",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "In the hopes of getting deep links.\r\n\r\nPointed out in https://lists.w3.org/Archives/Public/ietf-http-wg/2017OctDec/0399.html.\r\n\r\nHowever, https://tools.ietf.org/html/draft-ietf-httpbis-origin-frame-04#section-1 does have a deep link to <a href=\"./rfc7540#section-9.1.2\">[RFC7540], Section&nbsp;9.1.2</a>, so I don't think this ordering is the fundamental problem.\r\n\r\nI can't get any of these syntaxes to result in deep links from https://xml2rfc.tools.ietf.org/, so I'm not sure what the ietf-httpbis drafts are doing to get them. The httpsbis editors' drafts do *not* have deep links: http://httpwg.org/http-extensions/expect-ct.html#response-header-field-syntax\r\n\r\n@MikeBishop, halp! \ud83d\ude3a",
      "createdAt": "2017-12-06T22:00:38Z",
      "updatedAt": "2017-12-11T21:17:53Z",
      "closedAt": "2017-12-11T21:10:00Z",
      "mergedAt": "2017-12-11T21:10:00Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It turns out that https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-01 does have deep links because of magic from https://tools.ietf.org/tools/rfcmarkup/ that's not present in xml2rfc.\r\n\r\nThey're missing in https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-01#page-10's \"Section 4.2.3 of [I-D.ietf-tls-tls13]\", so I'll do a little digging to see what's broken there.",
          "createdAt": "2017-12-08T04:49:47Z",
          "updatedAt": "2017-12-08T04:49:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ah, it's probably the commented-out \"section x of draft-y markup\" in https://tools.ietf.org/tools/rfcmarkup/code, so deep links into drafts probably just won't work.",
          "createdAt": "2017-12-08T05:02:38Z",
          "updatedAt": "2017-12-08T05:02:38Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "bad2bb6e5ea9b763ee73e92a80a937a248ebc901",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "section-before-reference",
      "headRefOid": "ab1c45446571038718fce71edee075073974cf47",
      "mergeCommit": {
        "oid": "e4e8ca9f4c98b62fd22a0a935b1a39d95a989833"
      }
    },
    {
      "number": 93,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU2ODcxNTM5",
      "title": "Fix nits that Ilari found.",
      "url": "https://github.com/WICG/webpackage/pull/93",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/ilari-issues/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/ilari-issues/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2017-12-06T23:57:16Z",
      "updatedAt": "2017-12-15T19:22:29Z",
      "closedAt": "2017-12-15T19:22:12Z",
      "mergedAt": "2017-12-15T19:22:12Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f20545f920fdde8b743ea5ed36de50da3b3534ea",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "ilari-issues",
      "headRefOid": "885caef92cf129118e25379c1d5c9df7310866e6",
      "mergeCommit": {
        "oid": "b51c4db72de7e94e1d95f54eb7d38b10ac3d906c"
      }
    },
    {
      "number": 94,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU3MzYxNzc3",
      "title": "Define an HTTP/2 extension for cross-origin Server Push.",
      "url": "https://github.com/WICG/webpackage/pull/94",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/http-extension/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/http-extension/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2017-12-09T00:31:48Z",
      "updatedAt": "2017-12-15T19:35:56Z",
      "closedAt": "2017-12-15T19:35:47Z",
      "mergedAt": "2017-12-15T19:35:47Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "b51c4db72de7e94e1d95f54eb7d38b10ac3d906c",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "http-extension",
      "headRefOid": "d2e84a2b375459d621c17e9cc9c28c087248ec88",
      "mergeCommit": {
        "oid": "48c56140c4fad2485ba06f8257e1e58757705ac0"
      }
    },
    {
      "number": 95,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU3NDI5MzM3",
      "title": "remove unneeded/misleading metadata",
      "url": "https://github.com/WICG/webpackage/pull/95",
      "state": "MERGED",
      "author": "reschke",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "(for instance, this is not a work item of the HTTP working group)",
      "createdAt": "2017-12-10T12:37:44Z",
      "updatedAt": "2017-12-11T05:04:48Z",
      "closedAt": "2017-12-11T04:33:47Z",
      "mergedAt": "2017-12-11T04:33:46Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Oh, that makes sense. Thanks! I wish I could remember what caused me to include those three elements so I could try to fix that documentation.\r\n\r\nI have the same mistake in `draft-yasskin-dispatch-web-packaging.md` and `draft-yasskin-webpackage-use-cases.md` except with Dispatch as the workgroup. There's nothing special about Dispatch that would mean it's right to use them as the workgroup, right?",
          "createdAt": "2017-12-11T04:33:29Z",
          "updatedAt": "2017-12-11T04:33:29Z"
        },
        {
          "author": "reschke",
          "authorAssociation": "CONTRIBUTOR",
          "body": "If the draft is not an official work item of the WG, it shouldn't say so on the first page.\r\n\r\n(FWIW, the related rule is a bit ambiguous as it only says what to put there if a draft *is* a WG draft -- but that's my interpretation...)",
          "createdAt": "2017-12-11T05:01:36Z",
          "updatedAt": "2017-12-11T05:01:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks, done.",
          "createdAt": "2017-12-11T05:04:48Z",
          "updatedAt": "2017-12-11T05:04:48Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "58c3e7cae9ea0ba296acfa73b92576aa46c47ca3",
      "headRepository": "reschke/webpackage",
      "headRefName": "patch-1",
      "headRefOid": "05b1873c236cad7fd04345c9a8bd3b39d4edbf55",
      "mergeCommit": {
        "oid": "da0c883caf8a7024e9e5c7edcecc21fbd10760c9"
      }
    },
    {
      "number": 96,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU3Njg4ODM5",
      "title": "Add EdDSA certificates to the set with defined signature algorithms.",
      "url": "https://github.com/WICG/webpackage/pull/96",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I used the pre-hashed variants for those and switched the raw ed25519\r\npublic key to use ed25519ph, with an Open Question for whether that's\r\nthe right choice.\r\n\r\nIlari Liusvaara pointed out that draft-ietf-curdle-pkix is nearly published, so it makes sense to include its public key types in this document now. \r\n\r\n@sleevi, is this the right choice?\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/define-ed25519-certs/draft-yasskin-http-origin-signed-responses.html#signature-validity), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/define-ed25519-certs/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2017-12-11T22:30:05Z",
      "updatedAt": "2017-12-12T00:00:41Z",
      "closedAt": "2017-12-12T00:00:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "There are no plans at this time to support such certificates in Chrome",
          "createdAt": "2017-12-11T23:11:53Z",
          "updatedAt": "2017-12-11T23:11:53Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks Ryan. I'll drop this until some client says they really want it.",
          "createdAt": "2017-12-12T00:00:40Z",
          "updatedAt": "2017-12-12T00:00:40Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f20545f920fdde8b743ea5ed36de50da3b3534ea",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "define-ed25519-certs",
      "headRefOid": "33c531b14c1188d22071bbc9df7759387e3edcf0",
      "mergeCommit": null
    },
    {
      "number": 97,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU4NzExMjA3",
      "title": "Fix some comments from Yoav Weiss.",
      "url": "https://github.com/WICG/webpackage/pull/97",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@yoavweiss",
      "createdAt": "2017-12-15T23:03:42Z",
      "updatedAt": "2018-01-16T22:11:48Z",
      "closedAt": "2018-01-16T22:11:45Z",
      "mergedAt": "2018-01-16T22:11:45Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODU0OTUyMDU=",
          "commit": {
            "abbreviatedOid": "d9482fa"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2017-12-25T19:25:03Z",
          "updatedAt": "2017-12-25T19:25:08Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Maybe add a note that responses are encouraged to include `Cache-Control: no-transform`?",
              "createdAt": "2017-12-25T19:25:04Z",
              "updatedAt": "2018-01-16T21:51:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODc2OTkzMzI=",
          "commit": {
            "abbreviatedOid": "d9482fa"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-10T00:11:43Z",
          "updatedAt": "2018-01-10T00:11:43Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "@yoavweiss I mentioned no-transform up here.",
              "createdAt": "2018-01-10T00:11:43Z",
              "updatedAt": "2018-01-16T21:51:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODc3NjY5MzE=",
          "commit": {
            "abbreviatedOid": "d9482fa"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-10T08:58:10Z",
          "updatedAt": "2018-01-10T08:58:10Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "oh, OK. missed it :/",
              "createdAt": "2018-01-10T08:58:10Z",
              "updatedAt": "2018-01-16T21:51:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODc3NjcxMDk=",
          "commit": {
            "abbreviatedOid": "d9482fa"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2018-01-10T08:58:51Z",
          "updatedAt": "2018-01-10T08:58:51Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cf96c948220dbfddf8925617baa4dad6816ce9a8",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "yoav-comments",
      "headRefOid": "d7c8c15f54525884d3ffa455ceeacb4f5cf680ad",
      "mergeCommit": {
        "oid": "c5370744ef12d1c68d1e56140d95e45ce3b480ec"
      }
    },
    {
      "number": 98,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU5NTUyODAx",
      "title": "Start writing the bundling spec.",
      "url": "https://github.com/WICG/webpackage/pull/98",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html)\r\n\r\nThis fills a similar niche as [MHTML](https://tools.ietf.org/html/rfc2557), but\r\n* is random access,\r\n* efficiently encodes 8-bit payloads,\r\n* can represent multiple top-level resources,\r\n* can represent content-negotiated resources,\r\n* and possibly other advantages.\r\n\r\nI believe that combined with [signed exchanges](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html), bundles fill all of the [web packaging use cases](https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.html) except that they'll need a subsequent change to work for \"Third-party security review\", which will need a signature to cover groups of resources to enforce that their versions are consistent.",
      "createdAt": "2017-12-21T00:58:41Z",
      "updatedAt": "2018-12-01T00:34:31Z",
      "closedAt": "2018-05-29T21:00:12Z",
      "mergedAt": "2018-05-29T21:00:12Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(Note that I replied even in the feedback GitHub considers \"outdated\".)",
          "createdAt": "2018-03-26T07:11:51Z",
          "updatedAt": "2018-03-26T07:11:51Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Are you going to leave it to Fetch to drop the response body for a `HEAD` request? Or will that be an error to codify? It seems to me that you'd want to forbid `HEAD` to be encoded and only support it on the retrieval side and do the appropriate translations to `GET` minus response body there.",
          "createdAt": "2018-03-26T07:14:01Z",
          "updatedAt": "2018-03-26T07:14:01Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "(Another thought I had was to take inspiration from the Cache API, as sort of the API surface on top of this format. The Cache API only supports `GET` thus far, but it does have `Vary` support. Haven't fully explored whether it's a complete fit, but it's interesting to think about as a way to avoid introducing too many new primitives.)",
          "createdAt": "2018-03-27T07:09:31Z",
          "updatedAt": "2018-03-27T07:09:31Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I believe this is finally ready for a re-review. It's missing 3 things that are going to be important, but that I'd like to do in a subsequent patch:\r\n\r\n1. The algorithm to take the request a browser would generate, e.g. with multiple values in its `Accept` header, and find a matching request inside a bundle, where requests will generally only have 1 value in their `Accept` headers.\r\n1. Compression: the index can probably just be brotli-compressed, but response headers should be able to take advantage of a shared dictionary.\r\n1. Signatures covering multiple resources: this both saves on signature verification costs and ensures that resources have matching versions.",
          "createdAt": "2018-05-21T22:09:36Z",
          "updatedAt": "2018-05-21T22:09:36Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "> Do you think I should say that clients MAY reject bundles that aren't a valid CBOR item? Or something else?\r\n\r\n1. I think we want it to be fully deterministic across all conforming (browser) implementations how they would handle all possible sequences of bytes. I.e., at least as good as the HTML parser.\r\n2. I don't think we should use +cbor if that isn't always the case or required to be the case.\r\n\r\nRe: \"best available bundled response\" I'd prefer it as an open issue if you plan on addressing it rather than it saying it's implementation-defined.\r\n\r\n(Note that we might get rid of pairs still: https://github.com/whatwg/infra/issues/127.)",
          "createdAt": "2018-05-24T05:04:59Z",
          "updatedAt": "2018-05-24T05:04:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "1. I haven't added the MAY.\r\n1. I've removed the +cbor from the MIME type.\r\n1. I marked the \"best available bundled response\" as a TODO.\r\n\r\nThanks!",
          "createdAt": "2018-05-24T22:57:32Z",
          "updatedAt": "2018-05-24T22:57:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge this so it's easier to refer to and so I can start sending PRs to modify it, but please feel free to keep commenting and filing issues against it.",
          "createdAt": "2018-05-29T20:56:25Z",
          "updatedAt": "2018-05-29T20:56:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NDY2NjE3",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "You state that \"parsing MUST fail\" in a bunch of cases, but there's also a lot of scanning and jumping going on. Are there multiple levels where things can fail? That is, if you happened to just parse this once without jumping around, you can't simply return failure for all errors but would instead have to throw away items? That's rather unclear.",
          "createdAt": "2018-03-23T12:01:52Z",
          "updatedAt": "2018-03-23T12:06:04Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "This is not really good enough for browsers I think. You need to have a safelist.",
              "createdAt": "2018-03-23T12:01:52Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 316,
              "body": "It's unclear how to validate this in browsers. There's no such primitive.",
              "createdAt": "2018-03-23T12:02:17Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 321,
              "body": "Those key/value pairs are suitably constrained somehow? What's the parsing for them?",
              "createdAt": "2018-03-23T12:03:01Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzA4NjI5",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-24T19:51:43Z",
          "updatedAt": "2018-03-24T23:26:07Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "I believe one identifies an [absolute-URL string](https://url.spec.whatwg.org/#absolute-url-string) by running the [URL parser](https://url.spec.whatwg.org/#concept-url-parser) with no base URL and then checking that it doesn't have a fragment.\r\n\r\nAre you complaining that I'm not linking to the URL spec, that this isn't phrased as a parsing algorithm, both, or something else?",
              "createdAt": "2018-03-24T19:51:43Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 315,
              "body": "https://www.iana.org/assignments/http-methods/http-methods.xhtml is precise about the safe methods, but you have to click through to get cacheability defined, and the WebDAV methods leave it out. In an IETF draft, I'm pretty sure I can list the current methods that satisfy this (GET and HEAD), and in the browser-side loading living spec I can just list those expecting the list to get updated if any new ones get added.\r\n\r\nI also note that [Fetch](https://fetch.spec.whatwg.org/#http-network-or-cache-fetch) uses \"unsafe\" without specifying it more precisely.",
              "createdAt": "2018-03-24T19:54:14Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 321,
              "body": "They're HTTP headers, so we should do whatever https://fetch.spec.whatwg.org/#http-network-fetch does.\r\n\r\nOr are you worried about how claimed request headers are matched against browser request headers? That's not written yet. I was hoping to use the matching rules for PUSH_PROMISEs, but those aren't written yet either.",
              "createdAt": "2018-03-24T23:24:10Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzkwNDQy",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-26T07:08:21Z",
          "updatedAt": "2018-03-26T07:08:21Z",
          "comments": [
            {
              "originalPosition": 315,
              "body": "In the cache section, which is somewhat optional in a way.",
              "createdAt": "2018-03-26T07:08:21Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzkwNzIx",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-26T07:09:39Z",
          "updatedAt": "2018-03-26T07:09:40Z",
          "comments": [
            {
              "originalPosition": 316,
              "body": "Can I go with all three? E.g., `http://example.com/%` is not an \"absolute URI\", but will parse per the URL parser.",
              "createdAt": "2018-03-26T07:09:40Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzkwOTcy",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-26T07:11:03Z",
          "updatedAt": "2018-03-26T07:11:04Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "Well they're not quite the same as ordinary HTTP headers, since they are delimited differently, right? E.g., can you have a 0x0A byte in the value?",
              "createdAt": "2018-03-26T07:11:04Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA3MTEyMTk4",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Sorry for skipping the \"Are there multiple levels where things can fail?\" question earlier. My plan is that there are 2 levels where things can fail: \r\n\r\n1. The browser parses the metadata (https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html#load-metadata), and if anything fails there, the whole bundle is invalid.\r\n2. Then for any response the browser actually wants to use, it parses that particular response (https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html#load-response). If that fails, only that particular response is invalid, but the bundle can still contain other responses.\r\n\r\nThanks for saying that's not adequately clear; I'll try to fix it.\r\n\r\nI hadn't thought about how exactly to constrain HEAD. If you think the right approach is to treat it as an automatic transformation from GET, I'll do that.\r\n\r\nNone of this is done yet. I'll comment again when it is.",
          "createdAt": "2018-03-26T23:51:44Z",
          "updatedAt": "2018-03-26T23:57:50Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "HTTP/2 headers are also delimited in a way that lets their values include a 0x0A byte. I wonder if browsers handle that correctly...\r\n\r\nI suspect the right thing to do here is to explicitly create a [header list](https://fetch.spec.whatwg.org/#concept-header-list) from this, but since that concept doesn't exist in the IETF, I'll have to give up on the idea of making this an IETF draft.\r\n\r\nI'm going to ping some folks to see if I'll hurt any feelings by doing that.",
              "createdAt": "2018-03-26T23:51:44Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA3MTY5MDc0",
          "commit": {
            "abbreviatedOid": "2b6e2bb"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-27T06:49:47Z",
          "updatedAt": "2018-03-27T06:49:47Z",
          "comments": [
            {
              "originalPosition": 321,
              "body": "Oooh wow, I didn't know that about H/2. That's another reason to get a web-platform-tests setup.",
              "createdAt": "2018-03-27T06:49:47Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyMDkzMDIw",
          "commit": {
            "abbreviatedOid": "f4523f2"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Just skimmed through, had some nit comments / questions (non blocking).",
          "createdAt": "2018-05-22T09:45:58Z",
          "updatedAt": "2018-05-22T10:19:26Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "nit: should bolding be applied to **available bytes** ?",
              "createdAt": "2018-05-22T09:45:58Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 232,
              "body": "nit: `sectionOffsetsLength` (missing the closing \\`)",
              "createdAt": "2018-05-22T09:46:03Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 329,
              "body": "nit: extra \\\\",
              "createdAt": "2018-05-22T10:01:44Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 361,
              "body": "Wasn't fully unsure what could come here?",
              "createdAt": "2018-05-22T10:04:29Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 375,
              "body": "nit: missing ) after {{parse-cbor}}",
              "createdAt": "2018-05-22T10:05:37Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 473,
              "body": "\"Parsing the index section\" seems to say request has one url, do you mean it could have a list / redirect chain?",
              "createdAt": "2018-05-22T10:13:14Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyMjUzNDMw",
          "commit": {
            "abbreviatedOid": "f4523f2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-22T16:36:46Z",
          "updatedAt": "2018-05-22T16:49:42Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "Sure.",
              "createdAt": "2018-05-22T16:36:46Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 232,
              "body": "Thanks.",
              "createdAt": "2018-05-22T16:38:33Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 329,
              "body": "Thanks.",
              "createdAt": "2018-05-22T16:39:10Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 375,
              "body": "Thanks.",
              "createdAt": "2018-05-22T16:39:58Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 361,
              "body": "If we add more sections in the future, and the publisher wants to make sure parsers don't just ignore one of those sections because they don't understand it, this section points out the ones not to skip.\r\n\r\nI'm not certain this is the right way to do this. PNG does it with a particular capitalization in the section names: https://tools.ietf.org/html/rfc2083#page-13",
              "createdAt": "2018-05-22T16:43:21Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 473,
              "body": "This is just an asymmetry in how requests and responses default their values: https://fetch.spec.whatwg.org/#concept-request-url-list defaults from the request's url, while https://fetch.spec.whatwg.org/#concept-response-url is hard-coded to point to the response's url list. I believe both URL lists should always have 1 value for exchanges in the bundle.\r\n\r\nI suspect Fetch will actually wind up copying or extending this response when serving browser-generated requests from bundles, so that a redirect into a bundle can work correctly.",
              "createdAt": "2018-05-22T16:48:26Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyMjkxMjQ3",
          "commit": {
            "abbreviatedOid": "ae24147"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-22T18:16:11Z",
          "updatedAt": "2018-05-22T18:16:12Z",
          "comments": [
            {
              "originalPosition": 108,
              "body": "@domenic, [here's the use of streams](https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html#stream-operations) I mentioned on #whatwg. I'm thinking about re-doing it in terms of [`ReadableStream`](https://fetch.spec.whatwg.org/#readablestream) despite your advice because https://jyasskin.github.io/webpackage/bundles/draft-yasskin-dispatch-bundled-exchanges.html#load-response needs to create a [body's stream](https://fetch.spec.whatwg.org/#concept-body), which is defined as a `ReadableStream`. The stream a bundle's parsed from is likely to be a response body anyway, so it'll probably be a ReadableStream even if I pretend it isn't.\r\n\r\nWhat do you think?",
              "createdAt": "2018-05-22T18:16:11Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyNTIxMDM2",
          "commit": {
            "abbreviatedOid": "ae24147"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "I still find it a little hard to digest how the whole thing fits together, but I tried to review regardless.",
          "createdAt": "2018-05-23T10:21:48Z",
          "updatedAt": "2018-05-23T10:37:48Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "request-response?",
              "createdAt": "2018-05-23T10:21:48Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 46,
              "body": "I'd leave this out, since the signing is controversial and not required.",
              "createdAt": "2018-05-23T10:22:25Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 52,
              "body": "It seems discussion also takes place on GitHub?",
              "createdAt": "2018-05-23T10:22:45Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 70,
              "body": "I'd pick one separator and stick with it.",
              "createdAt": "2018-05-23T10:23:39Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 120,
              "body": "\"error in this specification\" doesn't appear to mean anything. Wouldn't it be better to say that seek or read can return an error and that callers of them need to account for that?",
              "createdAt": "2018-05-23T10:26:16Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 132,
              "body": "What Fetch defines as \"requests\" are not necessarily HTTP requests. They're more broad.",
              "createdAt": "2018-05-23T10:26:47Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 174,
              "body": "Why not? We define this for the Cache API, I think ideally we use the same algorithm here.",
              "createdAt": "2018-05-23T10:28:39Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 186,
              "body": "Is there still use in CBOR then? Doesn't the MIME type lie with +cbor if you cannot actually use a CBOR parser?",
              "createdAt": "2018-05-23T10:29:36Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 258,
              "body": "The idea with structs is that they are immutable.",
              "createdAt": "2018-05-23T10:31:09Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 570,
              "body": "You cannot have multiple headers of the same name? Might be worth calling out you cannot encode cookies.",
              "createdAt": "2018-05-23T10:35:41Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyNzQ4MzIz",
          "commit": {
            "abbreviatedOid": "ae24147"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-23T20:12:13Z",
          "updatedAt": "2018-05-24T00:02:43Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I was trying to emphasize that it's both. A hyphen doesn't feel quite right because \"request\" doesn't modify \"response\". A slash feels like it might be alternation, although https://infra.spec.whatwg.org/#pair uses it the way I intend here.",
              "createdAt": "2018-05-23T20:12:13Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 46,
              "body": "I don't intend to shy away from the controversial bits, but you're right that it's not required, so maybe it doesn't belong in the abstract.\r\n\r\nI do expect to add a section to bundles to efficiently encode multi-resource signatures with the same semantics as multiple signed-exchanges, at which point it'll come back to the abstract.",
              "createdAt": "2018-05-23T20:13:30Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 52,
              "body": "I think that's covered by the \"issues list\" comment in the next paragraph. HTTPWG drafts have similar text, and also discuss on GitHub issues.",
              "createdAt": "2018-05-23T20:14:19Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 70,
              "body": "Indeed, thanks.",
              "createdAt": "2018-05-23T20:14:39Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 120,
              "body": "I intended the same meaning as in https://infra.spec.whatwg.org/#assertions, but looking at the uses of \"wait\", \"seek\", and \"read\", every seek and read except the ones to the start of the stream was immediately preceded by a wait, so I may as well incorporate the wait into the other operations.",
              "createdAt": "2018-05-23T20:33:46Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 132,
              "body": "What's the best way to say that the keys here come from the subset of Fetch \"requests\" that are HTTP requests? I don't think it makes sense to include the other schemes mentioned in https://fetch.spec.whatwg.org/#url.",
              "createdAt": "2018-05-23T21:07:09Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 174,
              "body": "Clearly we're going to have to define that algorithm somewhere. I don't have a strong opinion between here and the WICG/Fetch side, but I was leaning toward WICG/Fetch, and would definitely prefer to do it in a separate PR even if you prefer this spec.\r\n\r\nUnfortunately, https://w3c.github.io/ServiceWorker/#query-cache-algorithm assumes that varied headers will be identical between the cached request and the queried request, which isn't plausible for a bundle intended to be used by more than one UA.\r\n\r\nFor example, imagine that Greta's UA sends `Accept-Language: de-DE,de,en;q=0.9`. In the Cache API, that's exactly the request header that'll be cached since the Cache API uses https://fetch.spec.whatwg.org/#concept-fetch to fill it in. Similarly, if Hilda's UA sends `Accept-Language: de-AT,de;q=0.9`, that's what her cache will contain. If the server wants to put a `de` resource in a bundle to serve both users, what `Accept-Language` header should they write? There isn't one that Query-Cache will find for both people. The same problem shows up for `Accept` across browsers instead of people. So we need a new algorithm.",
              "createdAt": "2018-05-23T21:37:18Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 186,
              "body": "I'm primarily using CBOR instead of a totally custom binary format because 1) ASCII/UTF-8 formats like JSON are nice because you can read them without custom parsers, and 2) we need a binary format for this, but there are likely to be generic tools to dump CBOR to a readable format, so that preserves as much of the ASCII benefit as possible.\r\n\r\nI would actually like to say that bundles must be well-formed CBOR items, but because most parsers won't actually work that way, I expect non-CBOR bundles to wind up existing in the wild. Do you think I should say that clients MAY reject bundles that aren't a valid CBOR item? Or something else?",
              "createdAt": "2018-05-23T21:49:39Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 570,
              "body": "I believe multiple `Cookie` headers would be encoded by joining them with semicolons (not that you'd generally put cookies in bundled requests), but yeah, `Set-Cookie` has no single-field form. Noted.\r\n\r\n(This line is actually redundant with the fact that CBOR maps exclude duplicate keys, so I've replaced it with an Assert.)",
              "createdAt": "2018-05-23T21:59:33Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            },
            {
              "originalPosition": 258,
              "body": "I think you mean that the set of item names is immutable. It's simple to change this to a map, so I've done that. The set of keys is only not-fixed because I wanted to let other specifications add section names that might define new metadata, but I'm not totally sure that's a good idea, so this might go back to a struct later.",
              "createdAt": "2018-05-23T23:08:29Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyODQ1NTA3",
          "commit": {
            "abbreviatedOid": "80d01b9"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-24T04:56:05Z",
          "updatedAt": "2018-05-24T04:56:05Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Even those are more broad as they carry fields HTTP requests don't have. I guess you could say requests whose url list contains a single URL whose scheme is an HTTP(S) scheme (unless this is restricted to secure contexts?).",
              "createdAt": "2018-05-24T04:56:05Z",
              "updatedAt": "2018-05-24T23:16:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzMjAzNzMw",
          "commit": {
            "abbreviatedOid": "69a0512"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-24T23:18:30Z",
          "updatedAt": "2018-05-24T23:18:30Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "I've removed the attempt to subset the kinds of Fetch requests this operation can return. If it would noticeably simplify the request-matching function I need to write, I might add the subsetting back later, but I don't really expect that.",
              "createdAt": "2018-05-24T23:18:30Z",
              "updatedAt": "2018-05-24T23:18:30Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2aef2193856c0561c700c0cfae4e8c042f5fcb31",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "bundles",
      "headRefOid": "69a051212454510749a42e388bdc5b29fac51be2",
      "mergeCommit": {
        "oid": "f3459fa7b0cc1ed85f941137aa076ec549655394"
      }
    },
    {
      "number": 99,
      "id": "MDExOlB1bGxSZXF1ZXN0MTU5OTExMzAy",
      "title": "Use CBOR maps in signed exchanges.",
      "url": "https://github.com/WICG/webpackage/pull/99",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Instead of arrays with alternating keys and values, which side-steps the\r\ndisagreement about CBOR canonical map ordering rules, I now specify one\r\nof the ordering rules and use maps where they make sense.\r\n\r\nThe one place I'm still not using a map is in the top level of the\r\nexchange representation, where the request/response/payload ordering\r\nseems useful and where we might someday want to add, for example, the\r\nrequest payload between the request and response.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/use-maps/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/use-maps/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@MikeBishop",
      "createdAt": "2017-12-22T18:03:58Z",
      "updatedAt": "2018-01-16T22:28:15Z",
      "closedAt": "2018-01-16T22:28:12Z",
      "mergedAt": "2018-01-16T22:28:12Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c5370744ef12d1c68d1e56140d95e45ce3b480ec",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "use-maps",
      "headRefOid": "aef19bc9081f5144a3d65a5af8dba0bd36f6e3bc",
      "mergeCommit": {
        "oid": "f1147d57b14121928352c0482979764c1b87f2b0"
      }
    },
    {
      "number": 106,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYyMDEyNzky",
      "title": "remove stray period",
      "url": "https://github.com/WICG/webpackage/pull/106",
      "state": "MERGED",
      "author": "evmar",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-01-10T00:53:17Z",
      "updatedAt": "2018-01-10T03:59:12Z",
      "closedAt": "2018-01-10T03:59:12Z",
      "mergedAt": "2018-01-10T03:59:12Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "48c56140c4fad2485ba06f8257e1e58757705ac0",
      "headRepository": "evmar/webpackage",
      "headRefName": "patch-1",
      "headRefOid": "5d85034dcc983d2a2e01abaec31ca1d5cd314e78",
      "mergeCommit": {
        "oid": "8f58480f21640671ac962b2aaf095785ef548472"
      }
    },
    {
      "number": 108,
      "id": "MDExOlB1bGxSZXF1ZXN0MTYzMzI2NDgx",
      "title": "Sign just the headers and identify a header to guard the payload.",
      "url": "https://github.com/WICG/webpackage/pull/108",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/incremental-validity/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/incremental-validity/draft-yasskin-http-origin-signed-responses.txt) (When TravisCI recovers.)\r\n\r\nThis limits the length of the signed data, which helps validation\r\nroutines use the non-prehashed variant of ed25519, and if the MI header\r\nfield is used, it allows clients to incrementally trust the beginning\r\nchunks of the payload as they are received instead of needing to wait\r\nfor the whole thing. ",
      "createdAt": "2018-01-17T01:00:05Z",
      "updatedAt": "2018-01-19T18:29:28Z",
      "closedAt": "2018-01-19T18:29:25Z",
      "mergedAt": "2018-01-19T18:29:25Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk0NjY1MjU=",
          "commit": {
            "abbreviatedOid": "814c43b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Reviewed to L300",
          "createdAt": "2018-01-17T14:53:11Z",
          "updatedAt": "2018-01-17T15:01:13Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Not for this commit, but this line was a bit hard for me to understand. Can we split to something like:\r\n```\r\nEach parameterised label MUST have parameters named \"sig\", \"integrity\", \"validityUrl\", \"date\", and \"expires\".\r\nIn addition, each parameterised label MUST have either \"certUrl\" and \"certSha256\" parameters, or an \"ed25519Key\" parameter.\r\n```",
              "createdAt": "2018-01-17T14:53:11Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            },
            {
              "originalPosition": 156,
              "body": "I assume the keys need to be sorted?\r\nhttps://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#canonical-cbor",
              "createdAt": "2018-01-17T15:00:35Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            },
            {
              "originalPosition": 161,
              "body": "this too?",
              "createdAt": "2018-01-17T15:00:43Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk0NzAzMDI=",
          "commit": {
            "abbreviatedOid": "814c43b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-17T15:03:25Z",
          "updatedAt": "2018-01-17T15:03:25Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "sorry maybe this is already sorted in \"the bytewise lexicographic order\"",
              "createdAt": "2018-01-17T15:03:25Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk1Mzg0MDI=",
          "commit": {
            "abbreviatedOid": "814c43b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-17T18:12:30Z",
          "updatedAt": "2018-01-17T18:44:49Z",
          "comments": [
            {
              "originalPosition": 156,
              "body": "Exactly: because the encoding of a string starts with its length, shorter strings sort before longer ones. This isn't obvious from the definition, but I do have the example of \"z\" sorting before \"aa\".\r\n\r\nThere's no actual need for the diagnostic form to appear in sorted order anyway, since canonicalization happens when encoding a semantic CBOR item to bytes, but I did sort it just to demonstrate the order.",
              "createdAt": "2018-01-17T18:12:30Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            },
            {
              "originalPosition": 33,
              "body": "Done.",
              "createdAt": "2018-01-17T18:44:22Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk2MzIyODQ=",
          "commit": {
            "abbreviatedOid": "7094753"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-17T23:46:38Z",
          "updatedAt": "2018-01-17T23:46:38Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "[Not for this commit] Should this be a http://www.ietf.org/rfc/rfc2616.txt http-date?",
              "createdAt": "2018-01-17T23:46:38Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3ODk2MzM1OTQ=",
          "commit": {
            "abbreviatedOid": "7094753"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-17T23:53:33Z",
          "updatedAt": "2018-01-17T23:53:48Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "> as soon as they are validated\r\n\r\nWould you clarify if this means \"potentially-validated\" from Section 3.6 algorithm, or \"valid\" from the full cert chain authority check in Section 4.3.1?",
              "createdAt": "2018-01-17T23:53:33Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAxOTYzMDY=",
          "commit": {
            "abbreviatedOid": "7094753"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-19T18:06:18Z",
          "updatedAt": "2018-01-19T18:06:18Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "It's possible the HTTPWG will tell me to use text dates, but I'd rather avoid the change until then: text dates are longer, take more code to parse and generate, and we can provide the human readability in devtools if we want. ",
              "createdAt": "2018-01-19T18:06:18Z",
              "updatedAt": "2018-01-19T18:27:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAyMDI0MDM=",
          "commit": {
            "abbreviatedOid": "7094753"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-19T18:28:39Z",
          "updatedAt": "2018-01-19T18:28:39Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "This turns out to be hard to word. It's actually both: there's a stack of standards here, and the next layer up mustn't process past the potentially-valid point when determining actual validity, and the layer above that mustn't process past the actually-valid point when using the data for some other purpose. It's totally plausible that a protocol might need to see the end of a message body to determine whether any of it is valid, but still take advantage of the incremental validity we're providing here to give that answer faster.\r\n\r\nI've updated the wording to try to capture that. I'm going to merge this to master to make my next PR easier to review, but please let me know if I need to change it more.",
              "createdAt": "2018-01-19T18:28:39Z",
              "updatedAt": "2018-01-19T18:28:39Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f1147d57b14121928352c0482979764c1b87f2b0",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "incremental-validity",
      "headRefOid": "e0eb9c3a41b252b001b6e82827595cebe9b17238",
      "mergeCommit": {
        "oid": "e2fd40941d584058bba30a80a43d7d41fd1b61e5"
      }
    },
    {
      "number": 109,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0MDcyNjkz",
      "title": "Specifying the Accept-Signature header to ask for signatures.",
      "url": "https://github.com/WICG/webpackage/pull/109",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/want-signature/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/want-signature/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n[RFC3230](https://tools.ietf.org/html/rfc3230#section-4.3.1) uses `Want-Digest` for a similar purpose, but `Accept-*` seems more common.\r\n\r\n@cramforce, does this look sensible? Have I over- or under-complicated it?",
      "createdAt": "2018-01-19T21:30:23Z",
      "updatedAt": "2018-01-30T17:05:38Z",
      "closedAt": "2018-01-26T21:14:28Z",
      "mergedAt": "2018-01-26T21:14:28Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@yoavweiss Here's your content negotiation mechanism.",
          "createdAt": "2018-01-24T18:31:46Z",
          "updatedAt": "2018-01-24T18:31:46Z"
        },
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "> @yoavweiss Here's your content negotiation mechanism.\r\n\r\nIndeed! missed that PR. Will go over it soonish",
          "createdAt": "2018-01-24T22:32:34Z",
          "updatedAt": "2018-01-24T22:32:34Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm merging this to unblock publishing the next IETF draft, but please keep commenting and filing issues as you notice problems.",
          "createdAt": "2018-01-26T21:13:47Z",
          "updatedAt": "2018-01-26T21:13:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAyODk1NzE=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-20T01:48:25Z",
          "updatedAt": "2018-01-20T01:48:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "When would a client send this? Would you expect a UA to always send this header?",
              "createdAt": "2018-01-20T01:48:25Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAyOTM0ODA=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-20T04:01:23Z",
          "updatedAt": "2018-01-20T04:01:24Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I would expect the AMP crawler to always send it. A browser might omit it on normal requests, but send it when there's an [`integrity=\"ed25519-xyz\"` attribute](https://github.com/mikewest/signature-based-sri#the-proposal), and, when the user says \"save page as\", it might try re-requesting all the resources with the header to see if it can include proofs that the resources aren't modified. Or if cross-signatures become a thing, the browser might always send a version of the header that asks for the cross-signature it cares about.",
              "createdAt": "2018-01-20T04:01:23Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzMDcyNDI=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-01-20T16:02:37Z",
          "updatedAt": "2018-01-20T16:02:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzMjU0NTc=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-21T09:10:14Z",
          "updatedAt": "2018-01-21T09:10:14Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I'd expect UA implementing pre-fetch mechanisms (incl. Chromium) to always send this header.\r\nLINK rel={prefetch,preload} primitives may prefetch the resources that are later meant to be integrity checked. While re-sending the request on <script integrity> usage is theoretically possible, it would incur additional latency which was the whole point of the prefetch.",
              "createdAt": "2018-01-21T09:10:14Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzMjU1MjQ=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-21T09:14:45Z",
          "updatedAt": "2018-01-21T09:14:46Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Would it be possible for the client (Chromium) to request ed25519key signature response, while not specifying the ed25519 public key (or its prefix)?\r\nI'm not sure if the UA knows which key its going to use at the request time (similar to the prefetch argument above).",
              "createdAt": "2018-01-21T09:14:46Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTA2MzI1MjY=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-22T21:28:54Z",
          "updatedAt": "2018-01-22T21:28:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "We wouldn't need to pass the header for [`as`](https://html.spec.whatwg.org/multipage/semantics.html#attr-link-as) types that don't support [`integrity` attributes](https://w3c.github.io/webappsec-subresource-integrity/#interface-extensions), but yeah, that's a good point for preloaded scripts and stylesheets. @otherdaniel, would it make sense to put `integrity` attributes on prefetch links? [`<link>` already supports the attribute](https://html.spec.whatwg.org/multipage/semantics.html#attr-link-integrity) for the benefit of stylesheets.\r\n\r\nServers can also opt to send a Signature unconditionally when they expect it to be needed by their SRI directives, although we probably don't want to risk that performance footgun.",
              "createdAt": "2018-01-22T21:28:54Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTA2MzMyMjY=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-22T21:31:11Z",
          "updatedAt": "2018-01-22T21:31:11Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Right now, no, although we could specify a way to say that. For example, `ed25519key; *`. I *think* that for the https://github.com/mikewest/signature-based-sri use case, the `integrity=ed25519-...` attribute is always available next to the `src`, so the browser could include the public key.\r\n@otherdaniel",
              "createdAt": "2018-01-22T21:31:11Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyNjgyNjE=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": null,
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T17:48:09Z",
          "updatedAt": "2018-01-24T17:48:09Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Regarding _integrity attributes on prefetch links_: We've been [discussing this](https://bugs.chromium.org/p/chromium/issues/detail?id=677022) in a different context, and the consensus then was that from a web developer's perspective it makes little sense to require integrity attributes on prefetches. The present Chrome/Chromium implementation doesn't deal super well with this, but we thought our implementation choices shouldn't be the deciding factor.\r\n\r\nI think one can argue this either way, but my gut feeling is that the prefetch shouldn't be burdened with this.",
              "createdAt": "2018-01-24T17:48:09Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyNzA4Mjg=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": null,
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T17:56:33Z",
          "updatedAt": "2018-01-24T17:56:33Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "According to Mike's proposal, this would always be the case.\r\n\r\nI can imagine use cases where this wouldn't be the case. Particularly if [Origin Policy](https://wicg.github.io/origin-policy/) happens, it'd be very convenient if the origin could declare its supported keys, without requiring them to be duplicated within each page. That would then break this.\r\n\r\nA related, but somewhat incomplete thought: Mike has been pushing around the idea that maybe each resource should carry its own integrity assertions (that is, the resource declares it's own hash, or maybe signature, etc.), which would make it somewhat self-contained. Then, much of the work could happen as each resource is downloaded, independently of where/how it's being used. That's a somewhat incomplete plan, but IMHO rather attractive since it offers a path to bring the cost of (additional) security down to near-zero, and predictably so. Much of what we discuss here isn't directly contradicting this, but does go in the opposite direction, in that a resource could only be integrity-checked if requested in specific ways. \r\n",
              "createdAt": "2018-01-24T17:56:33Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyODA1NTE=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T18:27:43Z",
          "updatedAt": "2018-01-24T18:30:23Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "'k, I realized that `ed25519key; *` already matches all keys, so the browser can use that on prefetches if we don't want those to include `integrity` attributes. I've added an example for this. Or servers can send their `Signature` headers unconditionally for those resources.",
              "createdAt": "2018-01-24T18:27:43Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            },
            {
              "originalPosition": 69,
              "body": "Yep, I wouldn't want to get in the way of putting keys in the Origin Policy. Servers can definitely send the `Signature` even if the browser didn't explicitly request it, which fits the second half. If that becomes policy, we can drop the `ed25519key; ...` stuff entirely.",
              "createdAt": "2018-01-24T18:30:12Z",
              "updatedAt": "2018-01-26T21:11:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTI1NDU2NDU=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": null,
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-30T12:48:17Z",
          "updatedAt": "2018-01-30T12:48:17Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "This is a bit of a nitpick, but: As I read draft-ietf-httpbis-header-structure-02, a lone asterisk wouldn't match the grammar given there. It specifies \r\n\r\n>  binary = \"*\" 1\\*21846(base64)\r\n\r\nwhich I read as at least 1 and at most 21846 base64 characters. I guess there should be some way to specifiy an empty binary string, but I can't figure out how.\r\n",
              "createdAt": "2018-01-30T12:48:17Z",
              "updatedAt": "2018-01-30T12:48:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTI2NDE5ODA=",
          "commit": {
            "abbreviatedOid": "6aa4dc9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-30T17:05:38Z",
          "updatedAt": "2018-01-30T17:05:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Good point, thanks. I've filed https://github.com/httpwg/http-extensions/issues/474.",
              "createdAt": "2018-01-30T17:05:38Z",
              "updatedAt": "2018-01-30T17:05:38Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6c5c07db62ce1136525f20665d9dd418bcee29a4",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "want-signature",
      "headRefOid": "d566fbe0121c4a4df8afcc126c0090285048008f",
      "mergeCommit": {
        "oid": "ea6ae8d710e7f16dce8b9d46f0cf7f01d2353eb1"
      }
    },
    {
      "number": 110,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0MDk5Mzg0",
      "title": "Define application/http-exchange+cbor.",
      "url": "https://github.com/WICG/webpackage/pull/110",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/envelope-format/draft-yasskin-http-origin-signed-responses.html#application-http-exchange)\r\n\r\nThis format wraps an HTTP exchange, which allows an HTTP/1 connection to\r\ntransfer cross-origin signed exchanges, and which may have other uses.\r\n\r\n@kinu @yoavweiss Does this look reasonable?",
      "createdAt": "2018-01-20T00:41:32Z",
      "updatedAt": "2018-01-26T21:26:51Z",
      "closedAt": "2018-01-26T21:26:48Z",
      "mergedAt": "2018-01-26T21:26:48Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Just read through the texts, LGTM\r\n\r\n/cc @horo-t",
          "createdAt": "2018-01-22T02:21:19Z",
          "updatedAt": "2018-01-22T02:21:19Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm merging this to unblock publishing the next IETF draft, but please keep commenting and filing issues as you notice problems.",
          "createdAt": "2018-01-26T21:23:24Z",
          "updatedAt": "2018-01-26T21:23:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzMjU3MDA=",
          "commit": {
            "abbreviatedOid": "f8a6833"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-01-21T09:25:11Z",
          "updatedAt": "2018-01-21T09:25:31Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Would it be possible to standardize one?",
              "createdAt": "2018-01-21T09:25:11Z",
              "updatedAt": "2018-01-26T21:22:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTAzNTg1MTQ=",
          "commit": {
            "abbreviatedOid": "f8a6833"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-22T02:23:05Z",
          "updatedAt": "2018-01-22T02:23:05Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "Reg: impl side concerns I think we're also fine with leaving it as N/A",
              "createdAt": "2018-01-22T02:23:05Z",
              "updatedAt": "2018-01-26T21:22:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTA2MjIxMTg=",
          "commit": {
            "abbreviatedOid": "f8a6833"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-22T20:53:54Z",
          "updatedAt": "2018-01-22T20:53:54Z",
          "comments": [
            {
              "originalPosition": 158,
              "body": "I'll grab `htxg` which matches the magic number that I pulled out of my hat, but I'm going to invite the HTTPWG to propose other names for the mime type, which could easily change the extension.",
              "createdAt": "2018-01-22T20:53:54Z",
              "updatedAt": "2018-01-26T21:22:55Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ea6ae8d710e7f16dce8b9d46f0cf7f01d2353eb1",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "envelope-format",
      "headRefOid": "226d506abe9a2278a87d77d3439c78adbe9b0ca7",
      "mergeCommit": {
        "oid": "be48821dbb4d1e21b16a44b24a8ebf549cad2cd7"
      }
    },
    {
      "number": 111,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0NjMyNDky",
      "title": "Changes inspired by Ryan's comments",
      "url": "https://github.com/WICG/webpackage/pull/111",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@sleevi, how's this look?\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/sleevi-comments/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/sleevi-comments/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-01-23T16:57:33Z",
      "updatedAt": "2018-01-26T20:44:49Z",
      "closedAt": "2018-01-26T20:44:45Z",
      "mergedAt": "2018-01-26T20:44:45Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEwMTE1NzE=",
          "commit": {
            "abbreviatedOid": "376a8d9"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-23T22:51:13Z",
          "updatedAt": "2018-01-23T22:51:13Z",
          "comments": [
            {
              "originalPosition": 191,
              "body": "@jschuh, here's your suggestion that clients can check for validity more often.",
              "createdAt": "2018-01-23T22:51:13Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEyOTU1ODY=",
          "commit": {
            "abbreviatedOid": "2ab9cb3"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T19:12:50Z",
          "updatedAt": "2018-01-24T19:20:45Z",
          "comments": [
            {
              "originalPosition": 78,
              "body": "Readability wise, this is very subtle and tripped me up during review here, that we're talking thirdparty.example.com versus example.com\r\n\r\nIt might make sense to use a different suffix here on the resource.validity, so that the visual pattern matching can more easily notice the difference in origins?",
              "createdAt": "2018-01-24T19:12:50Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 73,
              "body": "As a further comment re: examples, it's unclear what the implications of the overlap are between the expires on sig1 and the date on sig2. That is, it's not clear the use case for the overlapping set of signatures with the same validityURL, versus discrete (non-overlapping)\r\n\r\nThis is not specific to this PR, but was within the set of concerns with the examples being relatively opaque. It may be that an 'explainer' type document is better suited to capture this nuance, but as an example, it's a bit confusing :)",
              "createdAt": "2018-01-24T19:15:19Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 197,
              "body": "This guarantee is provided iff you have the same-origin assertion from line 647. The open question (in line 674) makes it unclear whether this would be true, but if that's removed, then it could be that validityUrl is served by a different entity, and thus does not provide a TLS guarantee.",
              "createdAt": "2018-01-24T19:16:43Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 197,
              "body": "Also, given validityUrls are unsigned and don't *seem* to be restricted to https:// in any of the normative requirements, I'm not sure that is inherently true, so much as assumed true?",
              "createdAt": "2018-01-24T19:19:32Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 219,
              "body": "1) Why not MUST?\r\n2) How do you determine \"as secure as\". What is the guidance meant to be provided to implementations in determining that assessment? Is HTTP on a local network 'at least as secure as' HTTPS, if it's over a VPN?",
              "createdAt": "2018-01-24T19:20:26Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEzMTUxMjQ=",
          "commit": {
            "abbreviatedOid": "5fa68ba"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T20:13:44Z",
          "updatedAt": "2018-01-24T20:14:01Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Ahhh, I don't think we'd want to use anything other than the IANA-reserved domains, especially in a draft, so I think you were doing great with thirdparty.example.com, which is why I mentioned the suffix part :)\r\n\r\nPut more precise: I do not think we should deviate from https://tools.ietf.org/html/rfc6761#section-6.5",
              "createdAt": "2018-01-24T20:13:44Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTEzNDUzOTQ=",
          "commit": {
            "abbreviatedOid": "2ab9cb3"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-24T21:55:46Z",
          "updatedAt": "2018-01-26T18:44:48Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "My thought is that you'd sign with two different signatures if you have different clients with incompatible constraints, for example one has Symantec but no newer roots, and another refuses to trust Symantec. The date ranges aren't exactly equal because there's no technical need for it: each signature is valid or expired independently. However, there's probably also no need for the author to use different date ranges, so I'll make them the same in my next update.",
              "createdAt": "2018-01-24T21:55:46Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 78,
              "body": "I've kept the same suffix pattern, and just varying the timestamp digits isn't particularly noticeable, but I've now abbreviated the signature so the longer origin now sticks out a lot more.",
              "createdAt": "2018-01-24T22:49:56Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 197,
              "body": "I've added a note that this guarantee only works if we keep the same-origin restriction. I'm going to argue for allowing a list of URLs, but that'll take a change to [draft-ietf-httpbis-header-structure](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-02).\r\n\r\nI wasn't sure whether to require validityUrls to be HTTPS or to reason that, if you care about this, your main resource is HTTPS, and since the validityUrl must be same-origin with the main URL, it's also HTTPS.\r\n\r\nI've now also signed the validityUrl, since if it has to be same-origin with the resource, there's not much point in caching it. If we change it to a list, I'll probably just sign the first member.",
              "createdAt": "2018-01-24T22:56:20Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 219,
              "body": "Blast your precision. \ud83d\ude09  So, I used SHOULD because the client might be loading an exchange from local disk with no indication of the transport that put it there. There might also be non-TLS transports that are actually as secure as TLS? I am happy to ban plain HTTP.\r\n\r\nHow's this?",
              "createdAt": "2018-01-24T23:01:54Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            },
            {
              "originalPosition": 23,
              "body": "Thanks for expressing that opinion. Fixed.",
              "createdAt": "2018-01-26T18:43:57Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTE5MzcwOTQ=",
          "commit": {
            "abbreviatedOid": "7fd5e2a"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "I think the question I raise here is beyond the scope of this PR, so I'm going to mark Approve for purposes of continuing the discussion, either async or in subsequent issues.",
          "createdAt": "2018-01-26T19:04:01Z",
          "updatedAt": "2018-01-26T19:07:06Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Could you explain what you mean by 'cross-signing certificate' here?\r\n\r\nThat is, 'normally' cross-signing refers to the same subject entity being validated by two different issuers - e.g., a given intermediate \"Intermediate Foo\" can be signed by both \"CA A\" and \"CA B\".\r\n\r\nThis makes me think that the use case here is `thirdparty.example.com` asserting that the content is truly from `example.com`, rather than being `example.com` proving that the `thirdpartysig` covers the resources from `thirdparty.example.com`.\r\n\r\nIf it's the latter (`thirdparty.example.com` certifying the content on `example.com`), then it seems we're introducing yet another Trusted Third Party into Web Packaging, beyond the CA model. That seems a radical departure from the TLS guarantees, and perhaps a subtle aspect I failed to realize - that this would allow non-CA entities to certify certificates.",
              "createdAt": "2018-01-26T19:04:01Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTE5NTE4NTQ=",
          "commit": {
            "abbreviatedOid": "7fd5e2a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-01-26T19:54:56Z",
          "updatedAt": "2018-01-26T19:54:56Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "I mean for all four of these signatures to sign the resource, not any other certificates. (Remember, this is currently about a single exchange, not for a bundle of exchanges that might contain resources from several origins.) One use case might be for `thirdparty.example.com` to be a binary transparency log whose signature certifies that the resource is contained in the log. I'm adding a more explicit statement of the cross-signing use cases in https://github.com/WICG/webpackage/pull/112/files#diff-a2197f2cbc199dc1463dc10213fa40d9R862.\r\n\r\nI'm going to remove the use of \"cross-signing\" lest it imply signing certificates to anyone else, and then merge so that I can publish a new I-D.",
              "createdAt": "2018-01-26T19:54:56Z",
              "updatedAt": "2018-01-26T20:42:23Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e2fd40941d584058bba30a80a43d7d41fd1b61e5",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "sleevi-comments",
      "headRefOid": "b5677cdc627bb5caac22526168b9c1313858b0b9",
      "mergeCommit": {
        "oid": "6c5c07db62ce1136525f20665d9dd418bcee29a4"
      }
    },
    {
      "number": 112,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY0NzI1NjUz",
      "title": "Cleanup and introduction improvements",
      "url": "https://github.com/WICG/webpackage/pull/112",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/cleanup/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/cleanup/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@KenjiBaheux, the introduction here should be usable as a simple explainer. Please check that it's readable and explains enough.",
      "createdAt": "2018-01-24T00:18:37Z",
      "updatedAt": "2018-01-26T23:45:34Z",
      "closedAt": "2018-01-26T23:45:27Z",
      "mergedAt": "2018-01-26T23:45:27Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm merging so I can publish a new I-D, but feel free to comment later.",
          "createdAt": "2018-01-26T23:45:20Z",
          "updatedAt": "2018-01-26T23:45:20Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "de4305825e6233e14081afc37cc63b648b2c82f9",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "cleanup",
      "headRefOid": "92c628c4afd90b7c7879bf5470fe7bfc79f134a0",
      "mergeCommit": {
        "oid": "92c628c4afd90b7c7879bf5470fe7bfc79f134a0"
      }
    },
    {
      "number": 116,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1NDc3NTIx",
      "title": "Update to the -23 TLS1.3 draft.",
      "url": "https://github.com/WICG/webpackage/pull/116",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "That draft splits the rsa_pss signature algorithm names to depend on the key's OID. I suspect all RSA keys in the wild use the rsaEncryption OID, so banning that (to avoid Bleichenbacher attacks) would be equivalent to banning RSA keys, but if not, maybe we could allow the RSASSA-PSS ones.\r\n\r\n@sleevi @davidben",
      "createdAt": "2018-01-26T22:41:52Z",
      "updatedAt": "2018-02-28T22:07:35Z",
      "closedAt": "2018-02-28T22:07:31Z",
      "mergedAt": "2018-02-28T22:07:31Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0MjE0MjU=",
          "commit": {
            "abbreviatedOid": "bf53491"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-22T01:20:45Z",
          "updatedAt": "2018-02-22T01:20:45Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "92c628c4afd90b7c7879bf5470fe7bfc79f134a0",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-rsa-pss-name",
      "headRefOid": "bf53491e2d8e2d4d9c989327894f1c6bff3ba89e",
      "mergeCommit": {
        "oid": "e0bf287561d5ffe8ea795809548827a30ce9aad0"
      }
    },
    {
      "number": 118,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY1ODEzOTg2",
      "title": "Update the README.",
      "url": "https://github.com/WICG/webpackage/pull/118",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "A quick update to the README that fixes #115. This doesn't update the explainer, which is still aimed at the pre-layered format.",
      "createdAt": "2018-01-29T20:50:21Z",
      "updatedAt": "2018-01-30T00:46:22Z",
      "closedAt": "2018-01-30T00:46:19Z",
      "mergedAt": "2018-01-30T00:46:19Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTIzNTIzMjA=",
          "commit": {
            "abbreviatedOid": "8e15f7f"
          },
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-01-29T20:52:57Z",
          "updatedAt": "2018-01-29T20:52:57Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "92c628c4afd90b7c7879bf5470fe7bfc79f134a0",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-readme",
      "headRefOid": "8e15f7f13166bc48d3277809fa6641531d935fba",
      "mergeCommit": {
        "oid": "4a099ad859b6164924b727ac3d0b4fd43d739a17"
      }
    },
    {
      "number": 119,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3MDYwNDMx",
      "title": "\"Signed Exchange\" Generator implementation",
      "url": "https://github.com/WICG/webpackage/pull/119",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR introduces a generator tool which implements the \"Signed HTTP Exchange\" proposed as in https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html\r\n\r\nThe code is written by @hajimehoshi, @nyaxt, @irori (all Googlers, thus can skip CLA) with adopted code from https://github.com/WICG/webpackage/tree/master/go/webpack.\r\n",
      "createdAt": "2018-02-05T05:28:11Z",
      "updatedAt": "2018-02-14T02:04:08Z",
      "closedAt": "2018-02-14T02:04:08Z",
      "mergedAt": "2018-02-14T02:04:08Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "I think all the current problems are solved (except for testing format in cert_url?) Sorry for the very huge PR, and thank you for taking a look!",
          "createdAt": "2018-02-08T08:16:30Z",
          "updatedAt": "2018-02-08T08:16:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxNDM0ODA=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I've reviewed through go/signedexchange/mice/mice.go.",
          "createdAt": "2018-02-05T21:10:53Z",
          "updatedAt": "2018-02-05T21:58:18Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I assume you gave `w` a name to avoid exporting it?",
              "createdAt": "2018-02-05T21:10:53Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 213,
              "body": "This could be more efficient, but for the data sizes that are likely in signed-exchange maps, it probably doesn't matter. Maybe just comment that?",
              "createdAt": "2018-02-05T21:14:03Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 89,
              "body": "Please also test a non-UTF-8 string.",
              "createdAt": "2018-02-05T21:16:15Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 12,
              "body": "Comment why you can't use https://golang.org/pkg/encoding/binary/#Write (size isn't necessarily a power of 2).",
              "createdAt": "2018-02-05T21:28:43Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 19,
              "body": "I'd expect a function called `ParsePEM` to only parse the PEM format, and not also serialize it to the TLS 1.3 Certificate message format. Call it `CertificateMessageFromPEM` or similar, or split it into two functions?",
              "createdAt": "2018-02-05T21:31:36Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 47,
              "body": "Could you paste the Certificate format from https://tools.ietf.org/html/draft-ietf-tls-tls13-23#section-4.4.2 here?\r\n\r\n```\r\nenum {\r\n    X509(0),\r\n    RawPublicKey(2),\r\n    (255)\r\n} CertificateType;\r\n\r\nstruct {\r\n    select (certificate_type) {\r\n        case RawPublicKey:\r\n          /* From RFC 7250 ASN.1_subjectPublicKeyInfo */\r\n          opaque ASN1_subjectPublicKeyInfo<1..2^24-1>;\r\n\r\n        case X509:\r\n          opaque cert_data<1..2^24-1>;\r\n    };\r\n    Extension extensions<0..2^16-1>;\r\n} CertificateEntry;\r\n\r\nstruct {\r\n    opaque certificate_request_context<0..2^8-1>;\r\n    CertificateEntry certificate_list<0..2^24-1>;\r\n} Certificate;\r\n```",
              "createdAt": "2018-02-05T21:34:27Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 71,
              "body": "I'm happy for this to be a TODO, but we'll also need to include the OCSP Status SignedCertificateTimestamps extensions.",
              "createdAt": "2018-02-05T21:35:40Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 75,
              "body": "This isn't a particularly useful test, but I also don't want to make you write a TLS parser just to test the code. `CertificateBody.Unmarshal` in https://github.com/bifurcation/mint/blob/master/handshake-messages.go#L295 might be helpful.",
              "createdAt": "2018-02-05T21:41:28Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 14,
              "body": "Add `> certurlfile`?",
              "createdAt": "2018-02-05T21:42:27Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 32,
              "body": "`%q` will avoid the need for quotes around `\"%s\"`. https://golang.org/pkg/fmt/#hdr-Printing",
              "createdAt": "2018-02-05T21:44:57Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 82,
              "body": "Give `i` a more explanatory name.",
              "createdAt": "2018-02-05T21:48:06Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 13,
              "body": "\"if one exists\" or \"the error if any\", I think.",
              "createdAt": "2018-02-05T21:49:30Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 24,
              "body": "Please comment what you're doing in this loop.",
              "createdAt": "2018-02-05T21:56:32Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxODQ2Nzc=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-05T23:50:09Z",
          "updatedAt": "2018-02-06T00:22:24Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "I recommend use of the assert package, to avoid having to repeat error messages. https://godoc.org/github.com/stretchr/testify/assert. The Google style guide disapproves, but they're wrong.",
              "createdAt": "2018-02-05T23:50:09Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 16,
              "body": "I think this is just an `Exchange`.",
              "createdAt": "2018-02-05T23:55:31Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 60,
              "body": "Would it make sense for this tool to assume that all headers are signed? We support signing a subset to allow the signatures to survive intermediate proxies, and this tool doesn't need to be a proxy. Then you could remove this function, and have AddSignatureHeader also add the Signed-Headers header.",
              "createdAt": "2018-02-06T00:00:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 103,
              "body": "Be consistent about whether the HTTP header fields are one \"header\" or a list of \"headers\". I tend to prefer making it plural, but one can argue that that's not literally correct.",
              "createdAt": "2018-02-06T00:03:49Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 140,
              "body": "Be consistent about whether you include \"canonical\" in these function names.",
              "createdAt": "2018-02-06T00:05:08Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 162,
              "body": "Checking against a base64-encoded version of the CBOR data won't make it easy to diagnose test failures. You might instead use https://godoc.org/github.com/ugorji/go/codec#Decoder.Decode to decode to an interface and then `fmt` that with `%v` to get a text representation of the cbor, which will have comprehensible assertion failures.",
              "createdAt": "2018-02-06T00:13:01Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 69,
              "body": "I've added the `validityUrl` into this map: https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signature-validity.\r\n\r\nThis is likely to change again, slightly: I think the validityUrl should be a list of URLs, only one of which must be same-origin with the request URL and included in the signature.",
              "createdAt": "2018-02-06T00:16:02Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 98,
              "body": "Comment why you allow the caller to pass in a random number generator.",
              "createdAt": "2018-02-06T00:17:46Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 27,
              "body": "@nyaxt pointed out that the last `nil` here is a bug: RSA-PSS requires that the salt length equals the hash length, so you need `&PSSOptions{SaltLength:rsa.PSSSaltLengthEqualsHash}`.",
              "createdAt": "2018-02-06T00:19:42Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQxOTY2MjA=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T00:58:48Z",
          "updatedAt": "2018-02-06T01:00:59Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Would you elaborate on this? I feel like keeping the code easier to understand without assert pkg knowledge is more valuable here. Golang docs also mentions this.\r\nhttps://golang.org/doc/faq#assertions\r\nhttps://golang.org/doc/faq#testing_framework\r\n\r\nAlthough, I do feel its a bit repetitive. How about introducing a one-off bytes compare helper function in this file and using it throughout the test?\r\nSomething like:\r\n```\r\nfunc assertBytesEqal(t *testing.T, desc string, expected, actual []byte) {\r\n  t.Helper()\r\n  if !bytes.Equal(expected, actual) {\r\n    t.Errorf(\"%s: got %v, want %v\", msg, expected, actual)\r\n  }\r\n}\r\n```",
              "createdAt": "2018-02-06T00:58:48Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 27,
              "body": "I'm preparing a separate PR to address this. Will follow up shortly.",
              "createdAt": "2018-02-06T00:59:52Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 60,
              "body": "I'm preparing a separate PR to address this. Will follow up shortly.",
              "createdAt": "2018-02-06T01:00:54Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMTQ5ODU=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T03:11:01Z",
          "updatedAt": "2018-02-06T03:27:47Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "https://github.com/hajimehoshi/webpackage/pull/2",
              "createdAt": "2018-02-06T03:11:01Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 60,
              "body": "https://github.com/hajimehoshi/webpackage/pull/3",
              "createdAt": "2018-02-06T03:27:44Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMjQ2Njg=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T04:43:57Z",
          "updatedAt": "2018-02-06T04:43:57Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Right. ",
              "createdAt": "2018-02-06T04:43:57Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMjQ4MzE=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T04:45:03Z",
          "updatedAt": "2018-02-06T04:45:03Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "I agree: sorting keys with a new array is not very effective but is the most direct way. I'll comment this later.",
              "createdAt": "2018-02-06T04:45:03Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMjYwMTI=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T04:57:48Z",
          "updatedAt": "2018-02-06T04:57:48Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "https://github.com/hajimehoshi/webpackage/pull/4",
              "createdAt": "2018-02-06T04:57:48Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMjY4MDQ=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you! I fixed the PR addressing on part of your comments. I'll be working on the rest later.",
          "createdAt": "2018-02-06T05:06:02Z",
          "updatedAt": "2018-02-06T05:57:39Z",
          "comments": [
            {
              "originalPosition": 213,
              "body": "Done.",
              "createdAt": "2018-02-06T05:06:02Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 89,
              "body": "Done",
              "createdAt": "2018-02-06T05:09:04Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2018-02-06T05:18:36Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 14,
              "body": "Done.",
              "createdAt": "2018-02-06T05:21:31Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2018-02-06T05:23:41Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 13,
              "body": "Done.",
              "createdAt": "2018-02-06T05:26:37Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 25,
              "body": "Hmm, I tend not to want to use assertions. This is just because I'd want to follow Go's standard convention, not only Google's convention.",
              "createdAt": "2018-02-06T05:34:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 16,
              "body": "Done.",
              "createdAt": "2018-02-06T05:38:50Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMzczMjE=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T06:37:53Z",
          "updatedAt": "2018-02-06T06:37:57Z",
          "comments": [
            {
              "originalPosition": 162,
              "body": "Done by https://github.com/WICG/webpackage/pull/119/commits/38c496415ca945dd369fcf3576f2a5416d63f9fb",
              "createdAt": "2018-02-06T06:37:53Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQyMzkxOTc=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T06:51:04Z",
          "updatedAt": "2018-02-06T07:47:10Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done.",
              "createdAt": "2018-02-06T06:51:04Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 19,
              "body": "Done. As this function is in `certurl` package, I thought `ParsePEM` was not so confusing IMHO. However, `CertificateMessageFromPEM` might be a better name.",
              "createdAt": "2018-02-06T06:56:42Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 71,
              "body": "Done.",
              "createdAt": "2018-02-06T07:00:40Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 69,
              "body": "Merged.",
              "createdAt": "2018-02-06T07:12:51Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 24,
              "body": "Done.",
              "createdAt": "2018-02-06T07:15:37Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 75,
              "body": "Thanks, but different from `codec.CborHandle`, this can't be passed to `%q` format?",
              "createdAt": "2018-02-06T07:45:36Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ0MjI3NDY=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T16:58:32Z",
          "updatedAt": "2018-02-06T18:39:08Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "s/effective/efficient/ It's very effective. :)",
              "createdAt": "2018-02-06T16:58:32Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 102,
              "body": "Instead of adding a third field to the test list, whose meaning isn't obvious from looking at the `{..., false}`, I'd probably write an independent assertion for the failure case:\r\n\r\n```go\r\nif err:=NewEncoder(&bytes.Buffer{}).EncodeTextString(\"\\x80 <- invalid UTF-8\"); err==nil {\r\n  t.Errorf(\"Expected an error for malformed UTF-8\")\r\n}\r\n```",
              "createdAt": "2018-02-06T17:04:20Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 97,
              "body": "Whoops, I forgot an \"and\" in my review comment, which you faithfully reproduced here. \"OCSP Status\" and \"SignedCertificateTimestamps\" are two separate extensions.",
              "createdAt": "2018-02-06T17:07:30Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 75,
              "body": "I don't really understand the question. [`codec.CborHandle`](http://ugorji.net/blog/go-codec-primer#decoding) isn't the object that's filled in when decoding cbor with codec, and I'd expect to format objects with `%v` instead of `%q` anyway.",
              "createdAt": "2018-02-06T18:39:07Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ0NTgwNTY=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-06T18:40:14Z",
          "updatedAt": "2018-02-06T19:31:03Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "In a usage string `[]` usually surrounds optional things, but here the pem-file isn't optional, and if the certurlFile is omitted the `>` needs to be absent too.",
              "createdAt": "2018-02-06T18:40:14Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 25,
              "body": "You don't have to use assertions, but to elaborate a bit:\r\n\r\nIt's a choice between \r\n```go\r\nfunc TestSingleRecord(t *testing.T) {\r\n\tvar buf bytes.Buffer\r\n\tmessage := []byte(\"When I grow up, I want to be a watermelon\")\r\n\tmi, err := Encode(&buf, message, 0x29)\r\n\tif err != nil {\r\n\t\tt.Fatal(err)\r\n\t}\r\n\r\n\tgotBytes := buf.Bytes()\r\n\twantBytes := append([]byte{0, 0, 0, 0, 0, 0, 0, 0x29}, message...)\r\n\tif !bytes.Equal(gotBytes, wantBytes) {\r\n\t\tt.Errorf(\"buf.Bytes(): got %v, want %v\", gotBytes, wantBytes)\r\n\t}\r\n\r\n\twantMI := \"mi-sha256=dcRDgR2GM35DluAV13PzgnG6-pvQwPywfFvAu1UeFrs\"\r\n\tif mi != wantMI {\r\n\t\tt.Errorf(\"e.MI(); got %v, want %v\", mi, wantMI)\r\n\t}\r\n}\r\n```\r\nvs\r\n```go\r\nfunc TestSingleRecord(t *testing.T) {\r\n\tvar buf bytes.Buffer\r\n\tmessage := []byte(\"When I grow up, I want to be a watermelon\")\r\n\tmi, err := Encode(&buf, message, 0x29)\r\n\trequire.NoError(t, err)\r\n\tassert.Equal(t, buf.Bytes(), append([]byte{0, 0, 0, 0, 0, 0, 0, 0x29}, message...), \"buf.Bytes()\")\r\n\tassert.Equal(t, mi, \"mi-sha256=dcRDgR2GM35DluAV13PzgnG6-pvQwPywfFvAu1UeFrs\", \"e.MI\")\r\n}\r\n```\r\n\r\nThere's fewer extraneous lines of code that get in the way when reading the test. It's also clearer whether you want the `Encode` call to succeed or fail where \"if error is not nil, fail\" has a double-negative. For the cases where the lack of an assertion library forces you to use a table, which is clearer to read?\r\n\r\n```go\r\n{\r\n\tbegin: 8,\r\n\tend:   24,\r\n\twant:  message[0:16],\r\n},\r\n```\r\nor\r\n```go\r\nassert.Equal(t, b[8:24], message[0:16])\r\n```\r\n\r\nI'm still not insisting that you diverge from the Go's authors' preference here, but it does harm test readability.",
              "createdAt": "2018-02-06T19:31:02Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ0NzYyMTg=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-06T19:32:00Z",
          "updatedAt": "2018-02-06T19:38:41Z",
          "comments": [
            {
              "originalPosition": 103,
              "body": "Be consistent about whether the HTTP header fields are one \"header\" or a list of \"headers\". I tend to prefer making it plural, but one can argue that that's not literally correct.",
              "createdAt": "2018-02-06T19:32:00Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 140,
              "body": "Be consistent about whether you include \"canonical\" in these function names.",
              "createdAt": "2018-02-06T19:32:21Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ1OTU1NDE=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-07T05:29:39Z",
          "updatedAt": "2018-02-07T06:56:11Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "Oops, done :-)",
              "createdAt": "2018-02-07T05:29:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 102,
              "body": "Done.",
              "createdAt": "2018-02-07T05:37:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 97,
              "body": "Done.",
              "createdAt": "2018-02-07T05:40:49Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 14,
              "body": "Done.",
              "createdAt": "2018-02-07T05:41:25Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 25,
              "body": "Thank you for elaboration! Well, to be honest, I agree that assertion is clearer and concise, but I was wondering if using assertions is worth being against the conventions (Especially in Go culture, it looks like following the conventions is important than adopting a 'better' local way).\r\n\r\nAs for readability, the current non-assertion way is less readable but it is not critical IMHO.",
              "createdAt": "2018-02-07T06:03:21Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 103,
              "body": "Done (I don't have a strong opinion. I adopted plurals).",
              "createdAt": "2018-02-07T06:07:39Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 177,
              "body": "Found that comparing `%q` strings is fragile since the order of map keys is not deterministic. I'll fix this later.",
              "createdAt": "2018-02-07T06:41:22Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 75,
              "body": "Ah sorry, I meant a decoded object by `codec.CborHandle` like what we did in singedexchange_test.go My question was, we could compare the formatted strings with `%q` but we couldn't do it with `CertificateBody`. \r\n\r\nAs for `%v`, this just shows the addresses of member pointers like `{[] [{0xc420194b00 []} {0xc420195080 []}]}`, so this doesn't work as we expected?",
              "createdAt": "2018-02-07T06:48:32Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ2MjMzMzg=",
          "commit": {
            "abbreviatedOid": "9a73e60"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-07T08:29:40Z",
          "updatedAt": "2018-02-07T08:29:40Z",
          "comments": [
            {
              "originalPosition": 177,
              "body": "Done.",
              "createdAt": "2018-02-07T08:29:40Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ3OTIyMTc=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-07T17:13:38Z",
          "updatedAt": "2018-02-07T17:18:25Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Ah, good point. It looks like you'd need https://github.com/davecgh/go-spew, or an extension to your `readableString()` function, to format through pointer values. Using that might still be worth it to make the test readable.",
              "createdAt": "2018-02-07T17:13:38Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            },
            {
              "originalPosition": 25,
              "body": "If you look at http://go-search.org/tops, assert is the 4th most imported package in all of Go, so, it basically is a convention even if the language designers don't like it.",
              "createdAt": "2018-02-07T17:18:25Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ3OTU4ODU=",
          "commit": {
            "abbreviatedOid": "9800a9e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-07T17:23:37Z",
          "updatedAt": "2018-02-07T17:23:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5MjYxMDA=",
          "commit": {
            "abbreviatedOid": "9800a9e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T00:54:24Z",
          "updatedAt": "2018-02-08T00:54:24Z",
          "comments": [
            {
              "originalPosition": 70,
              "body": "FYI, @sleevi tells me that using the TLS Certificate format is likely to cause problems for implementers, since its parser isn't actually exposed by TLS validation libraries. He suggests I just do a CBOR structure holding an array of certificates, an ocsp response, and an sct response. That's also easier for you to test, so don't spend too much time getting the Certificate message right in this change.",
              "createdAt": "2018-02-08T00:54:24Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5NjM2Nzg=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T05:57:36Z",
          "updatedAt": "2018-02-08T05:57:36Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Thank you!\r\n\r\nAs my `readableString` is only for fundamental types like a map or a slice of `interface{}`, this doesn't have a capability of analyzing struct members. It's possible to extend this to do that, but it'd be tough work.\r\n\r\nI tried `go-spew`, but both `spew.Sprintf(\"%v\", ...)` and `spew.Dump(...)` generates a lot of huge sequences of binary numbers, so I don't think spew has a lot of advantage compared to the current way...",
              "createdAt": "2018-02-08T05:57:36Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5NjY0OTI=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T06:20:50Z",
          "updatedAt": "2018-02-08T06:20:51Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "Done: Used `github.com/kylelemons/godebug/pretty.Compare` to make the 'binary' diff much more readable.\r\n\r\nAnother concern of such pretty printing of struct values is that the order of map keys and/or struct members are not assured. Probably I'd be able to create an expected `mint.CertificateBody` and compare them by `pretty.Compare`, but as I mentioned, this struct includes a lot of binary sequences, so this might not be very helpful very much?",
              "createdAt": "2018-02-08T06:20:51Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5NzA2NTg=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T06:52:56Z",
          "updatedAt": "2018-02-08T06:52:56Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Done.",
              "createdAt": "2018-02-08T06:52:56Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTQ5ODI3NTI=",
          "commit": {
            "abbreviatedOid": "863fe49"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-08T08:06:52Z",
          "updatedAt": "2018-02-08T08:06:52Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Done.",
              "createdAt": "2018-02-08T08:06:52Z",
              "updatedAt": "2018-02-08T08:10:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTU2MTM4NjY=",
          "commit": {
            "abbreviatedOid": "04fa384"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm myside.\r\n@jyasskin Would you merge once you are happy?",
          "createdAt": "2018-02-10T05:51:57Z",
          "updatedAt": "2018-02-10T05:52:30Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4a099ad859b6164924b727ac3d0b4fd43d739a17",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "gen-signedexchange",
      "headRefOid": "04fa384f0495aa52b6d446e9bc13e5a0e9cddcc7",
      "mergeCommit": {
        "oid": "51957369a8a96e1fce0081303d0f47382e00a9cf"
      }
    },
    {
      "number": 120,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3NzkyOTgy",
      "title": "Let certUrl and validityUrl contain lists",
      "url": "https://github.com/WICG/webpackage/pull/120",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/validity-url-lists/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/validity-url-lists/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-02-07T19:55:55Z",
      "updatedAt": "2021-02-17T00:19:08Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "validity-url-lists",
      "headRefOid": "29084389b699a1ecd6e55609ef2fafcb9910c64b",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 121,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY3ODMxMjc0",
      "title": "Sign over the OCSP response to make signing oracles temporary.",
      "url": "https://github.com/WICG/webpackage/pull/121",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/sign-ocsp/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/sign-ocsp/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@davidben @sleevi, how's this look?",
      "createdAt": "2018-02-07T22:49:20Z",
      "updatedAt": "2021-02-17T00:19:08Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "sign-ocsp",
      "headRefOid": "257fd2814201b30981efa043fb1cb9ee00f483cf",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@hajimehoshi @nyaxt FYI, this will need a change to the signature generator.",
          "createdAt": "2018-02-07T22:53:10Z",
          "updatedAt": "2018-02-07T22:53:10Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@davidben friendly ping. I'm trying to make b2 cut (which we'd like to target Origin-Trial), and is wondering if this PR is good enough to go in to the cut",
          "createdAt": "2018-08-20T01:37:29Z",
          "updatedAt": "2018-08-20T01:37:29Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Actually, given the timeline, I'd like to punt this to b3 if possible if you are comfortable.",
          "createdAt": "2018-08-20T06:19:55Z",
          "updatedAt": "2018-08-20T06:19:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTcyOTY4NzA=",
          "commit": {
            "abbreviatedOid": "bf6158e"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-16T19:49:43Z",
          "updatedAt": "2018-02-16T19:57:55Z",
          "comments": [
            {
              "originalPosition": 73,
              "body": "Signing oracles may also arise from implementation flaws like Bleichbacher attack or DROWN.",
              "createdAt": "2018-02-16T19:49:43Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 80,
              "body": "SHOULD NOT is weak here. Because this is not the opt-in X.509 extension (which is much more straightforward and strongly preferable), any client which deploys this instantly makes *all* sites vulnerable. That places the bar much higher. This specification dramatically upgrades the consequences of any site under a CA that pre-signs OCSP responses.",
              "createdAt": "2018-02-16T19:52:14Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 88,
              "body": "Not sure what \"yet\" means in this context. Going from opt-in X.509 extension to this weaker OCSP trick is a meaningful direction, but we can't switch from this weaker option to an X.509 extension because the mere existence of the other option is what introduces the vulnerability.\r\n\r\n(Or did you mean this as more a TODO-like comment rather than final specification text?)",
              "createdAt": "2018-02-16T19:53:32Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 43,
              "body": "s/can/SHOULD/ maybe? It seems, in general, that `certUrl`s should change whenever their contents change, otherwise old signed extensions would fail to validate.",
              "createdAt": "2018-02-16T19:55:46Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 23,
              "body": "I don't see `parsed-chain` used anywhere here, or am I missing something?",
              "createdAt": "2018-02-16T19:56:48Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTczMjMyMTU=",
          "commit": {
            "abbreviatedOid": "bf6158e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I've fixed your comments, but this whole change might get superseded by another PR to use an X.509 certificate extension instead.",
          "createdAt": "2018-02-16T21:34:20Z",
          "updatedAt": "2018-02-17T00:32:17Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Nope, I failed to use it. I've switched to the variable names from #122, although this is also going to interact with that refactoring..",
              "createdAt": "2018-02-16T21:34:20Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 43,
              "body": "Sure.",
              "createdAt": "2018-02-16T21:35:41Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 73,
              "body": "I've now mentioned those too.",
              "createdAt": "2018-02-16T21:47:00Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 80,
              "body": "Is there a useful distinction between the CA pre-signing OCSP responses but keeping them internal, vs releasing those responses to the certificate owner?\r\n\r\nI may as well say MUST here until someone complains.",
              "createdAt": "2018-02-16T21:49:16Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            },
            {
              "originalPosition": 88,
              "body": "It's something like a TODO, yeah. I've changed it.",
              "createdAt": "2018-02-17T00:30:47Z",
              "updatedAt": "2018-02-28T23:28:31Z"
            }
          ]
        }
      ]
    },
    {
      "number": 122,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4MzUyNTU0",
      "title": "Avoid the TLS 1.3 Certificate message.",
      "url": "https://github.com/WICG/webpackage/pull/122",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Use a custom CBOR certificate chain format instead.\r\n\r\nAlso register this format with IANA.\r\n\r\n@sleevi, better?\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/avoid-tls-messages/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/avoid-tls-messages/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-02-09T22:00:44Z",
      "updatedAt": "2018-03-02T18:24:14Z",
      "closedAt": "2018-02-28T23:16:46Z",
      "mergedAt": "2018-02-28T23:16:46Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@davidben should also look at this.\r\n\r\nDavid: The concern was that at present, no TLS library exposes its Certificate parsing or generating functions (Modulo Boring\u2019s CBS), and that, more generally speaking, the TLS libraries are maintained at separate cadences and release structures than UAs.\r\n\r\nThere\u2019s also the separable concern about semantics of or to the TLS layer and their interaction with Web Packaging, and thus the suggestion to make it an explicit format.",
          "createdAt": "2018-02-09T22:05:55Z",
          "updatedAt": "2018-02-09T22:05:55Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Haven't looked closely at the PR text yet, but I agree avoiding the TLS message makes sense. That was one of the comments I had in my queue. :-) Even with BoringSSL's `CBS` stuff, we don't expose the message itself, just the low-level length-prefix bits.\r\n\r\nYou needed different parsing rules from TLS anyway. TLS doesn't allow unsolicited extensions, so you actually reject, not ignore, unknown extensions. (SCTs, OCSP stapling, etc., are advertised in ClientHello or CertificateRequest, so the other side knows whether to include them.) Your signing rules are also slightly different, with the `certSha256` stuff.",
          "createdAt": "2018-02-09T23:22:01Z",
          "updatedAt": "2018-02-09T23:22:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTU1Nzg4OTQ=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-09T22:11:32Z",
          "updatedAt": "2018-02-09T22:13:18Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Is this right, or should it only be the leaf certificate that holds an SCT?",
              "createdAt": "2018-02-09T22:11:32Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            },
            {
              "originalPosition": 15,
              "body": "Oh, also, this is a simplification of the `status_request` TLS extension that omits the layer containing a `CertificateStatusType`. Is that the right choice?",
              "createdAt": "2018-02-09T22:12:48Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            },
            {
              "originalPosition": 16,
              "body": "A `SignedCertificateTimestampList` appears to be a serialized TLS message, but I guess because other systems have to generate this, it's ok?",
              "createdAt": "2018-02-09T22:13:15Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMDY0MDk=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T21:27:56Z",
          "updatedAt": "2018-02-13T21:27:56Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "Under RFC 6962, only the leaf has (additional) SCTs provided by the TLS extension\r\n\r\nUnder 6962-bis, this can change, but there are no implementations of 6962-bis (nor announced) that I know of.",
              "createdAt": "2018-02-13T21:27:56Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMDc1MzM=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T21:31:21Z",
          "updatedAt": "2018-02-13T21:31:21Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I believe so, at least as we discussed. This might be an area of future change.\r\n\r\nThe practical reality is that OCSP multi-stapling is rather inefficient for the browser case, given that \"Every Modern Browser\" (tm) effectively has an out-of-bands mechanism for dealing with intermediate revocation, treating it akin to root revocation, as well as heavily caching intermediate results (e.g. in the case of macOS, via an out-of-band datafile containing the revocation status of all intermediates, in the case of Windows, through background-fetching CRLs that cover CAs)\r\n\r\nFrom a PKI pursist standpoint, however, you could try and argue that such systems don't handle nested sets of name-constrained subordinate CAs, and for those cases (and, effectively, those cases alone), it makes sense to allow OCSP responses for intermediates to be stapled.",
              "createdAt": "2018-02-13T21:31:21Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMDc2Nzc=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T21:31:47Z",
          "updatedAt": "2018-02-13T21:31:47Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Right, this is passed as (effectively) opaque input, much like the OCSP response, into the certificate validation system, which contains a minimal subset of the TLS decoder for this case.",
              "createdAt": "2018-02-13T21:31:47Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMjIzMTQ=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T22:18:52Z",
          "updatedAt": "2018-02-13T22:18:52Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "I've changed it to just the leaf certificate. Thanks.",
              "createdAt": "2018-02-13T22:18:52Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTYzMjI3NDY=",
          "commit": {
            "abbreviatedOid": "1a3abfd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-13T22:20:16Z",
          "updatedAt": "2018-02-13T22:20:16Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I'm going to omit the \"nested sets of name-constrained subordinate CAs\" case from this draft, and if someone tells me to add it, I'm going to make them write the wording that distinguishes certificates that need OCSPs from ones that don't.",
              "createdAt": "2018-02-13T22:20:16Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0MjA1MzQ=",
          "commit": {
            "abbreviatedOid": "308c428"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-22T01:15:13Z",
          "updatedAt": "2018-02-22T01:19:50Z",
          "comments": [
            {
              "originalPosition": 112,
              "body": "Nit: There can be more than one valid signature for a given public key and message. I would say perhaps:\r\n\r\nIf `signature` is a valid signature of `message` by `publicKey` using `signing-alg` [...]",
              "createdAt": "2018-02-22T01:15:13Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            },
            {
              "originalPosition": 32,
              "body": "Re \"subsequent certificates\", I suspect this may end up being a bit controversial since the TLSWG intentionally went the other way with TLS 1.3 and made it easy to encode OCSP staples on intermediates. But I'll leave that for @sleevi and others to wrestle out later. :-)\r\n\r\n(In our TLS 1.3 implementation, we tolerate metadata on intermediates but ignore them for now. We'll start processing them if we have something useful to do with them.)",
              "createdAt": "2018-02-22T01:18:43Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            },
            {
              "originalPosition": 197,
              "body": "(Also the TLS 1.3 message has different parsing rules than what you want anyway.)",
              "createdAt": "2018-02-22T01:19:29Z",
              "updatedAt": "2018-02-28T23:13:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwMjY2NDE5",
          "commit": {
            "abbreviatedOid": "308c428"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-02-28T23:12:20Z",
          "updatedAt": "2018-03-02T18:24:14Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I'll look forward to when folks are objecting to this kind of detail.",
              "createdAt": "2018-02-28T23:12:20Z",
              "updatedAt": "2018-03-02T18:24:14Z"
            },
            {
              "originalPosition": 112,
              "body": "Thanks, fixed.",
              "createdAt": "2018-02-28T23:12:29Z",
              "updatedAt": "2018-03-02T18:24:14Z"
            },
            {
              "originalPosition": 197,
              "body": "Noted.",
              "createdAt": "2018-02-28T23:12:36Z",
              "updatedAt": "2018-03-02T18:24:14Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e0bf287561d5ffe8ea795809548827a30ce9aad0",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "avoid-tls-messages",
      "headRefOid": "18fe7e951e4c78f800575131e4a1fa984c1893a8",
      "mergeCommit": {
        "oid": "3af6b2f8074957d951c0465affe66b65ee81a596"
      }
    },
    {
      "number": 123,
      "id": "MDExOlB1bGxSZXF1ZXN0MTY4NTgwNjE3",
      "title": "Add a use-case for subresource bundling",
      "url": "https://github.com/WICG/webpackage/pull/123",
      "state": "MERGED",
      "author": "yoavweiss",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Closes https://github.com/WICG/webpackage/issues/101",
      "createdAt": "2018-02-12T13:38:49Z",
      "updatedAt": "2018-02-13T06:06:33Z",
      "closedAt": "2018-02-13T06:06:33Z",
      "mergedAt": "2018-02-13T06:06:33Z",
      "mergedBy": "yoavweiss",
      "comments": [
        {
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "body": "Your update LGTM",
          "createdAt": "2018-02-13T06:06:11Z",
          "updatedAt": "2018-02-13T06:06:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTU4NjcxMTI=",
          "commit": {
            "abbreviatedOid": "cd7afc4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I've pushed an update to your text. Let me know if I've said anything wrong, and then we can merge it.",
          "createdAt": "2018-02-12T17:06:44Z",
          "updatedAt": "2018-02-12T17:06:44Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6154680cc2f2d5118f0ec92fdbd86fc30427a29b",
      "headRepository": "yoavweiss/webpackage",
      "headRefName": "master",
      "headRefOid": "1b036a65168f9775778e02d348d73c4eadca5720",
      "mergeCommit": {
        "oid": "3f679f937814fa21770012cf9b8937ee4b51c199"
      }
    },
    {
      "number": 125,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcwNDA1MDQ3",
      "title": "signedexchange: Add flags 'requestHeader' and 'responseHeader'",
      "url": "https://github.com/WICG/webpackage/pull/125",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#124 \r\n\r\nThis is WIP: I have no idea how to treat the passed request headers.",
      "createdAt": "2018-02-21T08:38:28Z",
      "updatedAt": "2018-02-27T07:37:16Z",
      "closedAt": "2018-02-26T04:18:26Z",
      "mergedAt": "2018-02-26T04:18:26Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Right now, the spec says not to sign request headers, which would imply that the tool shouldn't actually take a `--requestHeader` argument. If we want to sign request headers (which is plausible, especially inside `application/http-exchange+cbor` objects instead of plain HTTP responses), I think the natural thing is to include them in the map created by `encodeRequest()`.",
          "createdAt": "2018-02-21T18:27:14Z",
          "updatedAt": "2018-02-21T18:27:14Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "> I think the natural thing is to include them in the map created by encodeRequest().\r\n\r\nThank you, done.",
          "createdAt": "2018-02-22T06:48:13Z",
          "updatedAt": "2018-02-22T06:48:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0NjI1NDY=",
          "commit": {
            "abbreviatedOid": "e44a80d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-02-22T06:56:37Z",
          "updatedAt": "2018-02-22T06:57:04Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "encodeRequest from L172 should include requestHeaders, while L149 should not",
              "createdAt": "2018-02-22T06:56:37Z",
              "updatedAt": "2018-02-22T07:35:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0NjM0MDc=",
          "commit": {
            "abbreviatedOid": "e44a80d"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you!",
          "createdAt": "2018-02-22T07:02:34Z",
          "updatedAt": "2018-02-22T07:02:39Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Done.",
              "createdAt": "2018-02-22T07:02:34Z",
              "updatedAt": "2018-02-22T07:35:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTkxODE5MzM=",
          "commit": {
            "abbreviatedOid": "164698e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-26T04:18:18Z",
          "updatedAt": "2018-02-26T04:18:18Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7e839644d00cb5094d7ce8bd71e016dfa57745f5",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "headers",
      "headRefOid": "164698e56ed66c442790f2ceb0c5a6ce411baf07",
      "mergeCommit": {
        "oid": "e52c1503cca67e5fdc80ebbf24a27936117d7dac"
      }
    },
    {
      "number": 126,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcwNjY2NjU5",
      "title": "signedexchange: Update tests",
      "url": "https://github.com/WICG/webpackage/pull/126",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The test results was changed at https://github.com/WICG/webpackage/commit/d989c1be0e6e717476f4291cea2edd2adbd867ac and this PR updates the test results.",
      "createdAt": "2018-02-22T06:25:15Z",
      "updatedAt": "2018-02-22T06:40:20Z",
      "closedAt": "2018-02-22T06:34:58Z",
      "mergedAt": "2018-02-22T06:34:58Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nyaxt PTAL",
          "createdAt": "2018-02-22T06:30:10Z",
          "updatedAt": "2018-02-22T06:30:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTg0NTk2NjA=",
          "commit": {
            "abbreviatedOid": "a30ef3b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-22T06:34:52Z",
          "updatedAt": "2018-02-22T06:34:52Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "8ac75415e5d82a110ecf659abf267e3c1e0e35ba",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "test",
      "headRefOid": "a30ef3bc48a42721c5a8ad22bac1c9ef10571df9",
      "mergeCommit": {
        "oid": "7e839644d00cb5094d7ce8bd71e016dfa57745f5"
      }
    },
    {
      "number": 127,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcwNjc2NjYz",
      "title": "signedexchange: Sort signed-headers value to make tests deterministic",
      "url": "https://github.com/WICG/webpackage/pull/127",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PTAL @nyaxt ",
      "createdAt": "2018-02-22T07:41:08Z",
      "updatedAt": "2018-02-27T07:36:59Z",
      "closedAt": "2018-02-26T04:19:18Z",
      "mergedAt": "2018-02-26T04:19:18Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3OTkxODIwMDY=",
          "commit": {
            "abbreviatedOid": "4929ec0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-02-26T04:19:13Z",
          "updatedAt": "2018-02-26T04:19:13Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7e839644d00cb5094d7ce8bd71e016dfa57745f5",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "signed-headers-order",
      "headRefOid": "4929ec0698ff14712fc5478734eddd13babf0b1c",
      "mergeCommit": {
        "oid": "61a634209db2d513ff6c3545c51c3c4946f0502d"
      }
    },
    {
      "number": 130,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcxNTk1ODM2",
      "title": "signedexchange: Follow the new (tantative) format",
      "url": "https://github.com/WICG/webpackage/pull/130",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-02-27T08:44:05Z",
      "updatedAt": "2018-05-21T15:48:31Z",
      "closedAt": "2018-05-21T07:23:13Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to wait until the spec text is updated, but will merge this to nyaxt/webpackage.",
          "createdAt": "2018-03-01T17:37:32Z",
          "updatedAt": "2018-03-01T17:37:32Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Should I close this? ",
          "createdAt": "2018-03-12T09:44:29Z",
          "updatedAt": "2018-03-12T09:44:29Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "not yet.",
          "createdAt": "2018-03-12T10:15:05Z",
          "updatedAt": "2018-03-12T10:15:05Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this now, since this is no longer the latest format",
          "createdAt": "2018-05-21T07:23:13Z",
          "updatedAt": "2018-05-21T07:23:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNTIzNjE2",
          "commit": {
            "abbreviatedOid": "5a83fa7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-01T17:36:04Z",
          "updatedAt": "2018-03-01T17:37:04Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "This comment is obsolete. Remove the line",
              "createdAt": "2018-03-01T17:36:04Z",
              "updatedAt": "2018-03-02T06:07:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAwNjgyNzUx",
          "commit": {
            "abbreviatedOid": "5a83fa7"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-02T06:07:55Z",
          "updatedAt": "2018-03-02T06:07:55Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done.",
              "createdAt": "2018-03-02T06:07:55Z",
              "updatedAt": "2018-03-02T06:07:56Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "61a634209db2d513ff6c3545c51c3c4946f0502d",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "newformat",
      "headRefOid": "8dc591cfc090adf91896d2df6cd2350df918a8e6",
      "mergeCommit": null
    },
    {
      "number": 131,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyMDYwODI0",
      "title": "Rewrite the explainer, and update the use-cases document.",
      "url": "https://github.com/WICG/webpackage/pull/131",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@KenjiBaheux @thinkpanzer, is this clear as an entry-point to the packaging specs? Have I missed anything folks will want to see?",
      "createdAt": "2018-02-28T20:16:24Z",
      "updatedAt": "2018-03-02T01:14:35Z",
      "closedAt": "2018-03-02T01:14:31Z",
      "mergedAt": "2018-03-02T01:14:31Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "61a634209db2d513ff6c3545c51c3c4946f0502d",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "explainer",
      "headRefOid": "04596cfd90e1ab2ddcf062a30c895d61a675e733",
      "mergeCommit": {
        "oid": "4791a993c8e226d5f011c2e1a9b097e7f512971c"
      }
    },
    {
      "number": 132,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyNjE4OTU0",
      "title": "Remove allResponseHeaders; handle signed request headers.",
      "url": "https://github.com/WICG/webpackage/pull/132",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@davidben, you'll probably like this one. It refactors the rules for trusting cross-origin exchanges so that they can be shared by Push and the application/http-exchange format. This let me cover all headers from those two transfer methods unconditionally, with only same-origin exchanges able to use `Signed-Headers` to select a subset.\r\n\r\nThere's a bunch of text motion, but sections id'ed `signed-headers` and `significant-headers` are basically unchanged in their new locations, and `authority-chain-validation` became the algorithm in `cross-origin-trust`.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/unify-cross-origin/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/unify-cross-origin/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-03-02T22:20:23Z",
      "updatedAt": "2018-03-05T20:37:42Z",
      "closedAt": "2018-03-05T20:37:39Z",
      "mergedAt": "2018-03-05T20:37:39Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAxMjg3NTY3",
          "commit": {
            "abbreviatedOid": "feb016a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-05T19:07:48Z",
          "updatedAt": "2018-03-05T19:09:10Z",
          "comments": [
            {
              "originalPosition": 326,
              "body": "@nyaxt pointed out that this needs to exclude the `Signature` header from the exchange passed to {{cross-origin-trust}} (since you can't cover a signature with itself), so I'm working on that.",
              "createdAt": "2018-03-05T19:07:48Z",
              "updatedAt": "2018-03-05T19:30:24Z"
            },
            {
              "originalPosition": 400,
              "body": "I'm excluding the `Signature` header from this too.",
              "createdAt": "2018-03-05T19:08:16Z",
              "updatedAt": "2018-03-05T19:30:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAxMjk1NjQ2",
          "commit": {
            "abbreviatedOid": "feb016a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-05T19:30:36Z",
          "updatedAt": "2018-03-05T19:30:37Z",
          "comments": [
            {
              "originalPosition": 326,
              "body": "Ok, fixed, I think.",
              "createdAt": "2018-03-05T19:30:37Z",
              "updatedAt": "2018-03-05T19:30:37Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4791a993c8e226d5f011c2e1a9b097e7f512971c",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "unify-cross-origin",
      "headRefOid": "8e16f135e1cbd4b691eb140971656a56fe714e50",
      "mergeCommit": {
        "oid": "3cae5496a86cafde2ab59f95bb62d6d47202445b"
      }
    },
    {
      "number": 133,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyNjI2MjU4",
      "title": "Mitigate publishers that accidentally sign private information",
      "url": "https://github.com/WICG/webpackage/pull/133",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This builds on #132, so probably review that one first.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/block-set-cookie/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/block-set-cookie/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@davidben",
      "createdAt": "2018-03-02T23:04:31Z",
      "updatedAt": "2018-03-05T20:45:11Z",
      "closedAt": "2018-03-05T20:45:01Z",
      "mergedAt": "2018-03-05T20:45:01Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3cae5496a86cafde2ab59f95bb62d6d47202445b",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "block-set-cookie",
      "headRefOid": "485d1a4a52450b4d4c8bbab10471456d0544413a",
      "mergeCommit": {
        "oid": "bda40d143d1162d3cb4b0374feb0b9ca6802eda0"
      }
    },
    {
      "number": 134,
      "id": "MDExOlB1bGxSZXF1ZXN0MTcyNjM3ODEw",
      "title": "Require a new certificate extension for packages",
      "url": "https://github.com/WICG/webpackage/pull/134",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This builds on #132, so probably review that one first.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/cert-extension/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/cert-extension/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@davidben @sleevi",
      "createdAt": "2018-03-03T00:43:08Z",
      "updatedAt": "2018-03-05T20:58:02Z",
      "closedAt": "2018-03-05T20:57:51Z",
      "mergedAt": "2018-03-05T20:57:51Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAxMzIzNjQx",
          "commit": {
            "abbreviatedOid": "1cbb6b1"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I'm going to merge this so I can make the IETF deadline, but I'm still happy to fix comments.",
          "createdAt": "2018-03-05T20:55:22Z",
          "updatedAt": "2018-03-05T20:56:13Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Note that because these certificates can't be used for TLS servers anymore, I'm diverging from the TLS format. IIUC, the initial 64 spaces are only needed in TLS because the attacker controls the initial content of the message, but since the attacker doesn't control that for packages, it doesn't seem to be needed here. I've added an open question to check that my guess is right.",
              "createdAt": "2018-03-05T20:55:22Z",
              "updatedAt": "2018-03-05T20:56:13Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "bda40d143d1162d3cb4b0374feb0b9ca6802eda0",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "cert-extension",
      "headRefOid": "1cbb6b1f60539fcd3f5e4cc4f225f1125db0ff04",
      "mergeCommit": {
        "oid": "0bb1e6d1c435e23698d0246d780e0fd753d511e4"
      }
    },
    {
      "number": 136,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczMDA3NDM1",
      "title": "Update use cases",
      "url": "https://github.com/WICG/webpackage/pull/136",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/update-use-cases/draft-yasskin-webpackage-use-cases.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.txt&url2=https://jyasskin.github.io/webpackage/update-use-cases/draft-yasskin-webpackage-use-cases.txt)\r\n\r\nI'm probably going to merge this without review to get it in time for the IETF deadline, but I'll definitely fix any comments that show up after that.",
      "createdAt": "2018-03-05T22:37:52Z",
      "updatedAt": "2018-03-05T23:48:47Z",
      "closedAt": "2018-03-05T23:27:19Z",
      "mergedAt": "2018-03-05T23:27:19Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ff961321d3d3718d8c6c1ab1322e053d0670edf2",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-use-cases",
      "headRefOid": "a813b899dbd829a640e8c63795305646ba20834c",
      "mergeCommit": {
        "oid": "fa48435c0f9a2c9d5c79c8d34f00398fcf5f40b7"
      }
    },
    {
      "number": 137,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczMDExMzk0",
      "title": "Add an archival use case.",
      "url": "https://github.com/WICG/webpackage/pull/137",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/archival-use-case/draft-yasskin-webpackage-use-cases.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-webpackage-use-cases.txt&url2=https://jyasskin.github.io/webpackage/archival-use-case/draft-yasskin-webpackage-use-cases.txt)\r\n\r\n@ibnesayeed @craigfrancis @TzviyaSiegman, you've been interested in this topic in issues like #105. What should I write in this section? I don't know enough about the topic to even describe the use case well.\r\n\r\nI'm probably going to merge this without review to get it in time for the IETF deadline, but I'll definitely fix any comments that show up after that.",
      "createdAt": "2018-03-05T22:57:15Z",
      "updatedAt": "2018-03-06T20:57:42Z",
      "closedAt": "2018-03-05T23:28:11Z",
      "mergedAt": "2018-03-05T23:28:11Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "craigfrancis",
          "authorAssociation": "NONE",
          "body": "Thanks for adding these notes @jyasskin \r\n\r\nI'm not sure how much I can add at the moment, as you have noted that packages could be used for archival purposes (actual implementation will probably be for the browsers to decide), and the only other point I have is the suggestion/concerns about JavaScript basing the date/time off the timestamp of the package (which is already covered).",
          "createdAt": "2018-03-06T11:33:25Z",
          "updatedAt": "2018-03-06T11:33:25Z"
        },
        {
          "author": "ibnesayeed",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks @jyasskin for this. The language used seems a little too informal. That said, I think we need to invite more people from the web arching community to give their input on the archival aspect here or in #105. In case of WARC file-based replay, certificates of the archive host are used in TLS communication rather than the original ones. I am CCing @anjackson, @hvdsomp, @phonedude, @ikreymer, @galsondor, and @machawk1 here for any comments on it.",
          "createdAt": "2018-03-06T13:07:56Z",
          "updatedAt": "2018-03-06T13:07:56Z"
        },
        {
          "author": "jmulliken",
          "authorAssociation": "NONE",
          "body": "I have some limited experience creating WARCs. Without knowing too much about the back-end, I can add that this approach would work for many html/css/javascript publications. We are currently using it for amenable web-based publications at Stanford University Press. Here, for example, is a web archive of our latest web publication: https://webrecorder.io/sup/enchanting-the-desert I think you could generalize a use case from this, but the type of publication is not the typical kind this group has looked at so far. That said I would LOVE for it to become part of the conversation.",
          "createdAt": "2018-03-06T20:45:45Z",
          "updatedAt": "2018-03-06T20:45:45Z"
        },
        {
          "author": "BigBlueHat",
          "authorAssociation": "NONE",
          "body": "From a Web Publication WG perspective, we'll want Packaged Web Publications (PWP) to live well beyond the rental of a domain name or certificate. Reducing the contents to a sandbox-ed experience may be fine if the contents are primarily (or exclusively) descriptive (i.e. little to no JS involved).\r\n\r\nIdeally, one could still experience a PWP they'd downloaded (or purchased) even if the domain or cert expired just days prior. Essentially, we don't want a reader's experience of a publication dependent on a rent-based architecture.\r\n\r\nAnd huge \ud83d\udc4d to involving a wider audience (i.e. WARC and friends) in the development of this potentially very valuable addition to the Web platform.",
          "createdAt": "2018-03-06T20:57:42Z",
          "updatedAt": "2018-03-06T20:57:42Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ff961321d3d3718d8c6c1ab1322e053d0670edf2",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "archival-use-case",
      "headRefOid": "240b8fb73d20829b3f6e59e6d4b7f5b2a799a1e3",
      "mergeCommit": {
        "oid": "4876351e99b4c08fd42a131e83ad216f9f47344c"
      }
    },
    {
      "number": 139,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczNTM1NDIy",
      "title": "Start an implementation draft",
      "url": "https://github.com/WICG/webpackage/pull/139",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/implementation-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/implementation-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)\r\n\r\nThis shows the state we expect to synchronize on for May.",
      "createdAt": "2018-03-07T18:25:53Z",
      "updatedAt": "2018-03-18T04:41:50Z",
      "closedAt": "2018-03-18T04:41:46Z",
      "mergedAt": "2018-03-18T04:41:46Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for starting on this. Please ping me when it's ready for review.\r\n\r\n- Chrome currently implements the old TLS certURl format.\r\n- ECDSA not supported\r\n- new envelope format",
          "createdAt": "2018-03-07T21:12:23Z",
          "updatedAt": "2018-03-07T21:12:23Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@twifkak",
          "createdAt": "2018-03-07T22:32:38Z",
          "updatedAt": "2018-03-07T22:32:38Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ok, I think this is ready to review.",
          "createdAt": "2018-03-08T23:03:31Z",
          "updatedAt": "2018-03-08T23:03:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAyOTIyOTQw",
          "commit": {
            "abbreviatedOid": "9fbef88"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-12T04:47:09Z",
          "updatedAt": "2018-03-12T04:55:07Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "Somehow this formatting is broken on the preview HTML version",
              "createdAt": "2018-03-12T04:47:09Z",
              "updatedAt": "2018-03-17T08:23:27Z"
            },
            {
              "originalPosition": 504,
              "body": "Chrome snapshot only allows 1 signature",
              "createdAt": "2018-03-12T04:50:04Z",
              "updatedAt": "2018-03-17T08:23:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NzYwNTM4",
          "commit": {
            "abbreviatedOid": "9fbef88"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-17T08:35:37Z",
          "updatedAt": "2018-03-17T08:35:37Z",
          "comments": [
            {
              "originalPosition": 504,
              "body": "Whoops, thanks for catching that.",
              "createdAt": "2018-03-17T08:35:37Z",
              "updatedAt": "2018-03-17T08:35:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NzYwNTQx",
          "commit": {
            "abbreviatedOid": "9fbef88"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-17T08:35:51Z",
          "updatedAt": "2018-03-17T08:35:51Z",
          "comments": [
            {
              "originalPosition": 289,
              "body": "Fixed. The parser expects a blank line before lists.",
              "createdAt": "2018-03-17T08:35:51Z",
              "updatedAt": "2018-03-17T08:35:51Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "648a9007f28a7600048cfa0fcbaf93fdec8f7c94",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "implementation-draft",
      "headRefOid": "20fc775a0c0eecfdd1f1151ba5be34275899201f",
      "mergeCommit": {
        "oid": "370a67e8ddf31fe6d1179012d12b7d1e2eb97c95"
      }
    },
    {
      "number": 140,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczNTM2ODQ0",
      "title": "gen-signedexchange: Remove 32 spaces from signed message",
      "url": "https://github.com/WICG/webpackage/pull/140",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-07T18:31:50Z",
      "updatedAt": "2018-03-12T06:28:22Z",
      "closedAt": "2018-03-12T06:28:22Z",
      "mergedAt": "2018-03-12T06:28:22Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAyNTQ3MTIx",
          "commit": {
            "abbreviatedOid": "07f3c27"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-03-09T05:20:27Z",
          "updatedAt": "2018-03-09T05:20:27Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4876351e99b4c08fd42a131e83ad216f9f47344c",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "nozero",
      "headRefOid": "07f3c2754410afe5da3a17abd215f60d27226d0a",
      "mergeCommit": {
        "oid": "17318a97b095e7ed12e6bfaf3a626348d2a64635"
      }
    },
    {
      "number": 143,
      "id": "MDExOlB1bGxSZXF1ZXN0MTczODM2ODYw",
      "title": "gen-se: Remove \"Signed-Headers\" header",
      "url": "https://github.com/WICG/webpackage/pull/143",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "Updates gen-signedexchange to match spec text changes in 3cae5496a86cafde2ab59f95bb62d6d47202445b",
      "createdAt": "2018-03-08T20:06:30Z",
      "updatedAt": "2018-03-12T06:59:00Z",
      "closedAt": "2018-03-12T06:59:00Z",
      "mergedAt": "2018-03-12T06:59:00Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm",
          "createdAt": "2018-03-09T05:19:34Z",
          "updatedAt": "2018-03-09T05:19:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAyNTQ3MDQ3",
          "commit": {
            "abbreviatedOid": "9e9ded2"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-09T05:19:45Z",
          "updatedAt": "2018-03-09T05:19:45Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "17318a97b095e7ed12e6bfaf3a626348d2a64635",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "rmSignedHeader",
      "headRefOid": "f4586e8c676c4fbad0f0efa8ddf660a02299f99c",
      "mergeCommit": {
        "oid": "5e767ecb9209a0df5a4f510c991a9a86a4a8eb12"
      }
    },
    {
      "number": 144,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc0MzExMjUx",
      "title": "gen-signedexchange: Limit num of chunks when splitting headers by colon",
      "url": "https://github.com/WICG/webpackage/pull/144",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This fixes the bug that colons were not usable in request/response headers.\r\n",
      "createdAt": "2018-03-12T09:27:49Z",
      "updatedAt": "2018-03-12T10:52:08Z",
      "closedAt": "2018-03-12T10:38:25Z",
      "mergedAt": "2018-03-12T10:38:25Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAyOTgzMDY2",
          "commit": {
            "abbreviatedOid": "b163e6c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-12T10:15:38Z",
          "updatedAt": "2018-03-12T10:15:38Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5e767ecb9209a0df5a4f510c991a9a86a4a8eb12",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "colon",
      "headRefOid": "b163e6cf350d6e0c487efbf0d05da85c2b9d55b7",
      "mergeCommit": {
        "oid": "6400cbc3f5f82d9d3f950ac7e37b5948050a8f54"
      }
    },
    {
      "number": 145,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc0MzE1NDU5",
      "title": "signedexchange: Remove signed-header usages",
      "url": "https://github.com/WICG/webpackage/pull/145",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PTAL",
      "createdAt": "2018-03-12T09:46:02Z",
      "updatedAt": "2018-03-13T02:21:42Z",
      "closedAt": "2018-03-13T01:47:25Z",
      "mergedAt": "2018-03-13T01:47:25Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAzMjQ3MjQw",
          "commit": {
            "abbreviatedOid": "8f3d711"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-12T22:47:19Z",
          "updatedAt": "2018-03-12T22:47:19Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5e767ecb9209a0df5a4f510c991a9a86a4a8eb12",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "remove-signedheader-usages",
      "headRefOid": "8f3d7118bd6e558c104958c843c3893b36051587",
      "mergeCommit": {
        "oid": "8ea52d8685076de20b49c16c6b5fa853c3b445d1"
      }
    },
    {
      "number": 146,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc0NTY0Mjg3",
      "title": "gen-signedexchange: Add expire flag",
      "url": "https://github.com/WICG/webpackage/pull/146",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PTAL",
      "createdAt": "2018-03-13T05:52:58Z",
      "updatedAt": "2018-03-13T06:11:30Z",
      "closedAt": "2018-03-13T06:11:27Z",
      "mergedAt": "2018-03-13T06:11:27Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTAzMzA1MTk2",
          "commit": {
            "abbreviatedOid": "3049183"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-13T06:01:24Z",
          "updatedAt": "2018-03-13T06:01:24Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "8ea52d8685076de20b49c16c6b5fa853c3b445d1",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "expire-flag",
      "headRefOid": "30491839eda9e56af3864fda6d37b65ef8513ee1",
      "mergeCommit": {
        "oid": "084ec75cd40d56c9670281c55aaffbc0cf7deac6"
      }
    },
    {
      "number": 148,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1MTU0OTUz",
      "title": "Replace the application/http-exchange+cbor format with a simpler format.",
      "url": "https://github.com/WICG/webpackage/pull/148",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This format:\r\n* Doesn't require a streaming CBOR parser parse it from a network stream.\r\n* Doesn't allow request payloads or response trailers, which don't fit into\r\n  the signature model.\r\n* Allows checking the signature before parsing the exchange headers.\r\n\r\nThis is similar to, but not exactly the same as the format @davidben proposed for #139: it pulls out the `Signature` header into bytestring before the other headers so that the second map can be literally the bytes in the signed string. This isn't extensible if we ever want to add new non-signed values, so I added a format version number into the format's magic number.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/no-streaming/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/no-streaming/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nFixes #135.",
      "createdAt": "2018-03-15T05:53:41Z",
      "updatedAt": "2018-04-04T22:51:56Z",
      "closedAt": "2018-04-04T22:51:53Z",
      "mergedAt": "2018-04-04T22:51:52Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MDk5ODk3",
          "commit": {
            "abbreviatedOid": "1985843"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-03T20:13:55Z",
          "updatedAt": "2018-04-03T20:27:52Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Yay!",
              "createdAt": "2018-04-03T20:13:55Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 25,
              "body": "WDYT about putting the two lengths first? (I.e. swap this one and the one above.) One less state in your parsing state machine. (First you read a fixed 5 + 3 + 3 bytes, then you check lengths, then you read additional `sigLength + headerLength` bytes.)",
              "createdAt": "2018-04-03T20:15:10Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 38,
              "body": "Nit: Specifically the `Transfer-Encoding` header inside the header block has no effect, whereas the outer `Transfer-Encoding` header which transfers the overall `application/signed-exchange` blob does. Dunno if that's worth clarifying.",
              "createdAt": "2018-04-03T20:16:40Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 167,
              "body": "(I like the current mix, of course. :-) )",
              "createdAt": "2018-04-03T20:17:54Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 15,
              "body": "Does the receiver need to check this value?",
              "createdAt": "2018-04-03T20:20:05Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 20,
              "body": "I might suggest instead saying that draft impls not use the final MIME type instead/additionally. Consider if this format changes a bit. Probably someone will end up in a situation where they need to support two iterations at the same time. That means you first need to read enough to dispatch on the type (which isn't even fixed-width), then parse the rest out. Or you cleverly meld the state machines.\r\n\r\nWhereas, if it's in the content type, the HTTP stack has already given you the headers as one atomic thing, so you can go ahead and dispatch there.\r\n\r\nEdit: Ah, I see you've put the parameter in the MIME type registration. Maybe make it clearer here that that's going on?",
              "createdAt": "2018-04-03T20:21:10Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 212,
              "body": "That seems a lot of complexity to put on the receiver. Why not just define application/signed-exchange-v1, application/signed-exchange-v2, etc. You don't need to parse out all this complex versioning information. We use a lot more bytes but header compression is nice, and is this format really going to have to change that much?\r\n\r\nYou might be able to make this extensible by saying the headers block is allowed to have unknown keys that you just ignore. This is how TLS does a lot of things. Though then you need to be sure that extensions are all safe for unknowing receivers to ignore.",
              "createdAt": "2018-04-03T20:25:26Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MTA2Nzgw",
          "commit": {
            "abbreviatedOid": "1985843"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-03T20:35:08Z",
          "updatedAt": "2018-04-03T23:30:57Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I think the receiver can trust the mime type, and now I've said so. If they don't match, the signature will fail to validate.",
              "createdAt": "2018-04-03T20:35:08Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 20,
              "body": "I think the version identifier has to go in both because people will store these as files, and their servers need to be able to pick the right mime type. But yeah, I've now said the client needs to trust the mime type.",
              "createdAt": "2018-04-03T23:02:29Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 25,
              "body": "Sure.",
              "createdAt": "2018-04-03T23:02:37Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 38,
              "body": "Clarified.",
              "createdAt": "2018-04-03T23:05:31Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 212,
              "body": "Hopefully the format won't change much once it's an RFC, but it is going to change until then. I think I talked to @sleevi about whether to make the headers block (especially the non-signed block) extensible, and he liked making it really simple, hence 21692e13a3b505292fbb248883ba368c4a2f178c.\r\n\r\nI think I can remove ranges from the version numbers, since most likely a client will only support 2 versions at a time.",
              "createdAt": "2018-04-03T23:14:49Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTA3MjA4",
          "commit": {
            "abbreviatedOid": "b95e497"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-04T21:28:28Z",
          "updatedAt": "2018-04-04T21:31:15Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I would probably suggest checking it, rather than ignoring it, just to make sure folks get it right. https://tools.ietf.org/html/draft-thomson-postel-was-wrong-02 and stuff.",
              "createdAt": "2018-04-04T21:28:28Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            },
            {
              "originalPosition": 220,
              "body": "Nit: That then suggests that versions aren't digits but opaque strings, right?",
              "createdAt": "2018-04-04T21:29:30Z",
              "updatedAt": "2018-04-04T21:39:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTA5MjM4",
          "commit": {
            "abbreviatedOid": "b95e497"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks!",
          "createdAt": "2018-04-04T21:35:31Z",
          "updatedAt": "2018-04-04T21:40:15Z",
          "comments": [
            {
              "originalPosition": 220,
              "body": "Yep, I believe I included that change in b95e497dd2bfb780504220ccd4ebe85fe64baf56 (especially `v: A string denoting the version`), but if you see a word I missed, let me know.",
              "createdAt": "2018-04-04T21:35:31Z",
              "updatedAt": "2018-04-04T21:40:15Z"
            },
            {
              "originalPosition": 16,
              "body": "Done.",
              "createdAt": "2018-04-04T21:35:41Z",
              "updatedAt": "2018-04-04T21:40:15Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c986519564139f1fa7929c20d11b6a97ae6911fa",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "no-streaming",
      "headRefOid": "77875f4e9fb4a3a268ff136a96a89a220d213980",
      "mergeCommit": {
        "oid": "f4ca17d1377bed966fdba85c03adbd798cfb5a96"
      }
    },
    {
      "number": 150,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NDM1Njcy",
      "title": "gen-se: Allow override of content-type response header",
      "url": "https://github.com/WICG/webpackage/pull/150",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "Found by @irori",
      "createdAt": "2018-03-16T04:04:16Z",
      "updatedAt": "2018-03-20T00:24:05Z",
      "closedAt": "2018-03-20T00:23:22Z",
      "mergedAt": "2018-03-20T00:23:22Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "So the problem was that `Add` could be called multiple times for the same header `content-type`, which was problematic?",
          "createdAt": "2018-03-16T04:39:57Z",
          "updatedAt": "2018-03-16T04:39:57Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "`Add` can be called multiple times for the same header, but `encodeResponseHeaders` uses only the first one (`value[0]` here:\r\nhttps://github.com/WICG/webpackage/blob/master/go/signedexchange/signedexchange.go#L104)",
          "createdAt": "2018-03-16T05:03:29Z",
          "updatedAt": "2018-03-16T05:03:29Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm",
          "createdAt": "2018-03-16T05:11:21Z",
          "updatedAt": "2018-03-16T05:11:21Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> encodeResponseHeaders uses only the first one (value[0] here:\r\n\r\nThis sounds like an another bug.",
          "createdAt": "2018-03-16T05:12:24Z",
          "updatedAt": "2018-03-16T05:12:24Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@twifkak FYI, while this shouldn't affect \"library\" usage of gen-se.",
          "createdAt": "2018-03-20T00:24:05Z",
          "updatedAt": "2018-03-20T00:24:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NDU4NzQz",
          "commit": {
            "abbreviatedOid": "124de3c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-16T05:36:20Z",
          "updatedAt": "2018-03-16T05:36:20Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "084ec75cd40d56c9670281c55aaffbc0cf7deac6",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "allowOverride",
      "headRefOid": "124de3ca3634b6d36b813e6b6f7a702b9981993f",
      "mergeCommit": {
        "oid": "10ed2ac60b18817e1a6b60cc9f19efdfeb441707"
      }
    },
    {
      "number": 153,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NjE1NjYz",
      "title": "Talk about publishers rather than authors.",
      "url": "https://github.com/WICG/webpackage/pull/153",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is just an editorial change rather than a behavior change.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/publisher-author/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/publisher-author/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-03-16T18:41:42Z",
      "updatedAt": "2018-03-17T08:04:58Z",
      "closedAt": "2018-03-17T08:04:55Z",
      "mergedAt": "2018-03-17T08:04:55Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0NzM4NDA5",
          "commit": {
            "abbreviatedOid": "989c6fa"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-16T22:51:43Z",
          "updatedAt": "2018-03-16T22:51:43Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "084ec75cd40d56c9670281c55aaffbc0cf7deac6",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "publisher-author",
      "headRefOid": "989c6faad793b0619584412769afa0e2d97a3562",
      "mergeCommit": {
        "oid": "648a9007f28a7600048cfa0fcbaf93fdec8f7c94"
      }
    },
    {
      "number": 155,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1NzM1MDcw",
      "title": "Insulate against changes in later versions of draft-thomson-http-mice-02.",
      "url": "https://github.com/WICG/webpackage/pull/155",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/draft-mice/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/draft-mice/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-03-18T04:44:28Z",
      "updatedAt": "2018-04-10T23:22:01Z",
      "closedAt": "2018-04-10T23:21:58Z",
      "mergedAt": "2018-04-10T23:21:58Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think the change totally makes sense to go in `draft-yasskin-http-origin-signed-responses.md`, but I'd like to avoid changing the impl snapshot `draft-yasskin-httpbis-origin-signed-exchanges-impl.md` at this point if there is no security concern.\r\n\r\nChromium has already implemented the current `draft-yasskin-httpbis-origin-signed-exchanges-impl.md` under flag, so any further changes will confuse the users who are currently experimenting with the feature.",
          "createdAt": "2018-03-19T06:11:07Z",
          "updatedAt": "2018-03-19T06:11:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ok, now that https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-00 is published, this is updated and ready for the -01 implementation draft.\r\n\r\nAnd I should check with @martinthomson whether this is a sensible way to handle changes in his MI draft. I've added a -draft2 suffix to all of the identifiers.",
          "createdAt": "2018-04-06T18:11:28Z",
          "updatedAt": "2018-04-06T18:11:28Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "We kinda screwed up the drafts leading to RFC 8188 by not including a draft-version in the name that we used for deployments.  That's a hard thing to reverse.  If you are serious about changing the mechanism to handle empty bodies properly, then there is a risk that things will change.",
          "createdAt": "2018-04-09T02:10:38Z",
          "updatedAt": "2018-04-09T02:10:38Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm not sure I follow you. RFC 8188 and draft-thomson-http-mice-02 don't cover the same thing.",
          "createdAt": "2018-04-09T02:27:04Z",
          "updatedAt": "2018-04-09T02:27:04Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "In 8188 we made a few (minor) changes over time.  Each time, we had to deploy a new name.  Given that the chances of changes here are non-trivial, maybe prepare for those changes by adding a draft-number suffix.",
          "createdAt": "2018-04-09T04:13:30Z",
          "updatedAt": "2018-04-09T04:13:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'll take that as an endorsement of this change, where I'm adding a draft number suffix to the header and content type. Thanks!",
          "createdAt": "2018-04-09T15:58:50Z",
          "updatedAt": "2018-04-09T15:58:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwMzEwODk1",
          "commit": {
            "abbreviatedOid": "be67b99"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM for draft ver2",
          "createdAt": "2018-04-09T01:38:02Z",
          "updatedAt": "2018-04-09T01:38:02Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0e013a978e2f7e1e112cd1dec297a26b3774f42b",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "draft-mice",
      "headRefOid": "be67b991c0230fbcb0936b38ded567d047ca5b41",
      "mergeCommit": {
        "oid": "09a77803e20fb87613ea186abf468caea79b09b7"
      }
    },
    {
      "number": 157,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc1ODYwMjU1",
      "title": "gen-signedexchange: Encode multiple values for the same header",
      "url": "https://github.com/WICG/webpackage/pull/157",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #151\r\n\r\nCC @twifkak \r\n\r\nPTAL",
      "createdAt": "2018-03-19T10:39:19Z",
      "updatedAt": "2018-03-20T06:55:25Z",
      "closedAt": "2018-03-19T12:16:01Z",
      "mergedAt": "2018-03-19T12:16:01Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "cherry-picked into nyaxt/master",
          "createdAt": "2018-03-20T00:43:24Z",
          "updatedAt": "2018-03-20T00:43:24Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that https://tools.ietf.org/html/rfc7230#section-3.2.2 calls out an exception for Set-Cookie. Obviously, Set-Cookie shouldn't appear in web packages, but I'm wondering if we can avoid the potential for semantic change (e.g. in any other non-standard headers) by instead looping over `value` and emitting several key/value pairs.",
          "createdAt": "2018-03-20T05:50:54Z",
          "updatedAt": "2018-03-20T05:50:54Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "@twifkak Good point. I feel like we should eliminate `Set-Cookie` explicitly. Did you mean we should have a kind of whitelist for standard headers?",
          "createdAt": "2018-03-20T06:21:44Z",
          "updatedAt": "2018-03-20T06:21:44Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry! My comment was based on a mistaken understanding of CBOR. I see now that it supports only one value per key. In that case, we should probably eliminate `Set-Cookie` here, or return an error if more than one `Set-Cookie` is present.\r\n\r\nFWIW, my packager tool currently strips all response headers in this list: https://jyasskin.github.io/webpackage/implementation-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#stateful-headers\r\n\r\nThis could be a useful thing to do at the library level, too, or you may want to keep it generic (e.g. allow users to generate stateful htxg's for testing). Both options seem reasonable to me.",
          "createdAt": "2018-03-20T06:52:39Z",
          "updatedAt": "2018-03-20T06:52:39Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, I think stripping the stateful header fields should be done on the library side. I'll create an issue for this and PR soon.",
          "createdAt": "2018-03-20T06:55:25Z",
          "updatedAt": "2018-03-20T06:55:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA0OTI5NTM0",
          "commit": {
            "abbreviatedOid": "3c8bef0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-19T11:49:10Z",
          "updatedAt": "2018-03-19T11:49:10Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "370a67e8ddf31fe6d1179012d12b7d1e2eb97c95",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "issue-151-multipleheader",
      "headRefOid": "3c8bef0b38144f332c92677a2679ff855cf5fc95",
      "mergeCommit": {
        "oid": "c3d7bd1615975432ab32b756dd87391e15738fc3"
      }
    },
    {
      "number": 158,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc2MDkzMDg4",
      "title": "gofmt -s -w",
      "url": "https://github.com/WICG/webpackage/pull/158",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-20T05:33:57Z",
      "updatedAt": "2018-04-11T01:00:34Z",
      "closedAt": "2018-04-11T01:00:34Z",
      "mergedAt": "2018-04-11T01:00:34Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "ping?",
          "createdAt": "2018-04-10T08:34:50Z",
          "updatedAt": "2018-04-10T08:34:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwOTA1Mzc1",
          "commit": {
            "abbreviatedOid": "9009da7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-10T16:06:13Z",
          "updatedAt": "2018-04-10T16:06:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMDU5MjE0",
          "commit": {
            "abbreviatedOid": "9009da7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-11T01:00:24Z",
          "updatedAt": "2018-04-11T01:00:24Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "10ed2ac60b18817e1a6b60cc9f19efdfeb441707",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "gofmt",
      "headRefOid": "9009da7d89cf63b022b8ef9cfea0de0d1e75dcd5",
      "mergeCommit": {
        "oid": "e3f928e822649adec5c7df456ce66b9b8a0e1442"
      }
    },
    {
      "number": 159,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc2MDk1NjQ2",
      "title": "cmd/gen-signedexchange: Add date flag",
      "url": "https://github.com/WICG/webpackage/pull/159",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#152 \r\n\r\nPTAL",
      "createdAt": "2018-03-20T05:57:17Z",
      "updatedAt": "2018-03-23T00:23:59Z",
      "closedAt": "2018-03-20T07:00:27Z",
      "mergedAt": "2018-03-20T07:00:27Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @hajimehoshi!\r\n\r\n@nyaxt would you cherry-pick this into nyaxt/master?",
          "createdAt": "2018-03-22T04:59:32Z",
          "updatedAt": "2018-03-22T04:59:32Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Done: https://github.com/nyaxt/webpackage/commit/8c727969402bce9f4bd86b1c530696a72aea0384",
          "createdAt": "2018-03-23T00:23:59Z",
          "updatedAt": "2018-03-23T00:23:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA1MjI4Nzk1",
          "commit": {
            "abbreviatedOid": "899f414"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-20T06:23:44Z",
          "updatedAt": "2018-03-20T06:23:44Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "10ed2ac60b18817e1a6b60cc9f19efdfeb441707",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "issue-152-date",
      "headRefOid": "899f414d427be9b267eed58ee954c7dd33b96108",
      "mergeCommit": {
        "oid": "11212299b4b34859f08e78dcbee4f790646555e7"
      }
    },
    {
      "number": 162,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc2MTA5NDMy",
      "title": "gen-signedexchange: Error with stateful request/response header fields",
      "url": "https://github.com/WICG/webpackage/pull/162",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "#160 \r\n\r\nPTAL",
      "createdAt": "2018-03-20T07:38:42Z",
      "updatedAt": "2018-03-26T05:59:02Z",
      "closedAt": "2018-03-26T05:59:02Z",
      "mergedAt": "2018-03-26T05:59:02Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Should these rather error out than ignore? (No need to take my comment authoritative / you can wait for nyaxt's response)",
          "createdAt": "2018-03-20T07:51:06Z",
          "updatedAt": "2018-03-20T07:51:06Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "First I thought that, but now I am not sure since gen-singnedexchange would not accept any response header including stateful headers, and this would not be useful. I'm fine with either.",
          "createdAt": "2018-03-20T08:00:25Z",
          "updatedAt": "2018-03-20T08:00:25Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Commented on #160, but +1 on kinu. This should be an error",
          "createdAt": "2018-03-20T08:11:09Z",
          "updatedAt": "2018-03-20T08:11:09Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Done.",
          "createdAt": "2018-03-22T06:12:49Z",
          "updatedAt": "2018-03-22T06:12:49Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "@nyaxt Are you happy with this PR? Thanks!",
          "createdAt": "2018-03-22T12:20:32Z",
          "updatedAt": "2018-03-22T12:20:32Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "ping @nyaxt ",
          "createdAt": "2018-03-26T05:42:20Z",
          "updatedAt": "2018-03-26T05:42:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA1OTk3MzYy",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-22T06:18:59Z",
          "updatedAt": "2018-03-22T06:18:59Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Consider exporting these two sets. I'd like to offer packager users the option to remove these headers rather than error, as I imagine some web servers probably Set-Cookie automatically. (Let me know if you think that's a bad idea.)",
              "createdAt": "2018-03-22T06:18:59Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA1OTk3NTMx",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sorry for the delay!",
          "createdAt": "2018-03-22T06:20:22Z",
          "updatedAt": "2018-03-22T06:20:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2MDAzMTgz",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-22T06:59:11Z",
          "updatedAt": "2018-03-22T06:59:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Good point. I'd add a new API to strip (probably in another PR). I'd like to keep `NewExchange` as it is. gen-signedexchange users would be able to choose to strip such headers by specifying flag. Does this make sense to you?",
              "createdAt": "2018-03-22T06:59:11Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2MDk0NjY0",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-03-22T12:27:01Z",
          "updatedAt": "2018-03-22T12:27:30Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "stateful response header %q can't be captured inside signed exchange",
              "createdAt": "2018-03-22T12:27:01Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            },
            {
              "originalPosition": 30,
              "body": "stateful request header %q can't be captured inside signed exchange\r\n\r\n",
              "createdAt": "2018-03-22T12:27:24Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2MTg1OTMw",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-22T16:00:13Z",
          "updatedAt": "2018-03-22T16:00:13Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Yep, that works for me.",
              "createdAt": "2018-03-22T16:00:13Z",
              "updatedAt": "2018-03-23T05:12:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2MzgwMTQ5",
          "commit": {
            "abbreviatedOid": "7bf786b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-23T05:12:59Z",
          "updatedAt": "2018-03-23T05:13:06Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Done.",
              "createdAt": "2018-03-23T05:12:59Z",
              "updatedAt": "2018-03-23T05:13:06Z"
            },
            {
              "originalPosition": 35,
              "body": "Done.",
              "createdAt": "2018-03-23T05:13:03Z",
              "updatedAt": "2018-03-23T05:13:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2Nzc5NzEw",
          "commit": {
            "abbreviatedOid": "82a15bc"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-26T05:57:28Z",
          "updatedAt": "2018-03-26T05:57:28Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "11212299b4b34859f08e78dcbee4f790646555e7",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "issue-160-statefulheader",
      "headRefOid": "82a15bcafafc91be9d7f5dd408d221afd355c08e",
      "mergeCommit": {
        "oid": "ae3fa9132a0d5934454cce0fbae2b4ea941aee73"
      }
    },
    {
      "number": 163,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc2NDkzMDYx",
      "title": "Fix #161: All HTTP header names should be lowercase.",
      "url": "https://github.com/WICG/webpackage/pull/163",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @irori. Please double-check that I fixed everywhere that failed to specify that HTTP headers are named in lowercase.\r\n\r\nSpec: [Preview](https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nImpl draft: [Preview](https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-03-21T14:26:12Z",
      "updatedAt": "2018-03-27T20:27:17Z",
      "closedAt": "2018-03-27T20:27:14Z",
      "mergedAt": "2018-03-27T20:27:14Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "It might be worth spelling out what the receiver should do if it sees an uppercase header. (Otherwise LGTM.)",
          "createdAt": "2018-03-21T15:54:17Z",
          "updatedAt": "2018-03-21T15:54:17Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you also update the \"implementation checkpoint\" and the envelope format there?",
          "createdAt": "2018-03-22T00:57:43Z",
          "updatedAt": "2018-03-22T00:57:43Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you also update [Section 5.3](https://jyasskin.github.io/webpackage/lowercase-headers-in-cbor/draft-yasskin-http-origin-signed-responses.html#rfc.section.5.3)?",
          "createdAt": "2018-03-22T02:00:59Z",
          "updatedAt": "2018-03-22T02:00:59Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks, done.",
          "createdAt": "2018-03-24T12:23:37Z",
          "updatedAt": "2018-03-24T12:23:37Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzE2Mjg0",
          "commit": {
            "abbreviatedOid": "def9b44"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-25T01:43:02Z",
          "updatedAt": "2018-03-25T01:43:02Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2Nzc2Mjkx",
          "commit": {
            "abbreviatedOid": "def9b44"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-26T05:26:08Z",
          "updatedAt": "2018-03-26T05:26:30Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Nit: lowercase",
              "createdAt": "2018-03-26T05:26:08Z",
              "updatedAt": "2018-03-27T20:23:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA3NDUzNDE3",
          "commit": {
            "abbreviatedOid": "def9b44"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-03-27T20:24:07Z",
          "updatedAt": "2018-03-27T20:24:08Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Thanks.",
              "createdAt": "2018-03-27T20:24:08Z",
              "updatedAt": "2018-03-27T20:24:08Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3fc67e270b4a89bed9a46732c985fd984c2a66d3",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "lowercase-headers-in-cbor",
      "headRefOid": "9e20b552343e0dd3ca22c565fea527ba07eed15c",
      "mergeCommit": {
        "oid": "c986519564139f1fa7929c20d11b6a97ae6911fa"
      }
    },
    {
      "number": 166,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc3MjQ5Njky",
      "title": "Update to draft-04 of structured headers.",
      "url": "https://github.com/WICG/webpackage/pull/166",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "But pin the implementation draft to -02.\r\n\r\nSpec: [Preview](https://jyasskin.github.io/webpackage/update-header-structure-draft/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/update-header-structure-draft/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nImpl draft: [Preview](https://jyasskin.github.io/webpackage/update-header-structure-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/update-header-structure-draft/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-03-24T17:49:18Z",
      "updatedAt": "2018-03-27T20:18:51Z",
      "closedAt": "2018-03-27T20:18:47Z",
      "mergedAt": "2018-03-27T20:18:47Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@mnot, FYI in case you like watching changes to drafts using structured headers.\r\n\r\n@hajimehoshi @nyaxt The encoding of binary content will need to change in the implementations, but only *after* we move to the next implementation draft.",
          "createdAt": "2018-03-24T17:52:56Z",
          "updatedAt": "2018-03-24T17:52:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2NzU3NDk0",
          "commit": {
            "abbreviatedOid": "538aa69"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-26T02:13:20Z",
          "updatedAt": "2018-03-26T02:13:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2Nzg1ODUx",
          "commit": {
            "abbreviatedOid": "538aa69"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-03-26T06:41:40Z",
          "updatedAt": "2018-03-26T06:41:40Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "11212299b4b34859f08e78dcbee4f790646555e7",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-header-structure-draft",
      "headRefOid": "538aa6996ac81b70161964c9553731afce9c5da2",
      "mergeCommit": {
        "oid": "3fc67e270b4a89bed9a46732c985fd984c2a66d3"
      }
    },
    {
      "number": 167,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc3MzI2MzI5",
      "title": "Make ecdsaSigValue fields visible so it can be asn1.Marshaled",
      "url": "https://github.com/WICG/webpackage/pull/167",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-03-26T01:54:00Z",
      "updatedAt": "2018-03-26T05:17:53Z",
      "closedAt": "2018-03-26T05:17:53Z",
      "mergedAt": "2018-03-26T05:17:53Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA2Nzc1MzUz",
          "commit": {
            "abbreviatedOid": "9963ed1"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-03-26T05:17:44Z",
          "updatedAt": "2018-03-26T05:17:44Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "11212299b4b34859f08e78dcbee4f790646555e7",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "fixRS",
      "headRefOid": "9963ed1014bb5784542d700880d4d0515f969fb9",
      "mergeCommit": {
        "oid": "2e88a4422a565221178891f50ed68c71cbcb6086"
      }
    },
    {
      "number": 168,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc5MTY0OTQy",
      "title": "Finalize impl snapshot",
      "url": "https://github.com/WICG/webpackage/pull/168",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Impl draft: [Preview](https://jyasskin.github.io/webpackage/finalize-impl-snapshot/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/finalize-impl-snapshot/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)\r\n\r\n@nyaxt @twifkak, I think this is the final set of changes needed before I publish this snapshot. Do you see anything that'll change before we want to move to the next snapshot?",
      "createdAt": "2018-04-03T17:18:25Z",
      "updatedAt": "2018-04-05T03:26:03Z",
      "closedAt": "2018-04-05T03:26:00Z",
      "mergedAt": "2018-04-05T03:26:00Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MDY3MDM2",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "I'll defer to @nyaxt for approval.",
          "createdAt": "2018-04-03T18:32:45Z",
          "updatedAt": "2018-04-03T18:39:51Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "nit: Specify an upper bound on `<positive-integer>`? Otherwise, it'll be an unspecified upper bound, as I'm sure nobody will use bignum for this. :)",
              "createdAt": "2018-04-03T18:32:45Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            },
            {
              "originalPosition": 76,
              "body": "Oh, I had missed the removal of tls-cert-chain earlier. Do you advise a content-type to use for certUrls when implementing against this snapshot?",
              "createdAt": "2018-04-03T18:36:35Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MDgzNjMx",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-03T19:22:41Z",
          "updatedAt": "2018-04-03T20:17:25Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "I added it for the impl draft (https://github.com/WICG/webpackage/pull/139/commits/2bc9a298b5686d22027164e36b3537ae654fd2a2), but Chrome just doesn't enforce it (https://cs.chromium.org/search/?q=tls-cert-chain&sq=package:chromium&type=cs), so I may as well not specify a new thing for just one version of the draft.\r\n\r\nI don't have a strong feeling for what the server should use. I could put this back if it makes you more comfortable, or you could use `application/octet-stream`.",
              "createdAt": "2018-04-03T19:22:41Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            },
            {
              "originalPosition": 93,
              "body": "'k. 10000 versions should be enough for anyone.",
              "createdAt": "2018-04-03T20:16:44Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5MTAxNjkz",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-03T20:19:44Z",
          "updatedAt": "2018-04-03T20:19:44Z",
          "comments": [
            {
              "originalPosition": 76,
              "body": "Meh, `octet-stream` works for me.",
              "createdAt": "2018-04-03T20:19:44Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTM2MDUy",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-04T23:34:07Z",
          "updatedAt": "2018-04-04T23:34:07Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "After a review of the main spec, I wound up removing numeric ranges from there, so I'll also remove them from here.",
              "createdAt": "2018-04-04T23:34:07Z",
              "updatedAt": "2018-04-04T23:34:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTQxOTg5",
          "commit": {
            "abbreviatedOid": "30baeaa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-05T00:08:49Z",
          "updatedAt": "2018-04-05T00:08:49Z",
          "comments": [
            {
              "originalPosition": 93,
              "body": "Works for me. Thanks for the heads up.",
              "createdAt": "2018-04-05T00:08:49Z",
              "updatedAt": "2018-04-05T00:08:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTA5NTQ4NDAw",
          "commit": {
            "abbreviatedOid": "1b1b333"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-04-05T00:54:26Z",
          "updatedAt": "2018-04-05T00:54:26Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f4ca17d1377bed966fdba85c03adbd798cfb5a96",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "finalize-impl-snapshot",
      "headRefOid": "1b1b33387d69a1b94e95dff3dfeb406a2a6b9a31",
      "mergeCommit": {
        "oid": "0d92d3b4ce3a11bf0bafa8b3a43216b584e6f99f"
      }
    },
    {
      "number": 170,
      "id": "MDExOlB1bGxSZXF1ZXN0MTc5NzczOTUw",
      "title": "Fix #147: Require URLs to be absolute.",
      "url": "https://github.com/WICG/webpackage/pull/170",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I realized this should probably also go in before I publish the implementation draft.\r\n\r\nSpec: [Preview](https://jyasskin.github.io/webpackage/absolute-urls/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/absolute-urls/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nImpl draft: [Preview](https://jyasskin.github.io/webpackage/absolute-urls/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/absolute-urls/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-04-05T19:30:07Z",
      "updatedAt": "2018-04-09T01:38:55Z",
      "closedAt": "2018-04-06T17:34:07Z",
      "mergedAt": "2018-04-06T17:34:07Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Looks good to me, assuming the allowance of all schemes (incl `file:`) is intentional (and it's safe to ignore fragments).",
          "createdAt": "2018-04-05T20:22:49Z",
          "updatedAt": "2018-04-05T20:22:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I suspect we're going to need to restrict the schemes some, but I'm not sure to what (https only? [potentially-trustworthy](https://www.w3.org/TR/secure-contexts/#is-origin-trustworthy) only?), so I was going to leave that open for now.",
          "createdAt": "2018-04-06T03:16:28Z",
          "updatedAt": "2018-04-06T03:16:28Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm",
          "createdAt": "2018-04-09T01:38:55Z",
          "updatedAt": "2018-04-09T01:38:55Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0d92d3b4ce3a11bf0bafa8b3a43216b584e6f99f",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "absolute-urls",
      "headRefOid": "fe766bea0130565408310be502837f46cc06b8a9",
      "mergeCommit": {
        "oid": "53e07536f6857e2cde1d833e733a93090ad49dd9"
      }
    },
    {
      "number": 171,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwMDYwMDk4",
      "title": "Fix #169: Explicitly accept SCTs in X.509 and OCSP extensions.",
      "url": "https://github.com/WICG/webpackage/pull/171",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @irori.\r\n\r\n@davidben @sleevi, is this the right thing to do? Or should I match [RFC6962](https://tools.ietf.org/html/rfc6962#section-3.3) by requiring clients to look in all three places?",
      "createdAt": "2018-04-06T21:38:01Z",
      "updatedAt": "2018-04-09T18:19:21Z",
      "closedAt": "2018-04-09T18:19:18Z",
      "mergedAt": "2018-04-09T18:19:18Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm confused. What's the motivation for ignoring them? That seems inconsistent, especially considering that SCTs will often be embedded in the certificate.\r\n\r\nIt also seems more complicated to ignore them for the implementer too. Implementation-wise, that wants to be thoroughly abstracted away from the web packaging logic anyway. If not, something is probably structured wrong.",
          "createdAt": "2018-04-06T21:51:36Z",
          "updatedAt": "2018-04-06T21:51:52Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin I think we can close as WontFix.\r\n\r\nAll three sources (certificate, OCSP, extension) should be acceptable. The most likely workflow is that all of the necessary SCTs will be within the certificate itself. However, we need an additional channel to supply SCTs (in the event the cert or OCSP response does not contain them), hence the need for the CBOR side (to match the TLS extension).\r\n\r\nSo... They should all work :) This is more about mirroring the TLS channels' set of authority expressions",
          "createdAt": "2018-04-06T21:54:14Z",
          "updatedAt": "2018-04-06T21:54:14Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "My argument for ignoring the other two methods is that it's simpler to have only one way to do things. However, if y'all think it's actually simpler to accept them from anywhere, I'll do that instead.\r\n\r\nIt's definitely not WontFix if we want to accept them from anywhere: the current text says that the SCT has to appear by itself. I have to fix that.\r\n\r\n@irori, are you the person implementing this, and were you asking because it's less code to accept them from any of the three places?",
          "createdAt": "2018-04-06T21:55:33Z",
          "updatedAt": "2018-04-06T21:55:33Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Yeah, from a CT ecosystem point of view, it's highly desirable that the CA is responsible for ensuring the compliance of the certificate with various CT policies, either via embedding SCTs in the certificate or via the OCSP response. That ensures a more consistent approach less likely to break due to changes in the CT ecosystem. The availability for the TLS extension (or, in this case, the dictionary) is meant to address scenarios in which the CA does not manage that effectively/at all, or the validity period of the certificate is so great that it exceeds the normal log ecosystem stability range. The former is increasingly less likely as CT deployment rolls out, while the latter has not yet happened and is only theoretical.\r\n\r\nThe ideal outcome is that Web Packagers do not have to 'think' about CT when packaging/updating signatures, and that it just works. This is a mechanism to allow for explicit control (as some large CDNs prefer, in order to keep certificates and OCSP responses small for clients that don't use CT) or rapid response.",
          "createdAt": "2018-04-06T21:59:17Z",
          "updatedAt": "2018-04-06T21:59:17Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "CT has a bunch of ways to deliver SCTs because it needed to slot into an existing and complex CA and TLS server ecosystem. You may have CAs that haven't gotten SCT support yet, you may have TLS servers that don't support the extension, you may have server operators that don't know to configure CT, etc. In a vacuum, yes, having only one mechanism would be by far the most preferable, but there were other considerations for it to succeed.\r\n\r\nGiven that CT thus looks like this, it should be consistent across uses, so that we *don't* need to make the implementation more complex. Chromium's implementation already bundles together the three sources. If the in-progress web packaging implementation isn't using that abstraction, we should fix that, and not the spec.",
          "createdAt": "2018-04-06T22:00:56Z",
          "updatedAt": "2018-04-06T22:00:56Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Done: https://jyasskin.github.io/webpackage/fix-169/draft-yasskin-http-origin-signed-responses.html#cross-origin-trust",
          "createdAt": "2018-04-06T22:03:56Z",
          "updatedAt": "2018-04-06T22:03:56Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "In hindsight, I suspect CT could have managed with just the in-cert mechanism and the TLS extension, without leeching off of OCSP, but so it goes. :-)",
          "createdAt": "2018-04-06T22:06:53Z",
          "updatedAt": "2018-04-06T22:06:53Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Yeah, accepting them is simpler from the implementer's point of view.\r\nThanks!\r\n",
          "createdAt": "2018-04-09T01:34:38Z",
          "updatedAt": "2018-04-09T01:34:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwMjIxODc3",
          "commit": {
            "abbreviatedOid": "c5fc489"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-04-06T22:05:35Z",
          "updatedAt": "2018-04-06T22:05:35Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0e013a978e2f7e1e112cd1dec297a26b3774f42b",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fix-169",
      "headRefOid": "c5fc489c4e2e254502ebdaf4c38d0f63264f69eb",
      "mergeCommit": {
        "oid": "53ff918dc04e1d041a10cba60b7397e147d6c008"
      }
    },
    {
      "number": 173,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwNDM5MzMx",
      "title": "Sketch loading and caching in the explainer based on Kinuko's description",
      "url": "https://github.com/WICG/webpackage/pull/173",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @kinu! This is a subset of your document that I think will give folks like the TAG enough to go on. The rest of your doc is most of the specification.\r\n\r\nhttps://github.com/jyasskin/webpackage/blob/sketch-loading/explainer.md#signed-exchange-loading-sketch",
      "createdAt": "2018-04-09T22:01:03Z",
      "updatedAt": "2018-05-08T22:00:47Z",
      "closedAt": "2018-05-08T22:00:39Z",
      "mergedAt": "2018-05-08T22:00:39Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've now made the layering more explicit and removed the claim that we'll put the inner exchange in the HTTP cache. There's still a section saying to explore that later.\r\n\r\nHow's it look now?",
          "createdAt": "2018-05-05T00:02:38Z",
          "updatedAt": "2018-05-05T00:02:38Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I think this is pretty much stable now, so I'll merge it. Comments and bugs are still welcome.",
          "createdAt": "2018-05-08T21:57:29Z",
          "updatedAt": "2018-05-08T21:57:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEwNzQ4MTQx",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for starting this! I have some comments/questions (probably more, but here're initial ones)",
          "createdAt": "2018-04-10T09:03:04Z",
          "updatedAt": "2018-04-10T09:55:24Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "nit: would it be better to say it depends on if the request is for a navigation or not? (Not sure how this text is confusing or not to the readers)",
              "createdAt": "2018-04-10T09:03:04Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 105,
              "body": "'only if the Service Worker responds with...' part felt a bit confusing (in this paragraph it's not clear if we're talking about fetching the physical URL in general or the case that with the embedder's SW).",
              "createdAt": "2018-04-10T09:28:43Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 138,
              "body": "Should it be clearer if we say 'If it fails to validate the signature' given that this talks about general validation failure cases (e.g. clock skew etc)?  (While I also found that we're using the text 'find a valid signature' throughout this change, so this is probably intentional?)\r\n",
              "createdAt": "2018-04-10T09:40:45Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 173,
              "body": "Do you have some example scenarios?",
              "createdAt": "2018-04-10T09:49:13Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 164,
              "body": "Let me clarify... at this point we start talking about caching the response(s) in the signed exchange, is that right?",
              "createdAt": "2018-04-10T09:52:24Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 182,
              "body": "I don't feel super comfortable having this text yet, UA should respect the cache headers but not sure if it should cache the response in the signed exchange.  Also: mentioning 'preload cache' here feels a bit confusing, it should come into play only when the signed exchange is 'preloaded', right?",
              "createdAt": "2018-04-10T09:53:29Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMDAzNjkw",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-10T20:44:34Z",
          "updatedAt": "2018-04-10T21:50:41Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Yeah, probably. Done.",
              "createdAt": "2018-04-10T20:44:34Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 105,
              "body": "I was worrying about either the physical URL's or the embedder's SW receiving the `application/signed-exchange` response but calling `e.respondWith(somethingElse)`. I can probably just ignore that subtlety for the explainer and let folks assume that SWs will return the real resource.",
              "createdAt": "2018-04-10T20:53:24Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 138,
              "body": "My idea here is that signed exchanges can have several signatures, some of which are invalid for this client (but might be valid for some other client), some of which are valid but not origin-trusted, and some of which are both valid and origin-trusted. The basic verification process is a search through those signatures for one that's both valid and origin-trusted. Does that make sense? I definitely want to avoid implying that there's exactly one signature, but I'm happy to reword to make this clearer.",
              "createdAt": "2018-04-10T21:00:59Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 164,
              "body": "Heh, yes, that wasn't clear at all. Is this new wording better?",
              "createdAt": "2018-04-10T21:16:00Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 173,
              "body": "1. The Accept header includes `image/newformat`, the response is actually in that format and so Chrome can't display it, and this winds up in the cache, preventing Chrome from doing a later request with our actual Accept headers, which would content-negotiate for an image we could actually display.\r\n2. The Accept-Language header doesn't match the user's language preferences, and the response is something they can't read. If we dropped the exchange with mis-matched request headers, we might negotiate the right response.\r\n\r\nI don't have an example of confusing the client beyond just caching an unusable resource that could have been content-negotiated using a connection to the real server. I guess that any real confusion could also be caused by a server that served a malicious response, so Chrome's already hardened against that.\r\n\r\nWe could put mismatched request headers in the preload cache and just exclude them from the HTTP cache, so a malicious or buggy intermediate would only hurt itself? It seems simpler to skip all caching, but you'd know better what's easier to implement.",
              "createdAt": "2018-04-10T21:39:00Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 182,
              "body": "Ah, I hadn't caught that whether to HTTP-cache it was still up in the air. I'll mention that.\r\n\r\nI could be misunderstanding the preload cache in general, but my impression was that (whatever we call it) it's the place that stores prefetches, preloads, the thing https://w3c.github.io/ServiceWorker/#navigation-preload-manager manages, and anything else where we want to use an already-stale response \"once\". ",
              "createdAt": "2018-04-10T21:47:02Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMTAzODQx",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-11T06:46:50Z",
          "updatedAt": "2018-04-11T06:46:51Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I see. Since the issue (https://github.com/whatwg/fetch/issues/590) isn't closed yet I added a question to ask for the clarification there, that would probably give you some additional context too. For now I just assume this is talking about 'a cache' for preload/prefetch or whatever.",
              "createdAt": "2018-04-11T06:46:50Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMTE2MjUw",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks! Added some more comments. (Let me know if you want to land this earlier than later, we can keep discussing even after committing this if you prefer)",
          "createdAt": "2018-04-11T07:38:15Z",
          "updatedAt": "2018-04-11T08:58:14Z",
          "comments": [
            {
              "originalPosition": 164,
              "body": "Loos a lot clearer, thanks!",
              "createdAt": "2018-04-11T08:08:05Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 182,
              "body": "Reading this further I started to worry that we say a lot about the HTTP cache here.\r\n\r\nDoes it make sense to have this part (putting it in HTTP cache) as an optional behavior, or could the spec leave which cache to put the resource up to UA?  Say, we can define a conceptual `signed response cache` and note that the behavior can be implemented in the HTTP cache if UA wants?\r\n\r\nMy concern is layering, efficiency and complexity: The signed exchange itself is cacheable, which seems to mean that the signed exchange layer sits on top of HTTP cache, therefore populating HTTP cache with the contents extracted from the signed exchange could mean:\r\n\r\n1. we may waste disk space by caching the data in dup'ed way (signed and non-signed ones)\r\n2. we may need to populate HTTP cache from the layer above it, which is probably unprecedented\r\n3. we need to make the HTTP cache understand the signed exchange logic and associate each entry with the corresponding signature in order to process the revalidation logic stated below",
              "createdAt": "2018-04-11T08:09:04Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 185,
              "body": "Does this imply that the signature's expiration has somewhat sticky effect on the resources that are installed from the signed exchange / bundle?  For some use cases like offline PWA installation this may not make a lot sense, or may have some inconsistency?  E.g. I think we'd want to keep the PWA's SW and assets installed from a bundle/exchange valid even after the signature expires, is that right?",
              "createdAt": "2018-04-11T08:29:45Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 214,
              "body": "I don't think the `FetchEvent` *needs* to include the notification, but if SW wants to know about that we can do that by utilizing navigation preload (only for the SWs that have enabled the feature), is the argument.",
              "createdAt": "2018-04-11T08:54:35Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMzQwMjcy",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-11T18:01:34Z",
          "updatedAt": "2018-04-11T18:01:34Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "Blargh. https://github.com/whatwg/fetch/issues/590#issuecomment-357995100 makes me realize that this is definitely *not* the preload cache. The preload cache has a bit of behavior that I want, but it sits after the Service Worker (i.e. caches SW responses), while we're currently thinking of this thing as sitting before the SW and providing input to it.\r\n\r\nYou mentioned prefetch \"basically just puts things in HTTP cache\": does that mean that when the subsequent page requests the prefetched thing, the request goes through the subsequent page's Service Worker, and the SW finds the prefetched thing if the it calls down to the network?",
              "createdAt": "2018-04-11T18:01:34Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMzU0NzE1",
          "commit": {
            "abbreviatedOid": "910fcec"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Let's see if we converge in the next couple rounds instead of committing early.",
          "createdAt": "2018-04-11T18:40:51Z",
          "updatedAt": "2018-04-11T20:40:49Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "Yes, I'm currently thinking that the signature's expiration sticks to the resources it guarded. We could argue the opposite based on the fact that we don't expire resources after their certificate or OCSP response expires, but I haven't been arguing that so far because those uses at least have a liveness guarantee at the point when the resource arrived.\r\n\r\nFor offline use, I'm going to argue (https://github.com/WICG/webpackage/issues/117) that we should extend signature expiration times by O(a month) as long as the client is continuously offline and can't fetch updates, rather than that we should just ignore signature expiration.",
              "createdAt": "2018-04-11T18:40:51Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 182,
              "body": "I don't think we can leave it entirely up to the UA, because developers will be able to see the differences, and our experience with the HTTP/2 Push cache makes me worried about introducing any visibly-different cache.\r\n\r\nIf we say that this all goes into the HTTP cache, but we also say that signed exchanges can't contain other signed exchanges or redirects, does that allow you to implement the specified behavior using two layers, to avoid your concerns?\r\n\r\nI played with the idea of not caching at all, but that'll break the case where we prefetch the .sxg and try to use its logical URL directly, which hurts non-AMP users, so I don't think it's realistic.\r\n",
              "createdAt": "2018-04-11T19:43:46Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 214,
              "body": "I agree that we can probably ship without this notification, but I think people will want it sooner or later. I'll downgrade my language here.\r\n\r\nThe existing navigation preload only applies to navigations, while signed exchanges also offer a response for subresources, so I think we'll need to extend its current spec. I also don't think we need opt-in to expose this: navigation preload needs opt-in because it adds an extra maybe-useless request, but this just exposes something that's happening anyway.",
              "createdAt": "2018-04-11T20:03:20Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDgzMjc0",
          "commit": {
            "abbreviatedOid": "5f6b103"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T05:26:44Z",
          "updatedAt": "2018-04-12T05:26:44Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "> You mentioned prefetch \"basically just puts things in HTTP cache\": does that mean that when the subsequent page requests the prefetched thing, the request goes through the subsequent page's Service Worker, and the SW finds the prefetched thing if the it calls down to the network?\r\n\r\nYeah that what happens.",
              "createdAt": "2018-04-12T05:26:44Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDg0MzY1",
          "commit": {
            "abbreviatedOid": "910fcec"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T05:35:16Z",
          "updatedAt": "2018-04-12T05:35:16Z",
          "comments": [
            {
              "originalPosition": 185,
              "body": "I see reg: offline use case.  What do you think about the following two cases:\r\n\r\n* UA populates HTTP cache with resources extracted from the signed exchange, and they expire when the signature of them expire\r\n* SW populates Cache Storage with resources come from the signed exchange (and SW may know the fact or not), and they will be around even after the signature of the original exchange expires\r\n\r\nMy mental model has been that the expiration matters when we process the signed exchange, but once if it's processed the resources that come from the signed exchange could just look similar to others. I think I'm fine with the current text, but wanted to note that (partly because not sticking the signature info is easier to implement).",
              "createdAt": "2018-04-12T05:35:16Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDg0NDc2",
          "commit": {
            "abbreviatedOid": "910fcec"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T05:36:13Z",
          "updatedAt": "2018-04-12T05:36:13Z",
          "comments": [
            {
              "originalPosition": 182,
              "body": "I still think having the signed responses only in so-called `preload cache` (or undefined memory cache thing) could make sense, at least from impl pov.  We sill cache the signed exchange, so having a layer that processes it and potentially caches it up to a certain period seems to be fairly natural to me (this is what we do for images, scripts etc), and that resolves your perf concern?  That model fits well with the expiration model too.",
              "createdAt": "2018-04-12T05:36:13Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDg0Mjg1",
          "commit": {
            "abbreviatedOid": "910fcec"
          },
          "author": "mnot",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T05:34:43Z",
          "updatedAt": "2018-04-12T05:44:18Z",
          "comments": [
            {
              "originalPosition": 192,
              "body": "HTTP freshness can't be modified like this; any upstream caches (e.g., CDN) won't be aware of these special semantics. \r\n\r\nI think the two approaches you have are:\r\n1. Don't do that -- i.e., make sure HTTP cache lifetime is always shorter than the signature expiration.\r\n2. If a client encounters a fresh cached response with an expired signature, it can force-refresh using things like `Cache-Control: max-age` in requests. Be aware, though, that request cache directives are ignored by many...",
              "createdAt": "2018-04-12T05:38:13Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 207,
              "body": "As above, if the response is still fresh, upstream caches will consider it so, so you'll need to cache-bust.",
              "createdAt": "2018-04-12T05:39:43Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 215,
              "body": "I feel like I'm missing something here -- what does \"first update the signature and then check for a 304\" mean?",
              "createdAt": "2018-04-12T05:40:48Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 53,
              "body": "Until their interaction with Push is specified, I wonder if it's better to just leave this out.",
              "createdAt": "2018-04-12T05:41:31Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 22,
              "body": "This terminology feels a bit generic; could we come up with something a bit more specific?\r\n\r\n",
              "createdAt": "2018-04-12T05:44:07Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDkwNTk1",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Some more lightweight comments (before think more about HTTP cache ones)",
          "createdAt": "2018-04-12T06:17:26Z",
          "updatedAt": "2018-04-12T06:24:06Z",
          "comments": [
            {
              "originalPosition": 248,
              "body": "It feels this should be allowed.",
              "createdAt": "2018-04-12T06:17:26Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 250,
              "body": "This seems questionable, given the text above says we stop prefetch steps before populating HTTP cache with the signed responses",
              "createdAt": "2018-04-12T06:18:28Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 252,
              "body": "I think yes.",
              "createdAt": "2018-04-12T06:18:42Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 254,
              "body": "No, for the same reason?",
              "createdAt": "2018-04-12T06:19:06Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNzQwODI1",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I'll update the content tomorrow, but some quick responses today:",
          "createdAt": "2018-04-12T18:28:37Z",
          "updatedAt": "2018-04-12T18:46:16Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "I don't have any better terms offhand, but I'll look for some.",
              "createdAt": "2018-04-12T18:28:37Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 53,
              "body": "In the explainer, I think it makes sense to lay out the goal, even though we haven't written down exactly how we're getting there yet. In the loading specification, I think you're right that I should only add the PUSH route when I can actually write down how the browser processes it.\r\n\r\nDoes that make sense? If you're not convinced, I'm not dead set on keeping this entry.\r\n\r\nThere's also a question of whether it makes sense to target Push in any new feature...",
              "createdAt": "2018-04-12T18:33:22Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 192,
              "body": "If I rewrite this sentence as \"If we put the *content* of the signed exchange in the HTTP cache\", does that fix things for you? I definitely don't mean that the envelope needs to have different cache behavior, just the signed bits we pull out of the envelope. (I'm looking for clearer words about this; distinguishing the envelope format from the logical HTTP exchange inside it has been tricky.)\r\n\r\nI *think* that's ok because the upstream caches like CDNs can only put the contents of a signed exchange into their cache if they understand signed exchanges, which means they're modifying code anyway and can also modify it in this way. I could even be wrong about that because it'd be code owned by two different groups?",
              "createdAt": "2018-04-12T18:37:53Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 215,
              "body": "To update the signature, the client follows https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.3.6. Then \"check for a 304\" is probably equivalent to \"makes a conditional request\". It's intended to be the two bullets above.",
              "createdAt": "2018-04-12T18:42:15Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 207,
              "body": "Here, the client would make an unconditional request to the `validity-url`, as described by https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#updating-validity, and it's fine for intermediates to cache that with normal HTTP semantics, and if the caching headers are set wrong, the client will probably wind up re-fetching the resource with a normal TLS request to its logical URL (the original publisher's origin), at which point any CDNs are welcome to serve their cached copy if they have one.",
              "createdAt": "2018-04-12T18:44:58Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 254,
              "body": "I need to think through how this affects how authors need to write their content, using more time than I have today, but thanks for also thinking about it.",
              "createdAt": "2018-04-12T18:46:00Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExOTA1MjU5",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-13T07:13:56Z",
          "updatedAt": "2018-04-13T07:13:56Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Looking at the comments by mnot, it seems intermediates may just go on and can cache the responses in the signed exchanges regardless of the request was for prefetches or not. Is that right, and if so should we note something here?",
              "createdAt": "2018-04-13T07:13:56Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEyNTQ0MjY1",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-16T18:53:20Z",
          "updatedAt": "2018-04-16T18:53:20Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "I _think_ @mnot is talking about proxies caching the enveloped signed exchange instead of proxies unwrapping the signed exchange and caching its contents (https://github.com/WICG/webpackage/pull/173#discussion_r181182126), but if he does think they'll blindly unwrap things, I need to think about the implications.",
              "createdAt": "2018-04-16T18:53:20Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEyNjc4MjI3",
          "commit": {
            "abbreviatedOid": "e49f193"
          },
          "author": "mnot",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-17T06:23:10Z",
          "updatedAt": "2018-04-17T06:23:10Z",
          "comments": [
            {
              "originalPosition": 152,
              "body": "Proxies today won't do anything to the body -- they'll just cache things according to the various HTTP caching rules, just like wiht everything else. ",
              "createdAt": "2018-04-17T06:23:10Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4MTY4NjA5",
          "commit": {
            "abbreviatedOid": "3c7b9c7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-07T21:59:46Z",
          "updatedAt": "2018-05-07T21:59:47Z",
          "comments": [
            {
              "originalPosition": 95,
              "body": "Does the preload cache might look equivalent to the memory/image cache to developers? If so, I should probably merge them in this list.",
              "createdAt": "2018-05-07T21:59:47Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4MTgwMDEz",
          "commit": {
            "abbreviatedOid": "3c7b9c7"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, this looks good / the layering part looks a lot clearer to me!  Left a few nit comments + some questions.",
          "createdAt": "2018-05-07T22:51:44Z",
          "updatedAt": "2018-05-07T23:16:04Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "This part can be in a different PR?",
              "createdAt": "2018-05-07T22:51:44Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 95,
              "body": "Having them separately looks good to me (Blink has separated preload cache out of memory cache, and it looks Yoav's trying to sketch preload cache roughly following the way",
              "createdAt": "2018-05-07T22:55:30Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 94,
              "body": "(HTTP cache and prefetch cache are not really different things in chrome impl, but that's probably fine)",
              "createdAt": "2018-05-07T22:58:08Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 24,
              "body": "'the outer exchange that fetches the outer resource' this sentence was unclear to me, what 'fetches' means here?",
              "createdAt": "2018-05-07T22:59:09Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 194,
              "body": "Does this extra check run only when the fetch comes from/via the Service Worker?  We also say the response is not really distinguishable between inner responses as a part of signed exchange vs regular resources from SW for now, they feel slightly inconsistent to me.",
              "createdAt": "2018-05-07T23:07:28Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 256,
              "body": "Yeah +1 to keep this as an open discussion for now",
              "createdAt": "2018-05-07T23:12:20Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 199,
              "body": "nit: annotate this as (TBD) too?",
              "createdAt": "2018-05-07T23:13:46Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4MTg3NjY2",
          "commit": {
            "abbreviatedOid": "3c7b9c7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-07T23:32:49Z",
          "updatedAt": "2018-05-08T00:00:28Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Hm, yeah, that's unclear. How about \"whose response's payload is the outer resource\"?",
              "createdAt": "2018-05-07T23:32:49Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 35,
              "body": "I can avoid moving it in this PR.",
              "createdAt": "2018-05-07T23:33:47Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 194,
              "body": "The extra check should happen even when there's no SW or no `fetch` handler in the SW. I tend to think of a page without a SW as equivalent to a page whose SW does nothing in its `fetch` handler, so if it looks like I'm deviating from that, or if that's the wrong model for me to have, let me know. :)",
              "createdAt": "2018-05-07T23:52:13Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            },
            {
              "originalPosition": 199,
              "body": "Done.",
              "createdAt": "2018-05-07T23:52:18Z",
              "updatedAt": "2018-05-08T21:57:00Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ff1ef788f6d1f2940aedc1d5c2c6372934e8d28c",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "sketch-loading",
      "headRefOid": "d0241569b77ea5ec80eb556f0751a6c331935a33",
      "mergeCommit": {
        "oid": "3fae1f32f18374fd2936b1e57f14605d6eb59e5e"
      }
    },
    {
      "number": 174,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgwNTQ5MzEx",
      "title": "gen-certurl: Follow the latest specification of certurl (OCSP and SCT)",
      "url": "https://github.com/WICG/webpackage/pull/174",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #165 \r\n\r\nOriginal author: @irori\r\n\r\nThis PR fixes gen-certurl to follow the latest specification.\r\n\r\nThis PR also adds internal/testhelper package for testing to show readable strings of CBOR binary.",
      "createdAt": "2018-04-10T09:59:28Z",
      "updatedAt": "2018-04-11T05:38:30Z",
      "closedAt": "2018-04-11T05:38:27Z",
      "mergedAt": "2018-04-11T05:38:26Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori Would you follow up on instructions/scripts on generating sct/ocsp files?",
          "createdAt": "2018-04-11T01:23:15Z",
          "updatedAt": "2018-04-11T01:23:15Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "> @irori Would you follow up on instructions/scripts on generating sct/ocsp files?\r\n\r\nSee here: https://docs.google.com/document/d/1gl_t8MmULHaEFT9Yny2bkNGjtTuB4K-ugvM44E0kXnM/edit#",
          "createdAt": "2018-04-11T04:19:18Z",
          "updatedAt": "2018-04-11T04:19:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMDYyMDE5",
          "commit": {
            "abbreviatedOid": "508edba"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-11T01:22:51Z",
          "updatedAt": "2018-04-11T01:22:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExMDg1OTQy",
          "commit": {
            "abbreviatedOid": "508edba"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks.",
          "createdAt": "2018-04-11T04:39:29Z",
          "updatedAt": "2018-04-11T04:39:29Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "53ff918dc04e1d041a10cba60b7397e147d6c008",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "issue-165-certchain",
      "headRefOid": "508edba3191bff692aadcea9d17d9655a8b511ad",
      "mergeCommit": {
        "oid": "90dfcb77fdb3364d36ac35cba9698bf395545ff2"
      }
    },
    {
      "number": 178,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxMDI2MzI1",
      "title": "Make all Structured Header identifiers lower-case.",
      "url": "https://github.com/WICG/webpackage/pull/178",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks to @twifkak for noticing the violation of\r\n[draft-ietf-httpbis-header-structure-04 Section 4.8](https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-04#section-4.8).\r\n\r\nNote that this will affect the next implementation draft but doesn't affect the [current one](https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-00).",
      "createdAt": "2018-04-11T20:58:31Z",
      "updatedAt": "2018-04-13T19:52:46Z",
      "closedAt": "2018-04-13T19:52:37Z",
      "mergedAt": "2018-04-13T19:52:37Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDAyNjg4",
          "commit": {
            "abbreviatedOid": "f801f93"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-11T21:05:36Z",
          "updatedAt": "2018-04-11T21:05:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDg5ODUy",
          "commit": {
            "abbreviatedOid": "f801f93"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-04-12T06:13:09Z",
          "updatedAt": "2018-04-12T06:13:09Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "90dfcb77fdb3364d36ac35cba9698bf395545ff2",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "lowercase-header-identifiers",
      "headRefOid": "3d07b89d468ef07d067f8a76d4c3a2b05229eb8c",
      "mergeCommit": {
        "oid": "078f19bcee9bdc13a0cbf221335572e177e5d284"
      }
    },
    {
      "number": 179,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxMDYyMjA1",
      "title": "Allow certificate re-use for TLS.",
      "url": "https://github.com/WICG/webpackage/pull/179",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See discussion in\r\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0041.html.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/remove-rsa/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/remove-rsa/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-04-12T00:30:47Z",
      "updatedAt": "2018-11-14T21:44:05Z",
      "closedAt": "2018-05-09T19:53:56Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "So, I am not convinced that this is a positive change we should make. While I can understand the proposal to restrict the signature algorithms, the reuse with TLS is something that I believe is a net-negative for the practical deployment scenario. While I realize that some providers, particularly those BYOC, may have difficulty managing two certificates, the separation requirement was mitigating both operational and cryptographic concerns.\r\n\r\nThat is, in a forced-separation model, there is no direct advantage or incentive to promoting online signing, while that is fundamentally necessary for TLS certificates. The same discussion can be seen regarding the key protections for Secondary Certificates. This is critically important when considering \"key compromise\" scenarios. While the current separation does not absolutely guarantee any operational security, it ensures the design does not incentivize insecurity. This is the same consideration as when thinking about forward-dating signatures, and just as in that case, there may be future operational or protocol restrictions (e.g. needing to cover an OCSP response), one can imagine that Web Packages may have future requirements similar to code signing certificates in the Microsoft ecosystem - namely, can only be issued to hardware-backed keys (as an example)\r\n\r\nAt this time, I do not think allowing the reuse with TLS is good for clients or for servers, despite the challenges some have raised.",
          "createdAt": "2018-04-12T13:29:50Z",
          "updatedAt": "2018-04-12T13:29:50Z"
        },
        {
          "author": "cramforce",
          "authorAssociation": "COLLABORATOR",
          "body": "@sleevi I think you are missing at least one part of the ecosystem incentive that I know you would usually care about:\r\n\r\n1. Allowing reuse with TLS is good for decentralization because it allows parties to reuse their cert to participate in package generation with minimal added effort.\r\n2. Forbidding reuse incentivizes outsourcing of package generation to specialized and naturally more centralized entities who generate the special certificates on behalf of the origin and generate packages for them.\r\n",
          "createdAt": "2018-04-12T13:42:32Z",
          "updatedAt": "2018-04-12T13:42:32Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@cramforce No, I'm not missing those from the considerations. I think the cross-protocol and key compromise risks are significantly greater through the introduction of Web Packaging (or Secondary Certificates), and thus deserve serious mitigations if clients are to consider implementing and shipping them. I do not think it is a positive step forward to ship without such mitigations.\r\n\r\nYour first argument is not consistent with the efforts that Google or the Chrome team have encouraged or the statements made regarding the automation of certificates. An alternative phrasing is that Web Packaging's practical deployment encourages greater automation through certificate issuance - which we already see widespread. Thus, the concerns about getting a second certificate are merely a misdirect and not applicable.\r\n\r\nRegarding your second argument, this is true already for CDNs, which can offer greater key protection for nodes than those afforded to clients. This is fundamentally no different than existing solutions such as Cloudflare, Amazon, or Google, all of which take steps to secure client keys from compromise. My concern would be if the use of a particular CDN or provider was functionally required or incentivized, but that is separate from an argument against CDNs.\r\n\r\nIn light of the security risks that clients would be faced with, I do not think this change is good, and I worry that it would make Web Packaging more difficult to reason about and accept from a security perspective. But I wonder whether we should be continuing this conversation on the list instead - I'm not sure @jyasskin's desired workmode, but since the conversation started there, it's probably best to continue it there.",
          "createdAt": "2018-04-12T13:49:51Z",
          "updatedAt": "2018-04-12T13:51:40Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Additionally this PR forgets to restore those 64 spaces in the context string.\r\n\r\nRegardless of which way this goes, as I mentioned when removing those spaces came up, I think removing them in the first place was a bad idea. It was only a matter of time before someone tries to remove the restriction and then forgets to fix the context string to match.\r\n\r\nEdit: Sorry, 64 spaces, not 32.",
          "createdAt": "2018-04-12T17:51:08Z",
          "updatedAt": "2018-04-12T17:54:52Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Note that, by requiring P-256 keys, most sites will already have to manage multiple certificates anyway. There are enough RSA-only TLS clients out there that, in practice, most folks need to have an RSA certificate. ECDSA certificates are primarily deployed in *addition* to RSA certificates, to reduce server resource usage (ECDSA signing is much faster than RSA signing).",
          "createdAt": "2018-04-12T18:01:34Z",
          "updatedAt": "2018-04-12T18:01:34Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks for having the main discussion on the list; I think more people can participate there.\r\n\r\n@davidben Your bug is now fixed; thanks for pointing it out.",
          "createdAt": "2018-04-16T18:16:02Z",
          "updatedAt": "2018-04-16T18:16:02Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Most of this change was merged in #181, and Ryan's objections in https://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0070.html seem to have convinced everyone to stop pushing for certificate re-use, so I'm closing this PR.",
          "createdAt": "2018-05-09T19:53:56Z",
          "updatedAt": "2018-05-09T19:53:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDUyOTQ4",
          "commit": {
            "abbreviatedOid": "218faaa"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T01:17:03Z",
          "updatedAt": "2018-04-12T01:17:08Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Would it be possible to pin the TLS version/draft in the signedexchange spec?",
              "createdAt": "2018-04-12T01:17:03Z",
              "updatedAt": "2018-05-09T19:51:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTExNDczMDM0",
          "commit": {
            "abbreviatedOid": "218faaa"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-04-12T03:58:12Z",
          "updatedAt": "2018-04-12T03:58:12Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Do you mean to the -28 draft or to exactly TLS 1.3? The TLS draft is [\"Submitted to IESG for Publication\"](https://datatracker.ietf.org/doc/draft-ietf-tls-tls13/), so it's unlikely that -28 will change significantly before it's published as an RFC.\r\n\r\nIt's possible to pin to 1.3, but [Ilari's post](https://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0050.html) seems to say that he wants this RFC to allow for future expansion in the set of algorithms without needing to revise this RFC. Other security folks might speak up and disagree, of course.\r\n\r\nNote that the WHATWG-side spec will be a living spec that'll follow the current version of TLS and specify exactly which algorithms browsers are using, even if this spec is less precise.",
              "createdAt": "2018-04-12T03:58:12Z",
              "updatedAt": "2018-05-09T19:51:13Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "fa9ebf9e3ec7b900dad04966867769fabde24b90",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "remove-rsa",
      "headRefOid": "e11726703c16e6b1ef730ceb8a3738d991080c80",
      "mergeCommit": null
    },
    {
      "number": 180,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgxNTc5OTMx",
      "title": "Re-add the 64-byte TLS signature padding.",
      "url": "https://github.com/WICG/webpackage/pull/180",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Per davidben's advice, it's safer to make all similar signature formats\r\nthe same.\r\n\r\nSeparate from #179 since it sounds like you're advising this even if that doesn't go in.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/re-add-tls-padding/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/re-add-tls-padding/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-04-13T19:45:07Z",
      "updatedAt": "2018-04-16T18:14:04Z",
      "closedAt": "2018-04-16T18:14:01Z",
      "mergedAt": "2018-04-16T18:14:01Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEyMTM4MTU1",
          "commit": {
            "abbreviatedOid": "8824c27"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-04-13T19:46:41Z",
          "updatedAt": "2018-04-13T19:46:41Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "078f19bcee9bdc13a0cbf221335572e177e5d284",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "re-add-tls-padding",
      "headRefOid": "778f33d1a49d6507e5fce0056e741e90cf2383e6",
      "mergeCommit": {
        "oid": "3f639391d047c945f43f2da0646e2a4b5c53fbb3"
      }
    },
    {
      "number": 181,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyNTEwODc1",
      "title": "Forbid RSA and only require secp256r1.",
      "url": "https://github.com/WICG/webpackage/pull/181",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See discussion in\r\nhttps://lists.w3.org/Archives/Public/ietf-http-wg/2018AprJun/0041.html.\r\n\r\nThis is #179 without the change to allow exchange-signing certificates to be used for TLS.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/remove-rsa-no-tls/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/remove-rsa-no-tls/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-04-18T15:06:24Z",
      "updatedAt": "2018-05-09T19:47:17Z",
      "closedAt": "2018-05-09T19:45:07Z",
      "mergedAt": "2018-05-09T19:45:07Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4ODM2OTQ5",
          "commit": {
            "abbreviatedOid": "1e540d7"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-09T17:44:22Z",
          "updatedAt": "2018-05-09T17:45:29Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Nit: You don't want the ecdsa/secp384r1 here, right?",
              "createdAt": "2018-05-09T17:44:22Z",
              "updatedAt": "2018-05-09T17:45:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4ODM4MTU2",
          "commit": {
            "abbreviatedOid": "1e540d7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-09T17:47:42Z",
          "updatedAt": "2018-05-09T17:47:43Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "It was an intentional part of the example, showing how an odd client, that changed which curve is supported, would announce that fact to servers. Let me know if you think I'm wrong to have an example like that.\r\n\r\n(I'm not certain my `Accept-Signature` thing is a good idea overall, but that's a discussion for another PR.)",
              "createdAt": "2018-05-09T17:47:42Z",
              "updatedAt": "2018-05-09T17:47:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4ODc2ODY5",
          "commit": {
            "abbreviatedOid": "1e540d7"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-09T19:41:20Z",
          "updatedAt": "2018-05-09T19:41:20Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Oh! Sorry, I got confused and read the text above as describing this example rather than the text below. Ignore me.",
              "createdAt": "2018-05-09T19:41:20Z",
              "updatedAt": "2018-05-09T19:41:20Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "aa37179e53c3b8d3808d4f9a745ddfa8f8c6e6a9",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "remove-rsa-no-tls",
      "headRefOid": "1e540d70c503d702cfe5af088e995154329eebc0",
      "mergeCommit": {
        "oid": "fa9ebf9e3ec7b900dad04966867769fabde24b90"
      }
    },
    {
      "number": 182,
      "id": "MDExOlB1bGxSZXF1ZXN0MTgyNTE0MTU5",
      "title": "Remove the \"Digest\" integrity header and bound MI record size.",
      "url": "https://github.com/WICG/webpackage/pull/182",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Digests require buffering the whole response body before determining that it's\r\nvalid, which unnecessarily increases the complexity in the verifier.\r\n\r\nThis change also puts a bound on the MI record size, also to limit the needed buffering.\r\n\r\n@davidben, have I explained the right reasons for doing this?\r\n\r\nFixes #138\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/remove-digest/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/remove-digest/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-04-18T15:16:40Z",
      "updatedAt": "2018-05-01T23:45:23Z",
      "closedAt": "2018-05-01T23:45:19Z",
      "mergedAt": "2018-05-01T23:45:18Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've now mentioned that motivation too.",
          "createdAt": "2018-05-01T23:43:42Z",
          "updatedAt": "2018-05-01T23:43:42Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTEzMzc1OTU4",
          "commit": {
            "abbreviatedOid": "e5b955d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Yup. Thanks!\r\n\r\nAnother motivation is just not having unnecessary options. Adding the digest option means the receiver needs to implement two modes, all so the sender has an option to save a for loop in their signer?",
          "createdAt": "2018-04-18T20:18:08Z",
          "updatedAt": "2018-04-18T20:18:08Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3f639391d047c945f43f2da0646e2a4b5c53fbb3",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "remove-digest",
      "headRefOid": "4c401a47cc760d420dec3dc04a15bbe056a54fb9",
      "mergeCommit": {
        "oid": "aa37179e53c3b8d3808d4f9a745ddfa8f8c6e6a9"
      }
    },
    {
      "number": 184,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg2NTEzOTI1",
      "title": "add signedexchange redirect README",
      "url": "https://github.com/WICG/webpackage/pull/184",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-08T02:52:42Z",
      "updatedAt": "2018-05-08T03:22:12Z",
      "closedAt": "2018-05-08T03:22:12Z",
      "mergedAt": "2018-05-08T03:22:11Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTE4MjE1MjMy",
          "commit": {
            "abbreviatedOid": "6484667"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-08T02:55:46Z",
          "updatedAt": "2018-05-08T02:55:46Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "aa37179e53c3b8d3808d4f9a745ddfa8f8c6e6a9",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "nyaxtReadMe",
      "headRefOid": "6484667a3b05a9dea62219c2dc578e05fe6051fc",
      "mergeCommit": {
        "oid": "ff1ef788f6d1f2940aedc1d5c2c6372934e8d28c"
      }
    },
    {
      "number": 189,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5MjY5NTQ5",
      "title": "Support latest envelope format",
      "url": "https://github.com/WICG/webpackage/pull/189",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #135 \r\nCorresponding spec change at f4ca17d1377bed966fdba85c03adbd798cfb5a96\r\n\r\n@jyasskin FYI",
      "createdAt": "2018-05-21T02:29:14Z",
      "updatedAt": "2018-05-22T01:49:38Z",
      "closedAt": "2018-05-22T01:49:38Z",
      "mergedAt": "2018-05-22T01:49:38Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxODQzMjI3",
          "commit": {
            "abbreviatedOid": "f55cc1c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-21T15:37:20Z",
          "updatedAt": "2018-05-21T15:47:45Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "`if _, err = signedexchange.Encode3BytesBigEndianUint(0x12345678); err != ...`",
              "createdAt": "2018-05-21T15:37:21Z",
              "updatedAt": "2018-05-22T01:47:34Z"
            },
            {
              "originalPosition": 29,
              "body": "Showing the got value and want value would be better",
              "createdAt": "2018-05-21T15:37:43Z",
              "updatedAt": "2018-05-22T01:47:34Z"
            },
            {
              "originalPosition": 83,
              "body": "`io.Copy` is better since `io.Copy` doesn't require successive memory region of `headerBuf.Length()`",
              "createdAt": "2018-05-21T15:40:43Z",
              "updatedAt": "2018-05-22T01:47:34Z"
            },
            {
              "originalPosition": 32,
              "body": "const?",
              "createdAt": "2018-05-21T15:47:27Z",
              "updatedAt": "2018-05-22T01:47:34Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2635cc5d8fc3177092806ce19826e9cd8f8461c9",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "new_envelope",
      "headRefOid": "ad0185088139fe92d5cf63e51189bf6a91b25592",
      "mergeCommit": {
        "oid": "221da8dbc8d042d92186d24860cc0e51b93ae960"
      }
    },
    {
      "number": 190,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5MjcyMzY1",
      "title": "Update structured header identifiers to lower-case",
      "url": "https://github.com/WICG/webpackage/pull/190",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Follow spec changes after #178 and 3fc67e270b4a89bed9a46732c985fd984c2a66d3\r\n\r\nFYI: @jyasskin ",
      "createdAt": "2018-05-21T03:01:31Z",
      "updatedAt": "2018-05-22T01:21:28Z",
      "closedAt": "2018-05-22T01:21:28Z",
      "mergedAt": "2018-05-22T01:21:28Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxODQyODQ2",
          "commit": {
            "abbreviatedOid": "0c51f3c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-21T15:36:12Z",
          "updatedAt": "2018-05-21T15:36:12Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "fa9ebf9e3ec7b900dad04966867769fabde24b90",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "cert-url",
      "headRefOid": "0c51f3c2db8f5b16ad84f36b172b808ba83986a6",
      "mergeCommit": {
        "oid": "2635cc5d8fc3177092806ce19826e9cd8f8461c9"
      }
    },
    {
      "number": 192,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5MjkyMzc1",
      "title": "Pad magic string to 8 bytes",
      "url": "https://github.com/WICG/webpackage/pull/192",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #191 ",
      "createdAt": "2018-05-21T06:21:37Z",
      "updatedAt": "2018-05-24T23:19:40Z",
      "closedAt": "2018-05-24T23:19:40Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Per discussion in #191, I think this isn't needed anymore.",
          "createdAt": "2018-05-24T23:19:40Z",
          "updatedAt": "2018-05-24T23:19:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIxOTczNDU3",
          "commit": {
            "abbreviatedOid": "e81185d"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-21T22:56:23Z",
          "updatedAt": "2018-05-21T22:56:23Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Especially since this already only leaves 3 bytes anyway, probably better to simply write:\r\n> and MUST use another 8-byte implementation-specific string beginning with \"sxg1-\".\r\n\r\nI.e. no sense in talking about padding schemes and such.",
              "createdAt": "2018-05-21T22:56:23Z",
              "updatedAt": "2018-05-21T22:56:37Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "fa9ebf9e3ec7b900dad04966867769fabde24b90",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "fixedlenmagic",
      "headRefOid": "e81185daf6529c1894bf4fc1e0cfdd1ddc2ec202",
      "mergeCommit": null
    },
    {
      "number": 193,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5NjA5NDI2",
      "title": "Update key strings in serializeSignedMessage to lower-case",
      "url": "https://github.com/WICG/webpackage/pull/193",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a follow-up to #190.\r\n\r\n#178 also changed the key strings in the canonical CBOR map.",
      "createdAt": "2018-05-22T10:04:29Z",
      "updatedAt": "2018-05-22T10:17:05Z",
      "closedAt": "2018-05-22T10:17:05Z",
      "mergedAt": "2018-05-22T10:17:05Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm. Thanks for the catch",
          "createdAt": "2018-05-22T10:16:31Z",
          "updatedAt": "2018-05-22T10:16:31Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyMTAzNzQ4",
          "commit": {
            "abbreviatedOid": "bdd4625"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-22T10:16:39Z",
          "updatedAt": "2018-05-22T10:16:39Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "221da8dbc8d042d92186d24860cc0e51b93ae960",
      "headRepository": null,
      "headRefName": "validity-url",
      "headRefOid": "bdd4625b8177153a6934ef9d31421d61deedf12c",
      "mergeCommit": {
        "oid": "c173772a4fb3c923d705a319e5e9f2fb1fd569d7"
      }
    },
    {
      "number": 194,
      "id": "MDExOlB1bGxSZXF1ZXN0MTg5ODIwNjA2",
      "title": "Fix the HTTP/1.1 exchanges to use Host headers instead of full URLs in the GET line.",
      "url": "https://github.com/WICG/webpackage/pull/194",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks to @triblondon for noticing in\r\nhttps://github.com/w3ctag/design-reviews/issues/235#issuecomment-379424440.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/fix-http1-samples/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/fix-http1-samples/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-05-22T23:37:49Z",
      "updatedAt": "2018-05-25T03:22:08Z",
      "closedAt": "2018-05-25T03:22:05Z",
      "mergedAt": "2018-05-25T03:22:05Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "How about `:path` + `:host` to deduplicate host?",
          "createdAt": "2018-05-23T02:25:36Z",
          "updatedAt": "2018-05-23T02:25:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It's more that the `Host` header isn't ever going to actually appear in the encoding. https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#same-origin-response doesn't allow it, and https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#application-signed-exchange lets the publisher pick their headers, and there's no reason for a publisher to include `Host` redundantly with the `:url`.\r\n\r\nDo you think it's ok to show the misleading mapping, or should I switch it to an HTTP/2 representation that doesn't have the Host header in the first place, or something else?",
          "createdAt": "2018-05-23T04:31:17Z",
          "updatedAt": "2018-05-23T04:31:17Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'd like to check my understanding first.\r\nAm I correct that:\r\n- The modified `3.2.1` example is only focused on how the http text format maps to CBOR representation\r\n  - It is out-of-scope of the section that the CBOR representation in the signature message may have filtered it out.\r\n  - It is possible but should be very rare for a signature message have `Host` request header in practice, since:\r\n     - application/signed-exchange packagers can choose to only include `:url` \r\n     - When transferring the exchange via H2, most servers would have no reason to include it in the list of Signed-Headers ",
          "createdAt": "2018-05-24T01:28:08Z",
          "updatedAt": "2018-05-24T01:28:08Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "(Question from @horo-t)\r\nDo you have any recommendation on how browsers should react if it received a signed exchange with conflicting `:url` and `Host` in its request headers?",
          "createdAt": "2018-05-24T01:29:20Z",
          "updatedAt": "2018-05-24T01:29:35Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "That all sounds correct. How does it sound to say that a signed exchange with conflicting `:url` and `Host` will never [be sufficiently similar to the browser's request](https://github.com/WICG/webpackage/blob/master/explainer.md#navigations-and-subresources-redirect)?",
          "createdAt": "2018-05-24T03:12:40Z",
          "updatedAt": "2018-05-24T03:12:40Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "SGTM",
          "createdAt": "2018-05-24T05:09:57Z",
          "updatedAt": "2018-05-24T05:09:57Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I felt bad about including the misleading `Host` headers, so I've now excluded them explicitly.",
          "createdAt": "2018-05-24T22:12:33Z",
          "updatedAt": "2018-05-24T22:12:33Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "still lgtm. I like the latest change better.",
          "createdAt": "2018-05-25T00:39:02Z",
          "updatedAt": "2018-05-25T00:39:02Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyODQ3MTQ3",
          "commit": {
            "abbreviatedOid": "3e7fffc"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-24T05:10:08Z",
          "updatedAt": "2018-05-24T05:10:08Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2aef2193856c0561c700c0cfae4e8c042f5fcb31",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fix-http1-samples",
      "headRefOid": "f99e91f117e909671a8739f72ccfe11db1bde47f",
      "mergeCommit": {
        "oid": "4910d72b57f4e92574a953f73cd07f67e3046b0f"
      }
    },
    {
      "number": 195,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwMDMxNDIy",
      "title": "Use the signature context string to distinguish draft versions.",
      "url": "https://github.com/WICG/webpackage/pull/195",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @sleevi for noticing the problem.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/include-version-in-sig-context/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/include-version-in-sig-context/draft-yasskin-http-origin-signed-responses.txt)\r\n",
      "createdAt": "2018-05-23T16:15:34Z",
      "updatedAt": "2018-05-24T20:38:13Z",
      "closedAt": "2018-05-24T20:38:10Z",
      "mergedAt": "2018-05-24T20:38:10Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "Happy to explain. This is about mitigation version rollback attacks. Right now, the version of the envelope is outside of the signed data. This creates the opportunity for an attacker to alter the version number, causing the signed data to be interpreted differently.\r\n\r\nIn Chromium, it came up in exploring the b0 to b1 transition, in which b0 ignores the OCSP response, but b1 requires it. An attacker could take a signed b1 response, mark it as b0, and bypass those security checks.\r\n\r\nSimilar to how X.509 certificates include the signature algorithm within the inner (signed) context, in addition to the outer envelope, or how TLS includes the version number as part of the session transcript, the goal is to ensure that the externally-negotiated properties (such as version) are also bound within the internal, signed content, to prevent any confusion issues. These are functionally the same as cross-protocol attacks, it just happens that its different versions of the same protocol (but functionally different protocols).\r\n\r\nThe general method of mitigating these cross-protocol attacks is using the context string, to ensure that distinct signatures are created for distinct protocols. This change is necessary, but I'm not entirely sure it's sufficient - if the Web Packaging protocol evolves over time / additional versions, the context string of those subsequent versions will still need to migrate.\r\n\r\nThus, it may make sense to explicitly include both versioning and draft numbers, of which the latter is more applicable here, and formalize that as an inherent part of the protocol. That's the sufficient part :)",
          "createdAt": "2018-05-23T18:31:01Z",
          "updatedAt": "2018-05-23T18:31:01Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "> I'm curious about the motivation\r\n\r\nAll signature payloads with the same key be distinguishable, otherwise an attacker can cause the verifier to misinterpret a signature made in one protocol as something else in a different protocol. This includes differences between different versions of the same protocol.\r\n\r\nAs a toy example, consider if one version signed request headers followed by response headers, and then another version switched the order. Without baking the version into the signature, I can trick the receiver into accepting a signed exchange different from what the origin actually signed.",
          "createdAt": "2018-05-23T18:31:34Z",
          "updatedAt": "2018-05-23T18:31:34Z"
        },
        {
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "body": "Ooops, I see Ryan and I crossed mid-stream! Hopefully some combination of the two is enlightening. :-)",
          "createdAt": "2018-05-23T18:32:01Z",
          "updatedAt": "2018-05-23T18:32:01Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm also happy to use \"HTTP Exchange 1\" as the standard context string with \"HTTP Exchange 1 b1\" as the pattern for draft strings, if y'all prefer. I don't think that changes anything substantively here: in either case, version 2 will use \"HTTP Exchange 2\" as its context string, and that'll be different from any of the options for v1.",
          "createdAt": "2018-05-23T18:44:39Z",
          "updatedAt": "2018-05-23T18:44:39Z"
        },
        {
          "author": "sleevi",
          "authorAssociation": "NONE",
          "body": "@jyasskin That sounds good, as it makes sure the expectation is setup in the base spec and so we remember to rev on any semantically-relevant change (overall) and on drafts :)",
          "createdAt": "2018-05-23T18:46:26Z",
          "updatedAt": "2018-05-23T18:46:26Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Done.",
          "createdAt": "2018-05-23T18:49:51Z",
          "updatedAt": "2018-05-23T18:49:51Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the explanations!",
          "createdAt": "2018-05-24T01:13:10Z",
          "updatedAt": "2018-05-24T01:13:10Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you add a ChangeLog entry too?",
          "createdAt": "2018-05-24T01:38:41Z",
          "updatedAt": "2018-05-24T01:38:41Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "> Would you add a ChangeLog entry too? \u2014 @nyaxt \r\n\r\nWhoops, thanks, done.",
          "createdAt": "2018-05-24T20:36:28Z",
          "updatedAt": "2018-05-24T20:36:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyNzEwMDMw",
          "commit": {
            "abbreviatedOid": "12fde52"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I'm curious about the motivation, but LGTM; thanks for the heads up!",
          "createdAt": "2018-05-23T18:23:41Z",
          "updatedAt": "2018-05-23T18:23:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyNzIwMDk4",
          "commit": {
            "abbreviatedOid": "b5caaa8"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-23T18:50:33Z",
          "updatedAt": "2018-05-23T18:50:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyODE0NDIz",
          "commit": {
            "abbreviatedOid": "b5caaa8"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-24T00:46:58Z",
          "updatedAt": "2018-05-24T00:46:58Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "da7b60d2dba16c6b7e1df8429a5115de0e39f7db",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "include-version-in-sig-context",
      "headRefOid": "d5732b69ccde30e03680ba22f760274aa63f6c36",
      "mergeCommit": {
        "oid": "2aef2193856c0561c700c0cfae4e8c042f5fcb31"
      }
    },
    {
      "number": 196,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkwMTYwNjcz",
      "title": "gen-certurl: Make -sct flag optional",
      "url": "https://github.com/WICG/webpackage/pull/196",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "As discussed in #171, the sct field of the cbor cert chain should be optional. (See also #175)\r\n\r\ncc: @jyasskin @horo-t",
      "createdAt": "2018-05-24T03:31:54Z",
      "updatedAt": "2018-07-17T05:18:22Z",
      "closedAt": "2018-05-24T05:08:24Z",
      "mergedAt": "2018-05-24T05:08:24Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIyODQ2ODg1",
          "commit": {
            "abbreviatedOid": "6f313c1"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-24T05:08:05Z",
          "updatedAt": "2018-05-24T05:08:05Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c173772a4fb3c923d705a319e5e9f2fb1fd569d7",
      "headRepository": null,
      "headRefName": "sct",
      "headRefOid": "6f313c13ddc4b60ee72d70a8361e86f8b30502e6",
      "mergeCommit": {
        "oid": "da7b60d2dba16c6b7e1df8429a5115de0e39f7db"
      }
    },
    {
      "number": 198,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxMDUzNzQy",
      "title": "Update magic string to sxg1-b1",
      "url": "https://github.com/WICG/webpackage/pull/198",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-29T07:22:33Z",
      "updatedAt": "2018-05-29T07:25:47Z",
      "closedAt": "2018-05-29T07:25:47Z",
      "mergedAt": "2018-05-29T07:25:47Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODcyODE0",
          "commit": {
            "abbreviatedOid": "c8d6d07"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-05-29T07:25:02Z",
          "updatedAt": "2018-05-29T07:25:02Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4910d72b57f4e92574a953f73cd07f67e3046b0f",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "sxg1-b1",
      "headRefOid": "c8d6d07ac70136cea55ded9fea198aa1b5cc3c4e",
      "mergeCommit": {
        "oid": "aa6e4bfd76f0f913d307ab8fecfe1c4b18bed14d"
      }
    },
    {
      "number": 199,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxMDU0OTgy",
      "title": "Update context string to follow #195",
      "url": "https://github.com/WICG/webpackage/pull/199",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-05-29T07:28:47Z",
      "updatedAt": "2018-05-29T09:29:31Z",
      "closedAt": "2018-05-29T09:29:31Z",
      "mergedAt": "2018-05-29T09:29:31Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "I think we should use a draft-specific string as noted in the spec, such as `\"HTTP Exchange 1 b1\"`.",
          "createdAt": "2018-05-29T07:48:44Z",
          "updatedAt": "2018-05-29T07:48:44Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODgzMjE0",
          "commit": {
            "abbreviatedOid": "ac9ccb8"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-29T08:01:48Z",
          "updatedAt": "2018-05-29T08:01:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODgzMzg4",
          "commit": {
            "abbreviatedOid": "ac9ccb8"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T08:02:22Z",
          "updatedAt": "2018-05-29T08:02:23Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Following the convention of Go, comments should start with `ContextString is...`.",
              "createdAt": "2018-05-29T08:02:23Z",
              "updatedAt": "2018-05-29T08:34:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODgzNTM4",
          "commit": {
            "abbreviatedOid": "ac9ccb8"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T08:02:54Z",
          "updatedAt": "2018-05-29T08:02:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Do we need to export this const? If not, this should be `contextString`",
              "createdAt": "2018-05-29T08:02:54Z",
              "updatedAt": "2018-05-29T08:34:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODkzNzQz",
          "commit": {
            "abbreviatedOid": "5e67631"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-05-29T08:33:55Z",
          "updatedAt": "2018-05-29T08:33:56Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done",
              "createdAt": "2018-05-29T08:33:55Z",
              "updatedAt": "2018-05-29T08:34:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTIzODk1NDgx",
          "commit": {
            "abbreviatedOid": "658001b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-29T08:38:35Z",
          "updatedAt": "2018-05-29T08:38:35Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "aa6e4bfd76f0f913d307ab8fecfe1c4b18bed14d",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "context_string_1",
      "headRefOid": "658001b2f25babff4043be706e3d685f6bdd0a35",
      "mergeCommit": {
        "oid": "e34d067841fb1d8750d28e69ee46e75c7a2a136b"
      }
    },
    {
      "number": 200,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkxNjI0OTA0",
      "title": "gen-signedexchange: Re-add the 64-byte signature padding",
      "url": "https://github.com/WICG/webpackage/pull/200",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Follows spec change after #180.",
      "createdAt": "2018-05-31T02:01:23Z",
      "updatedAt": "2018-05-31T03:30:25Z",
      "closedAt": "2018-05-31T03:30:18Z",
      "mergedAt": "2018-05-31T03:30:18Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0NjU3NDU4",
          "commit": {
            "abbreviatedOid": "6bb712e"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-05-31T02:57:08Z",
          "updatedAt": "2018-05-31T02:57:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI0NjYxMTI0",
          "commit": {
            "abbreviatedOid": "6bb712e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2018-05-31T03:30:25Z",
          "updatedAt": "2018-05-31T03:30:25Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f3459fa7b0cc1ed85f941137aa076ec549655394",
      "headRepository": null,
      "headRefName": "64spaces",
      "headRefOid": "6bb712e7be32d3af9600f1ad78e4ab25aaf6b755",
      "mergeCommit": {
        "oid": "01e618f6af1a0620b4956c5e83de1ee79e0690c1"
      }
    },
    {
      "number": 203,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkyNjE2MTAx",
      "title": "Fix the formatting in #index-section Step 3.7",
      "url": "https://github.com/WICG/webpackage/pull/203",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The leading `+` in L336 caused the markdown parser to interpret it as a new unordered list. This PR fixes it by moving the `+` to the end of previous line.",
      "createdAt": "2018-06-05T07:41:38Z",
      "updatedAt": "2018-06-06T08:04:17Z",
      "closedAt": "2018-06-06T08:04:17Z",
      "mergedAt": "2018-06-06T08:04:17Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI2MjcwNjA1",
          "commit": {
            "abbreviatedOid": "6740958"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Lol. Thank you.",
          "createdAt": "2018-06-06T08:03:51Z",
          "updatedAt": "2018-06-06T08:03:51Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "01e618f6af1a0620b4956c5e83de1ee79e0690c1",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "formatfix",
      "headRefOid": "6740958d15773ec2100a4dc6d5dd69d70ba23d14",
      "mergeCommit": {
        "oid": "cf19833ac903694f7c6971003ea48c27655263b8"
      }
    },
    {
      "number": 204,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzMTQ0NjIx",
      "title": "Add a test OID to the signed exchanges draft.",
      "url": "https://github.com/WICG/webpackage/pull/204",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Also change the content of the extension to an ASN.1 NULL.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/test-oid/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/test-oid/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\n@sleevi Is this right? Would you approve when the OID is actually allocated?",
      "createdAt": "2018-06-06T21:23:03Z",
      "updatedAt": "2018-06-08T11:54:32Z",
      "closedAt": "2018-06-08T11:54:24Z",
      "mergedAt": "2018-06-08T11:54:23Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3MDU1OTQ0",
          "commit": {
            "abbreviatedOid": "17a3d16"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-08T07:24:30Z",
          "updatedAt": "2018-06-08T07:24:38Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Would this mean we can make this with `openssl x509` by specifying `1.3.6.1.4.1.11129.2.1.22=DER:0500` in conf file?",
              "createdAt": "2018-06-08T07:24:30Z",
              "updatedAt": "2018-06-08T07:24:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3MDkwODYw",
          "commit": {
            "abbreviatedOid": "17a3d16"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-08T09:23:56Z",
          "updatedAt": "2018-06-08T09:23:57Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "You can also use \r\n`1.3.6.1.4.1.11129.2.1.22=ASN1:NULL` (as per https://www.openssl.org/docs/man1.0.2/crypto/ASN1_generate_nconf.html )",
              "createdAt": "2018-06-08T09:23:56Z",
              "updatedAt": "2018-06-08T09:23:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3MDkyMzQ1",
          "commit": {
            "abbreviatedOid": "17a3d16"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "The OID is now assigned.",
          "createdAt": "2018-06-08T09:28:35Z",
          "updatedAt": "2018-06-08T09:28:35Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cf19833ac903694f7c6971003ea48c27655263b8",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "test-oid",
      "headRefOid": "17a3d164ade70456e41253731c8ae4231df37615",
      "mergeCommit": {
        "oid": "d54c46939576bebd374f1a214eafa37c8ffc8911"
      }
    },
    {
      "number": 205,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzMjI5OTM0",
      "title": "Expose stateful header sets and make the check case-insensitive",
      "url": "https://github.com/WICG/webpackage/pull/205",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "HTTP Header names are case-insensitive.",
      "createdAt": "2018-06-07T07:41:32Z",
      "updatedAt": "2018-06-12T03:29:31Z",
      "closedAt": "2018-06-12T03:29:31Z",
      "mergedAt": "2018-06-12T03:29:31Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "PTAL",
          "createdAt": "2018-06-11T06:59:39Z",
          "updatedAt": "2018-06-11T06:59:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDQ1ODE4",
          "commit": {
            "abbreviatedOid": "d9a6281"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-11T06:32:42Z",
          "updatedAt": "2018-06-11T06:34:39Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "`if _, err = NewExchange(...); err == nil {`",
              "createdAt": "2018-06-11T06:32:42Z",
              "updatedAt": "2018-06-11T07:08:42Z"
            },
            {
              "originalPosition": 40,
              "body": "As we discussed offline, let's have functions instead of exposing variables.",
              "createdAt": "2018-06-11T06:34:35Z",
              "updatedAt": "2018-06-11T07:08:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDUwNTg1",
          "commit": {
            "abbreviatedOid": "c2e8c9b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with nits",
          "createdAt": "2018-06-11T06:59:54Z",
          "updatedAt": "2018-06-11T07:00:14Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "`for name := range requestHeaders {`",
              "createdAt": "2018-06-11T06:59:54Z",
              "updatedAt": "2018-06-11T07:08:42Z"
            },
            {
              "originalPosition": 39,
              "body": "ditto",
              "createdAt": "2018-06-11T07:00:01Z",
              "updatedAt": "2018-06-11T07:08:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDUyNDY2",
          "commit": {
            "abbreviatedOid": "368d65b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-11T07:09:00Z",
          "updatedAt": "2018-06-11T07:09:00Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "done",
              "createdAt": "2018-06-11T07:09:00Z",
              "updatedAt": "2018-06-11T07:09:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDUyNDc3",
          "commit": {
            "abbreviatedOid": "368d65b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-11T07:09:01Z",
          "updatedAt": "2018-06-11T07:09:01Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "done",
              "createdAt": "2018-06-11T07:09:01Z",
              "updatedAt": "2018-06-11T07:09:01Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cf19833ac903694f7c6971003ea48c27655263b8",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "lowercasechk",
      "headRefOid": "368d65b37005475216d7b73fcb44fe812070bd75",
      "mergeCommit": {
        "oid": "1afd132b8904f5f15177f07cb1d6ff52abee425c"
      }
    },
    {
      "number": 207,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzODYwNjc3",
      "title": "Small fixes for README.md to add/update some links",
      "url": "https://github.com/WICG/webpackage/pull/207",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add/update following links:\r\n* Bundled exchanges draft html\r\n* Loading sketch explainer\r\n* An additional link to chromium's testing repo that could be helpful for people who want to try out signed exchange tools",
      "createdAt": "2018-06-11T02:15:55Z",
      "updatedAt": "2018-06-12T18:33:52Z",
      "closedAt": "2018-06-11T03:01:01Z",
      "mergedAt": "2018-06-11T03:01:01Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2018-06-12T18:33:52Z",
          "updatedAt": "2018-06-12T18:33:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDIxNzIw",
          "commit": {
            "abbreviatedOid": "63f179e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-11T02:17:54Z",
          "updatedAt": "2018-06-11T02:17:54Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d54c46939576bebd374f1a214eafa37c8ffc8911",
      "headRepository": "kinu/webpackage",
      "headRefName": "readme-fix",
      "headRefOid": "63f179e856b94f1af5bda72f032ad1c09be826a7",
      "mergeCommit": {
        "oid": "9029215ad7a9e338f8f244a1e58fd17bf15fbd76"
      }
    },
    {
      "number": 208,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzODg3NTQ3",
      "title": "cmd: introduce dump-signedexchange tool",
      "url": "https://github.com/WICG/webpackage/pull/208",
      "state": "CLOSED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR introduces dump-exchange tool to pretty-print an signedexchange file.",
      "createdAt": "2018-06-11T06:48:29Z",
      "updatedAt": "2018-06-11T07:02:36Z",
      "closedAt": "2018-06-11T07:02:33Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you split the PR to only commit go/signedexchange/cbor/decoder* for now?\r\nPlease update the dump-signedexchange tool so that it can actually decode the file generated by gen-signedexchange",
          "createdAt": "2018-06-11T06:50:06Z",
          "updatedAt": "2018-06-11T06:50:06Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Sure, let me close this.",
          "createdAt": "2018-06-11T07:02:33Z",
          "updatedAt": "2018-06-11T07:02:33Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9029215ad7a9e338f8f244a1e58fd17bf15fbd76",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "cbor-decoder",
      "headRefOid": "96d3dbb66d0f627a91dde87dd7692e3635a75095",
      "mergeCommit": null
    },
    {
      "number": 209,
      "id": "MDExOlB1bGxSZXF1ZXN0MTkzODkwMTU4",
      "title": "cbor: Add decoder",
      "url": "https://github.com/WICG/webpackage/pull/209",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-11T07:04:41Z",
      "updatedAt": "2018-06-11T07:14:56Z",
      "closedAt": "2018-06-11T07:14:53Z",
      "mergedAt": "2018-06-11T07:14:53Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3NDUyNjM3",
          "commit": {
            "abbreviatedOid": "8fd857d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-11T07:09:43Z",
          "updatedAt": "2018-06-11T07:09:43Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9029215ad7a9e338f8f244a1e58fd17bf15fbd76",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "cbor-decoder",
      "headRefOid": "8fd857dfedae4d83e7bc2903d3f82dd94f75ff7c",
      "mergeCommit": {
        "oid": "4bec233ad99795b926af3afb8842a2c9cb4b36bd"
      }
    },
    {
      "number": 210,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0MTU5MDUw",
      "title": "Make MI encoding optional",
      "url": "https://github.com/WICG/webpackage/pull/210",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "WebBundling format doesn't require the payload to be MI encoded. This PR splits the encoding of the payload, so that it is possible to create an exchange without MI encoding.",
      "createdAt": "2018-06-12T03:48:08Z",
      "updatedAt": "2018-06-12T04:57:26Z",
      "closedAt": "2018-06-12T04:57:26Z",
      "mergedAt": "2018-06-12T04:57:26Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODE2NzU1",
          "commit": {
            "abbreviatedOid": "cdc2739"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T04:40:22Z",
          "updatedAt": "2018-06-12T04:40:45Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "This function no longer needs to return error?",
              "createdAt": "2018-06-12T04:40:22Z",
              "updatedAt": "2018-06-12T04:40:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODE4NTkx",
          "commit": {
            "abbreviatedOid": "cdc2739"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-12T04:57:11Z",
          "updatedAt": "2018-06-12T04:57:11Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "1afd132b8904f5f15177f07cb1d6ff52abee425c",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "senewapi",
      "headRefOid": "cdc2739f68e2be1649382dbea565f29dc603866d",
      "mergeCommit": {
        "oid": "72dc5d8c82c4314f5587021708b2053f277f0ec4"
      }
    },
    {
      "number": 211,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0MTc0Mzc0",
      "title": "Introduce gen-bundle tool to emit \"Bundled HTTP Exchanges\" [1]",
      "url": "https://github.com/WICG/webpackage/pull/211",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "[1] https://wicg.github.io/webpackage/draft-yasskin-dispatch-bundled-exchanges.html",
      "createdAt": "2018-06-12T06:05:51Z",
      "updatedAt": "2018-06-13T05:46:05Z",
      "closedAt": "2018-06-13T05:46:04Z",
      "mergedAt": "2018-06-13T05:46:04Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "PTAL",
          "createdAt": "2018-06-13T05:24:05Z",
          "updatedAt": "2018-06-13T05:24:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI3ODU2ODk4",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T08:07:13Z",
          "updatedAt": "2018-06-12T08:14:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "`headerMagicBytes` to be unexported?\r\n\r\nIf this is used only in `WriteBundle`, I'd move there.",
              "createdAt": "2018-06-12T08:07:13Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            },
            {
              "originalPosition": 15,
              "body": "`footerLength` in `writeFooter`",
              "createdAt": "2018-06-12T08:08:07Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            },
            {
              "originalPosition": 18,
              "body": "Do you have a plan to add members to the input? If no, just using slice would be enough.",
              "createdAt": "2018-06-12T08:08:54Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            },
            {
              "originalPosition": 4,
              "body": "Hmm, this sounds unsafe since payload can be modified on the caller side. At least we should have comments.",
              "createdAt": "2018-06-12T08:11:42Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            },
            {
              "originalPosition": 47,
              "body": "Where is error gone?",
              "createdAt": "2018-06-12T08:12:06Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MTY5NzYx",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T22:19:25Z",
          "updatedAt": "2018-06-12T22:19:25Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "The magic bytes are useful by itself. The clients can see if a given binary is a bundle or not.",
              "createdAt": "2018-06-12T22:19:25Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MTY5OTQ5",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T22:20:15Z",
          "updatedAt": "2018-06-12T22:20:15Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Yes. The implementation only encodes \"index\",\"responses\" sections atm, but there are other sections (such as manifest)",
              "createdAt": "2018-06-12T22:20:15Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MTcwMjc3",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-12T22:21:39Z",
          "updatedAt": "2018-06-12T22:21:39Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "The func uses named return vars",
              "createdAt": "2018-06-12T22:21:39Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MTk3MjQy",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T00:55:23Z",
          "updatedAt": "2018-06-13T00:55:23Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Ack",
              "createdAt": "2018-06-13T00:55:23Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjI5OTA2",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T05:23:02Z",
          "updatedAt": "2018-06-13T05:23:02Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2018-06-13T05:23:02Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjI5OTg4",
          "commit": {
            "abbreviatedOid": "889e6c9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T05:23:35Z",
          "updatedAt": "2018-06-13T05:23:36Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Done.",
              "createdAt": "2018-06-13T05:23:35Z",
              "updatedAt": "2018-06-13T05:23:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjMxMDYz",
          "commit": {
            "abbreviatedOid": "bc30d4f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T05:31:30Z",
          "updatedAt": "2018-06-13T05:31:34Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'm against exposing a `[]byte`.\r\n\r\n> The clients can see if a given binary is a bundle or not.\r\n\r\nWould it be possible to add a function to do that?",
              "createdAt": "2018-06-13T05:31:31Z",
              "updatedAt": "2018-06-13T05:31:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjMyOTky",
          "commit": {
            "abbreviatedOid": "bc30d4f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-13T05:43:27Z",
          "updatedAt": "2018-06-13T05:43:38Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Discussed offline, and we compromised this since there is no good substitution.",
              "createdAt": "2018-06-13T05:43:28Z",
              "updatedAt": "2018-06-13T05:43:38Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "72dc5d8c82c4314f5587021708b2053f277f0ec4",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "bundler3",
      "headRefOid": "bc30d4fc5abafa2d122cabc47ca18d81299b5cf9",
      "mergeCommit": {
        "oid": "76526bb8c8520e30e5fde888b6f771da07e3cead"
      }
    },
    {
      "number": 213,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0NDc2NTg0",
      "title": "Rename bundle.{Input => Bundle}, and bundle.{WriteBundle => Write}",
      "url": "https://github.com/WICG/webpackage/pull/213",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To prepare for bundle.Read",
      "createdAt": "2018-06-13T05:46:19Z",
      "updatedAt": "2018-06-13T06:07:20Z",
      "closedAt": "2018-06-13T06:07:19Z",
      "mergedAt": "2018-06-13T06:07:19Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjMzNzU0",
          "commit": {
            "abbreviatedOid": "10a75a0"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-13T05:48:46Z",
          "updatedAt": "2018-06-13T05:48:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "optional: How about implementing `WriteTo`?\r\n\r\nhttps://golang.org/pkg/io/#WriterTo",
              "createdAt": "2018-06-13T05:48:46Z",
              "updatedAt": "2018-06-13T05:59:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjM1NDIx",
          "commit": {
            "abbreviatedOid": "baa5726"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-13T05:59:51Z",
          "updatedAt": "2018-06-13T05:59:51Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Done",
              "createdAt": "2018-06-13T05:59:51Z",
              "updatedAt": "2018-06-13T05:59:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4MjM1OTc3",
          "commit": {
            "abbreviatedOid": "f0d7ade"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "still lgtm",
          "createdAt": "2018-06-13T06:03:56Z",
          "updatedAt": "2018-06-13T06:03:56Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "76526bb8c8520e30e5fde888b6f771da07e3cead",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "renameWriteBundle",
      "headRefOid": "f0d7aded4dfd170154eb9d1eae77c061861d30c8",
      "mergeCommit": {
        "oid": "94bef39ff4a117d6bb542d0386f5d250a440b2fa"
      }
    },
    {
      "number": 215,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0NzQ0OTM4",
      "title": "Update to draft-ietf-httpbis-header-structure-06.",
      "url": "https://github.com/WICG/webpackage/pull/215",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I believe this is just updates to section numbers, and the addition of ABNF for the headers.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/update-structured-headers/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/update-structured-headers/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-06-13T23:45:31Z",
      "updatedAt": "2018-06-14T03:09:52Z",
      "closedAt": "2018-06-14T03:09:48Z",
      "mergedAt": "2018-06-14T03:09:48Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori Would you check this?",
          "createdAt": "2018-06-14T01:29:55Z",
          "updatedAt": "2018-06-14T01:29:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NjIwNDAw",
          "commit": {
            "abbreviatedOid": "e3712f9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-14T01:55:49Z",
          "updatedAt": "2018-06-14T01:55:49Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI4NjIxMTY4",
          "commit": {
            "abbreviatedOid": "e3712f9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-14T02:01:35Z",
          "updatedAt": "2018-06-14T02:01:35Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ff4f9084675f17d4deb7885b2f1a49016c5a4e19",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-structured-headers",
      "headRefOid": "e3712f9a8db418c1473de62656752a54caec6ae6",
      "mergeCommit": {
        "oid": "638fdfcb69e8c7b32e8c4a6f00f36e249eb72680"
      }
    },
    {
      "number": 216,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk0NzQ1NzE5",
      "title": "Add IANA registrations for Accept-Signature and Signed-Headers headers.",
      "url": "https://github.com/WICG/webpackage/pull/216",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/register-headers/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/register-headers/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-06-13T23:51:33Z",
      "updatedAt": "2018-06-14T03:10:21Z",
      "closedAt": "2018-06-14T03:10:17Z",
      "mergedAt": "2018-06-14T03:10:17Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "LGTM",
          "createdAt": "2018-06-14T00:36:08Z",
          "updatedAt": "2018-06-14T00:36:08Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ff4f9084675f17d4deb7885b2f1a49016c5a4e19",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "register-headers",
      "headRefOid": "1e03e7dde90e0d8044dffe16d60846782614669b",
      "mergeCommit": {
        "oid": "fdc8c06f6fbdb529f0d9ba736257bf8ce7449609"
      }
    },
    {
      "number": 217,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MDQ3MzUz",
      "title": "Editorial: double quote all section names",
      "url": "https://github.com/WICG/webpackage/pull/217",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-14T23:54:58Z",
      "updatedAt": "2018-06-15T00:03:14Z",
      "closedAt": "2018-06-15T00:03:14Z",
      "mergedAt": "2018-06-15T00:03:14Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MDA5NTQ1",
          "commit": {
            "abbreviatedOid": "54526c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Oops, thanks.",
          "createdAt": "2018-06-15T00:02:59Z",
          "updatedAt": "2018-06-15T00:02:59Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ea7e7ff94ba9677b3ec920c02ad6d1264bb77247",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "formatfix2",
      "headRefOid": "54526c25723f32e51de6ab6d9665c24ba8399b16",
      "mergeCommit": {
        "oid": "e8c037bfb7a4db89579a02ef47767a3317b89996"
      }
    },
    {
      "number": 218,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MDQ4MzU3",
      "title": "Add note about `ignoredSections`",
      "url": "https://github.com/WICG/webpackage/pull/218",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "There doesn't seem to be a section that \"says not to process other sections\" as of now. Can we omit the steps until we have one?",
      "createdAt": "2018-06-15T00:03:32Z",
      "updatedAt": "2018-06-18T18:35:50Z",
      "closedAt": "2018-06-18T18:35:50Z",
      "mergedAt": "2018-06-18T18:35:50Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is here so that a future specification can define a section that replaces another one without needing to re-release this specification. This step definitely doesn't need to appear in an implementation until it implements a section that says to ignore another one, but to remove it from the specification, I'd want an argument that this kind of section is fundamentally a bad idea.",
          "createdAt": "2018-06-15T00:06:54Z",
          "updatedAt": "2018-06-15T00:06:54Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Got it.\r\n\r\nI was a bit confused when I was implementing the steps line-by-line. Would it be able to add a note how this is going to be used in future?",
          "createdAt": "2018-06-15T00:13:41Z",
          "updatedAt": "2018-06-15T00:13:41Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "If you were confused, it probably deserves a note. Do you want to try to word it, or should I try next week?",
          "createdAt": "2018-06-15T00:46:01Z",
          "updatedAt": "2018-06-15T00:46:01Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Tried something. PTAL",
          "createdAt": "2018-06-15T03:34:18Z",
          "updatedAt": "2018-06-15T03:34:18Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MjM3Njk1",
          "commit": {
            "abbreviatedOid": "bdfc665"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-15T16:29:47Z",
          "updatedAt": "2018-06-15T16:38:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "s/supercedes/supercede/",
              "createdAt": "2018-06-15T16:29:47Z",
              "updatedAt": "2018-06-18T00:41:41Z"
            },
            {
              "originalPosition": 5,
              "body": "How about\r\n\r\n> Implementations that don't implement any such sections are free to omit the relevant steps.\r\n\r\nsince even after we add such a section to the registry, implementations that don't implement it will still be able to skip the `ignoredSections` steps.\r\n\r\nI expect to get some pushback based on the fact that implementations are [always allowed to differ from the specified steps as long as they get the same answer](https://infra.spec.whatwg.org/#algorithms).",
              "createdAt": "2018-06-15T16:38:26Z",
              "updatedAt": "2018-06-18T00:41:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NDA2OTUz",
          "commit": {
            "abbreviatedOid": "bdfc665"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-18T00:26:21Z",
          "updatedAt": "2018-06-18T00:26:54Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2018-06-18T00:26:21Z",
              "updatedAt": "2018-06-18T00:41:41Z"
            },
            {
              "originalPosition": 5,
              "body": "That sounds much better! Applied.",
              "createdAt": "2018-06-18T00:26:24Z",
              "updatedAt": "2018-06-18T00:41:41Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c4aa55888d462b72f42ab36def91c29baba19fc9",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "noprocessother",
      "headRefOid": "34aff1c845b0e8ef5b7ddf903927dcfb692af09a",
      "mergeCommit": {
        "oid": "c6ba5817324c3f58be4517e7c430442cdeade649"
      }
    },
    {
      "number": 219,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1MDc2OTMz",
      "title": "Editorial: the map variable should be sectionOffsets",
      "url": "https://github.com/WICG/webpackage/pull/219",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-15T04:49:06Z",
      "updatedAt": "2018-06-15T16:40:22Z",
      "closedAt": "2018-06-15T16:40:22Z",
      "mergedAt": "2018-06-15T16:40:22Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5MjQwNzI4",
          "commit": {
            "abbreviatedOid": "854ddb7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-06-15T16:40:12Z",
          "updatedAt": "2018-06-15T16:40:12Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e8c037bfb7a4db89579a02ef47767a3317b89996",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "parseIdxNits",
      "headRefOid": "854ddb7fb25a887d410f6e0be07ed18ece19749b",
      "mergeCommit": {
        "oid": "c4aa55888d462b72f42ab36def91c29baba19fc9"
      }
    },
    {
      "number": 220,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1NDA0ODI5",
      "title": "Fix reference to headerCbor",
      "url": "https://github.com/WICG/webpackage/pull/220",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-18T01:06:18Z",
      "updatedAt": "2018-06-18T18:53:21Z",
      "closedAt": "2018-06-18T18:53:21Z",
      "mergedAt": "2018-06-18T18:53:21Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NjkyNjA4",
          "commit": {
            "abbreviatedOid": "f0ecbbd"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-06-18T18:52:34Z",
          "updatedAt": "2018-06-18T18:52:34Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c4aa55888d462b72f42ab36def91c29baba19fc9",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "fixrefresp",
      "headRefOid": "f0ecbbddc3320448683816102361acc6ba1375a8",
      "mergeCommit": {
        "oid": "53a11461ffdc37d7f4c6d84553d66423ccb8a5d6"
      }
    },
    {
      "number": 223,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1NDE3NzA3",
      "title": "dump-bundle: Introduce dump-bundle tool which implements bundled",
      "url": "https://github.com/WICG/webpackage/pull/223",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "exchange semantics",
      "createdAt": "2018-06-18T04:06:18Z",
      "updatedAt": "2018-06-22T01:33:30Z",
      "closedAt": "2018-06-22T01:33:29Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing this. Please review #230 instead",
          "createdAt": "2018-06-22T01:33:29Z",
          "updatedAt": "2018-06-22T01:33:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5NDI0ODA3",
          "commit": {
            "abbreviatedOid": "c570cd9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Sounds fine, but I'll take a deeper look at this later",
          "createdAt": "2018-06-18T04:26:53Z",
          "updatedAt": "2018-06-18T04:28:20Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "Why isn't this fixed now?",
              "createdAt": "2018-06-18T04:26:54Z",
              "updatedAt": "2018-06-18T04:28:20Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c4aa55888d462b72f42ab36def91c29baba19fc9",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "dump-bundle3",
      "headRefOid": "c570cd935809d10076656bbe128d0cc0bc9658d4",
      "mergeCommit": null
    },
    {
      "number": 224,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1Njc2MDI5",
      "title": "Update readme",
      "url": "https://github.com/WICG/webpackage/pull/224",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Feel free to land via rebase if everything looks good.",
      "createdAt": "2018-06-18T23:31:18Z",
      "updatedAt": "2018-06-19T05:50:59Z",
      "closedAt": "2018-06-19T05:50:31Z",
      "mergedAt": "2018-06-19T05:50:31Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5ODE4Mzkw",
          "commit": {
            "abbreviatedOid": "b957f8f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-19T05:04:29Z",
          "updatedAt": "2018-06-19T05:04:29Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "53a11461ffdc37d7f4c6d84553d66423ccb8a5d6",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-readme",
      "headRefOid": "b957f8fee06ab12d7aa2b2755d659df67da95a0a",
      "mergeCommit": {
        "oid": "14edb7ae061a8693e407ab2ba9931fd3b482b33d"
      }
    },
    {
      "number": 225,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1Njc2NjI2",
      "title": "Fix #202: Link to the Metadata field's definition.",
      "url": "https://github.com/WICG/webpackage/pull/225",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "[Preview](https://jyasskin.github.io/webpackage/link-metadata/draft-yasskin-wpack-bundled-exchanges.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.txt&url2=https://jyasskin.github.io/webpackage/link-metadata/draft-yasskin-wpack-bundled-exchanges.txt)\r\n\r\n@nyaxt How's this?",
      "createdAt": "2018-06-18T23:35:40Z",
      "updatedAt": "2018-06-19T05:50:50Z",
      "closedAt": "2018-06-19T05:50:46Z",
      "mergedAt": "2018-06-19T05:50:46Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTI5ODE4NDI4",
          "commit": {
            "abbreviatedOid": "9af7827"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-19T05:04:51Z",
          "updatedAt": "2018-06-19T05:04:51Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "53a11461ffdc37d7f4c6d84553d66423ccb8a5d6",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "link-metadata",
      "headRefOid": "9af7827c71448d359fd2779cbb9cc1dd74497e4e",
      "mergeCommit": {
        "oid": "115bb9a600cca5c4e2a35d0bd0c43ae4bace63db"
      }
    },
    {
      "number": 226,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk1OTkwNDAw",
      "title": "In both random-access maps, store the index and contents in the same order.",
      "url": "https://github.com/WICG/webpackage/pull/226",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [
        "bundled-exchanges"
      ],
      "body": "[Preview](https://jyasskin.github.io/webpackage/ordered-responses/draft-yasskin-wpack-bundled-exchanges.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.txt&url2=https://jyasskin.github.io/webpackage/ordered-responses/draft-yasskin-wpack-bundled-exchanges.txt)\r\n\r\nThis lets us store only lengths in the index, and compute offsets from\r\nthem, which in turn enforces that the contents don't overlap and don't\r\nhave gaps, making the content array well-formed CBOR.\r\n\r\nThis applies to both the section index and the request index.\r\n\r\nFixes #212.\r\n\r\nLet me know if you see any places that the parser still isn't checking that the bundle is well-formed CBOR.",
      "createdAt": "2018-06-20T00:08:17Z",
      "updatedAt": "2018-06-22T19:33:29Z",
      "closedAt": "2018-06-22T18:51:37Z",
      "mergedAt": "2018-06-22T18:51:36Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I love this change. Looks great on a first pass. I'll take a closer look later today.",
          "createdAt": "2018-06-20T00:28:28Z",
          "updatedAt": "2018-06-20T00:28:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwMjM2MDY3",
          "commit": {
            "abbreviatedOid": "a389864"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T04:24:52Z",
          "updatedAt": "2018-06-20T04:29:22Z",
          "comments": [
            {
              "originalPosition": 205,
              "body": "Should we remove the sentence \"That is, offsets in the index are relative to the start of the \"responses\" section.\"?",
              "createdAt": "2018-06-20T04:24:52Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            },
            {
              "originalPosition": 165,
              "body": "Should we scope this step (+its substeps) to parsing the responses array header?",
              "createdAt": "2018-06-20T04:27:46Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            },
            {
              "originalPosition": 176,
              "body": "Then, we can have this say:\r\nLet `currentOffset` be the ...\r\n\r\nwithout Step 2.",
              "createdAt": "2018-06-20T04:28:10Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNTY1NDgw",
          "commit": {
            "abbreviatedOid": "a389864"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-20T20:00:34Z",
          "updatedAt": "2018-06-20T20:46:13Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Sure.",
              "createdAt": "2018-06-20T20:00:34Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            },
            {
              "originalPosition": 205,
              "body": "Whoops, done.",
              "createdAt": "2018-06-20T20:41:41Z",
              "updatedAt": "2018-06-22T18:48:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNjM2MTMx",
          "commit": {
            "abbreviatedOid": "e1a382e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-21T00:50:37Z",
          "updatedAt": "2018-06-21T00:50:37Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3903da6eb6c613f2ab5250f8e6a97709d4f4f0ff",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "ordered-responses",
      "headRefOid": "aecebb874443f09897ca1425d6b60b46e51fa18f",
      "mergeCommit": {
        "oid": "7eb57935f50f0230a5102f47f5739073a8b63db2"
      }
    },
    {
      "number": 227,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2MjA0NzU4",
      "title": "Fix typo",
      "url": "https://github.com/WICG/webpackage/pull/227",
      "state": "MERGED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Two instances of receipient => recipient",
      "createdAt": "2018-06-20T16:38:53Z",
      "updatedAt": "2018-06-20T16:44:55Z",
      "closedAt": "2018-06-20T16:44:55Z",
      "mergedAt": "2018-06-20T16:44:55Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNDkwNDMw",
          "commit": {
            "abbreviatedOid": "926ba81"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-06-20T16:44:47Z",
          "updatedAt": "2018-06-20T16:44:47Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7aaf0d1271c2410bc8074898eaecaa9ecdcde13d",
      "headRepository": "EverlastingBugstopper/webpackage",
      "headRefName": "master",
      "headRefOid": "926ba81a21733effa33b1ce5a63b238b2503bfb2",
      "mergeCommit": {
        "oid": "fa5167d9f5691a435eb82b2d6457989c18854699"
      }
    },
    {
      "number": 228,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2MzA0OTQ0",
      "title": "Limit the allowed schemes for URLs.",
      "url": "https://github.com/WICG/webpackage/pull/228",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "And clarify the definition of \"absolute URL\".\r\n\r\nFixes #222.\r\n\r\n@kinu \r\n\r\n[Preview](https://jyasskin.github.io/webpackage/filter-schemes/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/filter-schemes/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-06-21T00:14:30Z",
      "updatedAt": "2018-06-21T04:03:14Z",
      "closedAt": "2018-06-21T02:30:43Z",
      "mergedAt": "2018-06-21T02:30:43Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! lgtm.",
          "createdAt": "2018-06-21T00:56:37Z",
          "updatedAt": "2018-06-21T00:56:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@twifkak I should have double-checked with you before merging this. Let me know if I've gotten the right set of schemes in each location.",
          "createdAt": "2018-06-21T02:32:10Z",
          "updatedAt": "2018-06-21T02:32:10Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "No worries; this LGTM.",
          "createdAt": "2018-06-21T04:03:14Z",
          "updatedAt": "2018-06-21T04:03:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMwNjM1ODkx",
          "commit": {
            "abbreviatedOid": "283cc4f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-21T00:48:37Z",
          "updatedAt": "2018-06-21T00:48:37Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "fa5167d9f5691a435eb82b2d6457989c18854699",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "filter-schemes",
      "headRefOid": "283cc4f2b85515781f678f834efb21005a632e8c",
      "mergeCommit": {
        "oid": "3903da6eb6c613f2ab5250f8e6a97709d4f4f0ff"
      }
    },
    {
      "number": 230,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2NjE3MDM0",
      "title": "Introduce dump-bundle tool and follow #226 format",
      "url": "https://github.com/WICG/webpackage/pull/230",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-22T01:32:53Z",
      "updatedAt": "2018-06-28T07:36:14Z",
      "closedAt": "2018-06-28T07:36:14Z",
      "mergedAt": "2018-06-28T07:36:14Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxMDUwNzcw",
          "commit": {
            "abbreviatedOid": "8928763"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-22T02:33:10Z",
          "updatedAt": "2018-06-22T02:37:16Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "`if err := ... ; err {`",
              "createdAt": "2018-06-22T02:33:11Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            },
            {
              "originalPosition": 26,
              "body": "Why do we need to introduce a struct for a option? Isn't just an argument enough so far? My expectation is `Dump`'s signature is changeable though `Dump` is exported.",
              "createdAt": "2018-06-22T02:34:07Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNTA4MjY0",
          "commit": {
            "abbreviatedOid": "8928763"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-06-25T08:20:56Z",
          "updatedAt": "2018-06-25T08:26:57Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I'd name `DeocdeUint` (small i) or `DeocdeUint64`.",
              "createdAt": "2018-06-25T08:20:56Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            },
            {
              "originalPosition": 6,
              "body": "I was wondering where this method is called. As this exposes a mutable value, I'd want to avoid this.",
              "createdAt": "2018-06-25T08:26:22Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            },
            {
              "originalPosition": 12,
              "body": "ditto",
              "createdAt": "2018-06-25T08:26:52Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxODY2NTA4",
          "commit": {
            "abbreviatedOid": "8928763"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-26T05:11:59Z",
          "updatedAt": "2018-06-26T05:11:59Z",
          "comments": [
            {
              "originalPosition": 37,
              "body": "Done",
              "createdAt": "2018-06-26T05:11:59Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxODY2NzMy",
          "commit": {
            "abbreviatedOid": "8928763"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "PTAL",
          "createdAt": "2018-06-26T05:13:48Z",
          "updatedAt": "2018-06-28T05:04:13Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done",
              "createdAt": "2018-06-26T05:13:49Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            },
            {
              "originalPosition": 26,
              "body": "Done",
              "createdAt": "2018-06-26T05:20:56Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjkxNjI2",
          "commit": {
            "abbreviatedOid": "7735a91"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-28T05:36:38Z",
          "updatedAt": "2018-06-28T05:48:15Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "As HTTP status is represented as an integer in `net/http` package, let's use an integer here.",
              "createdAt": "2018-06-28T05:36:39Z",
              "updatedAt": "2018-06-28T05:52:17Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3903da6eb6c613f2ab5250f8e6a97709d4f4f0ff",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "bundle-newfmt",
      "headRefOid": "2184ee55cf7421c3163b0226c39c0f4522386522",
      "mergeCommit": {
        "oid": "4c2ab911d453c4a43cbf954ef36a550d18f94d4f"
      }
    },
    {
      "number": 231,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2Nzg0Mjg1",
      "title": "Rename id-ce-testCanSignHttpExchanges to id-ce-canSignHttpExchangesDraft",
      "url": "https://github.com/WICG/webpackage/pull/231",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Per @sleevi's suggestion.\r\n\r\nFixes #229.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/rename-test-oid/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/rename-test-oid/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-06-22T16:19:05Z",
      "updatedAt": "2018-12-01T00:34:29Z",
      "closedAt": "2018-06-25T01:47:11Z",
      "mergedAt": "2018-06-25T01:47:11Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDQzMjY4",
          "commit": {
            "abbreviatedOid": "689d7da"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-25T00:36:10Z",
          "updatedAt": "2018-06-25T00:36:10Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDQ0MzY3",
          "commit": {
            "abbreviatedOid": "689d7da"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-25T00:54:27Z",
          "updatedAt": "2018-06-25T00:54:27Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7eb57935f50f0230a5102f47f5739073a8b63db2",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "rename-test-oid",
      "headRefOid": "689d7da40708296df20f87a5b1c27e8b68653073",
      "mergeCommit": {
        "oid": "55ac8bdf4adc7c68a14ce901187faa292f16f284"
      }
    },
    {
      "number": 232,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk2ODY4Njcy",
      "title": "Start the -impl-01 draft.",
      "url": "https://github.com/WICG/webpackage/pull/232",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I think this catches everything that we're expecting to be different or missing in the Chrome 69 implementation vs the main spec. Let me know if I've missed anything.\r\n\r\nFixes #186.",
      "createdAt": "2018-06-23T00:04:28Z",
      "updatedAt": "2018-07-09T18:41:40Z",
      "closedAt": "2018-07-09T18:41:36Z",
      "mergedAt": "2018-07-09T18:41:36Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM.\r\n\r\nShould we put tentative values on TBD size limits?",
          "createdAt": "2018-06-25T01:46:54Z",
          "updatedAt": "2018-06-25T01:46:54Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM",
          "createdAt": "2018-07-06T22:11:12Z",
          "updatedAt": "2018-07-06T22:11:12Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDQ4MDQw",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-25T01:46:04Z",
          "updatedAt": "2018-06-25T01:46:04Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDQ4MjUz",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T01:48:31Z",
          "updatedAt": "2018-06-25T01:48:32Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "For M69, we currently plan to support only single signature for an exchange.",
              "createdAt": "2018-06-25T01:48:32Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDY3MzEz",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-25T04:53:02Z",
          "updatedAt": "2018-06-25T05:18:35Z",
          "comments": [
            {
              "originalPosition": 703,
              "body": "Should we use \"mi-sha256\" or \"mi-sha256-draft2\" here?\r\n(@kinu and I can go with either, but want to clarify your decision on this)\r\n\r\nFor more context, I was wondering if this should be \"mi-sha256-draft2\", but noticed that https://github.com/martinthomson/http-mice/pull/8 isn't merged yet and mice draft02 expired in May.",
              "createdAt": "2018-06-25T04:53:03Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1201,
              "body": "Looks like this actually went away in draft-01?",
              "createdAt": "2018-06-25T04:53:59Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 107,
              "body": "[tangentially related]\r\nWhile the header-structure spec's 04->06 diff doesn't affect signed exchange much, we were wondering if the header spec would also apply to \"Content-Type\" header someday, since it disallows identifier being an `item`.\r\nWith the change, `v=b1` is invalid and it has to be `v=\"b1\"`.\r\n\r\nWhen parsing signed exchange, Chrome Canary currently allows both `v=b1` and `v=\"b1\"` so we are good here.\r\nHowever, we might want to change the Accept header to say `v=\"b1\"`",
              "createdAt": "2018-06-25T05:18:30Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNDA2MzQz",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM; only nits and naive questions.",
          "createdAt": "2018-06-30T00:09:19Z",
          "updatedAt": "2018-06-30T01:51:00Z",
          "comments": [
            {
              "originalPosition": 347,
              "body": "s/first item/first map/ (or s/first/second/)",
              "createdAt": "2018-06-30T00:09:19Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 355,
              "body": "Is this optional to allow for the possibility of an intermediate fetching and attaching it?",
              "createdAt": "2018-06-30T00:18:46Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 359,
              "body": "Should this be s/Each/The first/?",
              "createdAt": "2018-06-30T00:22:28Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 359,
              "body": "Also, s/value/value if any/ per {#cross-origin-trust}?",
              "createdAt": "2018-06-30T00:24:07Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 462,
              "body": "1. Does this mean the choice cannot depend on the signature_algorithms_cert extension?\r\n2. Can the choice be \"always return invalid\"? (That appears to be [what chromium does](https://cs.chromium.org/chromium/src/content/browser/web_package/signed_exchange_signature_verifier.cc?l=183&rcl=b7527b9711e28030e03ad438ba323af7142ce43b) IIUC.)\r\n\r\n(Pardon my naivety!)",
              "createdAt": "2018-06-30T01:00:00Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 607,
              "body": "s/to/if it wishes to/? (i.e. A client may use `thirdpartysig` without updating the others if it validates and meets its needs?)",
              "createdAt": "2018-06-30T01:06:04Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 699,
              "body": "s/digest/mi/",
              "createdAt": "2018-06-30T01:08:31Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1002,
              "body": "Should this be updated to remove the reference to the \"non-signed header section\", or perhaps the above \"`sigLength` bytes\" item clarified to be named that?",
              "createdAt": "2018-06-30T01:37:46Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1022,
              "body": "IIUC, the 3-byte header length should precede the signature value.",
              "createdAt": "2018-06-30T01:44:42Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1141,
              "body": "Should there be an implementation draft note for this, too?",
              "createdAt": "2018-06-30T01:48:10Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM0MTk4NDkz",
          "commit": {
            "abbreviatedOid": "2718c06"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-03T23:21:28Z",
          "updatedAt": "2018-07-06T21:22:50Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "The Structured Headers proposal doesn't intend to change existing headers' definitions, and practically I don't think it could change them in backward-incompatible ways like that.",
              "createdAt": "2018-07-03T23:21:28Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 347,
              "body": "Good catch. This needs to change in the main spec too.",
              "createdAt": "2018-07-03T23:22:13Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 359,
              "body": "Yep, SCTs might be embedded elsewhere.",
              "createdAt": "2018-07-03T23:23:48Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 355,
              "body": "I'm not sure why that says \"if any\"... It might date from when I thought intermediate certs could have OCSP responses.",
              "createdAt": "2018-07-03T23:24:23Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 462,
              "body": "1. I think so. Note that [signature_algorithms_cert](https://tlswg.github.io/tls13-spec/draft-ietf-tls-tls13.html#signature-algorithms) is a TLS option, which isn't really in effect when parsing a signed exchange.\r\n\r\n2. Yep. Supporting just one kind of public key is reasonable.",
              "createdAt": "2018-07-03T23:28:35Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 607,
              "body": "Yeah.",
              "createdAt": "2018-07-03T23:29:25Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 699,
              "body": "Oops.",
              "createdAt": "2018-07-03T23:29:37Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 703,
              "body": "I think \"mi-draft2/mi-sha256-draft2\" since we don't want to opt into the final RFC by mistake. (And I'm mostly ignoring expirations of Internet-Drafts.)",
              "createdAt": "2018-07-03T23:30:50Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1002,
              "body": "Yep, I'll refer to the signature instead of the non-signed headers.",
              "createdAt": "2018-07-03T23:31:47Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1022,
              "body": "Yep.",
              "createdAt": "2018-07-03T23:32:32Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1201,
              "body": "It's coming back. The change wasn't totally finished.",
              "createdAt": "2018-07-03T23:33:15Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 1141,
              "body": "Yes.",
              "createdAt": "2018-07-03T23:34:03Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            },
            {
              "originalPosition": 90,
              "body": "Thanks.",
              "createdAt": "2018-07-03T23:51:16Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTcxMTY4",
          "commit": {
            "abbreviatedOid": "d19cde6"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-06T22:12:34Z",
          "updatedAt": "2018-07-06T22:12:35Z",
          "comments": [
            {
              "originalPosition": 462,
              "body": "Out of curiosity, is there a specific \"other context\" that this language intends to prevent?",
              "createdAt": "2018-07-06T22:12:35Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTcyNDA3",
          "commit": {
            "abbreviatedOid": "35f0e3a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-06T22:20:29Z",
          "updatedAt": "2018-07-06T22:20:29Z",
          "comments": [
            {
              "originalPosition": 462,
              "body": "For example, lots of signature formats, like [JWS](https://tools.ietf.org/html/rfc7515#section-5.2), include an algorithm name in the signature in addition to a public key identifier. This allows some silly things like https://www.sjoerdlangkemper.nl/2016/09/28/attacking-jwt-authentication/.",
              "createdAt": "2018-07-06T22:20:29Z",
              "updatedAt": "2018-07-06T22:54:30Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ffa1046c76aabbb1e0ddc39325f8e8b553b26972",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "next-impl-draft",
      "headRefOid": "08267a11e6103c1541e44683dcbec834f31a6a5d",
      "mergeCommit": {
        "oid": "409d1780683d37fe5f0e4209af01164abd93bf22"
      }
    },
    {
      "number": 233,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3MDA5NDQ1",
      "title": "gen-signedexchange: Follow changes in #228",
      "url": "https://github.com/WICG/webpackage/pull/233",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-25T06:03:51Z",
      "updatedAt": "2018-06-25T06:52:56Z",
      "closedAt": "2018-06-25T06:52:56Z",
      "mergedAt": "2018-06-25T06:52:56Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMxNDgxMDI1",
          "commit": {
            "abbreviatedOid": "e811c46"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-06-25T06:33:05Z",
          "updatedAt": "2018-06-25T06:33:05Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "55ac8bdf4adc7c68a14ce901187faa292f16f284",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "restrict-https",
      "headRefOid": "e811c46b8c9914123d8b670c99804dea91f253a0",
      "mergeCommit": {
        "oid": "7ff595433768e7f71bc0f0dfbd48b71b347ebdb6"
      }
    },
    {
      "number": 235,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk3NzkxNjI2",
      "title": "Fixes #234: mi-sha256 should be base64 encoded",
      "url": "https://github.com/WICG/webpackage/pull/235",
      "state": "MERGED",
      "author": "ioggstream",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "The examples show a mi-sha256 hexdigest instead of bas64 encoding,\r\n\r\nsee https://github.com/martinthomson/http-mice/blob/master/draft-thomson-http-mice.md",
      "createdAt": "2018-06-27T16:45:45Z",
      "updatedAt": "2018-07-02T22:41:29Z",
      "closedAt": "2018-07-02T22:41:01Z",
      "mergedAt": "2018-07-02T22:41:01Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNjU3OTk2",
          "commit": {
            "abbreviatedOid": "c8ca724"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T01:00:42Z",
          "updatedAt": "2018-06-28T01:12:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I was wondering if this should be\r\n```\r\nMI: mi-sha256=*dcRDgR2GM35DluAV13PzgnG6-pvQwPywfFvAu1UeFrs==*\r\n```\r\n\r\nbut it looks like https://martinthomson.github.io/http-mice/draft-thomson-http-mice.html#header refers to RFC7230 and RFC7231, not https://tools.ietf.org/html/draft-ietf-httpbis-header-structure-06 yet.",
              "createdAt": "2018-06-28T01:00:42Z",
              "updatedAt": "2018-06-28T09:22:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNzI5NjY2",
          "commit": {
            "abbreviatedOid": "c8ca724"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T08:14:00Z",
          "updatedAt": "2018-06-28T08:14:01Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@nyaxt right, MICE doesn't use structured headers.\r\n\r\nOT: where can I ask questions/discuss on other parts of this proposal?",
              "createdAt": "2018-06-28T08:14:00Z",
              "updatedAt": "2018-06-28T09:22:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNzQxMjg5",
          "commit": {
            "abbreviatedOid": "c8ca724"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T08:41:10Z",
          "updatedAt": "2018-06-28T08:41:48Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "https://martinthomson.github.io/http-mice/draft-thomson-http-mice.html#mi-header-field-parameters says that the value is base64url encoding [[RFC7515](https://tools.ietf.org/html/rfc7515)], which does not have padding '=' characters.",
              "createdAt": "2018-06-28T08:41:10Z",
              "updatedAt": "2018-06-28T09:22:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMyNzYwMjQ2",
          "commit": {
            "abbreviatedOid": "d5a65e2"
          },
          "author": "ioggstream",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-28T09:23:08Z",
          "updatedAt": "2018-06-28T09:23:08Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "@irori thx++ :D",
              "createdAt": "2018-06-28T09:23:08Z",
              "updatedAt": "2018-06-28T09:23:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzNzk5NzIw",
          "commit": {
            "abbreviatedOid": "d5a65e2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks for catching this!",
          "createdAt": "2018-07-02T22:39:29Z",
          "updatedAt": "2018-07-02T22:39:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzODAwMDgx",
          "commit": {
            "abbreviatedOid": "d5a65e2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-02T22:41:28Z",
          "updatedAt": "2018-07-02T22:41:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "OT: Filing issues here is great. :)",
              "createdAt": "2018-07-02T22:41:29Z",
              "updatedAt": "2018-07-02T22:41:29Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7ff595433768e7f71bc0f0dfbd48b71b347ebdb6",
      "headRepository": "ioggstream/webpackage",
      "headRefName": "patch-1",
      "headRefOid": "d5a65e259336cbb89e21d94f895f031c3ab81ae1",
      "mergeCommit": {
        "oid": "18956cbd9342c70f37f3943a84584c9faa633bac"
      }
    },
    {
      "number": 239,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4MjMzNDAw",
      "title": "go/bundle: add README.md",
      "url": "https://github.com/WICG/webpackage/pull/239",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-06-29T07:13:03Z",
      "updatedAt": "2018-06-29T11:18:27Z",
      "closedAt": "2018-06-29T11:18:27Z",
      "mergedAt": "2018-06-29T11:18:27Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "lgtm, thanks!",
          "createdAt": "2018-06-29T09:23:21Z",
          "updatedAt": "2018-06-29T09:23:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTIxNDk1",
          "commit": {
            "abbreviatedOid": "6c8178b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:19:41Z",
          "updatedAt": "2018-06-29T07:20:17Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "`go get -u github.com/WICG/webpackage/go/bundle/cmd/...` would work to install all the binaries.",
              "createdAt": "2018-06-29T07:19:42Z",
              "updatedAt": "2018-06-29T08:55:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTI1OTM0",
          "commit": {
            "abbreviatedOid": "6c8178b"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T07:38:44Z",
          "updatedAt": "2018-06-29T07:38:51Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Should `foo.webbundle` be `foo.wbn` per https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.6.1 ?",
              "createdAt": "2018-06-29T07:38:44Z",
              "updatedAt": "2018-06-29T08:55:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTQ4MTE5",
          "commit": {
            "abbreviatedOid": "6c8178b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-06-29T08:55:40Z",
          "updatedAt": "2018-06-29T08:55:50Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done.",
              "createdAt": "2018-06-29T08:55:40Z",
              "updatedAt": "2018-06-29T08:55:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzMTc1MTUy",
          "commit": {
            "abbreviatedOid": "0775728"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-06-29T10:26:24Z",
          "updatedAt": "2018-06-29T10:26:24Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4c2ab911d453c4a43cbf954ef36a550d18f94d4f",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "readme2",
      "headRefOid": "0775728cf599cc8c0cb65a95b388f829f7ea22b0",
      "mergeCommit": {
        "oid": "0550d6cbcafa9a94a2c9488f10c09407a69b5719"
      }
    },
    {
      "number": 240,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4ODM4ODIz",
      "title": "gen-certurl: Fix usage messages",
      "url": "https://github.com/WICG/webpackage/pull/240",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-03T03:12:40Z",
      "updatedAt": "2018-07-03T07:20:18Z",
      "closedAt": "2018-07-03T07:20:18Z",
      "mergedAt": "2018-07-03T07:20:18Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzODY3Njcy",
          "commit": {
            "abbreviatedOid": "4f27c6a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-03T06:52:46Z",
          "updatedAt": "2018-07-03T06:52:46Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "18956cbd9342c70f37f3943a84584c9faa633bac",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "gen-certurl-usagefix",
      "headRefOid": "4f27c6a321ad65dfd6fefe0a0f389a21dfa5ea3b",
      "mergeCommit": {
        "oid": "17106833ba1e49fe838f6784e03c55de76dfacd5"
      }
    },
    {
      "number": 241,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk4ODUxODAz",
      "title": "gen-signedexchange: Add detailed README.md",
      "url": "https://github.com/WICG/webpackage/pull/241",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "cc: @kinu ",
      "createdAt": "2018-07-03T05:15:19Z",
      "updatedAt": "2018-07-04T03:23:18Z",
      "closedAt": "2018-07-04T03:23:18Z",
      "mergedAt": "2018-07-04T03:23:18Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Since the review UI is getting difficult and @irori and @davidben are OOO, I'll tentatively merge this and open an issue asking for post-merge review.",
          "createdAt": "2018-07-04T03:23:13Z",
          "updatedAt": "2018-07-04T03:23:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzODUxMDY2",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-03T05:15:54Z",
          "updatedAt": "2018-07-03T05:15:54Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "@irori I'm not sure if this is good. Do you have any suggestion here?",
              "createdAt": "2018-07-03T05:15:54Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzOTUyMTky",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-03T11:18:37Z",
          "updatedAt": "2018-07-03T11:51:30Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "go/signedexchange?",
              "createdAt": "2018-07-03T11:18:37Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 52,
              "body": "As long as you use Chrome with `--ignore-certificate-errors-spki-list`, this is fine.\r\n\r\n`-sct` should be optional (if not, we should fix `gen-certurl`), so we can omit it.\r\n\r\nFor OCSP, we should be able to use `openssl ocsp` to set up an OCSP responder and generate an OCSP response, but it would complicate this instructions even further.",
              "createdAt": "2018-07-03T11:50:37Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTMzOTc0MzEw",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Looking pretty good, thanks! (Made bunch of comments but all cosmetic)",
          "createdAt": "2018-07-03T12:31:52Z",
          "updatedAt": "2018-07-03T12:47:17Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "nit: constructs HTTP request ... -> constructs an HTTP request and response pair\r\n\r\nattach a -> attaches the\r\n\r\nto output file -> to an output file, or to the given output file",
              "createdAt": "2018-07-03T12:31:52Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 11,
              "body": "nit: a X.509 -> an X.509",
              "createdAt": "2018-07-03T12:33:54Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 13,
              "body": "nit: as a golang lib",
              "createdAt": "2018-07-03T12:34:23Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 28,
              "body": "nit: a signed exchange file that is signed using a self-signed certificate pair.",
              "createdAt": "2018-07-03T12:36:05Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 30,
              "body": "an HTTPS server\r\n\r\nstatic content -> static contents",
              "createdAt": "2018-07-03T12:36:13Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 37,
              "body": "nit: use a self signed certificate\r\n\r\nthere are no CA that issues -> there are no CAs that issue\r\n\r\n'signed exchange compatible' -> 'signed-exchange compatible' might be easier to read (optional)",
              "createdAt": "2018-07-03T12:37:48Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 74,
              "body": "Might be useful to note the version numbers too?",
              "createdAt": "2018-07-03T12:46:29Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM0MTYyNjYx",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-07-03T20:42:43Z",
          "updatedAt": "2018-07-03T21:04:58Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "I believe it's only a reference implementation to generate signed exchanges, rather than the whole spec?",
              "createdAt": "2018-07-03T20:42:43Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 11,
              "body": "Since `gen-certurl` accepts an OCSP response and SCT, I'd say \r\n\r\n> ... converts an X.509 certificate chain, an OCSP response, and an SCT (if one isn't already included in the certificate or OCSP response) to `application/cert-chain+cbor` ...",
              "createdAt": "2018-07-03T20:44:15Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 18,
              "body": "s/golang environment/The golang environment/\r\ns/on latest golang/on the latest golang/ or \"on the latest version of Go\"\r\ns/to [Go/to the [Go/\r\nMaybe s/golang/Go/g: I don't think the Go docs ever talk about \"golang\".",
              "createdAt": "2018-07-03T20:45:39Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 30,
              "body": "I would keep \"static content\". I think that's because \"content\" is used as a [mass noun](https://en.wikipedia.org/wiki/Mass_noun) for internet content, even though it can turn into \"contents\" when describing the contents of a box (but the content of a box would be fine too ... if you're thinking of all of the content as one notional thing ...). Sorry about English.",
              "createdAt": "2018-07-03T20:51:11Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 32,
              "body": "Maybe s/content/payload/ here, to match the HTTP term.",
              "createdAt": "2018-07-03T20:55:18Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 37,
              "body": "Or 'signed-exchange-compatible': https://en.wikipedia.org/wiki/Hyphen#Compound_modifiers",
              "createdAt": "2018-07-03T20:57:10Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 42,
              "body": "@davidben Could you double-check this series of commands?",
              "createdAt": "2018-07-03T20:59:36Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 73,
              "body": "s/supporting signed exchange/supporting signed exchanges/",
              "createdAt": "2018-07-03T21:02:06Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM0MjEzNzk2",
          "commit": {
            "abbreviatedOid": "97e7d49"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks for your review",
          "createdAt": "2018-07-04T01:22:39Z",
          "updatedAt": "2018-07-04T01:48:20Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Done",
              "createdAt": "2018-07-04T01:22:39Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 3,
              "body": "We plan to add the envelope parser later, but yes. Corrected.",
              "createdAt": "2018-07-04T01:23:19Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 9,
              "body": "Done",
              "createdAt": "2018-07-04T01:24:03Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 11,
              "body": "Done.",
              "createdAt": "2018-07-04T01:24:12Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 11,
              "body": "Taken",
              "createdAt": "2018-07-04T01:24:41Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 13,
              "body": "Done",
              "createdAt": "2018-07-04T01:24:50Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 18,
              "body": "Done.",
              "createdAt": "2018-07-04T01:25:32Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 28,
              "body": "Done",
              "createdAt": "2018-07-04T01:26:01Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 30,
              "body": "Did s/a/an",
              "createdAt": "2018-07-04T01:27:17Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2018-07-04T01:27:27Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 37,
              "body": "Took signed-exchange-compatible",
              "createdAt": "2018-07-04T01:27:56Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 52,
              "body": "Hmm. Leaving this as is for now. @irori would you mind updating here next week?",
              "createdAt": "2018-07-04T01:32:43Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 73,
              "body": "Done",
              "createdAt": "2018-07-04T01:33:09Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            },
            {
              "originalPosition": 74,
              "body": "Done",
              "createdAt": "2018-07-04T01:47:38Z",
              "updatedAt": "2018-07-04T01:49:06Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "17106833ba1e49fe838f6784e03c55de76dfacd5",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "readme-gense2",
      "headRefOid": "60fd7c7331c52bebb8a4e00b7139c8cc2f45feae",
      "mergeCommit": {
        "oid": "12b16a409fc7922b7e31808254bedb7e94563fef"
      }
    },
    {
      "number": 244,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5MTMwMzU5",
      "title": "Remove test headers from example firebase.json",
      "url": "https://github.com/WICG/webpackage/pull/244",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-04T03:25:44Z",
      "updatedAt": "2018-07-23T16:49:13Z",
      "closedAt": "2018-07-04T07:20:36Z",
      "mergedAt": "2018-07-04T07:20:36Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM0MjQ1Nzkw",
          "commit": {
            "abbreviatedOid": "6ae38d1"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-04T06:02:10Z",
          "updatedAt": "2018-07-04T06:02:10Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "12b16a409fc7922b7e31808254bedb7e94563fef",
      "headRepository": "WICG/webpackage",
      "headRefName": "fix-firebasejson",
      "headRefOid": "6ae38d198cfa22dd751fa2aa18a31c0b2e7a54ea",
      "mergeCommit": {
        "oid": "ffa1046c76aabbb1e0ddc39325f8e8b553b26972"
      }
    },
    {
      "number": 246,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5ODQ3ODMz",
      "title": "Several small fixes noticed by twifkak",
      "url": "https://github.com/WICG/webpackage/pull/246",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "* Certificate chains have an array item before the first certificate.\r\n* The first certificate's OCSP response was described as optional when\r\n  it's not.\r\n* The first certificate's SCT was *not* described as optional, but it\r\n  can appear in the certificate itself or the OCSP response.\r\n* \"digest/mi-sha256\" doesn't make sense.\r\n* There's no longer a non-signed headers section in SXG files.\r\n* An example had lengths in the wrong order.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/devin-cleanups/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/devin-cleanups/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2018-07-06T21:08:16Z",
      "updatedAt": "2018-07-10T03:38:37Z",
      "closedAt": "2018-07-10T03:38:33Z",
      "mergedAt": "2018-07-10T03:38:33Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTU3MDA2",
          "commit": {
            "abbreviatedOid": "853f04d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-06T21:10:20Z",
          "updatedAt": "2018-07-06T21:10:21Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "@davidben I think this matches what we actually want (OCSP is required on 1st cert & forbidden on later ones; SCT is optional everywhere), but I want to double-check with you in case I'm forgetting something. https://github.com/WICG/webpackage/pull/122/files#r169830552 has our previous discussion on the topic.",
              "createdAt": "2018-07-06T21:10:20Z",
              "updatedAt": "2018-07-06T21:20:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTY3MDcy",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for backporting the nits! I think you also intended to add an implementation draft note at https://github.com/WICG/webpackage/pull/246/files#diff-a2197f2cbc199dc1463dc10213fa40d9R1380 to change the magic number, per https://github.com/WICG/webpackage/pull/232#discussion-diff-199309577R1146.",
          "createdAt": "2018-07-06T21:52:47Z",
          "updatedAt": "2018-07-06T21:52:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MjcwMzY0",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-09T03:56:05Z",
          "updatedAt": "2018-07-09T03:56:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTgxOTkx",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T20:35:30Z",
          "updatedAt": "2018-07-09T20:35:30Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "@sleevi, David deferred to you on this. I'm finding myself a little uncomfortable having a different rule for SCTs on intermediate certs vs OCSP responses on intermediates, but I don't have a strong preference for which policy we have. I suspect it'll be easier to relax a rule that they're all forbidden on intermediates than to tighten a rule that they're allowed. Even if they're allowed in the format, of course, Chrome wouldn't need to process them.",
              "createdAt": "2018-07-09T20:35:30Z",
              "updatedAt": "2018-07-09T20:35:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NjEwMTcw",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T22:05:35Z",
          "updatedAt": "2018-07-09T22:05:35Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I'm not sure I understand the question. Are you asking whether it's ok to MUST NOT SCTs in subsequent certs, similar to OCSP? Or whether it's OK to relax the MUST NOT for OCSP? Or something different?",
              "createdAt": "2018-07-09T22:05:35Z",
              "updatedAt": "2018-07-09T22:05:35Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NjEwNTM1",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T22:07:00Z",
          "updatedAt": "2018-07-09T22:07:00Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "The question is basically, \"Is the new text right, and if not, what should I say instead?\"",
              "createdAt": "2018-07-09T22:07:00Z",
              "updatedAt": "2018-07-09T22:07:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NjEyOTA1",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T22:16:57Z",
          "updatedAt": "2018-07-09T22:16:57Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "So, for the normative changes:\r\n* OCSP now required, at least for the first cert (if any -> MUST)\r\n* CT now optional (MUST -> if any)\r\n\r\nIf so, that's correct.\r\n\r\nAs to any asymmetry between the two:\r\nOCSP on every cert is similar to OCSP Multi-stapling ( https://tools.ietf.org/html/rfc6961 ) in <= TLS 1.2 or the TLS 1.3 Certificate frame ( https://tools.ietf.org/html/draft-ietf-tls-tls13-28#section-4.4.2 ), for which the Extensions structure allows an OCSP response or an SCT for each individual certificate presented in the handshake. In those cases, both are optional (e.g. a TLS1.2 server could only support status_request extension), but allowed for every cert.\r\n\r\nThis is slightly different - OCSP is required by policy for the first cert, and forbidden for subsequent certs. I could see the MUST NOT be reduced to a SHOULD NOT in the cases where a browser's whitelist might not handle it (e.g. technically constrained sub-CA certs), but, meh.\r\n\r\nSo... Yes, the change and motivation look good. I could also see explicitly forbidding SCTs on subsequent certs to parallel the OCSP case, for the same reasons and motivations.",
              "createdAt": "2018-07-09T22:16:57Z",
              "updatedAt": "2018-07-09T22:16:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NjEzODc4",
          "commit": {
            "abbreviatedOid": "ae5ff94"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-09T22:21:23Z",
          "updatedAt": "2018-07-09T22:21:23Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Ok, thanks. I'll leave the new text as I have it since you don't say it's important for the two to be symmetric.",
              "createdAt": "2018-07-09T22:21:23Z",
              "updatedAt": "2018-07-09T22:21:23Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ffa1046c76aabbb1e0ddc39325f8e8b553b26972",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "devin-cleanups",
      "headRefOid": "ae5ff94347db2b0ac66fbc4bced4e0f597a7f9be",
      "mergeCommit": {
        "oid": "c68f0cc7eed08b6e7a4b2de014f2ea44efc2b277"
      }
    },
    {
      "number": 247,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5ODY4NTM2",
      "title": "Make the CanSignHttpExchanges extension non-critical.",
      "url": "https://github.com/WICG/webpackage/pull/247",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "But warn servers away from using it in TLS servers.\r\n\r\nFixes #238.\r\n\r\n@sleevi and any CA folks who see this, do you think I'm right to say \"Conforming CAs MUST NOT mark this extension as critical.\", or should I leave them without a requirement here?\r\n\r\nSpec: [Preview](https://jyasskin.github.io/webpackage/non-critical-extension/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/non-critical-extension/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nImpl draft: [Preview](https://jyasskin.github.io/webpackage/non-critical-extension/draft-yasskin-httpbis-origin-signed-exchanges-impl.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt&url2=https://jyasskin.github.io/webpackage/non-critical-extension/draft-yasskin-httpbis-origin-signed-exchanges-impl.txt)",
      "createdAt": "2018-07-06T23:54:04Z",
      "updatedAt": "2018-07-18T15:49:10Z",
      "closedAt": "2018-07-18T15:49:04Z",
      "mergedAt": "2018-07-18T15:49:04Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ok, @sleevi, I've moved the whole rationale to the security considerations. That section is a bit awkward: I could try to move some bits into 6.2 or 6.4, or decide that we don't need the full explanation at all, or just keep what I have.",
          "createdAt": "2018-07-09T20:27:22Z",
          "updatedAt": "2018-07-09T20:27:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MTg1NjUw",
          "commit": {
            "abbreviatedOid": "226f4ef"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "CHANGES_REQUESTED",
          "body": "A few nits, but overall looking good :)",
          "createdAt": "2018-07-07T00:12:31Z",
          "updatedAt": "2018-07-07T00:16:17Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "I don't think we'd want to include the second sentence in the spec. That is, it presumes that new clients use the OS verifier, or that they even have an OS verifier, which... isn't going to hold :)",
              "createdAt": "2018-07-07T00:12:31Z",
              "updatedAt": "2018-07-09T20:28:24Z"
            },
            {
              "originalPosition": 15,
              "body": "I think the motivation might be better detailed in security considerations.\r\n\r\nThe reason this is a bit tricky is that by virtue of non-critical, clients that don't recognize this extension WILL accept this extension in TLS connections. So we don't have a hard security boundary. Because of this motivation, it seems like it makes sense to be discussed in the security section, calling out that this is not a security boundary itself, but simply an ecosystem health thing.",
              "createdAt": "2018-07-07T00:14:16Z",
              "updatedAt": "2018-07-09T20:28:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTIxMDQ3",
          "commit": {
            "abbreviatedOid": "3ffea7c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2018-07-13T06:43:48Z",
          "updatedAt": "2018-07-13T06:43:48Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "409d1780683d37fe5f0e4209af01164abd93bf22",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "non-critical-extension",
      "headRefOid": "3ffea7c6105b1f40c2231e1807f46d46b8de072a",
      "mergeCommit": {
        "oid": "112fa93af900b43aafe88791be1d190ad96934e7"
      }
    },
    {
      "number": 249,
      "id": "MDExOlB1bGxSZXF1ZXN0MTk5OTg2NTM1",
      "title": "Address review comments from #245",
      "url": "https://github.com/WICG/webpackage/pull/249",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-09T04:03:30Z",
      "updatedAt": "2018-07-13T05:05:34Z",
      "closedAt": "2018-07-13T05:05:33Z",
      "mergedAt": "2018-07-13T05:05:33Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1NTA5ODk2",
          "commit": {
            "abbreviatedOid": "511a2a4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-09T17:07:37Z",
          "updatedAt": "2018-07-09T17:07:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Maybe \"to the domain you own and want to sign the exchange for\" or \"to the domain for which you want to sign the exchange\". I'm not sure how much we want to emphasize domain ownership vs just assuming that people can only get certs for their own domains.",
              "createdAt": "2018-07-09T17:07:37Z",
              "updatedAt": "2018-07-13T03:48:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2ODk4MjIy",
          "commit": {
            "abbreviatedOid": "511a2a4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-13T03:48:29Z",
          "updatedAt": "2018-07-13T03:48:29Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks. Suggestion taken.",
              "createdAt": "2018-07-13T03:48:29Z",
              "updatedAt": "2018-07-13T03:48:43Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "feed7c10ae8f5bbb28ad357910725c37a6bd0b58",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "readme-review",
      "headRefOid": "88f0481af85faa181a58c53cc46f55116e66293e",
      "mergeCommit": {
        "oid": "419ec9d25b719ace18fc8f646d60141048737a8b"
      }
    },
    {
      "number": 250,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwMDEzNjE1",
      "title": "gen-certurl: make sct command-line flag optional",
      "url": "https://github.com/WICG/webpackage/pull/250",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Address #243 ",
      "createdAt": "2018-07-09T07:32:03Z",
      "updatedAt": "2018-07-09T07:47:27Z",
      "closedAt": "2018-07-09T07:47:27Z",
      "mergedAt": "2018-07-09T07:47:27Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1MzA0OTEw",
          "commit": {
            "abbreviatedOid": "a19db34"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Ah I missed this, thanks. LGTM",
          "createdAt": "2018-07-09T07:40:03Z",
          "updatedAt": "2018-07-09T07:40:03Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ffa1046c76aabbb1e0ddc39325f8e8b553b26972",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "sctopt",
      "headRefOid": "a19db34d6008aa52c022a56a3e31536a7c3e0cec",
      "mergeCommit": {
        "oid": "39b2b762e9c697dcf43c932a19fcfeaafa29aa3a"
      }
    },
    {
      "number": 251,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwMzEwNjUz",
      "title": "signedexchange: Expose struct members",
      "url": "https://github.com/WICG/webpackage/pull/251",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR exposes all the members of `Exchange` for consistency.",
      "createdAt": "2018-07-10T07:56:17Z",
      "updatedAt": "2018-07-10T14:40:41Z",
      "closedAt": "2018-07-10T14:40:37Z",
      "mergedAt": "2018-07-10T14:40:36Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1ODQ4Nzk4",
          "commit": {
            "abbreviatedOid": "1d83ab0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-10T14:24:01Z",
          "updatedAt": "2018-07-10T14:24:01Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c68f0cc7eed08b6e7a4b2de014f2ea44efc2b277",
      "headRepository": "WICG/webpackage",
      "headRefName": "expose",
      "headRefOid": "1d83ab08fed48e5904deb3cea9bdc5a0d4d30eed",
      "mergeCommit": {
        "oid": "feed7c10ae8f5bbb28ad357910725c37a6bd0b58"
      }
    },
    {
      "number": 252,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAwMzY4MDU5",
      "title": "signedexchange: Implement dump-signedexchange command",
      "url": "https://github.com/WICG/webpackage/pull/252",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-10T11:42:55Z",
      "updatedAt": "2018-07-13T06:24:40Z",
      "closedAt": "2018-07-13T06:24:36Z",
      "mergedAt": "2018-07-13T06:24:36Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1ODQ5MzIy",
          "commit": {
            "abbreviatedOid": "ca93c1b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-10T14:25:05Z",
          "updatedAt": "2018-07-10T14:27:28Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Out of curiosity, what's the rationale for the change?",
              "createdAt": "2018-07-10T14:25:05Z",
              "updatedAt": "2018-07-13T06:20:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM1ODU2NDE0",
          "commit": {
            "abbreviatedOid": "ca93c1b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-10T14:39:09Z",
          "updatedAt": "2018-07-10T14:39:33Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "No strong reason. I'd want to avoid copying arrays and pass slices instead. Perhaps `Encode3Byte...` should be fixed in the same way for consistency, or we should keep `[3]byte` here for consistency. I prefer slices, but both are fine to me.",
              "createdAt": "2018-07-10T14:39:09Z",
              "updatedAt": "2018-07-13T06:20:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2ODk2ODQx",
          "commit": {
            "abbreviatedOid": "ca93c1b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-13T03:37:10Z",
          "updatedAt": "2018-07-13T03:37:15Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Let's keep it `[3]byte` then, or please provide reference to coding standards, etc. ",
              "createdAt": "2018-07-13T03:37:10Z",
              "updatedAt": "2018-07-13T06:20:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTEwOTE2",
          "commit": {
            "abbreviatedOid": "130c475"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-13T05:40:08Z",
          "updatedAt": "2018-07-13T05:40:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2018-07-13T05:40:08Z",
              "updatedAt": "2018-07-13T06:20:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTE2Njgx",
          "commit": {
            "abbreviatedOid": "130c475"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-13T06:18:42Z",
          "updatedAt": "2018-07-13T06:18:42Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a3ef919033510fdb0ae99a3eb0cbb97bc910db7b",
      "headRepository": "WICG/webpackage",
      "headRefName": "dump-signedexchange",
      "headRefOid": "60748f6bc87c3a4431fffa51448829977a19cae9",
      "mergeCommit": {
        "oid": "026d54f9f0ecfc0a5e442e8d51f96ea211c2ed75"
      }
    },
    {
      "number": 254,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxMTcyMTU3",
      "title": "gen-certurl: Fetch OCSP response from network if -ocsp is omitted",
      "url": "https://github.com/WICG/webpackage/pull/254",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-13T02:28:19Z",
      "updatedAt": "2018-07-13T06:03:31Z",
      "closedAt": "2018-07-13T06:03:01Z",
      "mergedAt": "2018-07-13T06:03:01Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "- Would you add test for this? (separate PR is fine)\r\n- Can we dedupe pem parsing? (separate PR is fine)",
          "createdAt": "2018-07-13T03:35:38Z",
          "updatedAt": "2018-07-13T03:35:38Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "PTAL\r\n\r\nTest added. Let me do pem cleanup in a separate PR.",
          "createdAt": "2018-07-13T05:02:40Z",
          "updatedAt": "2018-07-13T05:02:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2ODkzOTkx",
          "commit": {
            "abbreviatedOid": "3889ddb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-13T03:11:53Z",
          "updatedAt": "2018-07-13T03:11:53Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTA3MTcx",
          "commit": {
            "abbreviatedOid": "9c582d6"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-13T05:07:40Z",
          "updatedAt": "2018-07-13T05:07:40Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "feed7c10ae8f5bbb28ad357910725c37a6bd0b58",
      "headRepository": null,
      "headRefName": "ocsp",
      "headRefOid": "9c582d6ff1e417d2a6d8c07849d4b3f822fcbd8b",
      "mergeCommit": {
        "oid": "a3ef919033510fdb0ae99a3eb0cbb97bc910db7b"
      }
    },
    {
      "number": 255,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxMTk4OTM5",
      "title": "signedexchange: Add dump-singedexchange explanation to README",
      "url": "https://github.com/WICG/webpackage/pull/255",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-13T06:30:50Z",
      "updatedAt": "2018-07-15T10:17:28Z",
      "closedAt": "2018-07-15T10:13:11Z",
      "mergedAt": "2018-07-15T10:13:11Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3MjYxMjM1",
          "commit": {
            "abbreviatedOid": "8e72000"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-15T10:13:06Z",
          "updatedAt": "2018-07-15T10:13:06Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "026d54f9f0ecfc0a5e442e8d51f96ea211c2ed75",
      "headRepository": "WICG/webpackage",
      "headRefName": "readme",
      "headRefOid": "8e72000d1b685772ae2b9f2142a58141b42fc67a",
      "mergeCommit": {
        "oid": "d0b59078fe14672440ba4ccf45aa108c3770e796"
      }
    },
    {
      "number": 256,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxMjAwNTg2",
      "title": "gen-certurl: do not parse input certificates twice",
      "url": "https://github.com/WICG/webpackage/pull/256",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now FetchOCSPResponse and CreateCertChainCBOR (renamed from\r\nCertificateMessageFromPEM) take parsed x509.Certificates.",
      "createdAt": "2018-07-13T06:41:31Z",
      "updatedAt": "2018-07-13T07:00:44Z",
      "closedAt": "2018-07-13T07:00:40Z",
      "mergedAt": "2018-07-13T07:00:40Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTIxMzUx",
          "commit": {
            "abbreviatedOid": "04c50d0"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-13T06:45:22Z",
          "updatedAt": "2018-07-13T06:45:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM2OTIyNDI3",
          "commit": {
            "abbreviatedOid": "04c50d0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-13T06:50:56Z",
          "updatedAt": "2018-07-13T06:50:56Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "026d54f9f0ecfc0a5e442e8d51f96ea211c2ed75",
      "headRepository": null,
      "headRefName": "pem",
      "headRefOid": "04c50d072a627fcfe679ca2d92106ff99773e40a",
      "mergeCommit": {
        "oid": "aea87529338d5650ce1483356de56d2dea2c21a8"
      }
    },
    {
      "number": 257,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxNzgwODMz",
      "title": "Try all PEM blocks in private key file.",
      "url": "https://github.com/WICG/webpackage/pull/257",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Change gen-signedexchange to try parsing all blocks in the key file as a\r\nprivate key. On OpenSSL 1.1.0h, the instructions at README.md result in\r\na key file that has two blocks, where the first is an EC PARAMETERS\r\nblock and the second is the EC PRIVATE KEY. This allows that file to be\r\nread.",
      "createdAt": "2018-07-16T22:48:29Z",
      "updatedAt": "2018-07-18T03:55:42Z",
      "closedAt": "2018-07-18T03:55:42Z",
      "mergedAt": "2018-07-18T03:55:42Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Let me know if you prefer this to be pulled inside ParsePrivateKey.",
          "createdAt": "2018-07-16T22:49:00Z",
          "updatedAt": "2018-07-16T22:49:00Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for catching this!",
          "createdAt": "2018-07-17T02:20:59Z",
          "updatedAt": "2018-07-17T02:20:59Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NjU3NDAx",
          "commit": {
            "abbreviatedOid": "2f1c37f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-07-17T02:19:21Z",
          "updatedAt": "2018-07-17T02:20:40Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "%s/parsedPrivKey/derKey/g",
              "createdAt": "2018-07-17T02:19:21Z",
              "updatedAt": "2018-07-17T17:11:47Z"
            },
            {
              "originalPosition": 20,
              "body": "`fmt.Errorf(\"Invalid PEM block in private key file %q.\", *flagPrivateKey)`",
              "createdAt": "2018-07-17T02:20:33Z",
              "updatedAt": "2018-07-17T17:11:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3OTMxMjE1",
          "commit": {
            "abbreviatedOid": "baf507f"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T17:15:19Z",
          "updatedAt": "2018-07-17T17:15:19Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Renamed to pemBlock, since it's not necessarily a key.",
              "createdAt": "2018-07-17T17:15:19Z",
              "updatedAt": "2018-07-17T17:15:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3OTMxMjU2",
          "commit": {
            "abbreviatedOid": "baf507f"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-17T17:15:24Z",
          "updatedAt": "2018-07-17T17:15:24Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Done.",
              "createdAt": "2018-07-17T17:15:24Z",
              "updatedAt": "2018-07-17T17:15:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDkwOTc0",
          "commit": {
            "abbreviatedOid": "baf507f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-18T03:17:34Z",
          "updatedAt": "2018-07-18T03:17:34Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d0b59078fe14672440ba4ccf45aa108c3770e796",
      "headRepository": "twifkak/webpackage",
      "headRefName": "try_all_blocks",
      "headRefOid": "baf507fedec22ee2c31262dd8c74f03fc9a0a793",
      "mergeCommit": {
        "oid": "f2c876f632e937eeb227ddc2fa0198c9cc11d4b8"
      }
    },
    {
      "number": 258,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAxODI5MDA0",
      "title": "signedexchange: Hide Encode/Decode3BytesBigEndianUint",
      "url": "https://github.com/WICG/webpackage/pull/258",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR hides some functions that are not needed to be exposed.",
      "createdAt": "2018-07-17T05:37:03Z",
      "updatedAt": "2018-07-23T16:49:20Z",
      "closedAt": "2018-07-18T03:55:29Z",
      "mergedAt": "2018-07-18T03:55:29Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "> How about renaming the funcs to {En,De}code3BytesUint since bigendian is now the package name\r\n\r\nDone!",
          "createdAt": "2018-07-17T09:27:45Z",
          "updatedAt": "2018-07-17T09:27:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM3NzA2NzUw",
          "commit": {
            "abbreviatedOid": "479ad1b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "How about renaming the funcs to {En,De}code3BytesUint since `bigendian` is now the package name",
          "createdAt": "2018-07-17T07:38:49Z",
          "updatedAt": "2018-07-17T07:38:49Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d0b59078fe14672440ba4ccf45aa108c3770e796",
      "headRepository": "WICG/webpackage",
      "headRefName": "bigendian",
      "headRefOid": "ccac6e6e2eaee2da4a3341557f07708de5367264",
      "mergeCommit": {
        "oid": "010aa4e6124b3daef13d1177315c6ab0ed5aa70f"
      }
    },
    {
      "number": 259,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyMTE4NjEy",
      "title": "gen-certurl: Read SCT files from directory specified with -sctDir",
      "url": "https://github.com/WICG/webpackage/pull/259",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Instead of reading a serialized SignedCertificateTimestampList from a\r\nfile, read all `*.sct` files in a directory given by the `-sctDir` flag\r\nand serialize them into SignedCertificateTimestampList.\r\n\r\nThis matches the way how [nginx-ct](https://github.com/grahamedgecombe/nginx-ct) and Apache's [mod_ssl_ct](https://httpd.apache.org/docs/trunk/mod/mod_ssl_ct.html) module work,\r\nand allows users to use existing SCT generation tools.",
      "createdAt": "2018-07-18T01:58:28Z",
      "updatedAt": "2018-07-18T03:57:15Z",
      "closedAt": "2018-07-18T03:55:52Z",
      "mergedAt": "2018-07-18T03:55:52Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDgxMjg1",
          "commit": {
            "abbreviatedOid": "d41f9f7"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-18T02:03:00Z",
          "updatedAt": "2018-07-18T02:03:01Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I removed `-sct` here since SCT is not necessary for self-signed certs.\r\n\r\nI plan to add a separate section for instructions to create signed exchanges with trusted certificates, and will explain the usage of `-sctDir` there.",
              "createdAt": "2018-07-18T02:03:00Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDkxMDIy",
          "commit": {
            "abbreviatedOid": "d41f9f7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-07-18T03:17:55Z",
          "updatedAt": "2018-07-18T03:22:28Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "sgtm",
              "createdAt": "2018-07-18T03:17:55Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            },
            {
              "originalPosition": 26,
              "body": "Is this line necessary?",
              "createdAt": "2018-07-18T03:20:45Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            },
            {
              "originalPosition": 27,
              "body": "please catch err:\r\n```\r\nif err := binary.Write(...); err != nil {\r\n  panic(err) or return nil, err\r\n}\r\n```",
              "createdAt": "2018-07-18T03:21:56Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            },
            {
              "originalPosition": 29,
              "body": "ditto",
              "createdAt": "2018-07-18T03:22:04Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            },
            {
              "originalPosition": 30,
              "body": "ditto",
              "createdAt": "2018-07-18T03:22:11Z",
              "updatedAt": "2018-07-18T03:51:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDk1MzM0",
          "commit": {
            "abbreviatedOid": "c0504a2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-18T03:52:40Z",
          "updatedAt": "2018-07-18T03:52:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDk1NDc0",
          "commit": {
            "abbreviatedOid": "c0504a2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-18T03:54:15Z",
          "updatedAt": "2018-07-18T03:54:15Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Removed.",
              "createdAt": "2018-07-18T03:54:15Z",
              "updatedAt": "2018-07-18T03:54:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MDk1NDky",
          "commit": {
            "abbreviatedOid": "c0504a2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-18T03:54:24Z",
          "updatedAt": "2018-07-18T03:54:24Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Done (here and elsewhere).",
              "createdAt": "2018-07-18T03:54:24Z",
              "updatedAt": "2018-07-18T03:54:24Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d0b59078fe14672440ba4ccf45aa108c3770e796",
      "headRepository": null,
      "headRefName": "sct",
      "headRefOid": "c0504a26097cf8729c71421379a3748b717d1fa5",
      "mergeCommit": {
        "oid": "89928f9440f3253d479ea1284fa2cb076c0c3143"
      }
    },
    {
      "number": 260,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyMTkwNjUz",
      "title": "gen-signedexchange: Add -draft2 suffix on MI and mi-sha256",
      "url": "https://github.com/WICG/webpackage/pull/260",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-18T09:28:21Z",
      "updatedAt": "2018-07-18T22:45:06Z",
      "closedAt": "2018-07-18T22:45:06Z",
      "mergedAt": "2018-07-18T22:45:06Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4MTc0ODkz",
          "commit": {
            "abbreviatedOid": "19ed9ad"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-18T09:36:49Z",
          "updatedAt": "2018-07-18T09:36:49Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "89928f9440f3253d479ea1284fa2cb076c0c3143",
      "headRepository": null,
      "headRefName": "mi-draft2",
      "headRefOid": "19ed9adce86b834e64df2427f52576b9ab7e341d",
      "mergeCommit": {
        "oid": "2ea8932115955fcc5ff1e16bc4ccb893d572b610"
      }
    },
    {
      "number": 261,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDA2Njc4",
      "title": "Increase the header size limit to 512kB.",
      "url": "https://github.com/WICG/webpackage/pull/261",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is twice Chromium's limit for the request or response headers,\r\nsince both are included in the signed exchange headers block.",
      "createdAt": "2018-07-18T23:25:43Z",
      "updatedAt": "2018-07-20T16:57:00Z",
      "closedAt": "2018-07-19T15:35:52Z",
      "mergedAt": "2018-07-19T15:35:52Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. This matches M69 now.",
          "createdAt": "2018-07-19T15:35:46Z",
          "updatedAt": "2018-07-19T15:35:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzMxMTU1",
          "commit": {
            "abbreviatedOid": "b3e7c9e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-19T15:35:34Z",
          "updatedAt": "2018-07-19T15:35:34Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2ea8932115955fcc5ff1e16bc4ccb893d572b610",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "header-limit",
      "headRefOid": "b3e7c9e97dce8831d8d1e5cb68c1dcdb7b32a2f3",
      "mergeCommit": {
        "oid": "f274c9af68a1ff25542a196f5fbb37c745c4d4c4"
      }
    },
    {
      "number": 262,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDUwMDQ4",
      "title": "dump-signedexchange: dump signature header value too",
      "url": "https://github.com/WICG/webpackage/pull/262",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-19T05:39:57Z",
      "updatedAt": "2018-07-19T06:41:51Z",
      "closedAt": "2018-07-19T06:41:25Z",
      "mergedAt": "2018-07-19T06:41:24Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NTM4NjIz",
          "commit": {
            "abbreviatedOid": "5e7abe5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-19T06:39:07Z",
          "updatedAt": "2018-07-19T06:39:07Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2ea8932115955fcc5ff1e16bc4ccb893d572b610",
      "headRepository": null,
      "headRefName": "dump",
      "headRefOid": "5e7abe5357125b9dc379df477882a3c959abd3df",
      "mergeCommit": {
        "oid": "d4b8ed90db72721413055268a8b9db5a70a30596"
      }
    },
    {
      "number": 263,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDU4NzE3",
      "title": "signedexchange: Remove EncodeRequestWithHeaders",
      "url": "https://github.com/WICG/webpackage/pull/263",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "That function is not used anywhere.",
      "createdAt": "2018-07-19T06:39:30Z",
      "updatedAt": "2018-07-19T16:24:29Z",
      "closedAt": "2018-07-19T15:36:17Z",
      "mergedAt": "2018-07-19T15:36:17Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzMxNDQ0",
          "commit": {
            "abbreviatedOid": "d2d8386"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-19T15:36:11Z",
          "updatedAt": "2018-07-19T15:36:11Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2ea8932115955fcc5ff1e16bc4ccb893d572b610",
      "headRepository": "WICG/webpackage",
      "headRefName": "remove",
      "headRefOid": "d2d8386b06cdbe473ba755905e03a75561e0990f",
      "mergeCommit": {
        "oid": "fc11c0e98c9a570b831e81013d8dc8b42111432e"
      }
    },
    {
      "number": 264,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDYzNzcx",
      "title": "signedexchange: Rename some functions",
      "url": "https://github.com/WICG/webpackage/pull/264",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Change the function to a method to follow the same way as net/http.Request.Write.",
      "createdAt": "2018-07-19T07:07:26Z",
      "updatedAt": "2018-07-21T04:11:45Z",
      "closedAt": "2018-07-21T04:11:42Z",
      "mergedAt": "2018-07-21T04:11:42Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzMyMTU3",
          "commit": {
            "abbreviatedOid": "8235052"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-19T15:37:39Z",
          "updatedAt": "2018-07-19T15:39:16Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@twifkak wdyt?\r\n\r\nPlease also rename `ReadExchangeFile` if we are going to proceed.",
              "createdAt": "2018-07-19T15:37:39Z",
              "updatedAt": "2018-07-20T05:49:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzUyMjIx",
          "commit": {
            "abbreviatedOid": "8235052"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-19T16:25:29Z",
          "updatedAt": "2018-07-19T16:25:30Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we can keep the reading function as it is\r\n\r\nhttps://golang.org/pkg/net/http/#ReadRequest",
              "createdAt": "2018-07-19T16:25:29Z",
              "updatedAt": "2018-07-20T05:49:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzUyNTM5",
          "commit": {
            "abbreviatedOid": "8235052"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-19T16:26:19Z",
          "updatedAt": "2018-07-19T16:26:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Ah, `ReadExchangeFile` should be `ReadExchange`, right? I'll do this later.",
              "createdAt": "2018-07-19T16:26:19Z",
              "updatedAt": "2018-07-20T05:49:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzgyMDI3",
          "commit": {
            "abbreviatedOid": "8235052"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-19T17:46:51Z",
          "updatedAt": "2018-07-19T17:47:09Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "LGTM. I'm not well-acquainted with idiomatic Go style, so I'll defer to your judgment there. \r\n\r\nThanks for the heads up! ampproject/amppackager still depends on nyaxt/webpackage, so there's no breakage by this change, but I'll keep it in mind for when I fix that.",
              "createdAt": "2018-07-19T17:46:52Z",
              "updatedAt": "2018-07-20T05:49:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTM1MzAz",
          "commit": {
            "abbreviatedOid": "4a615ae"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-20T05:50:18Z",
          "updatedAt": "2018-07-20T05:50:18Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.\r\n\r\n> ampproject/amppackager still depends on nyaxt/webpackage, so there's no breakage by this change, but I'll keep it in mind for when I fix that.\r\n\r\nSure!",
              "createdAt": "2018-07-20T05:50:18Z",
              "updatedAt": "2018-07-20T05:50:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI3MDIz",
          "commit": {
            "abbreviatedOid": "4a615ae"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T22:22:38Z",
          "updatedAt": "2018-07-20T22:22:38Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6d8d60f2255c2e07c774fcd28c0096aca8953f84",
      "headRepository": "WICG/webpackage",
      "headRefName": "write",
      "headRefOid": "4a615ae493992b7566bdcc1ab0a23ba2c779a181",
      "mergeCommit": {
        "oid": "6b6829374e2f25d4732a6449b0e3adfaf03f5724"
      }
    },
    {
      "number": 265,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNDY4MjQ1",
      "title": "signedexchange: Unexport SigningAlgorithm",
      "url": "https://github.com/WICG/webpackage/pull/265",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-19T07:28:48Z",
      "updatedAt": "2018-07-19T16:27:06Z",
      "closedAt": "2018-07-19T16:27:03Z",
      "mergedAt": "2018-07-19T16:27:03Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4NzMxNzU4",
          "commit": {
            "abbreviatedOid": "8b5bb1a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-19T15:36:47Z",
          "updatedAt": "2018-07-19T15:36:47Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d4b8ed90db72721413055268a8b9db5a70a30596",
      "headRepository": "WICG/webpackage",
      "headRefName": "signingalgorithm",
      "headRefOid": "8b5bb1ab27b60b3f62e9bd5601711f00f0fc959e",
      "mergeCommit": {
        "oid": "6d8d60f2255c2e07c774fcd28c0096aca8953f84"
      }
    },
    {
      "number": 266,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNzQ2ODE4",
      "title": "gen-certurl: Show warnings on possibly invalid input",
      "url": "https://github.com/WICG/webpackage/pull/266",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Prints warning message when:\r\n- OCSP data cannot be parsed as a DER-encoded OCSP response\r\n- Cert and OCSP do not have embedded SCT, and `-sctDir` is not specified\r\n\r\nDidn't make them error since these are OK if generated cert-chain is used for testing, with the `--ignore-certificate-errors-spki-list` Chromium flag.",
      "createdAt": "2018-07-20T04:58:15Z",
      "updatedAt": "2018-07-23T01:35:41Z",
      "closedAt": "2018-07-23T01:35:35Z",
      "mergedAt": "2018-07-23T01:35:35Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTMzNjU0",
          "commit": {
            "abbreviatedOid": "8d93efb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-20T05:41:18Z",
          "updatedAt": "2018-07-20T05:43:46Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "`HasEmbeddedSCT returns true ...`",
              "createdAt": "2018-07-20T05:41:18Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            },
            {
              "originalPosition": 40,
              "body": "For warnings, I think `fmt.Fprintf(os.Stderr)` should be fine.\r\n\r\nExample usage in Go command: https://golang.org/src/cmd/go/main.go",
              "createdAt": "2018-07-20T05:43:37Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTM2Njg0",
          "commit": {
            "abbreviatedOid": "0c06eb9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-20T06:00:20Z",
          "updatedAt": "2018-07-20T06:00:20Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done",
              "createdAt": "2018-07-20T06:00:20Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTM2Njk5",
          "commit": {
            "abbreviatedOid": "0c06eb9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-20T06:00:23Z",
          "updatedAt": "2018-07-20T06:00:23Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Done",
              "createdAt": "2018-07-20T06:00:23Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM4OTM3NTY1",
          "commit": {
            "abbreviatedOid": "0c06eb9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-20T06:05:52Z",
          "updatedAt": "2018-07-20T06:05:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI2NjEx",
          "commit": {
            "abbreviatedOid": "0c06eb9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm % comments",
          "createdAt": "2018-07-20T22:20:08Z",
          "updatedAt": "2018-07-20T22:21:18Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Nit: use camelCase `ocspDer` https://golang.org/doc/effective_go.html#mixed-caps",
              "createdAt": "2018-07-20T22:20:08Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            },
            {
              "originalPosition": 28,
              "body": "ditto `parsedOcsp`",
              "createdAt": "2018-07-20T22:20:31Z",
              "updatedAt": "2018-07-23T01:33:14Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MzEyMjkx",
          "commit": {
            "abbreviatedOid": "44cd3cb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-23T01:34:42Z",
          "updatedAt": "2018-07-23T01:34:42Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "done",
              "createdAt": "2018-07-23T01:34:42Z",
              "updatedAt": "2018-07-23T01:34:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MzEyMjk4",
          "commit": {
            "abbreviatedOid": "44cd3cb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-23T01:34:45Z",
          "updatedAt": "2018-07-23T01:34:45Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "done",
              "createdAt": "2018-07-23T01:34:45Z",
              "updatedAt": "2018-07-23T01:34:45Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6d8d60f2255c2e07c774fcd28c0096aca8953f84",
      "headRepository": null,
      "headRefName": "sct-warn",
      "headRefOid": "44cd3cb62dc7c649f2a3e62718b4fbc579114591",
      "mergeCommit": {
        "oid": "dc0d95ae6c95da91bf4c6f43e8cc6805ddd99392"
      }
    },
    {
      "number": 267,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyNzk0Nzcz",
      "title": "Add instructions to create a signed exchange with a trusted certificate",
      "url": "https://github.com/WICG/webpackage/pull/267",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-20T09:31:09Z",
      "updatedAt": "2018-07-23T01:40:44Z",
      "closedAt": "2018-07-23T01:40:41Z",
      "mergedAt": "2018-07-23T01:40:41Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MTM2MDYx",
          "commit": {
            "abbreviatedOid": "2ecb963"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T17:00:15Z",
          "updatedAt": "2018-07-20T17:00:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI1NDY3",
          "commit": {
            "abbreviatedOid": "2ecb963"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T22:13:24Z",
          "updatedAt": "2018-07-20T22:13:24Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6d8d60f2255c2e07c774fcd28c0096aca8953f84",
      "headRepository": null,
      "headRefName": "readme",
      "headRefOid": "2ecb96302b38f18be22e3e370c025792bb7be526",
      "mergeCommit": {
        "oid": "a998ee9bc1eb0ef5a175b0c74a3a259cb5429319"
      }
    },
    {
      "number": 269,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAyOTY2MzQw",
      "title": "Fix the magic number of a signed-exchange example in -impl.",
      "url": "https://github.com/WICG/webpackage/pull/269",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-20T22:03:48Z",
      "updatedAt": "2018-07-20T22:12:07Z",
      "closedAt": "2018-07-20T22:11:45Z",
      "mergedAt": "2018-07-20T22:11:45Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI0MTMw",
          "commit": {
            "abbreviatedOid": "298e0ce"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T22:05:59Z",
          "updatedAt": "2018-07-20T22:05:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTM5MjI0ODQy",
          "commit": {
            "abbreviatedOid": "295cd22"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-20T22:09:58Z",
          "updatedAt": "2018-07-20T22:09:58Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4ce868caebde0c86f232fb99e2cc8f593dd4109b",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fix-impl-ex-magic-number",
      "headRefOid": "295cd2204288e4bec74636906e911d3054a1dbff",
      "mergeCommit": {
        "oid": "34881a2a6cd7b74e688c0e45b4a28e4f1372320c"
      }
    },
    {
      "number": 271,
      "id": "MDExOlB1bGxSZXF1ZXN0MjAzOTQ0OTYw",
      "title": "Always embed manifest in the bundle",
      "url": "https://github.com/WICG/webpackage/pull/271",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Addresses #270\r\n\r\nAfter giving more thought, I couldn't think of a use-case where we want to refer to a external manifest.\r\n\r\nOn the other hand, I also want to make the manifest URL optional, for use-cases where a bundle contains a part of a page resources (for example, common assets across multiple webpages, a ES module tree, etc.)",
      "createdAt": "2018-07-25T19:53:04Z",
      "updatedAt": "2018-07-27T04:06:59Z",
      "closedAt": "2018-07-27T04:06:59Z",
      "mergedAt": "2018-07-27T04:06:59Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I made the manifest mandatory so that a start_url would be available for when someone navigated to a bundle. Once we move the fallback URL out of the manifest, it serves that purpose, and I think it makes sense to make the manifest optional.",
          "createdAt": "2018-07-25T20:11:04Z",
          "updatedAt": "2018-07-25T20:11:04Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> Once we move the fallback URL out of the manifest, it serves that purpose, and I think it makes sense to make the manifest optional.\r\n\r\nSGTM\r\n",
          "createdAt": "2018-07-25T21:01:45Z",
          "updatedAt": "2018-07-25T21:01:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQwNDc5NTAz",
          "commit": {
            "abbreviatedOid": "6c7c6f8"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-25T20:09:48Z",
          "updatedAt": "2018-07-25T20:09:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "\"MUST\" should be capitalized per https://tools.ietf.org/html/rfc8174.",
              "createdAt": "2018-07-25T20:09:48Z",
              "updatedAt": "2018-07-25T21:01:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQwNDk3OTY5",
          "commit": {
            "abbreviatedOid": "83108eb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-25T21:00:18Z",
          "updatedAt": "2018-07-25T21:00:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.",
              "createdAt": "2018-07-25T21:00:18Z",
              "updatedAt": "2018-07-25T21:01:07Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a998ee9bc1eb0ef5a175b0c74a3a259cb5429319",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "manifest-lookup-self",
      "headRefOid": "a5dd06bb7fffb80dcd2ae779f6357018867cc867",
      "mergeCommit": {
        "oid": "c35382277cdc716835b8b36e94ff9007e498ce44"
      }
    },
    {
      "number": 272,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0MDI4MDQy",
      "title": "Update the extensions of default output file",
      "url": "https://github.com/WICG/webpackage/pull/272",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Use `.sxg` and `.wbn` instead of `.htxg` and `.webbundle`.",
      "createdAt": "2018-07-26T04:53:10Z",
      "updatedAt": "2018-07-26T07:17:53Z",
      "closedAt": "2018-07-26T07:17:53Z",
      "mergedAt": "2018-07-26T07:17:53Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQwNjAyNDQy",
          "commit": {
            "abbreviatedOid": "25bc56c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-26T07:12:15Z",
          "updatedAt": "2018-07-26T07:12:15Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a998ee9bc1eb0ef5a175b0c74a3a259cb5429319",
      "headRepository": null,
      "headRefName": "fileext",
      "headRefOid": "25bc56c1a192b4545a0971ce08e36803ab182b39",
      "mergeCommit": {
        "oid": "29be432ee121116c313f93765c403e7ac2203ba7"
      }
    },
    {
      "number": 273,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0MzM2NzI5",
      "title": "gen-bundle: Add options to create a bundle from local directory",
      "url": "https://github.com/WICG/webpackage/pull/273",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@nyaxt Do you think this is worth merging?",
      "createdAt": "2018-07-27T05:59:44Z",
      "updatedAt": "2018-07-31T09:30:59Z",
      "closedAt": "2018-07-31T09:30:56Z",
      "mergedAt": "2018-07-31T09:30:56Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is definitely worth merging, while need polishing up. @hajimehoshi PTAL",
          "createdAt": "2018-07-27T06:26:14Z",
          "updatedAt": "2018-07-27T06:26:38Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "All comments addressed. PTAL",
          "createdAt": "2018-07-31T05:31:00Z",
          "updatedAt": "2018-07-31T05:31:00Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review!",
          "createdAt": "2018-07-31T09:30:36Z",
          "updatedAt": "2018-07-31T09:30:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQwOTk1NTM2",
          "commit": {
            "abbreviatedOid": "62bc9ea"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-27T06:16:22Z",
          "updatedAt": "2018-07-27T06:25:41Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "b.Exchanges[0], b.Exchanges[i] = b.Exchanges[i], b.Exchanges[0]",
              "createdAt": "2018-07-27T06:16:22Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 53,
              "body": "Maybe https://golang.org/pkg/path/filepath/#Glob ?",
              "createdAt": "2018-07-27T06:22:54Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 113,
              "body": "oh wow. Please add a comment about this trick of using ResponseWriter->ServeFile to generate realistic response",
              "createdAt": "2018-07-27T06:24:19Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 31,
              "body": "Should we warn if *flagBaseUrl, *flagStartUrl is specified?",
              "createdAt": "2018-07-27T06:25:33Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxMDE5OTEw",
          "commit": {
            "abbreviatedOid": "62bc9ea"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-27T08:09:47Z",
          "updatedAt": "2018-07-27T08:11:27Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "or https://golang.org/pkg/path/filepath/#Walk :-)",
              "createdAt": "2018-07-27T08:09:47Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxMzE5Nzg1",
          "commit": {
            "abbreviatedOid": "62bc9ea"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-28T15:29:20Z",
          "updatedAt": "2018-07-28T16:22:11Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "For Go convention, `b` should be the first argument, which represents an output.",
              "createdAt": "2018-07-28T15:29:20Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 106,
              "body": "ditto.",
              "createdAt": "2018-07-28T16:21:48Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA0NDYy",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:28:18Z",
          "updatedAt": "2018-07-31T05:28:18Z",
          "comments": [
            {
              "originalPosition": 41,
              "body": "Done.",
              "createdAt": "2018-07-31T05:28:18Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA0NTEy",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:28:38Z",
          "updatedAt": "2018-07-31T05:28:38Z",
          "comments": [
            {
              "originalPosition": 53,
              "body": "Done.",
              "createdAt": "2018-07-31T05:28:38Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA0NTIz",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:28:42Z",
          "updatedAt": "2018-07-31T05:28:42Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Done.",
              "createdAt": "2018-07-31T05:28:42Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA0ODQ3",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:30:40Z",
          "updatedAt": "2018-07-31T05:30:41Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Now it returns exchanges as a return value.",
              "createdAt": "2018-07-31T05:30:40Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODA1NTky",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T05:35:39Z",
          "updatedAt": "2018-07-31T05:37:06Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "`flagBaseURL` for Go convention https://stackoverflow.com/questions/38616687/which-way-to-name-a-function-in-go-camelcase-or-semi-camelcase",
              "createdAt": "2018-07-31T05:35:39Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            },
            {
              "originalPosition": 6,
              "body": "ditto",
              "createdAt": "2018-07-31T05:35:45Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODExMTIy",
          "commit": {
            "abbreviatedOid": "c1f1fd9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-31T06:10:30Z",
          "updatedAt": "2018-07-31T06:10:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODQ3MTcz",
          "commit": {
            "abbreviatedOid": "de6ef10"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T08:24:41Z",
          "updatedAt": "2018-07-31T08:24:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "done",
              "createdAt": "2018-07-31T08:24:41Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODQ3MjQ5",
          "commit": {
            "abbreviatedOid": "de6ef10"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-31T08:24:53Z",
          "updatedAt": "2018-07-31T08:24:54Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "done",
              "createdAt": "2018-07-31T08:24:53Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxODU0NDA5",
          "commit": {
            "abbreviatedOid": "de6ef10"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-31T08:45:15Z",
          "updatedAt": "2018-07-31T08:45:27Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "nit: The comment should start with `responseWriter` for Go convention.",
              "createdAt": "2018-07-31T08:45:16Z",
              "updatedAt": "2018-07-31T08:52:36Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c35382277cdc716835b8b36e94ff9007e498ce44",
      "headRepository": null,
      "headRefName": "gen-bundle-from-dir",
      "headRefOid": "2356fb0f30a1ee8a053f39d1c428a84be6302c1b",
      "mergeCommit": {
        "oid": "3e3d55ed52e3560a679d182591a33e066655cdc4"
      }
    },
    {
      "number": 274,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0NDk3NDI1",
      "title": "Fix typo in README",
      "url": "https://github.com/WICG/webpackage/pull/274",
      "state": "CLOSED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-07-27T17:47:57Z",
      "updatedAt": "2018-07-27T17:50:16Z",
      "closedAt": "2018-07-27T17:50:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c35382277cdc716835b8b36e94ff9007e498ce44",
      "headRepository": "EverlastingBugstopper/webpackage",
      "headRefName": "avery/import-fix",
      "headRefOid": "05b722b7dc65daa99314c104e0a94886d131a539",
      "mergeCommit": null
    },
    {
      "number": 275,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0NDk4MDI2",
      "title": "Fix typo in README",
      "url": "https://github.com/WICG/webpackage/pull/275",
      "state": "MERGED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #268",
      "createdAt": "2018-07-27T17:50:33Z",
      "updatedAt": "2018-07-29T00:26:59Z",
      "closedAt": "2018-07-28T02:51:22Z",
      "mergedAt": "2018-07-28T02:51:22Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you!",
          "createdAt": "2018-07-28T02:51:29Z",
          "updatedAt": "2018-07-28T02:51:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxMzA1MjIy",
          "commit": {
            "abbreviatedOid": "4bbf449"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-28T02:51:17Z",
          "updatedAt": "2018-07-28T02:51:17Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c35382277cdc716835b8b36e94ff9007e498ce44",
      "headRepository": "EverlastingBugstopper/webpackage",
      "headRefName": "avery/typo",
      "headRefOid": "4bbf4491fb4c895ebd3e9ff22d00c9160ad5d260",
      "mergeCommit": {
        "oid": "b58d84649ddcc8aff2df593ec94dc9cc1c8ee0ca"
      }
    },
    {
      "number": 277,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0NzA5Mjc5",
      "title": "gen-signedexchange: Add flag to optionally dump signature message for\u2026",
      "url": "https://github.com/WICG/webpackage/pull/277",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026 debugging",
      "createdAt": "2018-07-30T06:50:29Z",
      "updatedAt": "2018-08-03T01:46:59Z",
      "closedAt": "2018-08-03T01:46:59Z",
      "mergedAt": "2018-08-03T01:46:59Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDE3MTQx",
          "commit": {
            "abbreviatedOid": "d762b86"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-30T07:29:41Z",
          "updatedAt": "2018-07-30T07:30:01Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "`os.Create`?",
              "createdAt": "2018-07-30T07:29:41Z",
              "updatedAt": "2018-08-01T08:20:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQyMjUyNzAw",
          "commit": {
            "abbreviatedOid": "d762b86"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-01T07:18:09Z",
          "updatedAt": "2018-08-01T07:18:09Z",
          "comments": [
            {
              "originalPosition": 30,
              "body": "Done",
              "createdAt": "2018-08-01T07:18:09Z",
              "updatedAt": "2018-08-01T08:20:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQyMjUzNjc1",
          "commit": {
            "abbreviatedOid": "8d625cc"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with nits",
          "createdAt": "2018-08-01T07:21:26Z",
          "updatedAt": "2018-08-01T07:22:59Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "`w` should be first for convention: as far as I know there is no explicit rule, but for standard libs, output streams tend to be the first argument.",
              "createdAt": "2018-08-01T07:21:26Z",
              "updatedAt": "2018-08-01T08:20:41Z"
            },
            {
              "originalPosition": 41,
              "body": "BTW, I think this code is not reachable?",
              "createdAt": "2018-08-01T07:22:01Z",
              "updatedAt": "2018-08-01T08:20:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQyMjk0OTQ5",
          "commit": {
            "abbreviatedOid": "2138780"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-01T09:28:24Z",
          "updatedAt": "2018-08-01T09:28:24Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I realized that this should be `flagCertificateUrl` and `flagValidityURL` for Go convention. Let's address on this later.",
              "createdAt": "2018-08-01T09:28:24Z",
              "updatedAt": "2018-08-01T09:28:24Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "b58d84649ddcc8aff2df593ec94dc9cc1c8ee0ca",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "dumpmsg",
      "headRefOid": "2138780d711e2565de952a404ad5c118bcaefd8e",
      "mergeCommit": {
        "oid": "c65d70ecfca7f24968edc0d5a808231d53cb1c23"
      }
    },
    {
      "number": 278,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0NzI3NDEw",
      "title": "gen-bundle: Drop pseudo headers in HAR",
      "url": "https://github.com/WICG/webpackage/pull/278",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Chromium generates HAR that includes HTTP/2 pseudo headers in the\r\n`request.headers` field. Drop them so that they don't conflict with\r\nBundled Exchanges' pseudo headers.",
      "createdAt": "2018-07-30T08:19:17Z",
      "updatedAt": "2018-07-30T11:32:01Z",
      "closedAt": "2018-07-30T11:32:01Z",
      "mergedAt": "2018-07-30T11:32:01Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDU2MTY4",
          "commit": {
            "abbreviatedOid": "ee2cde6"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-07-30T09:32:40Z",
          "updatedAt": "2018-07-30T09:32:50Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "if strings.HasPrefix(nvp.Name, \":\")",
              "createdAt": "2018-07-30T09:32:40Z",
              "updatedAt": "2018-07-30T10:01:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDY2MzU5",
          "commit": {
            "abbreviatedOid": "b698b1e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-07-30T10:02:23Z",
          "updatedAt": "2018-07-30T10:02:23Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done",
              "createdAt": "2018-07-30T10:02:23Z",
              "updatedAt": "2018-07-30T10:02:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDc3NDg5",
          "commit": {
            "abbreviatedOid": "b698b1e"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-07-30T10:39:16Z",
          "updatedAt": "2018-07-30T10:39:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQxNDkyNzEw",
          "commit": {
            "abbreviatedOid": "b698b1e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-07-30T11:31:33Z",
          "updatedAt": "2018-07-30T11:31:33Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "b58d84649ddcc8aff2df593ec94dc9cc1c8ee0ca",
      "headRepository": null,
      "headRefName": "pseudo",
      "headRefOid": "b698b1e470e9d86ab29aeb7c1676c3f66fc66152",
      "mergeCommit": {
        "oid": "8aca88c4122d4b268d25b595c0700665f234a749"
      }
    },
    {
      "number": 279,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA0OTg2OTAz",
      "title": "Move headers out of the CBOR map when constructing signed message bytes.",
      "url": "https://github.com/WICG/webpackage/pull/279",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To address #276 ",
      "createdAt": "2018-07-31T03:34:39Z",
      "updatedAt": "2018-08-20T01:38:16Z",
      "closedAt": "2018-08-20T01:38:16Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'd like to get @davidben's thoughts on any rework we do here, with reference to the [draft loading spec](http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#signed-message) that specifies how to check this.\r\n\r\nHe's out until mid-next-week, at which point I might be on leave, but if he's happy with a change while I'm out, go ahead and make it.",
          "createdAt": "2018-07-31T03:45:01Z",
          "updatedAt": "2018-07-31T03:45:01Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I don't have a strong preference on how we should fix this.\r\n@davidben Please also take a look at options being discussed at https://github.com/WICG/webpackage/issues/276 . We are happy to hear other serialization method ideas too.",
          "createdAt": "2018-07-31T03:47:49Z",
          "updatedAt": "2018-07-31T03:47:49Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "We will go forward with #287 instead.",
          "createdAt": "2018-08-20T01:38:16Z",
          "updatedAt": "2018-08-20T01:38:16Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "8aca88c4122d4b268d25b595c0700665f234a749",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "header-cbor-at-end",
      "headRefOid": "32332d6bc5da262700d966c22657b0f08311a72f",
      "mergeCommit": null
    },
    {
      "number": 280,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA1MzAyMDg2",
      "title": "Update go/bundle/README.md",
      "url": "https://github.com/WICG/webpackage/pull/280",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-01T03:54:12Z",
      "updatedAt": "2018-08-01T06:55:21Z",
      "closedAt": "2018-08-01T06:55:17Z",
      "mergedAt": "2018-08-01T06:55:17Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Added a note about the current behavior of `-startURL`.",
          "createdAt": "2018-08-01T06:22:26Z",
          "updatedAt": "2018-08-01T06:22:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQyMjQ0NjU3",
          "commit": {
            "abbreviatedOid": "0616f5c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-01T06:43:14Z",
          "updatedAt": "2018-08-01T06:43:14Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3e3d55ed52e3560a679d182591a33e066655cdc4",
      "headRepository": null,
      "headRefName": "readme",
      "headRefOid": "0616f5ca1bc4224ee4baef59ea32a6bd333a6f21",
      "mergeCommit": {
        "oid": "3dfaec9ee742c8b93dff20019418db65f7d1b38e"
      }
    },
    {
      "number": 281,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2NTIxMjA3",
      "title": "Integrate b1 signed exchanges with Fetch",
      "url": "https://github.com/WICG/webpackage/pull/281",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "[Preview](https://jyasskin.github.io/webpackage/loading-spec/loading.html)",
      "createdAt": "2018-08-06T21:26:25Z",
      "updatedAt": "2018-08-20T21:42:03Z",
      "closedAt": "2018-08-20T07:09:32Z",
      "mergedAt": "2018-08-20T07:09:32Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Hooking into [HTTP fetch](https://jyasskin.github.io/webpackage/loading-spec/loading.html#mp-http-fetch) gives me an easy way to inject a redirect, but it means that signed exchanges loaded from the filesystem, from blobs, etc. don't work. In the long run, I think we'll want them to work, so we'll want to either move the attachment point up to [main fetch](https://fetch.spec.whatwg.org/#concept-main-fetch), or manually go through some of the redirect steps in the other branches of [scheme fetch](https://fetch.spec.whatwg.org/#concept-scheme-fetch).\r\n\r\nI still think this PR is the right place to start: it'll be easier to see what that extension changes with this as a baseline.",
          "createdAt": "2018-08-13T22:26:23Z",
          "updatedAt": "2018-08-13T22:26:23Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Given that other @jyasskin PRs build on top of this PR, I'd like to proceed with this and then revise the bits later. @kinu Are you cool with this?",
          "createdAt": "2018-08-20T01:48:45Z",
          "updatedAt": "2018-08-20T01:48:45Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, let's merge it and consider separate PRs if we find any modifications are needed.",
          "createdAt": "2018-08-20T06:36:30Z",
          "updatedAt": "2018-08-20T06:36:30Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzNzkxMTY1",
          "commit": {
            "abbreviatedOid": "2cdb79d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-06T23:11:49Z",
          "updatedAt": "2018-08-06T23:51:50Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "@kinu Have y'all looked into the Service Worker side? I believe Fetch's https://fetch.spec.whatwg.org/#concept-http-fetch step 4.2\r\n\r\n> If request\u2019s redirect mode is \"follow\", then set request\u2019s service-workers mode to \"none\".\r\n\r\nprevents all redirects from hitting a service worker, so even if distributor.example.org just served a 302 to publisher.example.org, publisher.example.org's SW wouldn't get to handle the navigation. Am I misreading anything?",
              "createdAt": "2018-08-06T23:11:49Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 585,
              "body": "@sleevi @davidben The fact that the [certificate](http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#augmented-certificate-certificate) is stored un-parsed means that the spec winds up saying to parse out a public key twice, which feels like a security risk. How much can systems actually parse these structures ahead of time, vs when they're validating origin-trust?",
              "createdAt": "2018-08-06T23:19:17Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 242,
              "body": "Right now, I'm ignoring all of the [cache modes](https://fetch.spec.whatwg.org/#concept-request-cache-mode) in deciding to accept a signed exchange's content. They may be useful in controlling how to fetch the `.sxg` itself, and applying them to the content would probably just have the effect of forcing that to the network, which would defeat the point.\r\n\r\nDoes that sound right to y'all, or do you see any of the modes I should apply here?",
              "createdAt": "2018-08-06T23:23:07Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 610,
              "body": "I check the length of the validity window in cross-origin trust rather than while parsing the signature so that other uses of signatures can define their own maximum validities. e.g. maybe the Play store wants to sign that it's audited an app and have that be valid for more than a week.",
              "createdAt": "2018-08-06T23:43:57Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 640,
              "body": "@sleevi Is this a reasonable way to phrase the requirement?",
              "createdAt": "2018-08-06T23:45:10Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 766,
              "body": "@domenic This [whole section](http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#stream-algs) could migrate to either Fetch or Streams if you think it'll be useful to other specs.",
              "createdAt": "2018-08-06T23:49:38Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 542,
              "body": "@davidben How do you feel about this message algorithm? I think we can simplify it for b2, since I only made it this complicated to avoid confusion between multiple versions of the message, and that's now handled by the `HTTP Exchange 1 b1` context string, but it'll inform whether we can go to Origin Trial with b1 or have to go to b2 first.",
              "createdAt": "2018-08-06T23:51:30Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODM3NzY1",
          "commit": {
            "abbreviatedOid": "c3fab22"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T04:37:00Z",
          "updatedAt": "2018-08-07T04:37:01Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "For navigation the default redirect mode is \"manual\", therefore every time a request's redirected corresponding SW has a chance to see it.",
              "createdAt": "2018-08-07T04:37:00Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODM4ODc1",
          "commit": {
            "abbreviatedOid": "c3fab22"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T04:46:51Z",
          "updatedAt": "2018-08-07T04:46:51Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "This means that whenever UA loads things from a Signed Exchange UA also needs to check HTTP cache. Can you clarify what situation we are trying to deal with by this? If we don't cache the stashed exchange it feels it's just fine, or a site should probably set a short expiration date?",
              "createdAt": "2018-08-07T04:46:51Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTA0NDUz",
          "commit": {
            "abbreviatedOid": "c3fab22"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T17:32:47Z",
          "updatedAt": "2018-08-07T17:42:00Z",
          "comments": [
            {
              "originalPosition": 145,
              "body": "Aha! Thanks! \r\n\r\nI think both @cramforce's idea to use the `preloadResponse` and asking people to call `fetch()` with cache==\"only-if-cached\" will work, but to use \"only-if-cached\" we'll have to tell people to modify the original request or its clone, instead of creating a new request with the same URL. A new request with the same URL won't have the stashed exchange attached, and wiring those up will require an extra global map in the SW itself, which could also get confused by interleaved requests to different signed exchanges holding the same publication URL.",
              "createdAt": "2018-08-07T17:32:47Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 141,
              "body": "Imagine that Vashti visits https://app.com/ regularly, and app.com also publishes a signed exchange valid for a week to allow offline distribution. Now app.com discovers a vulnerability and patches it, but the vulnerable signed exchange is still out there.\r\n\r\nIf Vashti visits the site after the update and gets the new version into her cache, even stale, then even if an attacker manages to serve her the vulnerable signed exchange, she won't use it.\r\n\r\nThis isn't an absolute defense against anything, but it lowers the probability of a successful attack on frequent users of a site.",
              "createdAt": "2018-08-07T17:41:25Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTI5OTcy",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:36:12Z",
          "updatedAt": "2018-08-07T18:36:12Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "@davidben @sleevi How many hives does this bit give you?",
              "createdAt": "2018-08-07T18:36:12Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTMyNTk2",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:42:54Z",
          "updatedAt": "2018-08-07T18:42:54Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "I'm not going to have bandwidth to review this this week, in part because I need to go get treated for hives. It quite concerns me, and I can tell it's going to take time and focus that I don't yet have to adequately review :/",
              "createdAt": "2018-08-07T18:42:54Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTMzMjM4",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:44:27Z",
          "updatedAt": "2018-08-07T18:44:27Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "Can you explain why it feels like a security risk? I'm not sure I fully understand the question. Extracting an SPKI from a certificate is something easy on virtually all systems - the question is whether or not it's \"trusted\" data yet.",
              "createdAt": "2018-08-07T18:44:27Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTM0NjQz",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:47:46Z",
          "updatedAt": "2018-08-07T18:47:47Z",
          "comments": [
            {
              "originalPosition": 640,
              "body": "No. There's no such thing as \"trusted logs\", and this also isn't how clients evaluate whether a certificate complies with a given CT policy.\r\n\r\nI think much of this algorithm can be replaced by waving into the blackbox and saying that the OCSP response, the SCTs, and the certificates are inputs, for the host, and determine the response. I suspect you may want an added requirement on the OCSP responses freshness, or that the validating client MUST support Certificate Transparency (or is it optional for UAs that don't support CT but still support SXG?)",
              "createdAt": "2018-08-07T18:47:47Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTM0MTg0",
          "commit": {
            "abbreviatedOid": "6f4899e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T18:46:53Z",
          "updatedAt": "2018-08-07T19:24:16Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "I've been conditioned that any time we parse something twice, security bugs appear in the differences between the two parsers. However, if you're comfortable with this case (e.g. that nobody will actually write separate parsers), I'm also happy with it.",
              "createdAt": "2018-08-07T18:46:53Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 640,
              "body": "So put this all in the \"Attempt to build a trustworthy path\" step? Sounds good; how's this [new wording](http://api.csswg.org/bikeshed/?url=https://raw.githubusercontent.com/jyasskin/webpackage/loading-spec/loading.bs#trusting-certificate)?\r\n\r\nI don't think CT should be optional for signed exchanges even for UAs that don't use it for TLS connections. Knowing that a certificate was mis-issued has been an important part of our security analysis.",
              "createdAt": "2018-08-07T18:50:47Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            },
            {
              "originalPosition": 585,
              "body": "SG. I've added a pointer to #141 so that anyone implementing this knows to check with security folks.",
              "createdAt": "2018-08-07T19:22:18Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTY1NzMz",
          "commit": {
            "abbreviatedOid": "4fc7650"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T20:14:13Z",
          "updatedAt": "2018-08-07T20:14:13Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "I presume they're going to be using the same parser - is there reason to believe they may be different?",
              "createdAt": "2018-08-07T20:14:13Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0MTY2Mzgw",
          "commit": {
            "abbreviatedOid": "4fc7650"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T20:16:03Z",
          "updatedAt": "2018-08-07T20:16:03Z",
          "comments": [
            {
              "originalPosition": 640,
              "body": "You realize this means that only Chrome will implement SXGs for the foreseeable future? Coupling to CT in this way is going to either explicitly preclude certain UAs, or encourage them to adopt patterns that they've been reticent to do for TLS, precisely because they know it will harm the CT ecosystem. We should sync up on that. I realize the intersection between CT relates to SXG, but I think we need to be careful about MUSTing certain policy bits, compared to highlighting the tradeoffs.",
              "createdAt": "2018-08-07T20:16:03Z",
              "updatedAt": "2018-08-08T19:29:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0NjE1NjMx",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-08T21:26:22Z",
          "updatedAt": "2018-08-08T21:26:22Z",
          "comments": [
            {
              "originalPosition": 585,
              "body": "No particular reason.",
              "createdAt": "2018-08-08T21:26:22Z",
              "updatedAt": "2018-08-08T21:26:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0NjE1NzM2",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-08T21:26:40Z",
          "updatedAt": "2018-08-08T21:26:41Z",
          "comments": [
            {
              "originalPosition": 640,
              "body": "This is now a SHOULD with a link to a new Security Considerations section.",
              "createdAt": "2018-08-08T21:26:41Z",
              "updatedAt": "2018-08-08T21:26:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NDgyNTkw",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-20T01:48:54Z",
          "updatedAt": "2018-08-20T01:48:54Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTA5MDA0",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T06:02:28Z",
          "updatedAt": "2018-08-20T06:02:28Z",
          "comments": [
            {
              "originalPosition": 141,
              "body": "Chrome's current impl is not following this, which is the biggest concern, but that part probably needs a separate discussion anyways to proceed. (I'll file an impl bug and take a closer look if this needs to block our further milestones)",
              "createdAt": "2018-08-20T06:02:28Z",
              "updatedAt": "2018-08-20T06:02:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTEyNjk1",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T06:25:37Z",
          "updatedAt": "2018-08-20T06:25:37Z",
          "comments": [
            {
              "originalPosition": 242,
              "body": "This sg to me.",
              "createdAt": "2018-08-20T06:25:37Z",
              "updatedAt": "2018-08-20T06:25:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTE1MTYy",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-20T06:38:25Z",
          "updatedAt": "2018-08-20T06:38:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NjE5ODgw",
          "commit": {
            "abbreviatedOid": "4c9707c"
          },
          "author": "rwlbuis",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T12:25:52Z",
          "updatedAt": "2018-08-20T12:25:52Z",
          "comments": [
            {
              "originalPosition": 787,
              "body": "Note that the way this is rendered in Safari looks a bit weird, I only see step 1. and 3. with a big ISSUE section in between. But I guess once Step 2 has been fleshed out, it will look ok.",
              "createdAt": "2018-08-20T12:25:52Z",
              "updatedAt": "2018-08-20T12:25:52Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5f280322ed23a560eca43b2ea97a7b7cb6d31d07",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "loading-spec",
      "headRefOid": "4c9707c5edcff36a2000db02d9e3839b7b93af6b",
      "mergeCommit": {
        "oid": "51fa4e8b6a33ab5eb938c564b76a1773a4003be8"
      }
    },
    {
      "number": 282,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2NTYxODU0",
      "title": "gen-bundle: Add checks to prevent creating invalid bundles",
      "url": "https://github.com/WICG/webpackage/pull/282",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Drop the HAR entry if:\r\n- Request method is not GET.\r\n- Status code is not valid. Chromium puts status code 0 if the request\r\n  failed with a network error.",
      "createdAt": "2018-08-07T02:16:11Z",
      "updatedAt": "2018-08-07T07:07:17Z",
      "closedAt": "2018-08-07T07:06:46Z",
      "mergedAt": "2018-08-07T07:06:46Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODMzMTA5",
          "commit": {
            "abbreviatedOid": "e5bc177"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-08-07T03:58:02Z",
          "updatedAt": "2018-08-07T03:58:08Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I'm not sure on this change. Would you provide more context?",
              "createdAt": "2018-08-07T03:58:02Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODMzMjAy",
          "commit": {
            "abbreviatedOid": "e5bc177"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T03:58:42Z",
          "updatedAt": "2018-08-07T03:58:42Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Ah, how about simple check `Status != 0`?",
              "createdAt": "2018-08-07T03:58:42Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODMzMjQ4",
          "commit": {
            "abbreviatedOid": "e5bc177"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T03:59:04Z",
          "updatedAt": "2018-08-07T03:59:05Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "or >=100 <=999",
              "createdAt": "2018-08-07T03:59:05Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODQyMTcx",
          "commit": {
            "abbreviatedOid": "5d69637"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T05:13:04Z",
          "updatedAt": "2018-08-07T05:13:04Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Changed to check that status code is within [100, 999].",
              "createdAt": "2018-08-07T05:13:04Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODU4MTU2",
          "commit": {
            "abbreviatedOid": "5d69637"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T06:42:38Z",
          "updatedAt": "2018-08-07T06:42:38Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "optional: `http.MethodGet`",
              "createdAt": "2018-08-07T06:42:38Z",
              "updatedAt": "2018-08-07T06:56:00Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODU4ODI0",
          "commit": {
            "abbreviatedOid": "5d69637"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-07T06:45:34Z",
          "updatedAt": "2018-08-07T06:45:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQzODYxNDIz",
          "commit": {
            "abbreviatedOid": "adbbb0b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-07T06:56:22Z",
          "updatedAt": "2018-08-07T06:56:23Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2018-08-07T06:56:23Z",
              "updatedAt": "2018-08-07T06:56:23Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "93daebea27ae7baa09cf7f6bb0b18bbe9f7868e8",
      "headRepository": null,
      "headRefName": "gen-bundle",
      "headRefOid": "adbbb0b7b07043eb1ddc28fd4d188a3414645726",
      "mergeCommit": {
        "oid": "8ba185c14b25968acdcaed9eebdd13707ce6e7ca"
      }
    },
    {
      "number": 283,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA2ODk1MDcy",
      "title": "README.md: Link to go/signedexchange",
      "url": "https://github.com/WICG/webpackage/pull/283",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Now go/signedexchange/README.md would be more useful than Chromium's README.",
      "createdAt": "2018-08-08T05:18:50Z",
      "updatedAt": "2018-11-07T08:00:50Z",
      "closedAt": "2018-08-08T07:29:25Z",
      "mergedAt": "2018-08-08T07:29:25Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0Mjk2NzY0",
          "commit": {
            "abbreviatedOid": "cd9347a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-08T07:29:16Z",
          "updatedAt": "2018-08-08T07:29:16Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "8ba185c14b25968acdcaed9eebdd13707ce6e7ca",
      "headRepository": null,
      "headRefName": "readme",
      "headRefOid": "cd9347a50d803ef2e9a2306b743273be67e653ef",
      "mergeCommit": {
        "oid": "5f280322ed23a560eca43b2ea97a7b7cb6d31d07"
      }
    },
    {
      "number": 284,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA3MTQwMTMy",
      "title": "Update the README and explainer to match the new loading spec.",
      "url": "https://github.com/WICG/webpackage/pull/284",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "We should merge this after #281.",
      "createdAt": "2018-08-08T21:16:30Z",
      "updatedAt": "2018-08-20T21:41:30Z",
      "closedAt": "2018-08-20T07:10:10Z",
      "mergedAt": "2018-08-20T07:10:10Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "There will be things to be considered further, but this one lgtm/2. Thanks!",
          "createdAt": "2018-08-14T09:50:36Z",
          "updatedAt": "2018-08-14T09:50:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ0NjY5MDYy",
          "commit": {
            "abbreviatedOid": "cf01a90"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@kinu Would you review this?",
          "createdAt": "2018-08-09T01:59:27Z",
          "updatedAt": "2018-08-09T02:00:19Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "should we clarify `sufficiently similar`?\r\n```\r\nThe inner request doesn't [match](https://wicg.github.io/webpackage/loading.html#request-matching) the Request the Service Worker sent.\r\n```",
              "createdAt": "2018-08-09T01:59:28Z",
              "updatedAt": "2018-08-13T18:37:54Z"
            },
            {
              "originalPosition": 69,
              "body": "Should we expand SW -> Service Worker?",
              "createdAt": "2018-08-09T01:59:44Z",
              "updatedAt": "2018-08-13T18:37:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ1NzgyMDUz",
          "commit": {
            "abbreviatedOid": "cf01a90"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-13T18:36:10Z",
          "updatedAt": "2018-08-13T18:38:02Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Sure.",
              "createdAt": "2018-08-13T18:36:11Z",
              "updatedAt": "2018-08-13T18:38:02Z"
            },
            {
              "originalPosition": 69,
              "body": "Sure.",
              "createdAt": "2018-08-13T18:36:14Z",
              "updatedAt": "2018-08-13T18:38:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ1OTA4NDgx",
          "commit": {
            "abbreviatedOid": "4a99757"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-14T03:49:44Z",
          "updatedAt": "2018-08-14T03:49:44Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5f280322ed23a560eca43b2ea97a7b7cb6d31d07",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-explainer",
      "headRefOid": "4a99757b23c3ce13ae2c6c41f9b32b9aaa0869be",
      "mergeCommit": {
        "oid": "8970ae364819434679c8a5733710faeeaa391e3a"
      }
    },
    {
      "number": 285,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA3MTU0Mzgw",
      "title": "Define request matching in terms of draft-ietf-httpbis-variants.",
      "url": "https://github.com/WICG/webpackage/pull/285",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See https://docs.google.com/document/d/1JdJkdY7cK2rD9JXbK75sSn069c0rhF9UnLQACBZ1OtY/edit for more analysis and options, but building on @mnot's Variants seems like a good plan here.\n\nIf we go this way, it probably makes sense to move away from storing arbitrary request headers in both signed exchanges and bundles, and toward storing something like the [Variants + Variant-Key headers](https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#variants) directly.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/285.html\" title=\"Last updated on Dec 7, 2018, 11:35 PM GMT (d1d5c8c)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/285/f603e91...jyasskin:d1d5c8c.html\" title=\"Last updated on Dec 7, 2018, 11:35 PM GMT (d1d5c8c)\">Diff</a>",
      "createdAt": "2018-08-08T22:22:19Z",
      "updatedAt": "2018-12-08T00:01:28Z",
      "closedAt": "2018-12-08T00:01:24Z",
      "mergedAt": "2018-12-08T00:01:24Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4NTMzODA4",
          "commit": {
            "abbreviatedOid": "e585628"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "Per your PR-level comment: The Variants header specifies the list of all available variants, not which one this is. That would be the Variant-Key. AFAICT, there is no specified automated way for generating a Variant-Key from existing request headers (i.e. an algorithm to reproduce existing RFC723? behavior). It should be easy to construct one of those, but it seems like a good idea to standardize one. Otherwise, it makes it harder for publishers to generate SXGs. ",
          "createdAt": "2018-11-26T22:33:50Z",
          "updatedAt": "2018-11-26T22:53:52Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Maybe reword as e.g. [=header field specified to be content-negotiable with Variants=].",
              "createdAt": "2018-11-26T22:33:50Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 46,
              "body": "Also, it seems a bit up in the air as to where the UA implementor should look for specifications of Variant content negotiation mechanisms. Appendix A is one place, but presumably new or experimental HTTP headers will define them as part of their own spec? Or maybe it's OK to leave this a bit up in the air for now?",
              "createdAt": "2018-11-26T22:37:31Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 50,
              "body": "I think this is wrong, but I may be misreading this. e.g. If the cached response is `Accept-Language: foo` and the browser doesn't specify an `Accept-Language`, this would match, per the [specified content-negotiation mechanism](https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#content-language).",
              "createdAt": "2018-11-26T22:41:15Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 53,
              "body": "Ditto.",
              "createdAt": "2018-11-26T22:42:56Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNDczMzUy",
          "commit": {
            "abbreviatedOid": "8d60b58"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-30T22:23:12Z",
          "updatedAt": "2018-12-01T01:04:38Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "https://github.com/httpwg/http-extensions/issues/681 suggests a wiki page but doesn't actually create one.",
              "createdAt": "2018-11-30T22:23:12Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 45,
              "body": "How's \"the request header field of a content negotiation mechanism specified to be usable with Variants\"? https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#define talks about the content negotiation mechanism as the primary thing, with the request header being a piece of it.",
              "createdAt": "2018-12-01T00:50:42Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 50,
              "body": "It was out of date, now that Fetch has removed \"combined value\".\r\n\r\nVariants doesn't seem to handle the case where a request header is just missing: https://github.com/httpwg/http-extensions/issues/731.",
              "createdAt": "2018-12-01T01:02:58Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgxMDYzMTYz",
          "commit": {
            "abbreviatedOid": "df60799"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-04T01:55:42Z",
          "updatedAt": "2018-12-04T01:55:43Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Yeah, works for me.",
              "createdAt": "2018-12-04T01:55:42Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgxMDY0MDk0",
          "commit": {
            "abbreviatedOid": "df60799"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-04T02:00:34Z",
          "updatedAt": "2018-12-04T02:10:53Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Ah, okay, sounds good. I guess the effect of this is that SXG generators should choose the \"greatest common subset\" of variable headers that are supported by the UAs they're targeting. As long as UAs tend to add support for headers over time rather than remove, this should be fine.",
              "createdAt": "2018-12-04T02:00:34Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            },
            {
              "originalPosition": 50,
              "body": "I think support for null values of negotiable request headers (here and in the content negotiation algorithms) is a necessity, though. Otherwise, if 3 different UAs support 3 different sets of content negotiation algorithms, then it would be impossible to generate an SXG that could be used by all of them. The union of all supported headers would fail because of the first item above, and the intersection of all supported headers would fail because of this item.\r\n\r\nEven for a single UA, one would have to tailor the header list to the particular version of the UA.\r\n\r\nMaybe this isn't a problem in practice because the set of content-negotiable headers doesn't change that much. But it'd be nice to avoid some spooky-action-at-a-distance here that may lead to calcification of that list.\r\n\r\n(I hope I'm not misunderstanding; I haven't spent a lot of time thinking about this, so I may be.)",
              "createdAt": "2018-12-04T02:10:08Z",
              "updatedAt": "2018-12-07T23:33:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyOTExMjEy",
          "commit": {
            "abbreviatedOid": "d1d5c8c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-07T23:33:41Z",
          "updatedAt": "2018-12-07T23:33:41Z",
          "comments": [
            {
              "originalPosition": 50,
              "body": "I agree. Now I just delegate to the content-negotiation algorithms, which I'm fixing in https://github.com/httpwg/http-extensions/pull/735.",
              "createdAt": "2018-12-07T23:33:41Z",
              "updatedAt": "2018-12-07T23:33:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyOTE0MTM5",
          "commit": {
            "abbreviatedOid": "d1d5c8c"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-07T23:51:42Z",
          "updatedAt": "2018-12-07T23:51:42Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f603e91d73ef7189b4342662853bac84c6e9ff90",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "request-matching",
      "headRefOid": "d1d5c8c474da5e510fe484b3b97a6a4f6ad70475",
      "mergeCommit": {
        "oid": "dcb188d89aee7b2ab06b55d45ccad8343d924a06"
      }
    },
    {
      "number": 286,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4MDY0NjQz",
      "title": "Remove longlived impl diffs",
      "url": "https://github.com/WICG/webpackage/pull/286",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fix #197. \r\n\r\n@kinu, does this look good enough? [mice-03](https://tools.ietf.org/html/draft-thomson-http-mice-03) is now published.\r\n\r\nsigned-responses: [Preview](https://jyasskin.github.io/webpackage/remove-longlived-impl-diffs/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/remove-longlived-impl-diffs/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nbundled-exchanges: [Preview](https://jyasskin.github.io/webpackage/remove-longlived-impl-diffs/draft-yasskin-wpack-bundled-exchanges.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.txt&url2=https://jyasskin.github.io/webpackage/remove-longlived-impl-diffs/draft-yasskin-wpack-bundled-exchanges.txt)",
      "createdAt": "2018-08-13T18:32:31Z",
      "updatedAt": "2018-08-14T18:25:31Z",
      "closedAt": "2018-08-14T18:25:27Z",
      "mergedAt": "2018-08-14T18:25:27Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ1OTA3NTIx",
          "commit": {
            "abbreviatedOid": "52c8af8"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-14T03:41:02Z",
          "updatedAt": "2018-08-14T03:41:02Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5f280322ed23a560eca43b2ea97a7b7cb6d31d07",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "remove-longlived-impl-diffs",
      "headRefOid": "52c8af8200739cf1a31a26cc58f25a5ef0f14e6b",
      "mergeCommit": {
        "oid": "bc103472aacb7f1b4ff898e8e6eaf59cd6b09e04"
      }
    },
    {
      "number": 287,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4NDEwOTA5",
      "title": "Operate over header bytes instead of logical exchanges.",
      "url": "https://github.com/WICG/webpackage/pull/287",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Fixes #276 and makes it clearer that implementations shouldn't reserialize things per https://crbug.com/863499.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/fix-276-clearly-reuse-header-bytes/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/fix-276-clearly-reuse-header-bytes/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nThe change to the signed-message format can only take effect in b2, of course.",
      "createdAt": "2018-08-14T21:07:45Z",
      "updatedAt": "2018-08-20T21:41:01Z",
      "closedAt": "2018-08-17T05:42:04Z",
      "mergedAt": "2018-08-17T05:42:03Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Took a look, this looks good and am fine with either cherry-picking the format change only (nyaxt@ have a concern as the change included more) or landing this as is.",
          "createdAt": "2018-08-15T04:36:40Z",
          "updatedAt": "2018-08-15T04:36:40Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "IIUC, the commit has 2 goals:\r\n- Change the signature message format to not use CBOR\r\n- Explicitly pass CBOR header bytes to `{{ signature-validity }}` algorithm\r\n\r\nI'm not 100% confident from 30min review if all `exchange` concept change and `{{ signature-validity }}` procedure arguments change are consistent across all spec text.\r\nI think I'm fairly confident about the cross-origin path but I feel like there is subtlety with same-origin path.\r\n\r\nSince we are getting close to branch point, we discussed this with @kinu and decided to proceed with the PR and then follow up with fix-ups if needed. I was wondering if we could cherry-pick just the message format change for now but the lack of active implementation on the same-origin path atm may justify it a bit. That being said, I'd appreciate any help on reviewing cross-origin path.",
          "createdAt": "2018-08-15T04:45:05Z",
          "updatedAt": "2018-08-15T04:45:05Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ2MzI0NTU5",
          "commit": {
            "abbreviatedOid": "0840264"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-15T04:02:09Z",
          "updatedAt": "2018-08-15T04:34:39Z",
          "comments": [
            {
              "originalPosition": 200,
              "body": "Since we removed `{{significant-headers}}` concept, we might want to be pedantic here:\r\n\r\nIf the client relies on signature validity for any aspect of its behavior, it MUST ignore any header fields whose name are not listed in the `Signed-Headers` header field.",
              "createdAt": "2018-08-15T04:02:10Z",
              "updatedAt": "2018-08-15T04:34:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3MDI1NzY0",
          "commit": {
            "abbreviatedOid": "0840264"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-16T21:11:34Z",
          "updatedAt": "2018-08-16T21:11:35Z",
          "comments": [
            {
              "originalPosition": 113,
              "body": "tl;dr: I think it's fine for this part to be CBOR if you all want it to be CBOR. Sorry, I think I was unclear. It's more about re-encoding the headers than avoiding CBOR. :-)\r\n\r\nThis format's fine too, though if you do that, I suggest using BoringSSL's `CBB` functions in the implementation (we don't currently have `CBB_add_u64{,_length_prefixed}` since TLS doesn't use those, but they'd be easy to add). TLS also has a struct syntax you could borrow. (An 8 byte length prefix is also kind of impressively large for both URL and headers. :-) I don't think any implementation would tolerate either field to exceed, say, a 3 byte length. But 8 bytes is cool too if you prefer.)\r\n\r\nTo the CBOR point, I think I didn't express the concern clearly. My bad. It's not that you shouldn't trust the CBOR encoder itself. Rather, let's look at the pipeline of conversions we've got here.\r\n\r\nWe convert the byte representation of the signed exchange, to a CBOR AST (CBORValue), to some parsed signed exchange struct (SignedExchangeEnvelope), to the net/loading stack's representation (HttpResponseHeaders). Along the way, to verify the signature, we convert the SignedExchangeEnvelope *back* to the CBOR AST, then *back* to bytes, and *then* verify it.\r\n\r\nThat is:\r\n\r\n```\r\nbytes -> CBORValue -> SignedExchangeEnvelope -> HttpResponseHeaders -...-> web stack\r\n                                 |\r\n                                 v\r\n                             CBORValue\r\n                                 |\r\n                                 v\r\n                               bytes\r\n                                 |\r\n                                 v\r\n                         (verify signature)\r\n```\r\n\r\nWe want the \"verify signature\" step to cover what was ultimately sent to the rest of the stack. That's the point of this whole process. We wish to know that everything downstream of the verification only sees content attested by the signature.\r\n\r\nSuppose there's a logic bug in one of the right arrows. Maybe on certain malformed or weird input, we output something that can be massaged into an XSS. That's bad, but the signature mitigates a lot of potential attack vectors. The origin isn't going to sign the bad input, so as long as the verify step covered everything, an attacker can't use that bug to inject bad input into the origin. *The requirement on right arrows is they depend only on their inputs.*\r\n\r\nHowever, suppose there is a logic bug in one of the down arrows. Maybe we forgot to copy some new field from the SignedExchangeEnvelope into the CBORValue. That's a problem. An attacker can put the new field in, the signature would check out, and all the right arrows would think this new field was covered, when it really wasn't. *The requirement on down arrows is they preserve all information.*\r\n\r\nNote that, of these two requirements, one is much more straightforward than the other. It's hard to accidentally check a random global variable somewhere. :-) It's much easier to accidentally forget to encode something, or have some escaping bug in the encode somewhere.\r\n\r\nThus the goal is to minimize the complexity in the verify step. The trick I like most is to find the simplest representation and verify that. An array of bytes is a good candidate. No one is going to extend that. All the complex structure is carried within, and the verify step is blind to it all.\r\n\r\nNow, you can't always manage this. In the case of this logic, you are not just bytes. It's bytes plus some metadata decoded out of headers (cert-sha256, validity-url, etc). And, yeah, that means you need to go encode that metadata in some way. Maybe CBOR, maybe DER, or maybe something ad hoc. And, yeah, that's more down arrows. It would be more robust if you didn't have to do that, but there are also benefits to having the signature metadata outside of the payload, so the tradeoff is probably to leave those as is. Hopefully we don't have to extend those very often and the right arrows probably discard that information pretty quickly.\r\n\r\nThe rest of the payload, on the other hand, seems preferable to keep as bytes. Maybe someone will try to put trailers in there someday, I dunno.",
              "createdAt": "2018-08-16T21:11:35Z",
              "updatedAt": "2018-08-16T22:14:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3MDM0MTUw",
          "commit": {
            "abbreviatedOid": "0840264"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Some drive-by comments. They apply to the baseline of this PR, too; should I file a bug for them instead?",
          "createdAt": "2018-08-16T21:39:24Z",
          "updatedAt": "2018-08-16T21:52:29Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "I get a bit confused by the language \"no serialized headers\". It sounds like this means :method, :url, and :status would be omitted from {{cbor-representation}}, but I don't think that's what's intended.",
              "createdAt": "2018-08-16T21:39:24Z",
              "updatedAt": "2018-08-16T21:52:29Z"
            },
            {
              "originalPosition": 228,
              "body": "(Ditto.)",
              "createdAt": "2018-08-16T21:40:28Z",
              "updatedAt": "2018-08-16T21:52:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3MTAzMTIy",
          "commit": {
            "abbreviatedOid": "0840264"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Since @jyasskin is now OOO. I'll merge this and address @twifkak comments on a separate PR",
          "createdAt": "2018-08-17T05:41:14Z",
          "updatedAt": "2018-08-17T05:41:41Z",
          "comments": [
            {
              "originalPosition": 222,
              "body": "I'll do a separate PR for this.",
              "createdAt": "2018-08-17T05:41:15Z",
              "updatedAt": "2018-08-17T05:41:41Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "bc103472aacb7f1b4ff898e8e6eaf59cd6b09e04",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fix-276-clearly-reuse-header-bytes",
      "headRefOid": "0840264ec7ecbf484a0f68d7cf4787a47f30691b",
      "mergeCommit": {
        "oid": "5f976921cc0e45075ead7fa0a017aca080528b49"
      }
    },
    {
      "number": 288,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA4NDQwOTc0",
      "title": "Put a fallback URL at the beginning of signed exchanges",
      "url": "https://github.com/WICG/webpackage/pull/288",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This lets the browser redirect there if it doesn't recognize the version of the signed exchange.\r\n\r\nThis sits on top of #287 and #281, so please only review [`99fa76f`](https://github.com/WICG/webpackage/pull/288/commits/99fa76f42e04d3f4c0cc2d933f9f7d5ead2428ce). It fixes #242.\r\n\r\nOne question here is whether to include the method with the fallback URL. We can't do anything with a non-GET method right now, and after many years of HTTP, the only acceptable methods are GET and HEAD anyway, so I think we should consider dropping the method entirely, although not in this PR.\r\n\r\nsigned-responses: [Preview](https://jyasskin.github.io/webpackage/fallback-url/draft-yasskin-http-origin-signed-responses.html), [Diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/fix-276-clearly-reuse-header-bytes/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/fallback-url/draft-yasskin-http-origin-signed-responses.txt)\r\n\r\nLoading: [Preview](https://jyasskin.github.io/webpackage/fallback-url/loading.html#mp-http-fetch)",
      "createdAt": "2018-08-14T23:52:48Z",
      "updatedAt": "2018-08-20T21:41:49Z",
      "closedAt": "2018-08-20T07:21:22Z",
      "mergedAt": "2018-08-20T07:21:21Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3MTA0MjIz",
          "commit": {
            "abbreviatedOid": "99fa76f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "99fa76f lgtm",
          "createdAt": "2018-08-17T05:49:36Z",
          "updatedAt": "2018-08-17T05:49:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTIyNjE0",
          "commit": {
            "abbreviatedOid": "99fa76f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T07:10:16Z",
          "updatedAt": "2018-08-20T07:10:20Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "I was wondering if we'd need to fix the blow example, that includes ':url' in cbor representation.",
              "createdAt": "2018-08-20T07:10:16Z",
              "updatedAt": "2018-08-20T07:10:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTIyODAx",
          "commit": {
            "abbreviatedOid": "99fa76f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T07:11:02Z",
          "updatedAt": "2018-08-20T07:11:02Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Good catch. I'll file a separate PR for this",
              "createdAt": "2018-08-20T07:11:02Z",
              "updatedAt": "2018-08-20T07:11:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTI2NTgz",
          "commit": {
            "abbreviatedOid": "99fa76f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-20T07:26:02Z",
          "updatedAt": "2018-08-20T07:26:03Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Filed #290",
              "createdAt": "2018-08-20T07:26:03Z",
              "updatedAt": "2018-08-20T07:26:03Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "bc103472aacb7f1b4ff898e8e6eaf59cd6b09e04",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fallback-url",
      "headRefOid": "99fa76f42e04d3f4c0cc2d933f9f7d5ead2428ce",
      "mergeCommit": {
        "oid": "99fa76f42e04d3f4c0cc2d933f9f7d5ead2428ce"
      }
    },
    {
      "number": 290,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA5NDMyNjky",
      "title": "Update examples to match the new format",
      "url": "https://github.com/WICG/webpackage/pull/290",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@jyasskin FYI OOO",
      "createdAt": "2018-08-20T07:25:40Z",
      "updatedAt": "2018-08-20T08:23:20Z",
      "closedAt": "2018-08-20T08:23:20Z",
      "mergedAt": "2018-08-20T08:23:20Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTI3OTI3",
          "commit": {
            "abbreviatedOid": "e8564d7"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "non-owner lgtm",
          "createdAt": "2018-08-20T07:31:17Z",
          "updatedAt": "2018-08-20T07:31:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3NTI3OTU4",
          "commit": {
            "abbreviatedOid": "e8564d7"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-20T07:31:26Z",
          "updatedAt": "2018-08-20T07:31:26Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7970b594cd93a679771c5753dbc7f9b6e11af464",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "fixexample",
      "headRefOid": "e8564d7385fdf3d3ecde14b50f06f928559e2d74",
      "mergeCommit": {
        "oid": "d8e933ea1991dfc236d0bb69ee886c9ee27d6d15"
      }
    },
    {
      "number": 291,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA5NzU3Nzgx",
      "title": "Add signedexchange/version",
      "url": "https://github.com/WICG/webpackage/pull/291",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR introduces `Version` type to represent spec versions. This is needed to be a new package since this is referenced from multiple packages not only `signedexchange` but also `mice`.",
      "createdAt": "2018-08-21T09:12:00Z",
      "updatedAt": "2018-08-21T09:56:57Z",
      "closedAt": "2018-08-21T09:16:38Z",
      "mergedAt": "2018-08-21T09:16:38Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Lgtm",
          "createdAt": "2018-08-21T09:56:57Z",
          "updatedAt": "2018-08-21T09:56:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ3OTcwODgw",
          "commit": {
            "abbreviatedOid": "713691f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-08-21T09:14:53Z",
          "updatedAt": "2018-08-21T09:14:53Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d8e933ea1991dfc236d0bb69ee886c9ee27d6d15",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "versions",
      "headRefOid": "713691f7504b0cfd5f22da0569cb793a338bd025",
      "mergeCommit": {
        "oid": "c7235d44c20224eb14755aa06ddd3175bf4c74b5"
      }
    },
    {
      "number": 292,
      "id": "MDExOlB1bGxSZXF1ZXN0MjA5ODA1OTE3",
      "title": "Implement b2 version of encoder",
      "url": "https://github.com/WICG/webpackage/pull/292",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-21T12:18:15Z",
      "updatedAt": "2018-08-22T08:26:42Z",
      "closedAt": "2018-08-22T08:26:37Z",
      "mergedAt": "2018-08-22T08:26:37Z",
      "mergedBy": "hajimehoshi",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged @irori 's mice implementation",
          "createdAt": "2018-08-22T06:20:51Z",
          "updatedAt": "2018-08-22T06:20:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MDUxMjI1",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-21T13:12:36Z",
          "updatedAt": "2018-08-21T13:19:10Z",
          "comments": [
            {
              "originalPosition": 169,
              "body": "How about making `16*1024` a const MaximumSignatureHeaderValueLen",
              "createdAt": "2018-08-21T13:12:36Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 182,
              "body": "ditto",
              "createdAt": "2018-08-21T13:13:11Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 47,
              "body": "We need to resolve this before merge :)",
              "createdAt": "2018-08-21T13:18:45Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MDYzMTYx",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-21T13:39:38Z",
          "updatedAt": "2018-08-21T13:39:38Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Oops, nice catch",
              "createdAt": "2018-08-21T13:39:38Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzExMjU1",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-22T01:58:57Z",
          "updatedAt": "2018-08-22T01:58:58Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Let's use \"1b1\" as default until we have all the b2 changes in (i.e. http-mice-03).",
              "createdAt": "2018-08-22T01:58:58Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzEzMDQw",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-22T02:12:37Z",
          "updatedAt": "2018-08-22T02:16:20Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "This should be `\"sxg1-b2\\x00\"`",
              "createdAt": "2018-08-22T02:12:37Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzE4Njc4",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-22T02:57:56Z",
          "updatedAt": "2018-08-22T02:57:56Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I thought the spec said the magic header byte is `\"sxg1\\x00\\x00\\x00\\x00\"`.\r\n\r\n> 8 bytes consisting of the ASCII characters \u201csxg1\u201d followed by 4 0x00 bytes, to serve as a file signature. This is redundant with the MIME type, and recipients that receive both MUST check that they match and stop parsing if they don\u2019t.",
              "createdAt": "2018-08-22T02:57:56Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzI2OTcw",
          "commit": {
            "abbreviatedOid": "706bdaf"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you!",
          "createdAt": "2018-08-22T04:10:49Z",
          "updatedAt": "2018-08-22T04:18:06Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Agreed. Change this later then.",
              "createdAt": "2018-08-22T04:10:49Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 47,
              "body": "Done.",
              "createdAt": "2018-08-22T04:14:14Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 169,
              "body": "Done (defined a local unexported const)",
              "createdAt": "2018-08-22T04:15:59Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 182,
              "body": "Done",
              "createdAt": "2018-08-22T04:16:03Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            },
            {
              "originalPosition": 14,
              "body": "Done, but I'd like to know if the spec is correct or not.",
              "createdAt": "2018-08-22T04:18:00Z",
              "updatedAt": "2018-08-22T06:20:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzU5MTEx",
          "commit": {
            "abbreviatedOid": "1a24e7c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-22T07:25:13Z",
          "updatedAt": "2018-08-22T07:25:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4MzY1OTY0",
          "commit": {
            "abbreviatedOid": "1a24e7c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "mice/ lgtm",
          "createdAt": "2018-08-22T07:49:02Z",
          "updatedAt": "2018-08-22T07:49:02Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c7235d44c20224eb14755aa06ddd3175bf4c74b5",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "b2",
      "headRefOid": "1a24e7c2588294e6dd3e4f4bb7b049a19b61d525",
      "mergeCommit": {
        "oid": "b44a2d4816b7a855da3fdf5382ff445342fff8af"
      }
    },
    {
      "number": 294,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEwMzA2ODM1",
      "title": "gen-signedexchange: Add flag to optionally dump headers cbor for debu\u2026",
      "url": "https://github.com/WICG/webpackage/pull/294",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026gging",
      "createdAt": "2018-08-23T01:30:13Z",
      "updatedAt": "2018-08-23T02:49:49Z",
      "closedAt": "2018-08-23T02:18:36Z",
      "mergedAt": "2018-08-23T02:18:36Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4NzMxODE4",
          "commit": {
            "abbreviatedOid": "c8b0ef6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-23T01:39:37Z",
          "updatedAt": "2018-08-23T01:39:47Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Intended? (If so, please note in the patch description).",
              "createdAt": "2018-08-23T01:39:37Z",
              "updatedAt": "2018-08-23T02:06:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4NzM1NjMx",
          "commit": {
            "abbreviatedOid": "8270cd7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-23T02:06:55Z",
          "updatedAt": "2018-08-23T02:06:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "no. Thanks for the catch",
              "createdAt": "2018-08-23T02:06:55Z",
              "updatedAt": "2018-08-23T02:06:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4NzM2NzU3",
          "commit": {
            "abbreviatedOid": "8270cd7"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-08-23T02:15:01Z",
          "updatedAt": "2018-08-23T02:15:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ4NzQxNTc4",
          "commit": {
            "abbreviatedOid": "8270cd7"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-23T02:49:48Z",
          "updatedAt": "2018-08-23T02:49:49Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "I realized that the flag names include upper and lower cases... I was wondering if this is usual \ud83e\udd14 ",
              "createdAt": "2018-08-23T02:49:49Z",
              "updatedAt": "2018-08-23T02:49:49Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "b44a2d4816b7a855da3fdf5382ff445342fff8af",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "dumpcborhdr",
      "headRefOid": "8270cd751ee36a20224c55ee8d735ac0d419e208",
      "mergeCommit": {
        "oid": "59e2368120ae767d9ab54a07bfae7cd60612649f"
      }
    },
    {
      "number": 296,
      "id": "MDExOlB1bGxSZXF1ZXN0MjExMDA3Nzcx",
      "title": "Snapshot implementation draft b2",
      "url": "https://github.com/WICG/webpackage/pull/296",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-08-27T05:19:21Z",
      "updatedAt": "2018-09-03T12:46:42Z",
      "closedAt": "2018-09-03T12:46:42Z",
      "mergedAt": "2018-09-03T12:46:42Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I need to append the ChangeLog items in ToT then backport.",
          "createdAt": "2018-08-27T05:20:17Z",
          "updatedAt": "2018-08-27T05:20:17Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated ChangeLog. PTAL",
          "createdAt": "2018-09-03T05:30:11Z",
          "updatedAt": "2018-09-03T05:30:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5NTg3OTc5",
          "commit": {
            "abbreviatedOid": "ee52825"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-27T05:52:41Z",
          "updatedAt": "2018-08-27T05:52:50Z",
          "comments": [
            {
              "originalPosition": 359,
              "body": "Remove this and next line",
              "createdAt": "2018-08-27T05:52:41Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5NTg5Mjg0",
          "commit": {
            "abbreviatedOid": "ee52825"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-27T06:02:02Z",
          "updatedAt": "2018-08-27T06:02:02Z",
          "comments": [
            {
              "originalPosition": 359,
              "body": "Done.",
              "createdAt": "2018-08-27T06:02:02Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5ODE4NDk3",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "All these comments should probably go on the main file, not the implementation snapshot, so I apologize for lazily making them here. Snapshot LGTM.",
          "createdAt": "2018-08-27T18:03:03Z",
          "updatedAt": "2018-08-27T18:27:26Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "May not be worth deciding now, but future integrity formats may want names containing a variable number of slashes (e.g. a pair of base64-encoded strings), so you may want an escaping mechanism eventually.",
              "createdAt": "2018-08-27T18:03:03Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 181,
              "body": "Why move this down here from line 419?",
              "createdAt": "2018-08-27T18:08:51Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 366,
              "body": "This means the magic \"sxg1-b2\" must always remain 7 chars. Out of curiosity:\r\n - What's after `b9`? `bA`..`bZ`? Or do we move to `g1` (for gamma)? :P\r\n - What's v1 look like? \"sxg1\\0\\0\\0\"?",
              "createdAt": "2018-08-27T18:20:36Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 362,
              "body": "(Given 65536 is longer than several existing browsers can support (AFAICT), perhaps the fetch spec should say how browsers should respond if the fallbackUrl is too long? Or specify a minimum length they must support? Or is this already covered by some other part of Fetch?)",
              "createdAt": "2018-08-27T18:24:36Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5OTM4OTY0",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-28T01:29:29Z",
          "updatedAt": "2018-08-28T01:29:29Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "IIUC, the string here refers to format id such as \"digest/mi-sha256-03\" so I think we are OK?",
              "createdAt": "2018-08-28T01:29:29Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5OTQwOTMw",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-28T01:43:11Z",
          "updatedAt": "2018-08-28T01:48:45Z",
          "comments": [
            {
              "originalPosition": 181,
              "body": "We wanted to clarify that the UAs may start processing the headers part before verifying the entire payload.\r\nBefore this change, invalid payload could make headers invalid. After this change the headers checks are somewhat independent.\r\n\r\nThe original change was from @jyasskin, so I may be wrong.",
              "createdAt": "2018-08-28T01:43:11Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 366,
              "body": "> - What's after b9? bA..bZ? Or do we move to g1 (for gamma)? :P\r\n\r\nWe hope to get to a standard before reaching bA :airplane: \r\n\r\n> - What's v1 look like? \"sxg1\\0\\0\\0\"?\r\n\r\nThat is the idea.",
              "createdAt": "2018-08-28T01:44:49Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            },
            {
              "originalPosition": 362,
              "body": "I'm not sure. Would you mind filing a separate issue?",
              "createdAt": "2018-08-28T01:46:47Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5OTYwNDAz",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-28T04:11:31Z",
          "updatedAt": "2018-08-28T04:11:31Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Yeah, I think this is fine for the foreseeable future; I was just hypothesizing about a new integrity header.",
              "createdAt": "2018-08-28T04:11:31Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTQ5OTYwODU0",
          "commit": {
            "abbreviatedOid": "e43bf03"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-08-28T04:15:23Z",
          "updatedAt": "2018-08-28T04:15:23Z",
          "comments": [
            {
              "originalPosition": 362,
              "body": "OK, filed #297.",
              "createdAt": "2018-08-28T04:15:23Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNjcwMjk0",
          "commit": {
            "abbreviatedOid": "54296b4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-09-03T06:19:26Z",
          "updatedAt": "2018-09-03T06:19:51Z",
          "comments": [
            {
              "originalPosition": 440,
              "body": "\"at the beginning of the `application/signed-exchange` format\" might be more precise.",
              "createdAt": "2018-09-03T06:19:26Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNjczMDcw",
          "commit": {
            "abbreviatedOid": "54296b4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-03T06:35:04Z",
          "updatedAt": "2018-09-03T06:35:04Z",
          "comments": [
            {
              "originalPosition": 440,
              "body": "Done.",
              "createdAt": "2018-09-03T06:35:04Z",
              "updatedAt": "2018-09-03T06:36:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxNzE0MjMw",
          "commit": {
            "abbreviatedOid": "df367f7"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, this looks good!",
          "createdAt": "2018-09-03T09:04:57Z",
          "updatedAt": "2018-09-03T09:04:57Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "59e2368120ae767d9ab54a07bfae7cd60612649f",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "impl-b2",
      "headRefOid": "df367f700511182d54aab24ca1e23fbea8173de5",
      "mergeCommit": {
        "oid": "50277f4326e4974a4ab60992068fe853368561e2"
      }
    },
    {
      "number": 298,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEyNjU0MzM3",
      "title": "Update Change Log entries",
      "url": "https://github.com/WICG/webpackage/pull/298",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Ported from https://github.com/WICG/webpackage/pull/296",
      "createdAt": "2018-09-03T06:45:27Z",
      "updatedAt": "2018-11-29T07:13:53Z",
      "closedAt": "2018-11-29T07:13:53Z",
      "mergedAt": "2018-11-29T07:13:53Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MDM2NTUy",
          "commit": {
            "abbreviatedOid": "13a937f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks for adding these to the changelog. I added a commit suggesting different wording, which you're welcome to change again. :)",
          "createdAt": "2018-11-21T00:40:33Z",
          "updatedAt": "2018-11-21T00:40:33Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "827cb70e954750dca7bc8aecb977cd49442dc856",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "chlog",
      "headRefOid": "13a937fc07ce12e887ba383cf45421081b388eb6",
      "mergeCommit": {
        "oid": "25a0996a29529917865641c7b67d4dc04a5fd8df"
      }
    },
    {
      "number": 301,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEyOTA0Njky",
      "title": "dump-signedexchange: support b2 format",
      "url": "https://github.com/WICG/webpackage/pull/301",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also updates the spec comments in ReadExchange().",
      "createdAt": "2018-09-04T09:06:23Z",
      "updatedAt": "2018-09-05T00:50:30Z",
      "closedAt": "2018-09-05T00:50:26Z",
      "mergedAt": "2018-09-05T00:50:26Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUxOTc3ODUw",
          "commit": {
            "abbreviatedOid": "0e5c716"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-04T09:16:30Z",
          "updatedAt": "2018-09-04T09:16:30Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMTEwMzI2",
          "commit": {
            "abbreviatedOid": "0e5c716"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm, thanks!",
          "createdAt": "2018-09-04T15:01:14Z",
          "updatedAt": "2018-09-04T15:01:45Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "`else` is not needed here?\r\n\r\n```go\r\nif ver == version.Version1b1 {\r\n  // ...\r\n  continue\r\n}\r\nreturn fmt.Errorf(\"signedexchange: found a deprecated request key %q\", keyURL)\r\n```\r\n",
              "createdAt": "2018-09-04T15:01:14Z",
              "updatedAt": "2018-09-05T00:47:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyMzAyMjg5",
          "commit": {
            "abbreviatedOid": "1d295aa"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-05T00:47:42Z",
          "updatedAt": "2018-09-05T00:47:42Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "done.",
              "createdAt": "2018-09-05T00:47:42Z",
              "updatedAt": "2018-09-05T00:47:42Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "50277f4326e4974a4ab60992068fe853368561e2",
      "headRepository": null,
      "headRefName": "dump-b2",
      "headRefOid": "1d295aa21d5fce32a015b6d6d550859f328f6670",
      "mergeCommit": {
        "oid": "2b2ca9a1c8d769ad532510a4af6599ab812321a0"
      }
    },
    {
      "number": 302,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzMDIyODYy",
      "title": "Add go.mod/go.sum",
      "url": "https://github.com/WICG/webpackage/pull/302",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "Add `go.mod` and `go.sum` so that the dependent library versions are specified explicitly. This affects Go 1.11 module usages (without $GOPATH), and should not affect the current usual usage (with $GOPATH).\r\n\r\nThis is a preparation for Go modules which will be officially introduced at Go 1.12.\r\n\r\nNote: you can test this by:\r\n\r\n1. Checking out https://github.com/WICG/webpackage at your local machine, not under `$GOPATH/src`\r\n2. Run `GO111MODULE=on go test ./...`\r\n",
      "createdAt": "2018-09-04T15:45:47Z",
      "updatedAt": "2019-01-21T08:14:43Z",
      "closedAt": "2019-01-21T07:56:53Z",
      "mergedAt": "2019-01-21T07:56:53Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "I found some tests in bundle failed:\r\n\r\n```\r\n$ GO111MODULE=on go test ./...\r\n# github.com/WICG/webpackage/go/bundle\r\ngo/bundle/bundle.go:91: Fprintf format %s has arg e.Response.Status of wrong type int\r\n# github.com/WICG/webpackage/go/bundle/cmd/gen-bundle\r\ngo/bundle/cmd/gen-bundle/fromdir.go:90: Errorf call needs 1 arg but has 2 args\r\nok      github.com/WICG/webpackage/go/signedexchange    (cached)\r\nok      github.com/WICG/webpackage/go/signedexchange/cbor       (cached)\r\nok      github.com/WICG/webpackage/go/signedexchange/certurl    (cached)\r\nok      github.com/WICG/webpackage/go/signedexchange/internal/bigendian (cached)\r\nok      github.com/WICG/webpackage/go/signedexchange/mice       (cached)\r\nok      github.com/WICG/webpackage/go/webpack   (cached)\r\nok      github.com/WICG/webpackage/go/webpack/cbor      (cached)\r\n```\r\n\r\nIs this no longer maintained?",
          "createdAt": "2018-09-04T19:12:41Z",
          "updatedAt": "2018-09-04T19:12:41Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "go/bundle is not maintained anymore.\r\n",
          "createdAt": "2018-09-14T06:20:54Z",
          "updatedAt": "2018-09-14T06:20:54Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Then would it be better to remove bundle?",
          "createdAt": "2018-09-14T06:32:21Z",
          "updatedAt": "2018-09-14T06:32:21Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Would you update this PR?",
          "createdAt": "2019-01-07T00:15:58Z",
          "updatedAt": "2019-01-07T00:15:58Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "> go/bundle is not maintained anymore.\r\n\r\nSorry, I meant `go/webpack` here. `go/bundle` should be fixed",
          "createdAt": "2019-01-07T03:25:19Z",
          "updatedAt": "2019-01-07T03:25:31Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "```\r\ngo: github.com/Sirupsen/logrus@v1.3.0: parsing go.mod: unexpected module path \"github.com/sirupsen/logrus\" \r\n```\r\n\r\nLooks like there are an unavailable package. I'll take a look.",
          "createdAt": "2019-01-15T05:58:42Z",
          "updatedAt": "2019-01-15T05:58:42Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "https://github.com/mrichman/hargo/pull/11 will fix this issue.",
          "createdAt": "2019-01-15T06:22:47Z",
          "updatedAt": "2019-01-15T06:22:47Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Let's wait for the hargo PR merge",
          "createdAt": "2019-01-17T05:16:59Z",
          "updatedAt": "2019-01-17T05:16:59Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@hajimehoshi now the pr is merged, would you update this pr?",
          "createdAt": "2019-01-21T05:56:49Z",
          "updatedAt": "2019-01-21T05:56:49Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated :-)",
          "createdAt": "2019-01-21T06:27:17Z",
          "updatedAt": "2019-01-21T06:27:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0NDc1MDIz",
          "commit": {
            "abbreviatedOid": "17b4330"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-21T07:56:47Z",
          "updatedAt": "2019-01-21T07:56:47Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a253005203876c2b3cf59b3464c8728692a20ed2",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "mod",
      "headRefOid": "17b4330b281a0854c23efccac77713f78a4576d1",
      "mergeCommit": {
        "oid": "aa5229e178a936d8686c942f34fac22384be49bc"
      }
    },
    {
      "number": 304,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzNDc3NTg4",
      "title": "Update gen-certurl test",
      "url": "https://github.com/WICG/webpackage/pull/304",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add OCSP and SCT to the test input\r\n- Remove an unused function",
      "createdAt": "2018-09-06T02:23:08Z",
      "updatedAt": "2018-09-06T03:00:04Z",
      "closedAt": "2018-09-06T03:00:01Z",
      "mergedAt": "2018-09-06T03:00:01Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzUyMjY4",
          "commit": {
            "abbreviatedOid": "8de6a8c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-06T02:24:13Z",
          "updatedAt": "2018-09-06T02:24:13Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzU2MjI3",
          "commit": {
            "abbreviatedOid": "8de6a8c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-09-06T02:54:08Z",
          "updatedAt": "2018-09-06T02:54:08Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2b2ca9a1c8d769ad532510a4af6599ab812321a0",
      "headRepository": null,
      "headRefName": "test",
      "headRefOid": "8de6a8cf35f1b04911b2a529d2ebabb96455dec7",
      "mergeCommit": {
        "oid": "52e6fde487d5fb60796749398847f757e24eb7ba"
      }
    },
    {
      "number": 305,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzNDg1Mjgz",
      "title": "gen-certurl: Introduce CertChain type",
      "url": "https://github.com/WICG/webpackage/pull/305",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add `CertChain` type and replace `CreateCertChainCBOR()` with `CertChain.Write()`\r\n- Rename `parse.go` to `cert_chain.go`\r\n\r\n`adc920e` is just file renaming, so you might want to look at [`bbfbcfa`](https://github.com/WICG/webpackage/commit/bbfbcfaf0f479f1391395fd2dd8a64fa39e802d2) to see the diff.",
      "createdAt": "2018-09-06T03:28:04Z",
      "updatedAt": "2018-09-07T03:26:00Z",
      "closedAt": "2018-09-07T03:25:54Z",
      "mergedAt": "2018-09-07T03:25:54Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzYxNTI1",
          "commit": {
            "abbreviatedOid": "adc920e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-09-06T03:34:41Z",
          "updatedAt": "2018-09-06T03:37:05Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Would you name this const MagicString or something?",
              "createdAt": "2018-09-06T03:34:41Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            },
            {
              "originalPosition": 36,
              "body": "should we introduce a check so that item[1..] would not have OCSPResponse/SCTList?",
              "createdAt": "2018-09-06T03:36:53Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzY1MDgx",
          "commit": {
            "abbreviatedOid": "7477b5a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-06T04:03:15Z",
          "updatedAt": "2018-09-06T04:03:16Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Added a check for OCSP. For SCTList, having it in [1..] is allowed.",
              "createdAt": "2018-09-06T04:03:15Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzY1MDkx",
          "commit": {
            "abbreviatedOid": "7477b5a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-06T04:03:20Z",
          "updatedAt": "2018-09-06T04:03:20Z",
          "comments": [
            {
              "originalPosition": 26,
              "body": "Done.",
              "createdAt": "2018-09-06T04:03:20Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUyNzcyNjI4",
          "commit": {
            "abbreviatedOid": "7477b5a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "thx",
          "createdAt": "2018-09-06T05:04:16Z",
          "updatedAt": "2018-09-06T05:04:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTgyMjA1",
          "commit": {
            "abbreviatedOid": "7477b5a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-09-07T02:07:49Z",
          "updatedAt": "2018-09-07T02:13:23Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "`certchain.go` is better than `cert_chain.go`, since `_` has a special meaning in filenames in Go to indicate platforms (e.g. `foo_windows.go` is compiled only for Windows)",
              "createdAt": "2018-09-07T02:07:49Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            },
            {
              "originalPosition": 22,
              "body": "Use `%q` instead of `\\\"%s\\\"`",
              "createdAt": "2018-09-07T02:09:48Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            },
            {
              "originalPosition": 61,
              "body": "`if _, err := buf.WriteTo(os.Stdout); err != nil {`",
              "createdAt": "2018-09-07T02:11:01Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            },
            {
              "originalPosition": 22,
              "body": "Error messages should start with a small case: `input file ...`",
              "createdAt": "2018-09-07T02:13:15Z",
              "updatedAt": "2018-09-07T03:17:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTkxNDQz",
          "commit": {
            "abbreviatedOid": "845d33f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T03:18:15Z",
          "updatedAt": "2018-09-07T03:18:15Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Done.",
              "createdAt": "2018-09-07T03:18:15Z",
              "updatedAt": "2018-09-07T03:18:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTkxNDc2",
          "commit": {
            "abbreviatedOid": "845d33f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T03:18:33Z",
          "updatedAt": "2018-09-07T03:18:33Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done.",
              "createdAt": "2018-09-07T03:18:33Z",
              "updatedAt": "2018-09-07T03:18:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMTkxNDg2",
          "commit": {
            "abbreviatedOid": "845d33f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-09-07T03:18:37Z",
          "updatedAt": "2018-09-07T03:18:37Z",
          "comments": [
            {
              "originalPosition": 61,
              "body": "Done.",
              "createdAt": "2018-09-07T03:18:37Z",
              "updatedAt": "2018-09-07T03:18:37Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "52e6fde487d5fb60796749398847f757e24eb7ba",
      "headRepository": null,
      "headRefName": "cert-chain",
      "headRefOid": "845d33f8d6c1cd58901636aa8e207a2a7b7aa072",
      "mergeCommit": {
        "oid": "baf35f234cb490cd925859269d43e76a45d37247"
      }
    },
    {
      "number": 306,
      "id": "MDExOlB1bGxSZXF1ZXN0MjEzODE4ODIy",
      "title": "certurl: Add a parser of application/cert-chain+cbor format",
      "url": "https://github.com/WICG/webpackage/pull/306",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will be used by upcoming `dump-certurl` tool.",
      "createdAt": "2018-09-07T05:17:39Z",
      "updatedAt": "2018-09-10T07:49:11Z",
      "closedAt": "2018-09-10T07:49:05Z",
      "mergedAt": "2018-09-10T07:49:05Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzMjA1OTk5",
          "commit": {
            "abbreviatedOid": "8f710f7"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-07T05:21:22Z",
          "updatedAt": "2018-09-07T05:21:22Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "baf35f234cb490cd925859269d43e76a45d37247",
      "headRepository": null,
      "headRefName": "read-certchain",
      "headRefOid": "8f710f7a7b66788933158b043a7c33746dc2d732",
      "mergeCommit": {
        "oid": "0e7699ac582dbdea2110f80f7ebd1cba4fc41b87"
      }
    },
    {
      "number": 307,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE0MjA3OTY0",
      "title": "dump-signedexchange: Add a flag to dump only signature value",
      "url": "https://github.com/WICG/webpackage/pull/307",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-10T06:16:53Z",
      "updatedAt": "2018-09-10T06:45:10Z",
      "closedAt": "2018-09-10T06:45:06Z",
      "mergedAt": "2018-09-10T06:45:06Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTUzNjQwNzg4",
          "commit": {
            "abbreviatedOid": "6de1a23"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-10T06:43:09Z",
          "updatedAt": "2018-09-10T06:43:09Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "baf35f234cb490cd925859269d43e76a45d37247",
      "headRepository": null,
      "headRefName": "dump-signature",
      "headRefOid": "6de1a23358a7c430049e3cfc80b271741ec489aa",
      "mergeCommit": {
        "oid": "99155ecef1923aa7c4ce1948946ca41ea511064a"
      }
    },
    {
      "number": 308,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE0MjI4NTQ3",
      "title": "Add dump-certurl tool",
      "url": "https://github.com/WICG/webpackage/pull/308",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Example output:\r\n```\r\nCertificate #0:\r\n  Subject: sxg.example.com\r\n  Valid from: 2018-08-30 03:34:29 +0000 UTC\r\n  Valid until: 2018-11-28 03:34:29 +0000 UTC\r\n  Issuer: Let's Encrypt Authority X3\r\n  Embedded SCT:\r\n    LogID: VYHUwhaQNgFK6gubVzxT8MDkOHhwJQgXL6OqHQcT0ww=\r\n    LogID: pFASaQVaFVReYhGrN7wQP2KuVXakXksXFEU+GyIQaiU=\r\nError: The main certificate does not have canSignHttpExchangesDraft extension\r\nOCSP response:\r\n  Status: 0 (good)\r\n  ProducedAt: 2018-09-05 04:34:00 +0000 UTC\r\n  ThisUpdate: 2018-09-05 04:00:00 +0000 UTC\r\n  NextUpdate: 2018-09-12 04:00:00 +0000 UTC\r\nCertificate #1:\r\n  Subject: Let's Encrypt Authority X3\r\n  Valid from: 2016-03-17 16:40:46 +0000 UTC\r\n  Valid until: 2021-03-17 16:40:46 +0000 UTC\r\n  Issuer: DST Root CA X3\r\n```",
      "createdAt": "2018-09-10T08:03:28Z",
      "updatedAt": "2018-09-11T08:33:37Z",
      "closedAt": "2018-09-11T08:33:33Z",
      "mergedAt": "2018-09-11T08:33:33Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDY4MzM0",
          "commit": {
            "abbreviatedOid": "b9cbec2"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-09-11T06:48:48Z",
          "updatedAt": "2018-09-11T06:48:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU0MDkyNDgz",
          "commit": {
            "abbreviatedOid": "b9cbec2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-11T08:12:21Z",
          "updatedAt": "2018-09-11T08:12:21Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0e7699ac582dbdea2110f80f7ebd1cba4fc41b87",
      "headRepository": null,
      "headRefName": "dump-certurl",
      "headRefOid": "b9cbec2afef78367cb20978f3d229b776a2f0340",
      "mergeCommit": {
        "oid": "ffd0fa1ad67089a03c9481067022c8e7d1c3ec8f"
      }
    },
    {
      "number": 309,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE1NDkxODcy",
      "title": "gen-signedexchange: Emit 1b2 format by default",
      "url": "https://github.com/WICG/webpackage/pull/309",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-14T06:20:14Z",
      "updatedAt": "2018-09-14T06:28:59Z",
      "closedAt": "2018-09-14T06:28:59Z",
      "mergedAt": "2018-09-14T06:28:59Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU1MzY1NjMw",
          "commit": {
            "abbreviatedOid": "15ad135"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-14T06:25:13Z",
          "updatedAt": "2018-09-14T06:25:13Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ffd0fa1ad67089a03c9481067022c8e7d1c3ec8f",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "gen-b2-default",
      "headRefOid": "15ad135c4679c613401ef233761fde665cbe89aa",
      "mergeCommit": {
        "oid": "cf685b1384810a94cb7074a24c06ade8d7ab6550"
      }
    },
    {
      "number": 311,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE2NDg1NDUx",
      "title": "Grammar fixes",
      "url": "https://github.com/WICG/webpackage/pull/311",
      "state": "MERGED",
      "author": "dandv",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-19T00:59:56Z",
      "updatedAt": "2018-09-19T21:33:42Z",
      "closedAt": "2018-09-19T01:34:54Z",
      "mergedAt": "2018-09-19T01:34:54Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2018-09-19T01:34:49Z",
          "updatedAt": "2018-09-19T01:34:49Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU2NjI5MDI2",
          "commit": {
            "abbreviatedOid": "2c38698"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-19T01:34:43Z",
          "updatedAt": "2018-09-19T01:34:43Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cf685b1384810a94cb7074a24c06ade8d7ab6550",
      "headRepository": "dandv/webpackage",
      "headRefName": "patch-1",
      "headRefOid": "2c38698e90903043cfe6b3e3dbc644d20783a587",
      "mergeCommit": {
        "oid": "37007a0479231036f2fc24ad4bf2a9556e3febbf"
      }
    },
    {
      "number": 312,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE4NTk1Mjg5",
      "title": "Update content-type value in README.md",
      "url": "https://github.com/WICG/webpackage/pull/312",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-27T10:08:12Z",
      "updatedAt": "2018-09-27T11:42:33Z",
      "closedAt": "2018-09-27T11:42:30Z",
      "mergedAt": "2018-09-27T11:42:30Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU5Mzc1MzQz",
          "commit": {
            "abbreviatedOid": "7cb1542"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-27T10:13:59Z",
          "updatedAt": "2018-09-27T10:13:59Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "37007a0479231036f2fc24ad4bf2a9556e3febbf",
      "headRepository": "WICG/webpackage",
      "headRefName": "irori-patch-1",
      "headRefOid": "7cb1542deaaa4c2d33cab8cf1ae6caef00d51a85",
      "mergeCommit": {
        "oid": "3861c07aadf10affb602f47116ef6b71d508fa34"
      }
    },
    {
      "number": 313,
      "id": "MDExOlB1bGxSZXF1ZXN0MjE4ODgxNjA0",
      "title": "Update Content-Type in examples/firebase.json to b2",
      "url": "https://github.com/WICG/webpackage/pull/313",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-09-28T07:48:55Z",
      "updatedAt": "2018-09-28T08:23:13Z",
      "closedAt": "2018-09-28T08:23:13Z",
      "mergedAt": "2018-09-28T08:23:13Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTU5NzU5MDMz",
          "commit": {
            "abbreviatedOid": "1f3183a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-09-28T08:14:38Z",
          "updatedAt": "2018-09-28T08:14:38Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3861c07aadf10affb602f47116ef6b71d508fa34",
      "headRepository": null,
      "headRefName": "firebase-json",
      "headRefOid": "1f3183a937bc5d4810185af07accc16cd840653d",
      "mergeCommit": {
        "oid": "d79d16fc4eb6897a6be30d5d855d8813672bd1b8"
      }
    },
    {
      "number": 317,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI0MTI5ODEx",
      "title": "Delete outdated examples.",
      "url": "https://github.com/WICG/webpackage/pull/317",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Keep firebase.json, which is still up-to-date.\r\n\r\nFixes #316.",
      "createdAt": "2018-10-18T23:30:25Z",
      "updatedAt": "2018-11-14T21:55:21Z",
      "closedAt": "2018-11-14T21:55:17Z",
      "mergedAt": "2018-11-14T21:55:17Z",
      "mergedBy": "twifkak",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think this is up to @jyasskin ",
          "createdAt": "2018-10-24T11:17:39Z",
          "updatedAt": "2018-10-24T11:17:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1MDk1NDcx",
          "commit": {
            "abbreviatedOid": "1890eb7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-11-14T21:49:45Z",
          "updatedAt": "2018-11-14T21:49:45Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d79d16fc4eb6897a6be30d5d855d8813672bd1b8",
      "headRepository": "twifkak/webpackage",
      "headRefName": "examples",
      "headRefOid": "1890eb7cb4d1b10968d87365a67bb0a54a727da8",
      "mergeCommit": {
        "oid": "40d859524f9c948142f1568949df5409e81341f7"
      }
    },
    {
      "number": 318,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI1MjY1MjI5",
      "title": "gen-signedexchange: Write SXG to stdout when \"-o -\" is given",
      "url": "https://github.com/WICG/webpackage/pull/318",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is useful when using gen-signedexchange in a command pipeline.",
      "createdAt": "2018-10-24T04:59:34Z",
      "updatedAt": "2018-10-25T01:28:17Z",
      "closedAt": "2018-10-25T01:27:57Z",
      "mergedAt": "2018-10-25T01:27:57Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzUzOTY4",
          "commit": {
            "abbreviatedOid": "999239c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T06:58:59Z",
          "updatedAt": "2018-10-24T06:59:13Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hmm, how about changing the default value an empty string, which means stdout?",
              "createdAt": "2018-10-24T06:58:59Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzYyMjQy",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T07:27:40Z",
          "updatedAt": "2018-10-24T07:27:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done. (I was a bit worried that users may forget to add -o and mess up their terminals with binary output... but this is probably just fine.)",
              "createdAt": "2018-10-24T07:27:40Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzYyNDA5",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-10-24T07:28:05Z",
          "updatedAt": "2018-10-24T07:28:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzY3NjMx",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T07:43:27Z",
          "updatedAt": "2018-10-24T07:43:27Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "+1 irori's concern. Can we isatty?\r\nOne possible impl of this is https://github.com/mattn/go-isatty but feel free to use alternatives",
              "createdAt": "2018-10-24T07:43:27Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzcxNzY3",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T07:54:48Z",
          "updatedAt": "2018-10-24T07:54:48Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "+1 to use isatty. You are suggesting that if -o is omitted and isatty is true, this application should show warnings?\r\n",
              "createdAt": "2018-10-24T07:54:48Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3NzkzNzU1",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T08:48:26Z",
          "updatedAt": "2018-10-24T08:48:26Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Hmmm, isatty feels too fancy to me.\r\n\r\nCan we go with the original approach (\"-o -\" means stdout)? That's a common convention specified in the [POSIX Utility Syntax Guidelines](http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap12.html#tag_12_02) (Guideline 13) so it wouldn't surprise users.\r\n",
              "createdAt": "2018-10-24T08:48:26Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3ODEwOTY1",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-24T09:27:04Z",
          "updatedAt": "2018-10-24T09:27:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Sure, I'm also fine with `-`. Stdout by default was just my preference, so let's go with `-` :-)",
              "createdAt": "2018-10-24T09:27:04Z",
              "updatedAt": "2018-10-25T01:22:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY3ODI0MTUx",
          "commit": {
            "abbreviatedOid": "a4470bb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-10-24T09:57:25Z",
          "updatedAt": "2018-10-24T09:57:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTY4MTc5ODMz",
          "commit": {
            "abbreviatedOid": "999239c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-10-25T01:24:40Z",
          "updatedAt": "2018-10-25T01:24:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Changed back to `-` and merging. Thanks for the comments!",
              "createdAt": "2018-10-25T01:24:40Z",
              "updatedAt": "2018-10-25T01:24:40Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d79d16fc4eb6897a6be30d5d855d8813672bd1b8",
      "headRepository": null,
      "headRefName": "stdout",
      "headRefOid": "f7ab20273f051a8611613c753f1de280f63993b2",
      "mergeCommit": {
        "oid": "a5650fe0a6202ed82d1e7eb1b50cca0331c26193"
      }
    },
    {
      "number": 320,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3MTg5MzI5",
      "title": "Add version field to the Exchange struct",
      "url": "https://github.com/WICG/webpackage/pull/320",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Mostly just refactoring, except that dump-signedexchange now prints\r\nformat version.",
      "createdAt": "2018-10-31T07:53:34Z",
      "updatedAt": "2018-11-01T01:59:18Z",
      "closedAt": "2018-11-01T01:59:11Z",
      "mergedAt": "2018-11-01T01:59:11Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwMTM5MzQ3",
          "commit": {
            "abbreviatedOid": "89c5bea"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-10-31T08:42:33Z",
          "updatedAt": "2018-10-31T08:42:33Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTMyOTgx",
          "commit": {
            "abbreviatedOid": "89c5bea"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-01T01:54:27Z",
          "updatedAt": "2018-11-01T01:54:27Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a5650fe0a6202ed82d1e7eb1b50cca0331c26193",
      "headRepository": null,
      "headRefName": "version",
      "headRefOid": "89c5bea3ae93b945f03603281c26c9f1666ce2c7",
      "mergeCommit": {
        "oid": "425476d20c752780fc7ba1ba099344ddd95acdba"
      }
    },
    {
      "number": 323,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3NDk0NjE0",
      "title": "Add Structured Headers parser",
      "url": "https://github.com/WICG/webpackage/pull/323",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is part of #319 and will be used to parse `signature` header.",
      "createdAt": "2018-11-01T02:27:11Z",
      "updatedAt": "2018-11-09T05:06:34Z",
      "closedAt": "2018-11-02T04:54:29Z",
      "mergedAt": "2018-11-02T04:54:29Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "FWIW, we've been collecting common tests in:\r\n  https://github.com/httpwg/structured-header-tests\r\n\r\nThey haven't been updated in a while, so they might be out of sync with the current spec, but I plan on spending some time on them soon.\r\n\r\nContributions most welcome, of course. Having a common test suite for all implementations should help intro considerably.",
          "createdAt": "2018-11-03T08:13:09Z",
          "updatedAt": "2018-11-03T08:13:09Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Current implementation lacks several features (toplevel is only Parameterised List, no float and boolean supports). I'd like to add these when I have time, and then we'll be able to use the test suite.",
          "createdAt": "2018-11-09T02:09:12Z",
          "updatedAt": "2018-11-09T02:09:12Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "Understood. Even if you just cherry-pick the applicable tests in the meantime, that would be great, as it would help assure there isn't too much drift. If there's anything we can do to help (e.g., separating into files differently, labelling test types, etc.) just say so.",
          "createdAt": "2018-11-09T05:06:34Z",
          "updatedAt": "2018-11-09T05:06:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTY3ODcz",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T06:18:41Z",
          "updatedAt": "2018-11-01T06:19:38Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "I thought OWS is defined as a space char or a tab char that might be followed by whitespace characters: https://tools.ietf.org/html/rfc7230#section-3.2.3 In this implementation, only tab characters on left side would be removed.",
              "createdAt": "2018-11-01T06:18:42Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTYyNjEw",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T05:40:51Z",
          "updatedAt": "2018-11-01T06:26:07Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Simply []ParameterizedIdentifier?\r\n\r\n",
              "createdAt": "2018-11-01T05:40:51Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 2,
              "body": "Note to self: Did a quick search and looks like this is the first Go impl of the spec",
              "createdAt": "2018-11-01T05:44:04Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 134,
              "body": "Should we add `p.peekRune`?",
              "createdAt": "2018-11-01T06:15:04Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 34,
              "body": "We might want to use bytes.Buffer here? You can then use https://golang.org/pkg/bytes/#Buffer.ReadBytes and such",
              "createdAt": "2018-11-01T06:19:20Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 45,
              "body": "should we operate per `rune`?",
              "createdAt": "2018-11-01T06:24:57Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTY5OTk0",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Discussed offline. byte seems fine.",
          "createdAt": "2018-11-01T06:32:41Z",
          "updatedAt": "2018-11-01T06:32:41Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTc2MTU1",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:09:25Z",
          "updatedAt": "2018-11-01T07:09:26Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Sorry this was my misunderstanding",
              "createdAt": "2018-11-01T07:09:25Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTc2OTQy",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:14:14Z",
          "updatedAt": "2018-11-01T07:14:14Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "As we discussed offline, I'm ok to go with `byte`. Rather, should the parser cause errors when non-ASCII chars were found?",
              "createdAt": "2018-11-01T07:14:14Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTgwMzc0",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:31:41Z",
          "updatedAt": "2018-11-01T07:31:42Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "ASCII-ness is not explicitly checked, but non-ASCII characters will cause error in `perse*` functions where the character is consumed. For example, parseString() fails if the character isn't in the range [` `, `~`].",
              "createdAt": "2018-11-01T07:31:41Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTc5ODM3",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "sgtm in general",
          "createdAt": "2018-11-01T07:29:06Z",
          "updatedAt": "2018-11-01T07:33:31Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "nits: error message should start with small caps in convention (there are a lot of messages don't follow this rule in this project though...)\r\n\r\nhttps://github.com/golang/go/wiki/Errors\r\n\r\nHow about starting with `structuredheader:`?",
              "createdAt": "2018-11-01T07:29:06Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 1,
              "body": "Let's make it a different package `structured_header`. We'd need to export some functions.",
              "createdAt": "2018-11-01T07:30:51Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTgyNDY3",
          "commit": {
            "abbreviatedOid": "9b5ee89"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:42:09Z",
          "updatedAt": "2018-11-01T07:42:10Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "I thought this is the preferred way?\r\n\r\nhttps://golang.org/pkg/testing/#pkg-overview\r\n\r\n> To write a new test suite, create a file whose name ends _test.go that contains the TestXxx functions as described here. Put the file in the same package as the one being tested. The file will be excluded from regular package builds but will be included when the \u201cgo test\u201d command is run. For more detail, run \u201cgo help test\u201d and \u201cgo help testflag\u201d.",
              "createdAt": "2018-11-01T07:42:10Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTg0ODE4",
          "commit": {
            "abbreviatedOid": "3be445f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T07:54:19Z",
          "updatedAt": "2018-11-01T07:54:19Z",
          "comments": [
            {
              "originalPosition": 84,
              "body": "Done.",
              "createdAt": "2018-11-01T07:54:19Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTkzNzkx",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T08:32:36Z",
          "updatedAt": "2018-11-01T08:32:36Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Done.",
              "createdAt": "2018-11-01T08:32:36Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNTk0MzEz",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T08:34:39Z",
          "updatedAt": "2018-11-01T08:34:39Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "I'd like to keep using string, as functions like `strings.TrimLeft` can be used directly.",
              "createdAt": "2018-11-01T08:34:39Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNjA4NTgz",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T09:24:28Z",
          "updatedAt": "2018-11-01T09:24:29Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "Yes, this is the preferred way.",
              "createdAt": "2018-11-01T09:24:28Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNjI0ODI2",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T10:15:33Z",
          "updatedAt": "2018-11-01T10:15:33Z",
          "comments": [
            {
              "originalPosition": 1,
              "body": "We discussed offline and concluded it would not be worth making this a different package by exposing a lot of functions. (There is a technique to expose functions only for testing, but it is a little messy). Let's keep as this is. Thanks.",
              "createdAt": "2018-11-01T10:15:33Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNjI2Mjc2",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-01T10:20:27Z",
          "updatedAt": "2018-11-01T10:24:39Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "nit: Parameters represents ...\r\n\r\n(I felt it is strange a plural noun followed by a verb in third-person singular form, but it looks like it is permitted e.g. https://golang.org/pkg/net/http/#PushOptions)",
              "createdAt": "2018-11-01T10:20:27Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            },
            {
              "originalPosition": 243,
              "body": "Couldn't we reach this with arbitrary user-input? Sorry if I am missing.",
              "createdAt": "2018-11-01T10:24:35Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTMyMjAw",
          "commit": {
            "abbreviatedOid": "d9b3557"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-02T00:10:22Z",
          "updatedAt": "2018-11-02T00:10:22Z",
          "comments": [
            {
              "originalPosition": 243,
              "body": "Line 228 guarantees that here's `*`.",
              "createdAt": "2018-11-02T00:10:22Z",
              "updatedAt": "2018-11-02T00:26:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTM1MTA5",
          "commit": {
            "abbreviatedOid": "d2b2797"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-02T00:27:16Z",
          "updatedAt": "2018-11-02T00:27:16Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done",
              "createdAt": "2018-11-02T00:27:16Z",
              "updatedAt": "2018-11-02T00:27:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTY3OTAy",
          "commit": {
            "abbreviatedOid": "d2b2797"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-02T04:36:18Z",
          "updatedAt": "2018-11-02T04:36:18Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "425476d20c752780fc7ba1ba099344ddd95acdba",
      "headRepository": null,
      "headRefName": "structuredheader",
      "headRefOid": "d2b27979a045bb08bad51a9909cc483f8fed810d",
      "mergeCommit": {
        "oid": "af1d94a287a9350655c7d4729bdcc352db7011af"
      }
    },
    {
      "number": 325,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3NTcyNjEw",
      "title": "Do not use signedexchange/version in mice package",
      "url": "https://github.com/WICG/webpackage/pull/325",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "So that the package can be used independently from Signed Exchange.",
      "createdAt": "2018-11-01T10:21:12Z",
      "updatedAt": "2018-11-02T00:28:03Z",
      "closedAt": "2018-11-02T00:27:56Z",
      "mergedAt": "2018-11-02T00:27:56Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwNjYwMzU2",
          "commit": {
            "abbreviatedOid": "d833742"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-01T12:18:14Z",
          "updatedAt": "2018-11-01T12:18:53Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "nit: No `()`",
              "createdAt": "2018-11-01T12:18:14Z",
              "updatedAt": "2018-11-02T00:23:55Z"
            },
            {
              "originalPosition": 36,
              "body": "ditto",
              "createdAt": "2018-11-01T12:18:19Z",
              "updatedAt": "2018-11-02T00:23:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTMwNDQx",
          "commit": {
            "abbreviatedOid": "d833742"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-02T00:00:44Z",
          "updatedAt": "2018-11-02T00:00:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTM0Njg3",
          "commit": {
            "abbreviatedOid": "ab5fcd6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-02T00:24:29Z",
          "updatedAt": "2018-11-02T00:24:29Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Done",
              "createdAt": "2018-11-02T00:24:29Z",
              "updatedAt": "2018-11-02T00:24:29Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcwOTM0NzAy",
          "commit": {
            "abbreviatedOid": "ab5fcd6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-02T00:24:34Z",
          "updatedAt": "2018-11-02T00:24:34Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Done",
              "createdAt": "2018-11-02T00:24:34Z",
              "updatedAt": "2018-11-02T00:24:34Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "425476d20c752780fc7ba1ba099344ddd95acdba",
      "headRepository": null,
      "headRefName": "mice",
      "headRefOid": "ab5fcd64c901e0bbae18787dadbef8cbde7874ce",
      "mergeCommit": {
        "oid": "54c7a94bd4e578a5ffc884c645439b5da91b97b7"
      }
    },
    {
      "number": 326,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3ODA0OTA4",
      "title": "Reject uncachable status code",
      "url": "https://github.com/WICG/webpackage/pull/326",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Chromium CL: https://chromium-review.googlesource.com/c/chromium/src/+/1313712\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/nyaxt/webpackage/pull/326.html\" title=\"Last updated on Nov 20, 2018, 5:59 AM GMT (95b849a)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/326/54c7a94...nyaxt:95b849a.html\" title=\"Last updated on Nov 20, 2018, 5:59 AM GMT (95b849a)\">Diff</a>",
      "createdAt": "2018-11-02T01:13:16Z",
      "updatedAt": "2018-11-20T20:08:23Z",
      "closedAt": "2018-11-20T20:08:23Z",
      "mergedAt": "2018-11-20T20:08:23Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu wdyt?",
          "createdAt": "2018-11-02T01:19:38Z",
          "updatedAt": "2018-11-02T01:19:38Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I think there is a reasonable set of status codes which we should allow, but not sure where the boundary is.\r\n\r\n- **1xx Informational**: IIUC, these are partial responses which doesn't make sense to be captured.\r\n- **non-cachable responses**: Disallowing those seem to align with the request method restrictions. (strawman)\r\n\r\n@kinu made a point that redirect is disallowed in the loading spec, so there is also discussion of where to enforce the restriction",
          "createdAt": "2018-11-02T01:28:26Z",
          "updatedAt": "2018-11-02T01:28:26Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm less sure about the non-cacheable responses, for example for CaheStorage we don't check any of these but specifically throw an error if it's 206 (partial response). And if we take a deeper look getting 203 (non-authoritative) seems a little weird, handling of 206 (partial content) responses would need to be discussed in the loading spec (as well as handling of range requests), and all 3xx are forbidden in the loading spec.  Overall I feel it might make better sense to have the part only in the loading spec, at least until we have a clearer thought of what should be valid.",
          "createdAt": "2018-11-02T02:39:29Z",
          "updatedAt": "2018-11-02T02:39:29Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Well or maybe we can just start with 200 only. Looking into other status code most of them don't really make sense. (I prefer forbidding it in the loading spec though) /cc @horo-t",
          "createdAt": "2018-11-02T09:01:40Z",
          "updatedAt": "2018-11-02T09:01:40Z"
        },
        {
          "author": "mnot",
          "authorAssociation": "NONE",
          "body": "A status code that is uncacheable by default can still be cached if it has explicit freshness information. I think you need to reference the entire [response cacheability algorithm](https://httpwg.org/specs/rfc7234.html#response.cacheability).",
          "createdAt": "2018-11-03T06:52:40Z",
          "updatedAt": "2018-11-03T06:52:40Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu @horo-t @mnot Thank you for your input!\r\nI'll update the PR shortly to only allow 200 here to be most restrictive, but I'm open to loosen the restriction to the response cacheablility algorithm if we have a use case.",
          "createdAt": "2018-11-05T00:30:24Z",
          "updatedAt": "2018-11-05T00:30:24Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu Would you mind sharing the background why you'd prefer this to be loading spec?\r\n\r\nI'm mixed since we already have `:method` cacheability validation in the sxg format spec. While I think having it outside format spec makes sense if we consider non-webbrowser consumers in the future (which are not covered by `loading.md` iiuc).\r\n\r\nAnother strawman would be to have:\r\n- format spec say only cachable responses are signature valid\r\n- loading spec to allow only 200",
          "createdAt": "2018-11-05T00:41:43Z",
          "updatedAt": "2018-11-05T00:41:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1MTMwMTM3",
          "commit": {
            "abbreviatedOid": "0341c4b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-11-14T23:30:52Z",
          "updatedAt": "2018-11-14T23:48:11Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Let's replace the \"or not cacheable\" bit with the reference to https://httpwg.org/specs/rfc7234.html#rfc.section.3, since that also talks about methods.",
              "createdAt": "2018-11-14T23:33:51Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 4,
              "body": "```suggestion\r\n1. If `exchange`'s response is not complete, (Section 3.1 of {{!RFC7234}}),\r\n```",
              "createdAt": "2018-11-14T23:37:43Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 6,
              "body": "I believe \"shared cache\" is the right term, according to https://httpwg.org/specs/rfc7234.html#rfc.section.1. \"public\" is a response directive, not a type of cache.\r\n\r\nI'd also rather not use the term \"cacheable\" here since https://httpwg.org/specs/rfc7234.html#rfc.section.3 doesn't define it as a predicate on responses. Instead perhaps:\r\n\r\n```suggestion\r\n1. If Section 3 of {{RFC7234}} forbids a shared cache from storing `exchange`'s response, return \"invalid\".\r\n```",
              "createdAt": "2018-11-14T23:41:21Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 5,
              "body": "I think I agree with having this tighter restriction in the loading spec only, at least for now. ",
              "createdAt": "2018-11-14T23:48:04Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjEwNzU2",
          "commit": {
            "abbreviatedOid": "0341c4b"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for your review!",
          "createdAt": "2018-11-20T05:49:03Z",
          "updatedAt": "2018-11-20T05:56:52Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2018-11-20T05:49:04Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 6,
              "body": "Done.",
              "createdAt": "2018-11-20T05:49:11Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            },
            {
              "originalPosition": 3,
              "body": "Done",
              "createdAt": "2018-11-20T05:51:39Z",
              "updatedAt": "2018-11-20T05:59:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2OTUyMDk4",
          "commit": {
            "abbreviatedOid": "95b849a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2018-11-20T20:05:05Z",
          "updatedAt": "2018-11-20T20:05:05Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "40d859524f9c948142f1568949df5409e81341f7",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "statuscode",
      "headRefOid": "95b849aa501be4cd609880e37879dbefe8e5118a",
      "mergeCommit": {
        "oid": "827cb70e954750dca7bc8aecb977cd49442dc856"
      }
    },
    {
      "number": 327,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI3ODQ2OTg3",
      "title": " Implement mice decoder",
      "url": "https://github.com/WICG/webpackage/pull/327",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is part of #319.",
      "createdAt": "2018-11-02T06:52:55Z",
      "updatedAt": "2018-11-05T05:39:43Z",
      "closedAt": "2018-11-05T05:39:38Z",
      "mergedAt": "2018-11-05T05:39:38Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxMzk0NzE0",
          "commit": {
            "abbreviatedOid": "45d0a9c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-05T01:58:58Z",
          "updatedAt": "2018-11-05T02:04:13Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "multiple",
              "createdAt": "2018-11-05T01:58:58Z",
              "updatedAt": "2018-11-05T05:36:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxNDEyODQy",
          "commit": {
            "abbreviatedOid": "45d0a9c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-05T04:46:27Z",
          "updatedAt": "2018-11-05T04:46:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxNDE4NTgy",
          "commit": {
            "abbreviatedOid": "a41a7c3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-05T05:39:08Z",
          "updatedAt": "2018-11-05T05:39:09Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Done.",
              "createdAt": "2018-11-05T05:39:08Z",
              "updatedAt": "2018-11-05T05:39:09Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "af1d94a287a9350655c7d4729bdcc352db7011af",
      "headRepository": null,
      "headRefName": "mice",
      "headRefOid": "a41a7c34891d56f2cb47e7c9b421f8d83b52fe90",
      "mergeCommit": {
        "oid": "9926d715af63070a8f46593d8832f3674f8b784f"
      }
    },
    {
      "number": 328,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4MjI5MzI4",
      "title": "Update loading spec to impl b2 snapshot",
      "url": "https://github.com/WICG/webpackage/pull/328",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/nyaxt/webpackage/pull/328.html\" title=\"Last updated on Dec 18, 2018, 12:01 AM UTC (b2687a5)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/328/9b58b4c...nyaxt:b2687a5.html\" title=\"Last updated on Dec 18, 2018, 12:01 AM UTC (b2687a5)\">Diff</a>",
      "createdAt": "2018-11-05T03:08:46Z",
      "updatedAt": "2018-12-18T00:05:15Z",
      "closedAt": "2018-12-18T00:05:15Z",
      "mergedAt": "2018-12-18T00:05:15Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "ref #310 ",
          "createdAt": "2018-11-05T06:06:42Z",
          "updatedAt": "2018-11-05T06:06:42Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "I'll address your comments shortly, but feel free to take over this change (or any of my PRs when you think it would be more productive).\r\nI'm happy with both having you pushing new changes to this PR branch or creating a new PR from scratch.",
          "createdAt": "2018-11-20T06:06:36Z",
          "updatedAt": "2018-11-20T06:06:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc1OTA5Njcx",
          "commit": {
            "abbreviatedOid": "31271a0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Are you good making the updates to match -b2, or should I take over this change?",
          "createdAt": "2018-11-16T17:43:33Z",
          "updatedAt": "2018-11-16T18:18:20Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02#page-12 says this should be \r\n\r\n```suggestion\r\n    : \"digest/mi-sha256-03\"\r\n```",
              "createdAt": "2018-11-16T17:43:33Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 127,
              "body": "https://tools.ietf.org/html/draft-thomson-http-mice-03#section-3 says we need to parse this out of the Digest header, not look for a top-level header.",
              "createdAt": "2018-11-16T17:46:12Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 90,
              "body": "The b2 signed message in https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02#page-11 is significantly different from the b1 message.",
              "createdAt": "2018-11-16T17:50:30Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 82,
              "body": "b2 includes a fallback URL here. https://tools.ietf.org/html/draft-yasskin-httpbis-origin-signed-exchanges-impl-02#section-5.3",
              "createdAt": "2018-11-16T18:15:09Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjI5OTM5",
          "commit": {
            "abbreviatedOid": "31271a0"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-20T07:27:37Z",
          "updatedAt": "2018-11-20T08:06:16Z",
          "comments": [
            {
              "originalPosition": 120,
              "body": "Done.",
              "createdAt": "2018-11-20T07:27:37Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 127,
              "body": "Thanks for catching this. I tried to add parse steps.",
              "createdAt": "2018-11-20T07:28:14Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 82,
              "body": "Added steps to extract the fallback URL + an assert that it matches the result of [=extracting the fallback URL=] algorithm",
              "createdAt": "2018-11-20T07:54:50Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            },
            {
              "originalPosition": 90,
              "body": "Ack. (Can address tomorrow, or feel free to take over)",
              "createdAt": "2018-11-20T08:06:11Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc5NjIzNDkz",
          "commit": {
            "abbreviatedOid": "3050644"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-29T04:18:18Z",
          "updatedAt": "2018-11-29T04:18:18Z",
          "comments": [
            {
              "originalPosition": 90,
              "body": "Updated.",
              "createdAt": "2018-11-29T04:18:18Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1MzMwOTEy",
          "commit": {
            "abbreviatedOid": "0e6bf92"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-15T00:36:11Z",
          "updatedAt": "2018-12-15T00:36:12Z",
          "comments": [
            {
              "originalPosition": 82,
              "body": "The UTF-8 conversion only wound up in one of the two places, so I've refactored them together.",
              "createdAt": "2018-12-15T00:36:11Z",
              "updatedAt": "2018-12-18T00:01:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1MzMxOTE0",
          "commit": {
            "abbreviatedOid": "c35cd85"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Please double-check the series of commits I added, but then this looks good to squash onto master. Thanks!",
          "createdAt": "2018-12-15T00:45:03Z",
          "updatedAt": "2018-12-15T00:45:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1ODU1OTY1",
          "commit": {
            "abbreviatedOid": "b2687a5"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2018-12-18T00:05:00Z",
          "updatedAt": "2018-12-18T00:05:00Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9b58b4c7a7da682fbf1cc6cc0a1e3d034dc7847c",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "loadingb2",
      "headRefOid": "b2687a50ea58138689807d521a933332c26a1527",
      "mergeCommit": {
        "oid": "5cc8e005e53d6a0023de4f1903ad9a52e26d5805"
      }
    },
    {
      "number": 329,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4Mjg4MjIw",
      "title": "Update test keys in signedexchange_test.go to secp256r1",
      "url": "https://github.com/WICG/webpackage/pull/329",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-05T09:30:17Z",
      "updatedAt": "2018-11-06T01:28:04Z",
      "closedAt": "2018-11-06T01:28:00Z",
      "mergedAt": "2018-11-06T01:28:00Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxNDk0MDI1",
          "commit": {
            "abbreviatedOid": "6a4270c"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-05T10:32:13Z",
          "updatedAt": "2018-11-05T10:32:13Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9926d715af63070a8f46593d8832f3674f8b784f",
      "headRepository": null,
      "headRefName": "test",
      "headRefOid": "6a4270c29fa96527df262667680710dab1e44e01",
      "mergeCommit": {
        "oid": "11a8237ab37f5473bc2a36d1e36914387adbcebf"
      }
    },
    {
      "number": 330,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4NTQ4NTEy",
      "title": "go/signedexchange: Drop RSA keys support",
      "url": "https://github.com/WICG/webpackage/pull/330",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "RSA keys are forbidden since before version b1, so there's no reason to\r\nkeep it.",
      "createdAt": "2018-11-06T01:37:50Z",
      "updatedAt": "2018-11-06T05:47:47Z",
      "closedAt": "2018-11-06T05:47:43Z",
      "mergedAt": "2018-11-06T05:47:43Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODM5MjE5",
          "commit": {
            "abbreviatedOid": "9fccfeb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-06T01:53:38Z",
          "updatedAt": "2018-11-06T01:53:38Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "11a8237ab37f5473bc2a36d1e36914387adbcebf",
      "headRepository": null,
      "headRefName": "drop-rsa",
      "headRefOid": "9fccfeb69154a4ac300e48cad5f28d9d9cf7a7c6",
      "mergeCommit": {
        "oid": "1e04cb21ea906b7ea286acd876cf59332daaf0bc"
      }
    },
    {
      "number": 331,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4NTgxNjg1",
      "title": "Add signature verifier to signingalgorithm.go",
      "url": "https://github.com/WICG/webpackage/pull/331",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This also moves signer_test.go to signingalgorithm_test.go, as it only uses `signingalgorithm` package.",
      "createdAt": "2018-11-06T05:54:57Z",
      "updatedAt": "2018-11-06T08:34:01Z",
      "closedAt": "2018-11-06T08:33:55Z",
      "mergedAt": "2018-11-06T08:33:55Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "(This is part of #319)",
          "createdAt": "2018-11-06T07:30:50Z",
          "updatedAt": "2018-11-06T07:30:50Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODg0MDI0",
          "commit": {
            "abbreviatedOid": "d79c0ce"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-06T07:08:27Z",
          "updatedAt": "2018-11-06T07:10:03Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Optional: add RFC 3279 ref?",
              "createdAt": "2018-11-06T07:08:27Z",
              "updatedAt": "2018-11-06T07:25:03Z"
            },
            {
              "originalPosition": 32,
              "body": "Can be another PR: prefix all error message with \"signingalgorithm: \"?",
              "createdAt": "2018-11-06T07:09:42Z",
              "updatedAt": "2018-11-06T07:25:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODg3Mzk4",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T07:25:19Z",
          "updatedAt": "2018-11-06T07:25:19Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Done.",
              "createdAt": "2018-11-06T07:25:19Z",
              "updatedAt": "2018-11-06T07:25:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODg3NDE0",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T07:25:22Z",
          "updatedAt": "2018-11-06T07:25:23Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2018-11-06T07:25:22Z",
              "updatedAt": "2018-11-06T07:25:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODg4NzY5",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T07:31:43Z",
          "updatedAt": "2018-11-06T07:31:46Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Do we plan to add another verifier other than `ecdsaVerifier`? If not, I think exporting `ecdsaVerifier` and returning it instead of returning an interface value should be fine.",
              "createdAt": "2018-11-06T07:31:43Z",
              "updatedAt": "2018-11-06T07:31:46Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxODk1NzI5",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T07:59:57Z",
          "updatedAt": "2018-11-06T07:59:57Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "We may support ed25519 (and/or other non-legacy, non-RSA signing algorithms defined by TLS 1.3 or later) in the future.\r\n\r\nI'd like to use this interface in the first place, to minimize caller-side changes when we support them.",
              "createdAt": "2018-11-06T07:59:57Z",
              "updatedAt": "2018-11-06T07:59:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTAxNjQ4",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T08:20:32Z",
          "updatedAt": "2018-11-06T08:20:33Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Makes sense.",
              "createdAt": "2018-11-06T08:20:32Z",
              "updatedAt": "2018-11-06T08:20:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTAyNTg0",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T08:23:50Z",
          "updatedAt": "2018-11-06T08:24:34Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Don't we need a package name here?",
              "createdAt": "2018-11-06T08:23:50Z",
              "updatedAt": "2018-11-06T08:24:34Z"
            },
            {
              "originalPosition": 32,
              "body": "Ditto",
              "createdAt": "2018-11-06T08:23:56Z",
              "updatedAt": "2018-11-06T08:24:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTAzNTcy",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T08:26:50Z",
          "updatedAt": "2018-11-06T08:26:51Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "No, `signingalgorithm` is dot-imported at line 9.",
              "createdAt": "2018-11-06T08:26:51Z",
              "updatedAt": "2018-11-06T08:26:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTA0Mjk5",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-06T08:28:58Z",
          "updatedAt": "2018-11-06T08:28:58Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Oh, I missed that, sorry",
              "createdAt": "2018-11-06T08:28:58Z",
              "updatedAt": "2018-11-06T08:28:58Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTA0NTQ2",
          "commit": {
            "abbreviatedOid": "cc6353a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-06T08:29:41Z",
          "updatedAt": "2018-11-06T08:29:41Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "1e04cb21ea906b7ea286acd876cf59332daaf0bc",
      "headRepository": null,
      "headRefName": "verifier",
      "headRefOid": "cc6353a6b32f8690d133fcf7b415c64cfef044ce",
      "mergeCommit": {
        "oid": "3fda2263d1bed1616c8f9b9aa0d703a28a2efb19"
      }
    },
    {
      "number": 332,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4NjI1Nzgw",
      "title": "go/signedexchange: Make serializeSignedMessage non-method func",
      "url": "https://github.com/WICG/webpackage/pull/332",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It was a method of Signer, but will be used by verifier too.\r\n\r\nThis is part of #319.",
      "createdAt": "2018-11-06T09:36:03Z",
      "updatedAt": "2018-11-07T00:47:28Z",
      "closedAt": "2018-11-07T00:47:24Z",
      "mergedAt": "2018-11-07T00:47:24Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTMyNDU5",
          "commit": {
            "abbreviatedOid": "1622916"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-06T09:44:35Z",
          "updatedAt": "2018-11-06T09:44:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcxOTQxOTYx",
          "commit": {
            "abbreviatedOid": "1622916"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-06T10:06:44Z",
          "updatedAt": "2018-11-06T10:06:44Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3fda2263d1bed1616c8f9b9aa0d703a28a2efb19",
      "headRepository": null,
      "headRefName": "serialize",
      "headRefOid": "16229161dc205db9f42ed091a295944bdd66b65b",
      "mergeCommit": {
        "oid": "40888fb03ed2fe06c5d93ed5c70b71231ed498db"
      }
    },
    {
      "number": 333,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4OTA1MTAw",
      "title": "dump-signedexchange: verify exchange's signature",
      "url": "https://github.com/WICG/webpackage/pull/333",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds -verify option to dump-signedexhcange, which runs\r\nthe verification algorithm [1] on the given signed-exchange.\r\n\r\nBy default certificate chain is fetched from signature's cert-url,\r\nbut that can be overridden by -cert flag.\r\n\r\nCurrently it only checks signature validity [2], and does not\r\nperform certificate verification (step 7 of [2]).\r\n\r\n[1] draft-yasskin-http-origin-signed-responses.html#cross-origin-trust\r\n[2] draft-yasskin-http-origin-signed-responses.html#signature-validity",
      "createdAt": "2018-11-07T03:14:32Z",
      "updatedAt": "2018-11-07T07:25:17Z",
      "closedAt": "2018-11-07T07:25:13Z",
      "mergedAt": "2018-11-07T07:25:13Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "This is the main patch of #319.",
          "createdAt": "2018-11-07T03:16:20Z",
          "updatedAt": "2018-11-07T03:16:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzMyNzgz",
          "commit": {
            "abbreviatedOid": "2dc8905"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-07T03:57:06Z",
          "updatedAt": "2018-11-07T03:59:11Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Would you add a comment what this is?",
              "createdAt": "2018-11-07T03:57:06Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzM1Njk4",
          "commit": {
            "abbreviatedOid": "2dc8905"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T04:19:10Z",
          "updatedAt": "2018-11-07T05:57:14Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "How about letting `verify` return error and handling it on the caller side? BTW, is it fine to print the error to stdout?",
              "createdAt": "2018-11-07T04:19:11Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            },
            {
              "originalPosition": 67,
              "body": "Optional: I prefer interface to function, but I think function is also fine here.",
              "createdAt": "2018-11-07T04:24:45Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            },
            {
              "originalPosition": 239,
              "body": "Should we compare port number?",
              "createdAt": "2018-11-07T04:25:59Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzQ4OTEx",
          "commit": {
            "abbreviatedOid": "ff1b1b4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:01:22Z",
          "updatedAt": "2018-11-07T06:01:22Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Oh, it was just copied from an existing test case, but it doesn't have to be fixed timestamp.\r\nChanged to `time.Now()`.\r\n",
              "createdAt": "2018-11-07T06:01:22Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzUwMzg0",
          "commit": {
            "abbreviatedOid": "ff1b1b4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:13:17Z",
          "updatedAt": "2018-11-07T06:13:17Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Would a constant time be better for testing in general?",
              "createdAt": "2018-11-07T06:13:17Z",
              "updatedAt": "2018-11-07T06:34:04Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzUzODUx",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:35:05Z",
          "updatedAt": "2018-11-07T06:35:05Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Yeah maybe. (I was Chromium build sheriff on Mon and Tue, and saw tests failing because of the end of DST...)\r\n\r\nChanged to a (better-named) fixed timestamp.",
              "createdAt": "2018-11-07T06:35:05Z",
              "updatedAt": "2018-11-07T06:35:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzUzOTcx",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:35:38Z",
          "updatedAt": "2018-11-07T06:35:38Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Done.\r\n\r\nSince this is a dump tool, verification errors are not considered \"hard error\", so printing them to stdout and continue processing is fine I think.",
              "createdAt": "2018-11-07T06:35:38Z",
              "updatedAt": "2018-11-07T06:35:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU0Mjc5",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:37:19Z",
          "updatedAt": "2018-11-07T06:37:19Z",
          "comments": [
            {
              "originalPosition": 239,
              "body": "URL.Host contains port number.\r\nhttps://golang.org/pkg/net/url/#URL",
              "createdAt": "2018-11-07T06:37:19Z",
              "updatedAt": "2018-11-07T06:37:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU3MTkw",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:53:02Z",
          "updatedAt": "2018-11-07T06:53:02Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "I don't have strong opinion either. Can we go with a function pointer for now, since it requires fewer lines?",
              "createdAt": "2018-11-07T06:53:02Z",
              "updatedAt": "2018-11-07T06:53:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU4MDA1",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T06:57:27Z",
          "updatedAt": "2018-11-07T06:57:27Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Sure, go with a function pointer :-)",
              "createdAt": "2018-11-07T06:57:27Z",
              "updatedAt": "2018-11-07T06:57:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU4NDk3",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T07:00:00Z",
          "updatedAt": "2018-11-07T07:00:03Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "`fmt.Println(err)`? Now the error is handled by `log.Fatal`, which I think is different from what we want.",
              "createdAt": "2018-11-07T07:00:00Z",
              "updatedAt": "2018-11-07T07:00:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzU5OTA5",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-07T07:07:42Z",
          "updatedAt": "2018-11-07T07:07:43Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "`verify` returns error not on verification errors, but when a bad command-line flag is given (e.g. -cert file doesn't exist). In such cases, probably we should exit with non-zero status.",
              "createdAt": "2018-11-07T07:07:42Z",
              "updatedAt": "2018-11-07T07:07:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzYyNDk1",
          "commit": {
            "abbreviatedOid": "3b6b65b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-07T07:20:45Z",
          "updatedAt": "2018-11-07T07:20:45Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "40888fb03ed2fe06c5d93ed5c70b71231ed498db",
      "headRepository": null,
      "headRefName": "verify",
      "headRefOid": "3b6b65ba8e4297ea7b75756cb57e713d2433499c",
      "mergeCommit": {
        "oid": "a7e95bf2e13c123dace6e55563d7ac0527a00cd3"
      }
    },
    {
      "number": 334,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI4OTQ1NDAw",
      "title": "go/signedexchange: Update README.md",
      "url": "https://github.com/WICG/webpackage/pull/334",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "...mentioning about `dump-exchange`'s `-verify` option.\r\n\r\nThis is part of #319.",
      "createdAt": "2018-11-07T08:04:29Z",
      "updatedAt": "2018-11-07T08:55:32Z",
      "closedAt": "2018-11-07T08:11:54Z",
      "mergedAt": "2018-11-07T08:11:54Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTcyMzczMjU3",
          "commit": {
            "abbreviatedOid": "fc579a4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-07T08:07:45Z",
          "updatedAt": "2018-11-07T08:07:45Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a7e95bf2e13c123dace6e55563d7ac0527a00cd3",
      "headRepository": null,
      "headRefName": "readme",
      "headRefOid": "fc579a4052a88d552d2d04308dbb815768f6b53e",
      "mergeCommit": {
        "oid": "108353c183ddfda9fb4c27bde710fc6449faf666"
      }
    },
    {
      "number": 337,
      "id": "MDExOlB1bGxSZXF1ZXN0MjI5NTY0ODc1",
      "title": "dump-signedexchange: correctly dump request headers",
      "url": "https://github.com/WICG/webpackage/pull/337",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-09T01:51:06Z",
      "updatedAt": "2018-11-09T01:56:24Z",
      "closedAt": "2018-11-09T01:56:24Z",
      "mergedAt": "2018-11-09T01:56:24Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Ooohh. good catch.",
          "createdAt": "2018-11-09T01:54:48Z",
          "updatedAt": "2018-11-09T01:54:48Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTczMjQ5MTQx",
          "commit": {
            "abbreviatedOid": "f343247"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-09T01:54:39Z",
          "updatedAt": "2018-11-09T01:54:39Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "108353c183ddfda9fb4c27bde710fc6449faf666",
      "headRepository": null,
      "headRefName": "dump",
      "headRefOid": "f343247934748eb779a39abb545bb4faa3e79fec",
      "mergeCommit": {
        "oid": "7a8aaafe3f1138a1de854aaf72a1bcf6c97705b1"
      }
    },
    {
      "number": 339,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMwOTM0OTY5",
      "title": "Reject uncached headers",
      "url": "https://github.com/WICG/webpackage/pull/339",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fixes #336 and fixes #340.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/nyaxt/webpackage/pull/339.html\" title=\"Last updated on Jan 10, 2019, 5:26 PM UTC (3e85268)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/339/80005f0...nyaxt:3e85268.html\" title=\"Last updated on Jan 10, 2019, 5:26 PM UTC (3e85268)\">Diff</a>",
      "createdAt": "2018-11-14T18:22:08Z",
      "updatedAt": "2019-02-22T23:17:09Z",
      "closedAt": "2019-01-10T17:31:58Z",
      "mergedAt": "2019-01-10T17:31:58Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "We would like to rely on https://github.com/httpwg/http-core/pull/181 instead. However we might want to use this for the implementation snapshot depending on the time frame.",
          "createdAt": "2019-01-07T01:08:49Z",
          "updatedAt": "2019-01-07T01:08:49Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm not hopeful that httpwg/http-core#181 will get in by the end of this week, so I'm probably going to add the rest of the hop-by-hop headers and other non-cached headers here and get this merged.",
          "createdAt": "2019-01-07T03:58:36Z",
          "updatedAt": "2019-01-07T03:58:36Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Please take a look. This will fix #336 and fix #340.",
          "createdAt": "2019-01-10T05:32:38Z",
          "updatedAt": "2019-01-10T05:32:38Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "LGTM. Updated ChangeLog",
          "createdAt": "2019-01-10T07:22:39Z",
          "updatedAt": "2019-01-10T07:22:39Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "2 more small changes, and now I'll merge.",
          "createdAt": "2019-01-10T17:23:40Z",
          "updatedAt": "2019-01-10T17:23:40Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry for the delay - why is the list of hop-by-hop headers here (and in Chromium) different from the one listed at https://tools.ietf.org/html/rfc2616#section-13.5.1?",
          "createdAt": "2019-02-22T23:17:09Z",
          "updatedAt": "2019-02-22T23:17:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2MDE3Nzcz",
          "commit": {
            "abbreviatedOid": "53b7429"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-16T23:27:13Z",
          "updatedAt": "2018-11-16T23:27:14Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "See https://github.com/WICG/webpackage/issues/336#issuecomment-439559157; I think we should reject all of the headers in the `kHopByHopResponseHeaders`, `kChallengeResponseHeaders`, and `kCookieResponseHeaders` arrays in https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc. Maybe that list should roll into the {{stateful-headers}} list?",
              "createdAt": "2018-11-16T23:27:14Z",
              "updatedAt": "2019-01-10T17:22:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDU0MTkx",
          "commit": {
            "abbreviatedOid": "557708e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-10T05:33:16Z",
          "updatedAt": "2019-01-10T05:33:16Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "80005f09c1e52675b9279dc44a87c2887b63cf8d",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "rejectTE",
      "headRefOid": "3e852684930764c0d1fa7a3dbc7bda2372aa2759",
      "mergeCommit": {
        "oid": "9f212606eb9ca4b09c5edb2ab8772b4d8e761814"
      }
    },
    {
      "number": 341,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyMjAxODcw",
      "title": "verifier.go: Add checks for request method and stateful headers",
      "url": "https://github.com/WICG/webpackage/pull/341",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This implements Step 3-5 of the \"Cross-origin trust\" algorithm\r\n([Section 4 of draft-yasskin-http-origin-signed-responses.html](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#rfc.section.4)).",
      "createdAt": "2018-11-20T06:06:12Z",
      "updatedAt": "2018-11-20T06:54:45Z",
      "closedAt": "2018-11-20T06:54:40Z",
      "mergedAt": "2018-11-20T06:54:40Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjEzOTk4",
          "commit": {
            "abbreviatedOid": "253de33"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2018-11-20T06:08:50Z",
          "updatedAt": "2018-11-20T06:09:39Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Would you factor out a helper method so we wont have label jump `continue`s?",
              "createdAt": "2018-11-20T06:08:50Z",
              "updatedAt": "2018-11-20T06:28:41Z"
            },
            {
              "originalPosition": 39,
              "body": "L132 seems broken?",
              "createdAt": "2018-11-20T06:09:21Z",
              "updatedAt": "2018-11-20T06:28:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjE5MDU1",
          "commit": {
            "abbreviatedOid": "a921463"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-20T06:32:33Z",
          "updatedAt": "2018-11-20T06:32:33Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Done.",
              "createdAt": "2018-11-20T06:32:33Z",
              "updatedAt": "2018-11-20T06:32:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjE5MTI1",
          "commit": {
            "abbreviatedOid": "a921463"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-20T06:32:52Z",
          "updatedAt": "2018-11-20T06:32:52Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Not actually, 'e' refers to a local variable.\r\nAdded `` ` `` around `e` hoping to make it easier to understand.",
              "createdAt": "2018-11-20T06:32:52Z",
              "updatedAt": "2018-11-20T06:32:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjIxMTM5",
          "commit": {
            "abbreviatedOid": "a921463"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-20T06:43:36Z",
          "updatedAt": "2018-11-20T06:43:36Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc2NjIyNzg3",
          "commit": {
            "abbreviatedOid": "a921463"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-20T06:52:26Z",
          "updatedAt": "2018-11-20T06:52:26Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "40d859524f9c948142f1568949df5409e81341f7",
      "headRepository": null,
      "headRefName": "header-check",
      "headRefOid": "a921463422a3edeca0aeb64bf3b04ed013c3bf9d",
      "mergeCommit": {
        "oid": "0c6a7b2f36628975fff98e92e5686aa3811e697d"
      }
    },
    {
      "number": 343,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyNTM2MjYw",
      "title": "go/signedexchange: More tests for signature verification",
      "url": "https://github.com/WICG/webpackage/pull/343",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-11-21T04:33:25Z",
      "updatedAt": "2018-11-27T01:18:16Z",
      "closedAt": "2018-11-27T01:17:45Z",
      "mergedAt": "2018-11-27T01:17:45Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Rebased onto master after #344. PTAL",
          "createdAt": "2018-11-26T02:20:20Z",
          "updatedAt": "2018-11-26T02:20:20Z"
        },
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori: @hajimehoshi is on vacation, so please feel free to merge.",
          "createdAt": "2018-11-26T14:12:51Z",
          "updatedAt": "2018-11-26T14:12:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MDc1MDAw",
          "commit": {
            "abbreviatedOid": "afcba62"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T04:42:35Z",
          "updatedAt": "2018-11-21T04:42:50Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "The current situation around `Exchange.RequestHeaders` is quite tricky. We might want to resolve it first.\r\n`func (*Exchange) encodeRequest()` assumes `\":method\"` key to not be in the `RequestHeaders` map, while `func (*Exchange) decodeRequest()` will populate the key.",
              "createdAt": "2018-11-21T04:42:36Z",
              "updatedAt": "2018-11-26T02:18:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MDg0OTI0",
          "commit": {
            "abbreviatedOid": "afcba62"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T05:50:44Z",
          "updatedAt": "2018-11-21T05:50:44Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "OK, created #344.",
              "createdAt": "2018-11-21T05:50:44Z",
              "updatedAt": "2018-11-26T02:18:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MzA1ODEx",
          "commit": {
            "abbreviatedOid": "c1330ca"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-26T14:11:02Z",
          "updatedAt": "2018-11-26T14:12:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "@hajimehoshi Any thoughts on using named return values here?\r\nhttps://tour.golang.org/basics/7 discourages using it on long func, but I'm open here.",
              "createdAt": "2018-11-26T14:11:02Z",
              "updatedAt": "2018-11-26T14:12:04Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d22bd1441decd63ee57a3a70bdbba81fbf433d4c",
      "headRepository": null,
      "headRefName": "test",
      "headRefOid": "c1330ca41ae31f2dd9592d1011bce66ecc748c5c",
      "mergeCommit": {
        "oid": "26098994e169185eb870e569d6455310771119cc"
      }
    },
    {
      "number": 344,
      "id": "MDExOlB1bGxSZXF1ZXN0MjMyNTQ2MTEx",
      "title": "go/signedexchange: Refactor request method handling",
      "url": "https://github.com/WICG/webpackage/pull/344",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add `RequestMethod` field to the `Exchange` struct\r\n- `NewExchange()` takes `method` as a parameter\r\n- Fix a bug that request headers were not encoded\r\n- Function Renamings\r\n  - {encode,decode}Request -> {encode,decode}RequestMap\r\n  - {encode,decode}ResponseHeaders -> {encode,decode}ResponseMap",
      "createdAt": "2018-11-21T05:50:10Z",
      "updatedAt": "2018-11-26T02:02:21Z",
      "closedAt": "2018-11-26T02:02:21Z",
      "mergedAt": "2018-11-26T02:02:21Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Pushed one more commit. PTAL\r\n\r\n- gen-signedexchange: Add `-method` option\r\n- dump-signedexchange: Print exchange's request method",
          "createdAt": "2018-11-26T01:55:53Z",
          "updatedAt": "2018-11-26T01:55:53Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MTEzMTA3",
          "commit": {
            "abbreviatedOid": "f7c7462"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T08:06:01Z",
          "updatedAt": "2018-11-21T08:08:40Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "`http.MethodGet` sounds better",
              "createdAt": "2018-11-21T08:06:01Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            },
            {
              "originalPosition": 28,
              "body": "ditto",
              "createdAt": "2018-11-21T08:07:26Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            },
            {
              "originalPosition": 21,
              "body": "`http.MethodGet` and `http.MethodHead`",
              "createdAt": "2018-11-21T08:08:21Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MTE3MDA5",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T08:19:27Z",
          "updatedAt": "2018-11-21T08:19:27Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done",
              "createdAt": "2018-11-21T08:19:27Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MTE3MDMw",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T08:19:31Z",
          "updatedAt": "2018-11-21T08:19:31Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "Done",
              "createdAt": "2018-11-21T08:19:31Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3MTE3MDcy",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-21T08:19:37Z",
          "updatedAt": "2018-11-21T08:19:37Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Done",
              "createdAt": "2018-11-21T08:19:37Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc3NTQwMzk3",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-11-22T08:15:22Z",
          "updatedAt": "2018-11-22T08:15:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MTExNDI3",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-26T01:39:44Z",
          "updatedAt": "2018-11-26T01:39:44Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Make plural? `encoders` or `encs` or `es`?",
              "createdAt": "2018-11-26T01:39:44Z",
              "updatedAt": "2018-11-26T01:54:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MTExNTA1",
          "commit": {
            "abbreviatedOid": "0ec29b2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-26T01:40:32Z",
          "updatedAt": "2018-11-26T01:40:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MTEyODEx",
          "commit": {
            "abbreviatedOid": "654e9cd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-11-26T01:55:08Z",
          "updatedAt": "2018-11-26T01:55:08Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "done",
              "createdAt": "2018-11-26T01:55:08Z",
              "updatedAt": "2018-11-26T01:55:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTc4MTEzNDcz",
          "commit": {
            "abbreviatedOid": "654e9cd"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-11-26T02:01:19Z",
          "updatedAt": "2018-11-26T02:01:19Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "827cb70e954750dca7bc8aecb977cd49442dc856",
      "headRepository": null,
      "headRefName": "requestmap",
      "headRefOid": "654e9cd6e80d9511a618c09d19cd39253dde1a1a",
      "mergeCommit": {
        "oid": "d22bd1441decd63ee57a3a70bdbba81fbf433d4c"
      }
    },
    {
      "number": 346,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM1MTQzMjYz",
      "title": "Strictly UTF-8 decode the fallback URL",
      "url": "https://github.com/WICG/webpackage/pull/346",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Bikeshed warned that I'd never defined |fallbackUrl|, but I missed it\nbefore going on parental leave. Do y'all see any problems with picking this conversion from bytes to a string?\n\n@irori, we ought to test this with a couple bad fallback URLs, say one starting with a BOM, and one with an invalid sequence that the UTF-8 decoder might convert to U+FFFD. Would you be willing to add those tests?\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/346.html\" title=\"Last updated on Dec 1, 2018, 12:31 AM GMT (121ecb1)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/346/2eddf31...jyasskin:121ecb1.html\" title=\"Last updated on Dec 1, 2018, 12:31 AM GMT (121ecb1)\">Diff</a>",
      "createdAt": "2018-11-30T23:19:28Z",
      "updatedAt": "2018-12-20T08:44:08Z",
      "closedAt": "2018-12-05T15:37:48Z",
      "mergedAt": "2018-12-05T15:37:48Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I should add that I found https://cs.chromium.org/chromium/src/net/http/http_response_headers.cc?l=920&rcl=6aa20f013414d789e8d72752a6885ef3d990d274 after I wrote this change, indicating that maybe we'd rather `Location` headers be all-ASCII. We can enforce that for SXG URLs if y'all think it's a good idea.\r\n\r\nThis is also related to https://github.com/whatwg/fetch/issues/843.",
          "createdAt": "2018-12-04T03:12:49Z",
          "updatedAt": "2018-12-04T03:12:49Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "UTF-8 is generally preferable I think, but it depends a bit on what kind of field this is. Happy to help if you could give some context.",
          "createdAt": "2018-12-04T10:37:48Z",
          "updatedAt": "2018-12-04T10:37:48Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@annevk This is the field at the beginning of the Signed Exchange format that gives both the URL of the inner resource and a target to redirect to if the Signed Exchange is broken (doesn't parse, the signature doesn't validate, maybe other things).",
          "createdAt": "2018-12-04T15:00:06Z",
          "updatedAt": "2018-12-04T15:00:06Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I'd make those UTF-8. The URL parser will turn it all into ASCII, but it seems preferable to be able to serialize in more ways.",
          "createdAt": "2018-12-05T09:03:43Z",
          "updatedAt": "2018-12-05T09:03:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks, @annevk!",
          "createdAt": "2018-12-05T15:38:41Z",
          "updatedAt": "2018-12-05T15:38:41Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "For the record, tests for this are https://github.com/web-platform-tests/wpt/commit/2e19cbe5d5d74821056d4ae2cef435accefaf4ef and https://github.com/web-platform-tests/wpt/commit/e663fa084dcdac43fea5cdd6c69b059b5ad0743f.",
          "createdAt": "2018-12-20T08:44:07Z",
          "updatedAt": "2018-12-20T08:44:07Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgwNTkwOTEz",
          "commit": {
            "abbreviatedOid": "121ecb1"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-03T01:21:20Z",
          "updatedAt": "2018-12-03T01:21:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgxMDYzNjg4",
          "commit": {
            "abbreviatedOid": "121ecb1"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sure, I will add the tests.",
          "createdAt": "2018-12-04T01:58:30Z",
          "updatedAt": "2018-12-04T01:58:30Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2eddf319bdbd24df3a2fa64522be3437ad9efd96",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "utf-8-decode-fallback-url",
      "headRefOid": "121ecb16738bf8f280fe6c16559fcbdd235f5547",
      "mergeCommit": {
        "oid": "f603e91d73ef7189b4342662853bac84c6e9ff90"
      }
    },
    {
      "number": 348,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM3MDMyMTUx",
      "title": "Add a security consideration about content sniffing.",
      "url": "https://github.com/WICG/webpackage/pull/348",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This fixes #321, I think. @molnarg, how do you feel about this?\n\nI'll need to add this to bundles too, but I want to get the SXG text right first.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/348.html\" title=\"Last updated on Dec 13, 2018, 12:52 AM GMT (052993b)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/348/dcb188d...jyasskin:052993b.html\" title=\"Last updated on Dec 13, 2018, 12:52 AM GMT (052993b)\">Diff</a>",
      "createdAt": "2018-12-08T00:55:45Z",
      "updatedAt": "2018-12-19T22:43:38Z",
      "closedAt": "2018-12-19T22:43:35Z",
      "mergedAt": "2018-12-19T22:43:35Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Chromium CL: https://chromium-review.googlesource.com/c/chromium/src/+/1373430",
          "createdAt": "2018-12-13T02:29:02Z",
          "updatedAt": "2018-12-13T02:29:02Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I need some help understanding the model.\r\n\r\nIs the idea that `application/signed-exchange` and `application/webbundle` responses cannot be sniffed as scripts or same-origin quirks mode style sheets? If so, we could add them to <https://fetch.spec.whatwg.org/#should-response-to-request-be-blocked-due-to-mime-type?>. I don't think it matters for other nosniff contexts per https://mimesniff.spec.whatwg.org/#determining-the-computed-mime-type-of-a-resource.\r\n\r\nOr is the idea that the responses they encompass (i.e., those in the bundle/archive) cannot be sniffed? If so, we could \"dynamically inject\" this header when we create those responses ensuring \"determine nosniff\" always returns true for them downstream.",
          "createdAt": "2018-12-13T14:49:57Z",
          "updatedAt": "2018-12-13T14:49:57Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@annevk One of the bigger risks is that they might be sniffed as PDFs, Flash, or other plugin-recognized types. The risky file types don't necessarily follow the Fetch spec, so the header isn't guaranteed to work, but we thought it'd improve our chances.\r\n\r\n@mikewest may have other answers. He suggested requiring nosniff here. We also want to make internal responses automatically nosniff, but that'll come in a separate change.",
          "createdAt": "2018-12-13T16:59:48Z",
          "updatedAt": "2018-12-13T16:59:48Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Ah plugins, that is indeed a poorly specified area. Note that currently we don't have any language that suggests nosniff would work for plugins.",
          "createdAt": "2018-12-13T17:20:54Z",
          "updatedAt": "2018-12-13T17:20:54Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yep. I don't personally have evidence that this improves things for any particular plugin; we're just hoping. I don't have strong feelings about whether this is the right thing to do.",
          "createdAt": "2018-12-13T19:06:25Z",
          "updatedAt": "2018-12-13T19:06:25Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "I think we need to know concretely what this will help with so it can be tested for (and specified if it isn't already). In particular as we'd have to do this for other new formats too, presumably (e.g., Wasm)? (I see the benefits for the contained non-HTTP responses, but as you said that's separate.)",
          "createdAt": "2018-12-13T20:36:25Z",
          "updatedAt": "2018-12-13T20:36:25Z"
        },
        {
          "author": "mikewest",
          "authorAssociation": "MEMBER",
          "body": "In general, I'd like for us to be strict about new mechanisms we're adding to the platform that might result in executable code. I don't have any concrete examples of places where plugins could misinterpret an SXG response as something unfortunate, but there are a number of examples of plugins' propensity to zealously sniff incoming content into executable code. I'd like to make that less likely.\r\n\r\nThat said, when I was talking with @jyasskin about this a few days ago, I incorrectly assumed that `nosniff` applied to plugin content. In the meantime, @jyasskin pointed out that https://html.spec.whatwg.org/multipage/iframe-embed-object.html#object-type-detection makes strictly obeying `Content-Type` headers entirely optional for plugin resources, and that we apparently don't do so in Chrome. I think we should change that (though I don't have any data that would suggest that it's safe to do so; I'll add some metrics). If we don't, then I think I agree with @annevk that the Fetch bits of this change wouldn't have any teeth.\r\n\r\n> Or is the idea that the responses they encompass (i.e., those in the bundle/archive) cannot be sniffed? If so, we could \"dynamically inject\" this header when we create those responses ensuring \"determine nosniff\" always returns true for them downstream.\r\n\r\nAs above, I'd like for us to strictly enforce MIME type checks for resources contained in SXG responses. Implicitly injecting a nosniff requirement seems like it would indeed be simpler for developers, so I'd be on board with that kind of mechanism. It seems like requiring developers to include the header has a higher chance of increasing usage even in browsers that don't support SXG (as presumably developers would inject the header themselves on both the SXG-encoded resource, and the plain ol' resource), but that might be asking too much.",
          "createdAt": "2018-12-18T08:08:41Z",
          "updatedAt": "2018-12-18T08:08:41Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to revert the discussion of `X-Content-Type-Options:nosniff` in this PR, to land the general anti-sniffing advice, and then open a new PR that deals specifically with that header, both for the SXG itself and for its contents.",
          "createdAt": "2018-12-19T22:34:55Z",
          "updatedAt": "2018-12-19T22:34:55Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyOTIyNjMx",
          "commit": {
            "abbreviatedOid": "379f532"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-08T00:57:45Z",
          "updatedAt": "2018-12-08T00:57:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgyOTI5MTcx",
          "commit": {
            "abbreviatedOid": "379f532"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-08T02:56:57Z",
          "updatedAt": "2018-12-08T02:56:57Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTgzNTEyNDI5",
          "commit": {
            "abbreviatedOid": "ea22292"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "still lg",
          "createdAt": "2018-12-11T05:07:22Z",
          "updatedAt": "2018-12-11T05:07:22Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cfd62a17b7b3c2cfd99a88eec9a5e5462b9ca149",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "anti-content-sniffing",
      "headRefOid": "71a9b8b15fc832794f79b4eb43556427a2933d9c",
      "mergeCommit": {
        "oid": "f030d4341bb1fc8c1b21f934850b3984f93b88c0"
      }
    },
    {
      "number": 351,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM4MjcxNzUx",
      "title": "gen-signedexchange: Add -nocheck flag",
      "url": "https://github.com/WICG/webpackage/pull/351",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This flag lets gen-signedexchange skip some input validations. This is needed to create SXGs for web-platform-tests.\r\n\r\nThis also fixes a bug that Exchange.Verify() fails when `url.Parse(fallbackUrl).String() != fallbackUrl`. (Note: current Chromium impl has the same bug, see https://crbug.com/914247)",
      "createdAt": "2018-12-13T05:47:01Z",
      "updatedAt": "2018-12-15T06:10:18Z",
      "closedAt": "2018-12-15T06:10:15Z",
      "mergedAt": "2018-12-15T06:10:15Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "bikeshed: `ignoreerrors` is more idionatic...\r\n\r\nhttps://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies\r\n\r\n2018\u5e7412\u670814\u65e5(\u91d1) 10:53\u3001Kunihiko Sakamoto \u3055\u3093\uff08notifications@github.com\uff09\u306e\u30e1\u30c3\u30bb\u30fc\u30b8:\r\n\r\n> *@irori* commented on this pull request.\r\n> ------------------------------\r\n>\r\n> In go/signedexchange/cmd/gen-signedexchange/main.go\r\n> <https://github.com/WICG/webpackage/pull/351#discussion_r241623334>:\r\n>\r\n> > @@ -47,6 +47,8 @@ var (\r\n>  \tflagDumpHeadersCbor      = flag.String(\"dumpHeadersCbor\", \"\", \"Dump metadata and headers encoded as a canonical CBOR to a file for debugging.\")\r\n>  \tflagOutput               = flag.String(\"o\", \"out.sxg\", \"Signed exchange output file. If value is '-', sxg is written to stdout.\")\r\n>\r\n> +\tflagSkipCheck = flag.Bool(\"skipcheck\", false, \"Do not reject invalid input arguments\")\r\n>\r\n> OK, renamed to -ignoreErrors.\r\n>\r\n> \u2014\r\n> You are receiving this because your review was requested.\r\n> Reply to this email directly, view it on GitHub\r\n> <https://github.com/WICG/webpackage/pull/351#discussion_r241623334>, or mute\r\n> the thread\r\n> <https://github.com/notifications/unsubscribe-auth/AABCNkEZrmjeeuer6WH2L_VEun5c_EaXks5u4wSegaJpZM4ZQ-Cg>\r\n> .\r\n>\r\n",
          "createdAt": "2018-12-14T02:05:04Z",
          "updatedAt": "2018-12-14T02:06:24Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "> bikeshed: `ignoreerrors` is more idionatic... https://golang.org/cmd/go/#hdr-Compile_packages_and_dependencies \r\n\r\nHmm we already have many camelCase flags and I'd like to keep the consistency.",
          "createdAt": "2018-12-14T06:23:29Z",
          "updatedAt": "2018-12-14T06:23:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTA4ODc1",
          "commit": {
            "abbreviatedOid": "4a18d31"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-13T05:48:18Z",
          "updatedAt": "2018-12-13T05:50:45Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I feel like `-nocheck=false` sounds confusing due to two negative words. Wouldn't `-skipcheck=false` be better?",
              "createdAt": "2018-12-13T05:48:18Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTEwMTIx",
          "commit": {
            "abbreviatedOid": "4a18d31"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-13T05:55:42Z",
          "updatedAt": "2018-12-13T05:55:43Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Or `flagCheck = flag.Bool(\"check\", true, ...)`?",
              "createdAt": "2018-12-13T05:55:43Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTEwNDYz",
          "commit": {
            "abbreviatedOid": "4a18d31"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-13T05:57:35Z",
          "updatedAt": "2018-12-13T05:57:35Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Both are fine :-)",
              "createdAt": "2018-12-13T05:57:35Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTExOTUz",
          "commit": {
            "abbreviatedOid": "d15d9b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-13T06:05:42Z",
          "updatedAt": "2018-12-13T06:05:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Renamed to `-skipcheck`, as default-true boolean flag feels a bit unusual to me.",
              "createdAt": "2018-12-13T06:05:42Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0NTEyMzk0",
          "commit": {
            "abbreviatedOid": "d15d9b2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-13T06:08:04Z",
          "updatedAt": "2018-12-13T06:10:12Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "bikeshedding: How about `-ignoreErrors` (aligned w/ `make`) or `-f` (most of coreutils)",
              "createdAt": "2018-12-13T06:08:04Z",
              "updatedAt": "2018-12-14T01:52:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg0OTQ0MDU2",
          "commit": {
            "abbreviatedOid": "c00b6ec"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-14T01:53:34Z",
          "updatedAt": "2018-12-14T01:53:34Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "OK, renamed to `-ignoreErrors`.",
              "createdAt": "2018-12-14T01:53:34Z",
              "updatedAt": "2018-12-14T01:53:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1MDIxNTU1",
          "commit": {
            "abbreviatedOid": "c00b6ec"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-12-14T09:17:32Z",
          "updatedAt": "2018-12-14T09:17:32Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "dcb188d89aee7b2ab06b55d45ccad8343d924a06",
      "headRepository": null,
      "headRefName": "requesturi",
      "headRefOid": "c00b6ec7cee87233e865ba49f179ba5409289fdf",
      "mergeCommit": {
        "oid": "d3352199e0a074ef0ce4390232b861560d061425"
      }
    },
    {
      "number": 352,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5MjI5ODU5",
      "title": "Allow SXGs to be loaded from localhost or files.",
      "url": "https://github.com/WICG/webpackage/pull/352",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See also some discussion in https://crbug.com/915576.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/352.html\" title=\"Last updated on Dec 17, 2018, 5:44 PM UTC (579eac9)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/352/d335219...jyasskin:579eac9.html\" title=\"Last updated on Dec 17, 2018, 5:44 PM UTC (579eac9)\">Diff</a>",
      "createdAt": "2018-12-17T17:44:01Z",
      "updatedAt": "2018-12-17T23:59:23Z",
      "closedAt": "2018-12-17T23:59:19Z",
      "mergedAt": "2018-12-17T23:59:19Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg1ODUyMTkx",
          "commit": {
            "abbreviatedOid": "579eac9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-17T23:48:30Z",
          "updatedAt": "2018-12-17T23:48:30Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d3352199e0a074ef0ce4390232b861560d061425",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "allow-localhost",
      "headRefOid": "579eac92cf5e2ba4341c0c0a524f674a593b041c",
      "mergeCommit": {
        "oid": "9b58b4c7a7da682fbf1cc6cc0a1e3d034dc7847c"
      }
    },
    {
      "number": 353,
      "id": "MDExOlB1bGxSZXF1ZXN0MjM5NzAyMDUy",
      "title": "go: Initial b3 support",
      "url": "https://github.com/WICG/webpackage/pull/353",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Start adding support for #350\r\n\r\nThe output is identical to `b2` but the magic bytes for now.",
      "createdAt": "2018-12-19T03:34:57Z",
      "updatedAt": "2018-12-19T06:02:45Z",
      "closedAt": "2018-12-19T06:02:45Z",
      "mergedAt": "2018-12-19T06:02:45Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2Mzc3MjQy",
          "commit": {
            "abbreviatedOid": "cec7852"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-19T03:38:44Z",
          "updatedAt": "2018-12-19T03:38:44Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2MzkzMzU4",
          "commit": {
            "abbreviatedOid": "cec7852"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-12-19T05:39:18Z",
          "updatedAt": "2018-12-19T05:39:18Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5cc8e005e53d6a0023de4f1903ad9a52e26d5805",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "b3",
      "headRefOid": "cec785285e1c250cd570938de51f46b9dbc34aa0",
      "mergeCommit": {
        "oid": "cfd62a17b7b3c2cfd99a88eec9a5e5462b9ca149"
      }
    },
    {
      "number": 354,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMDE4ODM5",
      "title": "Prevent content-type sniffing",
      "url": "https://github.com/WICG/webpackage/pull/354",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@annevk @molnarg This has the somewhat controversial requirement that SXGs are served with `X-Content-Type-Options: nosniff` from #348. @molnarg, if we want this, we should show a case where it actually prevents a plugin from sniffing an executable content type.\n\nI've also added the promised requirement that clients treat the contents as including that header, and a requirement we haven't discussed yet that the contents actually include a `Content-Type` header.\n\n[signed-responses preview](https://jyasskin.github.io/webpackage/nosniff-header/draft-yasskin-http-origin-signed-responses.html#seccons-content-sniffing)\n[bundled-exchanges preview](https://jyasskin.github.io/webpackage/nosniff-header/draft-yasskin-wpack-bundled-exchanges.html#seccons-content-sniffing)\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/354.html\" title=\"Last updated on Jan 14, 2019, 7:30 PM UTC (cf5f1b1)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/354/595f72f...jyasskin:cf5f1b1.html\" title=\"Last updated on Jan 14, 2019, 7:30 PM UTC (cf5f1b1)\">Diff</a>",
      "createdAt": "2018-12-20T00:43:47Z",
      "updatedAt": "2019-01-16T04:27:50Z",
      "closedAt": "2019-01-16T04:27:47Z",
      "mergedAt": "2019-01-16T04:27:47Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "No objections from me, though I'm curious why the extra measures to prevent content-sniffing the inner response. Given the other safety measures in #348, is still there a concern that a plugin might unexpectedly trigger after the virtual redirect?",
          "createdAt": "2018-12-20T07:22:30Z",
          "updatedAt": "2018-12-20T07:22:30Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "#348 warns folks away from doing dangerous things, but doesn't prevent them, especially if they host the SXG on a separate domain. Adding XCTO:nosniff to the inner responses protects the signing domain.",
          "createdAt": "2018-12-20T23:29:51Z",
          "updatedAt": "2018-12-20T23:29:51Z"
        },
        {
          "author": "molnarg",
          "authorAssociation": "NONE",
          "body": "The X-Content-Type-Options and the Content-Type header is more for preventing non-plugin (e.g. HTML) content sniffing, as described in https://mimesniff.spec.whatwg.org. Plugins can just ignore all headers in the worst case (though some of them look at the headers), but browser content sniffing will have to obey the headers as mandated in the MIME sniffing spec (Content-Type header) and the fetch spec: https://fetch.spec.whatwg.org/#x-content-type-options-header (X-Content-Type-Options header).\r\n\r\nAs a concrete example for plugins, Flash (which is a plugin that looks at headers) will refuse to execute if there is a Content-Type header that is not application/x-shockwave-flash https://miki.it/blog/2014/7/8/abusing-jsonp-with-rosetta-flash#mitigations-by-website-owners",
          "createdAt": "2018-12-29T15:01:43Z",
          "updatedAt": "2018-12-29T15:01:43Z"
        },
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "So this requirement would prevent the package itself and its contents from being executed as a script and used as a style sheet (in very limited circumstances, assuming the contents are not labeled with a JavaScript MIME type or text/css). Per https://mimesniff.spec.whatwg.org/#determining-the-computed-mime-type-of-a-resource I don't think it would prevent any other kind of sniffing for the package except for maybe plugins but it sounds like they don't really care for this header. I guess that's fine?\r\n\r\nPlease use https://fetch.spec.whatwg.org/#concept-header-extract-mime-type rather than the MIME Sniffing definition of obtaining a MIME type btw (sorry, agreed that this all needs cleaning up).",
          "createdAt": "2019-01-02T14:27:38Z",
          "updatedAt": "2019-01-02T14:27:38Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The \"extract mime type\" change is done. The Content-Type will always be set to \"application/signed-exchange\" for signed exchanges, so no risk of Flash claiming the content, or of executing as script or a stylesheet. It seems unlikely that this content will parse as a script or stylesheet anyway, with the NULs early in the format, but XCTO does a better job of blocking stylesheets than adding the content type to the [\"Should response to request be blocked due to its MIME type?\"](https://fetch.spec.whatwg.org/#should-response-to-request-be-blocked-due-to-mime-type?) list.\r\n\r\nMike suggests @otherdaniel may have time to review the constraints on the inner resource, but if that's not done by Monday, I think we can merge this anyway and fix up problems as people point them out.",
          "createdAt": "2019-01-10T17:59:25Z",
          "updatedAt": "2019-01-10T17:59:25Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2ODY5MDYy",
          "commit": {
            "abbreviatedOid": "8c417f9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-20T07:04:50Z",
          "updatedAt": "2018-12-20T07:04:50Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "595f72f94b0bbbfa318ad075c83260befd622ede",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "nosniff-header",
      "headRefOid": "cf5f1b1e8f4a68c83fe135cf64358e8b697f4be2",
      "mergeCommit": {
        "oid": "c4fd5cfef2a5bd3914b092f9c23e422303dc9ded"
      }
    },
    {
      "number": 355,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMDcwNDU2",
      "title": "go/signedexchange: Rework TestSignedExchange",
      "url": "https://github.com/WICG/webpackage/pull/355",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is the most basic test case, but before this patch it only covered\r\nthe b1 format. Also, we did not have any tests for `ReadExchange()`.\r\n\r\nAfter this patch, it tests all the supported format versions, by using\r\n`ReadExchange()` to deserialize exchanges.",
      "createdAt": "2018-12-20T06:59:31Z",
      "updatedAt": "2018-12-20T07:42:08Z",
      "closedAt": "2018-12-20T07:42:04Z",
      "mergedAt": "2018-12-20T07:42:04Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2ODY4ODc5",
          "commit": {
            "abbreviatedOid": "8f1dca4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-20T07:03:52Z",
          "updatedAt": "2018-12-20T07:03:52Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2ODc2MzE4",
          "commit": {
            "abbreviatedOid": "8f1dca4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-12-20T07:39:35Z",
          "updatedAt": "2018-12-20T07:39:35Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "8375493173910d369aecdb7ca90762129b3f26b1",
      "headRepository": null,
      "headRefName": "test",
      "headRefOid": "8f1dca4c1a5e448a717ceb8d5821a38e5b6d5e4c",
      "mergeCommit": {
        "oid": "e33a55b4545eebcbb89646399371a795516d5463"
      }
    },
    {
      "number": 356,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMDg5OTQy",
      "title": "go/signedexchange: Run signedexchange tests against all supported versions",
      "url": "https://github.com/WICG/webpackage/pull/356",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This patch turns all existing tests in signedexchange_test.go\r\ninto grouped tests parameterized by format version.",
      "createdAt": "2018-12-20T08:37:47Z",
      "updatedAt": "2018-12-21T06:22:22Z",
      "closedAt": "2018-12-21T06:22:17Z",
      "mergedAt": "2018-12-21T06:22:17Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@hajimehoshi WDYT?",
          "createdAt": "2018-12-21T06:03:36Z",
          "updatedAt": "2018-12-21T06:03:36Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg2ODkzMTk0",
          "commit": {
            "abbreviatedOid": "0de25ed"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-20T08:43:51Z",
          "updatedAt": "2018-12-20T08:43:51Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjgxOTc1",
          "commit": {
            "abbreviatedOid": "0de25ed"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm (I didn't know `(*testing.T).Run()`. That's good to know :-)",
          "createdAt": "2018-12-21T06:16:10Z",
          "updatedAt": "2018-12-21T06:16:10Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e33a55b4545eebcbb89646399371a795516d5463",
      "headRepository": null,
      "headRefName": "test",
      "headRefOid": "0de25edc7dfb249c9eedb8dd3320a1cf44ff6f02",
      "mergeCommit": {
        "oid": "8f7d57c7acfcd577de1b2c7260d5dbc2268c645d"
      }
    },
    {
      "number": 357,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMzY3NTIy",
      "title": "go: [b3] omit request map",
      "url": "https://github.com/WICG/webpackage/pull/357",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This commit updates the CBOR representation of the exchange headers to\r\nonly contain response map.",
      "createdAt": "2018-12-21T04:11:57Z",
      "updatedAt": "2019-01-06T23:37:39Z",
      "closedAt": "2019-01-06T23:37:39Z",
      "mergedAt": "2019-01-06T23:37:39Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Also, you would need to update `TestSignedExchange` in signedexchange_test.go since request header is not seen in the deserialized Exchange in 1b3.",
          "createdAt": "2018-12-21T04:34:16Z",
          "updatedAt": "2018-12-21T04:34:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjY5MDcy",
          "commit": {
            "abbreviatedOid": "203be61"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-21T04:24:49Z",
          "updatedAt": "2018-12-21T04:24:50Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Maybe `e.Version != version.version1b1 && e.Version != version.version1b2` (assuming that future versions don't have the request map)?",
              "createdAt": "2018-12-21T04:24:49Z",
              "updatedAt": "2018-12-21T04:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjY5MTA5",
          "commit": {
            "abbreviatedOid": "203be61"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-21T04:25:17Z",
          "updatedAt": "2018-12-21T04:25:17Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Reaching here is a bug of this package, so `panic` would be fine.",
              "createdAt": "2018-12-21T04:25:17Z",
              "updatedAt": "2018-12-21T04:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjcxNzM2",
          "commit": {
            "abbreviatedOid": "203be61"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2018-12-21T04:49:25Z",
          "updatedAt": "2018-12-21T04:56:32Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "Done.",
              "createdAt": "2018-12-21T04:49:25Z",
              "updatedAt": "2018-12-21T04:56:32Z"
            },
            {
              "originalPosition": 13,
              "body": "Done.",
              "createdAt": "2018-12-21T04:49:33Z",
              "updatedAt": "2018-12-21T04:56:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjcyODgy",
          "commit": {
            "abbreviatedOid": "fb57e7d"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-21T05:00:40Z",
          "updatedAt": "2018-12-21T05:00:40Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3Mjc2MTE1",
          "commit": {
            "abbreviatedOid": "fb57e7d"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2018-12-21T05:31:00Z",
          "updatedAt": "2018-12-21T05:31:00Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MTkxNDA5",
          "commit": {
            "abbreviatedOid": "fb57e7d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This matches #360 as far as I can see.",
          "createdAt": "2019-01-03T21:32:23Z",
          "updatedAt": "2019-01-03T21:32:23Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "168ac78618017e0c44468f619cd40001fae5d507",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "b3noreqmap",
      "headRefOid": "fb57e7d557763cac0f6cc9d476ec8fbf306085ea",
      "mergeCommit": {
        "oid": "67ecc9351a7911f2944eecf60694c287e728474c"
      }
    },
    {
      "number": 358,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQwMzcyNzcy",
      "title": "Fix format string errors",
      "url": "https://github.com/WICG/webpackage/pull/358",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2018-12-21T05:01:53Z",
      "updatedAt": "2018-12-21T05:38:50Z",
      "closedAt": "2018-12-21T05:22:22Z",
      "mergedAt": "2018-12-21T05:22:22Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3MjczNzUx",
          "commit": {
            "abbreviatedOid": "31e34e9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2018-12-21T05:08:06Z",
          "updatedAt": "2018-12-21T05:08:06Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg3Mjc2OTg0",
          "commit": {
            "abbreviatedOid": "31e34e9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2018-12-21T05:38:50Z",
          "updatedAt": "2018-12-21T05:38:50Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "168ac78618017e0c44468f619cd40001fae5d507",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "gofix",
      "headRefOid": "31e34e901985866799852674c1a8ea1dc7a3e562",
      "mergeCommit": {
        "oid": "cee76ef4008cdf50eea946fb47a8c123ec4d983a"
      }
    },
    {
      "number": 359,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQxODIyNTcz",
      "title": "Use Fetch's method of extracting a MIME type instead of MIMEsniff.",
      "url": "https://github.com/WICG/webpackage/pull/359",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks for the pointer, @annevk.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/359.html\" title=\"Last updated on Jan 7, 2019, 9:12 PM UTC (51fc87c)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/359/80005f0...jyasskin:51fc87c.html\" title=\"Last updated on Jan 7, 2019, 9:12 PM UTC (51fc87c)\">Diff</a>",
      "createdAt": "2019-01-02T19:06:58Z",
      "updatedAt": "2019-01-10T00:06:45Z",
      "closedAt": "2019-01-10T00:06:41Z",
      "mergedAt": "2019-01-10T00:06:41Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "If you indeed want to include parameters you want to omit the double quotes, per discussion in https://github.com/whatwg/mimesniff/issues/52. Typically these kind of checks ignore parameters however, so you might want to add a note to that effect and carefully test for it. (I'm actually not aware of a place where we do a literal check.)",
          "createdAt": "2019-01-04T08:18:05Z",
          "updatedAt": "2019-01-04T08:18:05Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Ok, if everyone else ignores parameters, we will here too. Done and thanks.",
          "createdAt": "2019-01-04T18:14:28Z",
          "updatedAt": "2019-01-04T18:14:28Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@nyaxt @kinu FYI, this changes the `application/cert-chain+cbor` MIME type check to allow and ignore parameters.",
          "createdAt": "2019-01-10T00:05:57Z",
          "updatedAt": "2019-01-10T00:05:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg4OTM4MDI5",
          "commit": {
            "abbreviatedOid": "e8272d4"
          },
          "author": "annevk",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-03T09:19:17Z",
          "updatedAt": "2019-01-03T09:21:18Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "It should be either a MIME type or failure at this point.",
              "createdAt": "2019-01-03T09:19:17Z",
              "updatedAt": "2019-01-07T21:12:31Z"
            },
            {
              "originalPosition": 19,
              "body": "I suspect you want to return the essence of the returned MIME type, meaning this will have to be slightly more involved. (It was a little ambiguous already. E.g., do parameters matter?)",
              "createdAt": "2019-01-03T09:21:12Z",
              "updatedAt": "2019-01-07T21:12:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5MTA3Nzg0",
          "commit": {
            "abbreviatedOid": "e8272d4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Thanks for checking this!",
          "createdAt": "2019-01-03T17:28:06Z",
          "updatedAt": "2019-01-03T17:35:40Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Whoops, thanks!",
              "createdAt": "2019-01-03T17:28:06Z",
              "updatedAt": "2019-01-07T21:12:31Z"
            },
            {
              "originalPosition": 19,
              "body": "I intended to forbid parameters here, since https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#internet-media-type-applicationcert-chaincbor doesn't define any. I think the current text accomplishes that? If you think it's better to ignore parameters (by using the essence), I'm happy to do that instead.",
              "createdAt": "2019-01-03T17:31:08Z",
              "updatedAt": "2019-01-07T21:12:31Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "80005f09c1e52675b9279dc44a87c2887b63cf8d",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "new-mime-type-algorithm",
      "headRefOid": "51fc87c2be716d31378145bb4e7ebf12d036d89b",
      "mergeCommit": {
        "oid": "8cf6f78da08b688b5b0192a5fa44c3390b08c60b"
      }
    },
    {
      "number": 360,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQxODg1NTAy",
      "title": "Rely on variants",
      "url": "https://github.com/WICG/webpackage/pull/360",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This depends on https://github.com/httpwg/http-extensions/pull/744. @mnot should probably take a look.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/360.html\" title=\"Last updated on Jan 7, 2019, 8:56 PM UTC (c7afd7d)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/360/67ecc93...jyasskin:c7afd7d.html\" title=\"Last updated on Jan 7, 2019, 8:56 PM UTC (c7afd7d)\">Diff</a>",
      "createdAt": "2019-01-03T01:03:04Z",
      "updatedAt": "2019-01-07T21:10:37Z",
      "closedAt": "2019-01-07T21:10:32Z",
      "mergedAt": "2019-01-07T21:10:32Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjQ5Njk5",
          "commit": {
            "abbreviatedOid": "17ff994"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-06T23:21:42Z",
          "updatedAt": "2019-01-06T23:36:15Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Should we clarify that they are response headers to align with your other edits?",
              "createdAt": "2019-01-06T23:21:42Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjU2OTg5",
          "commit": {
            "abbreviatedOid": "17ff994"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T01:36:58Z",
          "updatedAt": "2019-01-07T01:37:06Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "I think we ban POST method by this \"not safe\" check. (POST is actually cachable per https://tools.ietf.org/html/rfc7231#section-4.2.3 ). Should we keep this check?",
              "createdAt": "2019-01-07T01:36:58Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjY5OTE2",
          "commit": {
            "abbreviatedOid": "17ff994"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T03:44:30Z",
          "updatedAt": "2019-01-07T03:47:40Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Yes. I'll do that in the morning before I merge.",
              "createdAt": "2019-01-07T03:44:30Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            },
            {
              "originalPosition": 165,
              "body": "This line did ban POST, but since the headers can't encode a method anymore, I don't think we need to keep it.",
              "createdAt": "2019-01-07T03:45:45Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5Njc3NTA5",
          "commit": {
            "abbreviatedOid": "17ff994"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-07T05:00:58Z",
          "updatedAt": "2019-01-07T05:00:58Z",
          "comments": [
            {
              "originalPosition": 165,
              "body": "Ah I missed that. Thanks for the explanation :)",
              "createdAt": "2019-01-07T05:00:58Z",
              "updatedAt": "2019-01-07T20:56:20Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "67ecc9351a7911f2944eecf60694c287e728474c",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "rely-on-variants",
      "headRefOid": "c7afd7d083d38c939936ba7719f602e77d49086d",
      "mergeCommit": {
        "oid": "1a81570ab4adddd0fb8786e9182ed8ae202e3581"
      }
    },
    {
      "number": 361,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyMTE1NTc4",
      "title": "Restrict the browser's request's method to GET or HEAD.",
      "url": "https://github.com/WICG/webpackage/pull/361",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Since this is after a 303 redirect, I think the method can only be something else if a service worker messes with things, but we should prevent service workers from getting us into a weird state.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/361.html\" title=\"Last updated on Jan 3, 2019, 9:28 PM UTC (e33e03f)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/361/8f7d57c...jyasskin:e33e03f.html\" title=\"Last updated on Jan 3, 2019, 9:28 PM UTC (e33e03f)\">Diff</a>",
      "createdAt": "2019-01-03T21:28:02Z",
      "updatedAt": "2019-01-07T21:11:31Z",
      "closedAt": "2019-01-07T21:11:28Z",
      "mergedAt": "2019-01-07T21:11:28Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @kinu @horo-t ",
          "createdAt": "2019-01-06T23:37:19Z",
          "updatedAt": "2019-01-06T23:37:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjUwMzIw",
          "commit": {
            "abbreviatedOid": "e33e03f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-06T23:36:46Z",
          "updatedAt": "2019-01-06T23:36:46Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "8f7d57c7acfcd577de1b2c7260d5dbc2268c645d",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "restrict-request-method",
      "headRefOid": "e33e03f9d796be39460966ec3548a5d94e30d52e",
      "mergeCommit": {
        "oid": "80005f09c1e52675b9279dc44a87c2887b63cf8d"
      }
    },
    {
      "number": 363,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyNTQ0Njg0",
      "title": "verifier.go: Reject incomplete responses",
      "url": "https://github.com/WICG/webpackage/pull/363",
      "state": "CLOSED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is part of #362.",
      "createdAt": "2019-01-07T03:35:40Z",
      "updatedAt": "2019-01-11T05:56:50Z",
      "closedAt": "2019-01-11T01:40:17Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Response completeness is no longer required. (#368)\r\nClosing.",
          "createdAt": "2019-01-11T01:40:17Z",
          "updatedAt": "2019-01-11T01:40:17Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTg5NjgwMjI0",
          "commit": {
            "abbreviatedOid": "9b4ae79"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-01-07T05:26:13Z",
          "updatedAt": "2019-01-07T05:26:19Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "`http.StatusPartialContent`",
              "createdAt": "2019-01-07T05:26:14Z",
              "updatedAt": "2019-01-07T05:26:19Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "67ecc9351a7911f2944eecf60694c287e728474c",
      "headRepository": null,
      "headRefName": "complete",
      "headRefOid": "9b4ae792a8f9e147be2712023fb853b122c633b2",
      "mergeCommit": null
    },
    {
      "number": 364,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyNTQ0OTAx",
      "title": "[b3] go: Verify if the response is complete",
      "url": "https://github.com/WICG/webpackage/pull/364",
      "state": "CLOSED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@irori We should merge the changes w/ https://github.com/WICG/webpackage/pull/363",
      "createdAt": "2019-01-07T03:37:44Z",
      "updatedAt": "2019-01-09T07:10:52Z",
      "closedAt": "2019-01-09T07:10:52Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Closing because of #368 ",
          "createdAt": "2019-01-09T07:10:47Z",
          "updatedAt": "2019-01-09T07:10:47Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "67ecc9351a7911f2944eecf60694c287e728474c",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "iscomplete",
      "headRefOid": "a18c0563723fb1b5dcd4d6da39fa2776e8c2ad51",
      "mergeCommit": null
    },
    {
      "number": 367,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQyNTgwMjg5",
      "title": "[b3] go: Verify if the response is cacheable by a shared cache",
      "url": "https://github.com/WICG/webpackage/pull/367",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-07T08:01:07Z",
      "updatedAt": "2019-01-10T01:20:38Z",
      "closedAt": "2019-01-10T01:20:32Z",
      "mergedAt": "2019-01-10T01:20:32Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@hajimehoshi PTL, this one is not blocked by spec discussions.",
          "createdAt": "2019-01-09T07:07:01Z",
          "updatedAt": "2019-01-09T07:07:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwMDg0MzIz",
          "commit": {
            "abbreviatedOid": "f62ac8e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-08T03:51:22Z",
          "updatedAt": "2019-01-08T03:51:22Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNjQ4NDIy",
          "commit": {
            "abbreviatedOid": "f62ac8e"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-01-09T09:59:39Z",
          "updatedAt": "2019-01-09T09:59:39Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "67ecc9351a7911f2944eecf60694c287e728474c",
      "headRepository": null,
      "headRefName": "cacheable",
      "headRefOid": "f62ac8e3646058511e792354aa972894d7a37fd0",
      "mergeCommit": {
        "oid": "d78e50cccf3d7345ae45d7f4b74ff1471afd1478"
      }
    },
    {
      "number": 368,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzMTkzMjQz",
      "title": "Don't require the enclosed response to be complete #365",
      "url": "https://github.com/WICG/webpackage/pull/368",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-09T02:28:34Z",
      "updatedAt": "2019-01-10T07:23:19Z",
      "closedAt": "2019-01-10T07:23:19Z",
      "mergedAt": "2019-01-10T07:23:19Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDAwMjIx",
          "commit": {
            "abbreviatedOid": "58bf215"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This seems good, but you'll have to rebase.",
          "createdAt": "2019-01-10T00:02:45Z",
          "updatedAt": "2019-01-10T00:02:45Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d78e50cccf3d7345ae45d7f4b74ff1471afd1478",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "removeiscompl",
      "headRefOid": "cba4fb5a4681dbff48900b666d2c1a5ca8b2d20c",
      "mergeCommit": {
        "oid": "f23a70b66c805159c0f4eb062c311d3a36c115b0"
      }
    },
    {
      "number": 369,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzMjE5MjM3",
      "title": "go: Introduce certurl.NewCertChain",
      "url": "https://github.com/WICG/webpackage/pull/369",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-09T05:51:09Z",
      "updatedAt": "2019-01-09T06:46:42Z",
      "closedAt": "2019-01-09T06:46:34Z",
      "mergedAt": "2019-01-09T06:46:34Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNTg2NDcx",
          "commit": {
            "abbreviatedOid": "dd66cff"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-09T06:26:04Z",
          "updatedAt": "2019-01-09T06:26:04Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "80005f09c1e52675b9279dc44a87c2887b63cf8d",
      "headRepository": null,
      "headRefName": "newcertchain",
      "headRefOid": "dd66cffdf16350ef6b476e237c4cca4cc7c3f2a1",
      "mergeCommit": {
        "oid": "d599eaa9a87f28c843e38663c9fa1378e08f09c8"
      }
    },
    {
      "number": 370,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzMjI5MDYx",
      "title": "gen-signedexchange: Verify generated exchange",
      "url": "https://github.com/WICG/webpackage/pull/370",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "This patch lets gen-signedexchange validate the generated exchange\r\nusing `Verify()`, when `-ignoreErrors` flag is not specified.\r\n\r\nBreaking change: Now `signedexchange.NewExchange` takes request URL as a\r\nstring (not a `*url.URL`), and does not return an error.",
      "createdAt": "2019-01-09T06:53:09Z",
      "updatedAt": "2019-01-11T06:05:48Z",
      "closedAt": "2019-01-11T06:05:31Z",
      "mergedAt": "2019-01-11T06:05:31Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Updated after #371. PTAL",
          "createdAt": "2019-01-10T09:51:29Z",
          "updatedAt": "2019-01-10T09:51:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNTk0MTY2",
          "commit": {
            "abbreviatedOid": "45548c4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-09T07:10:03Z",
          "updatedAt": "2019-01-09T07:10:12Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Would you briefly summarize what the logic here is doing? (or factor out a `func` with a name which indicate what it is doing?",
              "createdAt": "2019-01-09T07:10:03Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNjEyMTQ1",
          "commit": {
            "abbreviatedOid": "bda71fe"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-09T08:24:27Z",
          "updatedAt": "2019-01-09T08:24:27Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Added comments and tweaked block structure a bit.",
              "createdAt": "2019-01-09T08:24:27Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNjEzNDY5",
          "commit": {
            "abbreviatedOid": "bda71fe"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-09T08:28:41Z",
          "updatedAt": "2019-01-09T08:28:42Z",
          "comments": [
            {
              "originalPosition": 58,
              "body": "Noticed that this decodes MI-encoding of e.Payload.  #371 will resolve this.",
              "createdAt": "2019-01-09T08:28:42Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMTI1MTAz",
          "commit": {
            "abbreviatedOid": "99fdcbf"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-10T09:59:48Z",
          "updatedAt": "2019-01-10T09:59:48Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMTI1MDc3",
          "commit": {
            "abbreviatedOid": "99fdcbf"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T09:59:43Z",
          "updatedAt": "2019-01-10T10:00:13Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Do we need this check ?",
              "createdAt": "2019-01-10T09:59:43Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNDkxNTMy",
          "commit": {
            "abbreviatedOid": "c08b3d1"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-11T01:46:45Z",
          "updatedAt": "2019-01-11T01:46:45Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Ah thanks for the catch. Removed.",
              "createdAt": "2019-01-11T01:46:45Z",
              "updatedAt": "2019-01-11T04:58:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNTAxNjY5",
          "commit": {
            "abbreviatedOid": "c08b3d1"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-01-11T02:51:24Z",
          "updatedAt": "2019-01-11T02:51:24Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a70ac8d6426b35ce12ecfe6d3003c68e2bacfc00",
      "headRepository": null,
      "headRefName": "gen-sxg",
      "headRefOid": "99d36c340349515fcb25f89665e416da85b2d0dd",
      "mergeCommit": {
        "oid": "595f72f94b0bbbfa318ad075c83260befd622ede"
      }
    },
    {
      "number": 371,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzMjQ1OTg5",
      "title": "go: Verify() shouldn't replace Payload",
      "url": "https://github.com/WICG/webpackage/pull/371",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "hajimehoshi",
        "nyaxt"
      ],
      "labels": [],
      "body": "Before this patch, `e.Verify()` replaced `e.Payload` with mice-decoded\r\npayload bytes. It's unintuitive that `Verify()` mutates the `Exchange`, so\r\nthis patch lets `Verify()` return the decoded payload in addition to\r\nthe boolean result.",
      "createdAt": "2019-01-09T08:20:16Z",
      "updatedAt": "2019-01-10T09:42:25Z",
      "closedAt": "2019-01-10T09:42:18Z",
      "mergedAt": "2019-01-10T09:42:18Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "This blocks #370.",
          "createdAt": "2019-01-09T08:22:57Z",
          "updatedAt": "2019-01-09T08:22:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkwNjQ4NzU4",
          "commit": {
            "abbreviatedOid": "3de064e"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-09T10:00:30Z",
          "updatedAt": "2019-01-09T10:00:31Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "We'd want comments about the returning values.",
              "createdAt": "2019-01-09T10:00:30Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDM0Nzc4",
          "commit": {
            "abbreviatedOid": "5718783"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T03:05:42Z",
          "updatedAt": "2019-01-10T03:05:42Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Done.",
              "createdAt": "2019-01-10T03:05:42Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDM3NzAy",
          "commit": {
            "abbreviatedOid": "5718783"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T03:25:02Z",
          "updatedAt": "2019-01-10T03:25:02Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I think `Verify` doesn't have to return a boolean value: how about returning the decoded payload bytes on success, or nil otherwise?",
              "createdAt": "2019-01-10T03:25:02Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDUzNjQ2",
          "commit": {
            "abbreviatedOid": "7fb498f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T05:29:06Z",
          "updatedAt": "2019-01-10T05:29:07Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Done.\r\nI was reluctant to do that since the distinction between an empty slice and nil is subtle, but probably it's just okay.",
              "createdAt": "2019-01-10T05:29:06Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDU0OTg0",
          "commit": {
            "abbreviatedOid": "7fb498f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T05:38:48Z",
          "updatedAt": "2019-01-10T05:38:48Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Ah, I'm really sorry but I missed the case when this function succeeds and the result is empty. Then `Verify` should return a boolean value indicating success. (Using a difference between a nil slice and 0-length slice would be confusing)\r\n\r\nThen the signature of this function would be\r\n\r\n```go\r\nfunc (e *Exchange) Verify(verificationTime time.Time, certFetcher CertFetcher, l *log.Logger) ([]byte, bool)\r\n```\r\n",
              "createdAt": "2019-01-10T05:38:48Z",
              "updatedAt": "2019-01-10T05:47:03Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDU2MzUy",
          "commit": {
            "abbreviatedOid": "1030552"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-10T05:47:49Z",
          "updatedAt": "2019-01-10T05:47:49Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "No problem, done :)",
              "createdAt": "2019-01-10T05:47:49Z",
              "updatedAt": "2019-01-10T05:47:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMDYwNzM4",
          "commit": {
            "abbreviatedOid": "1030552"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-01-10T06:15:31Z",
          "updatedAt": "2019-01-10T06:15:31Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d78e50cccf3d7345ae45d7f4b74ff1471afd1478",
      "headRepository": null,
      "headRefName": "payload",
      "headRefOid": "103055267ec7ac5942cfbcb50789b90da825feb0",
      "mergeCommit": {
        "oid": "c92d54404b65c38fba7b6f215ae75eb9b8bd502f"
      }
    },
    {
      "number": 372,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzNzQ3Nzg5",
      "title": "minor: close brackets in reference to RFC",
      "url": "https://github.com/WICG/webpackage/pull/372",
      "state": "MERGED",
      "author": "rz",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-10T16:22:39Z",
      "updatedAt": "2019-01-10T16:27:08Z",
      "closedAt": "2019-01-10T16:27:08Z",
      "mergedAt": "2019-01-10T16:27:07Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxMjkzNzcz",
          "commit": {
            "abbreviatedOid": "888fde4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Whoops, thanks.",
          "createdAt": "2019-01-10T16:25:31Z",
          "updatedAt": "2019-01-10T16:25:31Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c92d54404b65c38fba7b6f215ae75eb9b8bd502f",
      "headRepository": "rz/webpackage",
      "headRefName": "patch-1",
      "headRefOid": "888fde44d75cb6e4847a443694a441e76a21d146",
      "mergeCommit": {
        "oid": "a275d5ba604f7c591cfd33a651d037f701c47669"
      }
    },
    {
      "number": 373,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQzOTA1NjIw",
      "title": " go: Implement uncached-headers check",
      "url": "https://github.com/WICG/webpackage/pull/373",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [
        "go"
      ],
      "body": "",
      "createdAt": "2019-01-11T04:16:14Z",
      "updatedAt": "2019-01-11T04:53:44Z",
      "closedAt": "2019-01-11T04:53:44Z",
      "mergedAt": "2019-01-11T04:53:44Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkxNTE1NDEy",
          "commit": {
            "abbreviatedOid": "8d3a6c7"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-11T04:39:33Z",
          "updatedAt": "2019-01-11T04:39:33Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9f212606eb9ca4b09c5edb2ab8772b4d8e761814",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "go-uncachedhdr",
      "headRefOid": "8d3a6c72c1a20c59cdfac79950426dd075339a4e",
      "mergeCommit": {
        "oid": "a70ac8d6426b35ce12ecfe6d3003c68e2bacfc00"
      }
    },
    {
      "number": 374,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0NjUyNDI2",
      "title": "Introduce signed exchange report for distributors",
      "url": "https://github.com/WICG/webpackage/pull/374",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "This change introduces the signed exchange report for distributors discussed at https://github.com/w3c/network-error-logging/issues/99#issuecomment-453421388.\n\nExemple:\n```\n{\n  \"type\": \"network-error\",\n  \"url\": \"https://publisher.example/article.html\",\n  \"age\": 234,\n  \"user_agent\": \"Mozilla/5.0 (X11; Linux x86_64; rv:60.0) ...\",\n  \"body\": {\n    \"referrer\": \"https://aggregator.example/article.html\",\n    \"sampling_fraction\": 1,\n    \"server_ip\": \"123.122.121.120\",  // The IP address of distributor.example.\n    \"protocol\": \"http/1.1\",\n    \"method\": \"GET\",\n    \"status_code\": 200,\n    \"elapsed_time\": 1234,\n    \"phase\": \"sxg\",\n    \"type\": \"sxg.failed\",\n\n    \"sxg\": {\n      \"outer_url\": \"https://distributor.example/publisher.example/article.html.sxg\",\n      \"inner_url\": \"https://publisher.example/article.html\",\n      \"cert_url\": \"https://distributor.example/publisher.example/cert\"\n    },\n  }\n}\n```\n\nThis spec change requires the new OPTIONAL `additional body` argument of the algorithm of \"Generate a network error report\" of Network Error Logging spec. https://github.com/w3c/network-error-logging/pull/100\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/374.html\" title=\"Last updated on Feb 15, 2019, 2:32 AM UTC (7365813)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/374/aa31685...horo-t:7365813.html\" title=\"Last updated on Feb 15, 2019, 2:32 AM UTC (7365813)\">Diff</a>",
      "createdAt": "2019-01-15T02:06:37Z",
      "updatedAt": "2019-02-28T03:34:50Z",
      "closedAt": "2019-02-27T21:18:20Z",
      "mergedAt": "2019-02-27T21:18:20Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Could you please review again?\r\nI want to start the implementation of this feature in Chromium.",
          "createdAt": "2019-02-07T01:39:58Z",
          "updatedAt": "2019-02-07T01:39:58Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@igrigorik ,  @dcreager  Could you please review this PR?",
          "createdAt": "2019-02-13T00:10:27Z",
          "updatedAt": "2019-02-13T00:10:27Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I closed and reopened this PR to trigger Travis CI which has failed due to xml2rfc bug (https://trac.tools.ietf.org/tools/xml2rfc/trac/ticket/393).",
          "createdAt": "2019-02-15T02:34:41Z",
          "updatedAt": "2019-02-15T02:34:41Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Could you please merge this pull request?\r\n\r\nI have already implemented it in Chromium.\r\nhttps://crrev.com/c/1468855",
          "createdAt": "2019-02-22T02:07:06Z",
          "updatedAt": "2019-02-22T02:07:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTYyMTUw",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T17:27:07Z",
          "updatedAt": "2019-01-28T17:27:08Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "@dcreager In NEL we went with `elapsed-time`? Or is our example outdated in Reporting? \r\n\r\nWe should make sure that keys are consistent. It may make sense to add a non-normative note somewhere in Reporting about conventions we want to enforce?",
              "createdAt": "2019-01-28T17:27:08Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTY1OTIy",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T17:35:14Z",
          "updatedAt": "2019-01-28T17:35:14Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "Outdated example, we went with `elapsed_time`.  TAG recommended `camel_case` for JSON field names.  I like your suggestion of noting the conventions!",
              "createdAt": "2019-01-28T17:35:14Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTcxMTM1",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T17:46:28Z",
          "updatedAt": "2019-01-28T17:46:28Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "@igrigorik do you see `elapsed-time` in the current NEL draft somewhere?  I'm seeing it spelled correctly (`elapsed_time`) everywhere, but want to make sure I didn't miss anything!",
              "createdAt": "2019-01-28T17:46:28Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTgzNzg5",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "igrigorik",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T18:14:37Z",
          "updatedAt": "2019-01-28T18:14:37Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "Ah, I might be looking at the outdated TR: https://www.w3.org/TR/reporting/#sample-reports",
              "createdAt": "2019-01-28T18:14:37Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MTg5MTUw",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T18:26:43Z",
          "updatedAt": "2019-01-28T18:26:44Z",
          "comments": [
            {
              "originalPosition": 328,
              "body": "Oh good catch!  Those are still present in the [latest editor's draft](https://w3c.github.io/reporting/#sample-reports) too.",
              "createdAt": "2019-01-28T18:26:43Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0MzMzMjQ1",
          "commit": {
            "abbreviatedOid": "6e4d8ec"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Here's a round of review, but there's more coming.",
          "createdAt": "2019-01-19T00:55:28Z",
          "updatedAt": "2019-01-28T21:29:43Z",
          "comments": [
            {
              "originalPosition": 300,
              "body": "A request's URL is a URL record, not an ECMAScript object. You'll need to explicitly run the URL serializer to get a string.",
              "createdAt": "2019-01-19T00:55:28Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 296,
              "body": "This is usually phrased more like \r\n\r\n```html\r\nTo <dfn>queue a signed exchange report</dfn> |report|, the UA MUST:\r\n```\r\n\r\nThat ties into Infra requirements like https://infra.spec.whatwg.org/#algorithms.",
              "createdAt": "2019-01-19T00:58:45Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 7,
              "body": "You don't need this now that you've marked the definition with `data-export`.",
              "createdAt": "2019-01-28T19:38:10Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 6,
              "body": "You shouldn't need this anymore, after https://github.com/w3c/network-error-logging/pull/102. Remember to [update your bikeshed data](https://tabatkins.github.io/bikeshed/#updating-bikeshed) to get the new definition.",
              "createdAt": "2019-01-28T19:39:50Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 301,
              "body": "https://w3c.github.io/network-error-logging/#network-requests says \"For user agents that service requests according to the [FETCH] standard, a network request corresponds to one execution of the HTTP-network fetch algorithm.\", while [outer request](https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/374.html#signed-exchange-report-outer-request) is an instance of https://fetch.spec.whatwg.org/#concept-request, which is shared across multiple executions of the HTTP-network fetch algorithm. @dcreager, what are we actually supposed to pass here?",
              "createdAt": "2019-01-28T21:06:11Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n            |actualResponse|, reporting to |report|, in the context of |request|'s\r\n```\r\n\r\nOr put the `, reporting to...` part at the end.",
              "createdAt": "2019-01-28T21:08:36Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 15,
              "body": "Please pull more of this out of the \"monkeypatch\" section into dedicated algorithms.\r\n\r\nHere, I think it makes sense to have a \"new signed exchange report\" algorithm, which takes the inputs you need to initialize the report.",
              "createdAt": "2019-01-28T21:11:39Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 30,
              "body": "Does it work to have `queuing signed exchange report` take both a report and a result, which reduces the length of these substeps by a step?",
              "createdAt": "2019-01-28T21:15:34Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 32,
              "body": "Pull this whole block into an algorithm, so you can write just\r\n\r\n```bikeshed\r\n1. [=In parallel=], [=wait and queue a report for=] |parsedExchange| and |report|.\r\n```",
              "createdAt": "2019-01-28T21:17:39Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n            of the server from which the user agent received the |actualResponse|,\r\n```",
              "createdAt": "2019-01-28T21:18:36Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 18,
              "body": "This needs to be transmitted as a [response](https://fetch.spec.whatwg.org/#concept-response) field in the Fetch spec. Could you [file a Fetch issue](https://github.com/whatwg/fetch/issues/new) about tracking it, and @ annevk and me? It'll probably have something to do with https://fetch.spec.whatwg.org/#concept-connection-obtain, but I want Anne's feedback before picking a particular layering.",
              "createdAt": "2019-01-28T21:28:17Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 55,
              "body": "Is this an arbitrary `[=string=]`, one from an enumerated set of strings, an object of some type, or something else?",
              "createdAt": "2019-01-28T21:29:17Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Mjk1NDY3",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Ok, that's the rest.",
          "createdAt": "2019-01-28T22:36:20Z",
          "updatedAt": "2019-01-28T23:19:19Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n:: The result of loading signed exchange.\r\n```\r\n\r\nAnd similarly s/A/The/ in the below definitions.",
              "createdAt": "2019-01-28T22:36:20Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 64,
              "body": "Please design this to accommodate signed exchanges with multiple signatures, each one of which might have a `cert-url`.",
              "createdAt": "2019-01-28T22:40:30Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 84,
              "body": "```suggestion\r\n|response|, reporting to a [=signed exchange report=] |report|, in the context of an\r\n```",
              "createdAt": "2019-01-28T22:49:57Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nwhich indicates an error, as described by the following steps:\r\n```\r\n\r\nor just\r\n\r\n```suggestion\r\nwhich indicates an error:\r\n```",
              "createdAt": "2019-01-28T22:51:34Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 85,
              "body": "Since you take the report itself, why return the failure reason instead of just setting it into the report's result? (I'm not saying to just set it, rather that you should find a reason to decide one way or the other.)",
              "createdAt": "2019-01-28T22:52:10Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 62,
              "body": "What's the default value, before it gets set? And for \"cert URL\" below.",
              "createdAt": "2019-01-28T22:53:44Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 55,
              "body": "Looks like it's enumerated. Please define all the possible values, either as `<dfn>`s or as a [WebIDL enumeration](https://heycam.github.io/webidl/#idl-enums), and have the uses link to those definitions.\r\n\r\n@dcreager / @igrigorik, I lean toward using a WebIDL enumeration, since that lets us easily group the values and refer to the set when defining operations' return types, but do you have a preference? Should the defined values include the \"sxg.\" that they'll have as the report's [type](https://w3c.github.io/network-error-logging/#predefined-network-error-types)?",
              "createdAt": "2019-01-28T22:55:08Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 154,
              "body": "@dcreager, how do you feel about abbreviating vs spelling out \"certificate\"?",
              "createdAt": "2019-01-28T23:02:28Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 169,
              "body": "I'm a little worried this'll get stale if [read a body](https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/374.html#reading-a-body) ever grows another kind of error return. Maybe move the definition of the error type into that algorithm?",
              "createdAt": "2019-01-28T23:04:36Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 180,
              "body": "```suggestion\r\n<dfn>Parsing the Signature header field</dfn> |signatureString|, reporting to a\r\n```\r\n\r\nand probably put it after |client|.",
              "createdAt": "2019-01-28T23:05:20Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 183,
              "body": "Same change to \"returned by the following steps\" as above.",
              "createdAt": "2019-01-28T23:06:47Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 249,
              "body": "```suggestion\r\n|certSha256|, reporting to a [=signed exchange report=] |report|, in the context of an\r\n```",
              "createdAt": "2019-01-28T23:09:26Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 261,
              "body": "```suggestion\r\n    of the server from which the user agent recieved the |certResponse|, if\r\n```",
              "createdAt": "2019-01-28T23:10:08Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 304,
              "body": "Should we abort these steps or send the report as-is? If aborting is right, please add a `Note:` paragraph saying why.",
              "createdAt": "2019-01-28T23:13:58Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 309,
              "body": "```suggestion\r\n    * `outer_url`: |report|'s [=signed exchange report/outer request=]'s\r\n```\r\n\r\nI think?\r\n\r\nOr\r\n\r\n```suggestion\r\n    : `outer_url`\r\n    :: |report|'s [=signed exchange report/outer request=]'s\r\n```",
              "createdAt": "2019-01-28T23:14:45Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 319,
              "body": "Should it be `\"sxg.ok\"` or just `\"ok\"`?",
              "createdAt": "2019-01-28T23:15:51Z",
              "updatedAt": "2019-02-13T01:30:55Z"
            },
            {
              "originalPosition": 327,
              "body": "Do we need to block all errors when the certificate comes from a different IP than the SXG or just certificate errors? Add a `Note:` paragraph (or a privacy consideration like in https://w3c.github.io/network-error-logging/#privacy-considerations) saying why we block whatever we block.",
              "createdAt": "2019-01-28T23:18:51Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MzYyMzMz",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-29T03:17:10Z",
          "updatedAt": "2019-01-29T03:17:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Humm.. when I removed this line I saw the error even after updating the bikeshed data.\r\n```\r\nLINE ~1059: No 'dfn' refs found for 'generate a network error report'\r\n```",
              "createdAt": "2019-01-29T03:17:11Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Mzc4MTMw",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-29T04:59:31Z",
          "updatedAt": "2019-01-29T04:59:31Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "@tabatkins, did I do something wrong? https://github.com/tabatkins/bikeshed-data/commit/913e4ff6ee06e56f604f53a6906c729576fe0c6c incorporated the network-error-logging data but doesn't include this definition. Do I need `data-export=\"\"` instead of just [`data-export`](https://github.com/w3c/network-error-logging/blob/gh-pages/index.html#L1021)?",
              "createdAt": "2019-01-29T04:59:31Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Mzc4NzY4",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for the review!",
          "createdAt": "2019-01-29T05:03:53Z",
          "updatedAt": "2019-01-29T06:01:44Z",
          "comments": [
            {
              "originalPosition": 319,
              "body": "When |report|'s [=signed exchange report/result=] is `\"ok\"`, |report body|'s `\"type\"` is `\"sxg.ok\"`.",
              "createdAt": "2019-01-29T05:03:53Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 15,
              "body": "done",
              "createdAt": "2019-01-29T05:04:09Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 19,
              "body": "done",
              "createdAt": "2019-01-29T05:04:14Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 25,
              "body": "done",
              "createdAt": "2019-01-29T05:04:17Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 30,
              "body": "done",
              "createdAt": "2019-01-29T05:04:20Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 32,
              "body": "done",
              "createdAt": "2019-01-29T05:04:23Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 55,
              "body": "done",
              "createdAt": "2019-01-29T05:04:31Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 62,
              "body": "done",
              "createdAt": "2019-01-29T05:04:35Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 64,
              "body": "Done. Changed to `<dfn>cert URL list</dfn>`",
              "createdAt": "2019-01-29T05:04:38Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 84,
              "body": "done",
              "createdAt": "2019-01-29T05:04:47Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 85,
              "body": "It is intended to reduces the length of lines. I wanted to avoid writing ``Set |report|'s [=signed exchange report/result=] to `\"parse_error\"\\` and return a failure.`` many places.\r\nDo you think this is better?",
              "createdAt": "2019-01-29T05:05:01Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 86,
              "body": "done",
              "createdAt": "2019-01-29T05:05:06Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 169,
              "body": "done",
              "createdAt": "2019-01-29T05:05:13Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 180,
              "body": "done",
              "createdAt": "2019-01-29T05:05:18Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 183,
              "body": "done",
              "createdAt": "2019-01-29T05:05:21Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 249,
              "body": "done",
              "createdAt": "2019-01-29T05:05:25Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 261,
              "body": "done",
              "createdAt": "2019-01-29T05:05:29Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 296,
              "body": "done",
              "createdAt": "2019-01-29T05:05:34Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 304,
              "body": "Added `Note:` paragraph.",
              "createdAt": "2019-01-29T05:05:42Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 300,
              "body": "done",
              "createdAt": "2019-01-29T05:05:47Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 309,
              "body": "done",
              "createdAt": "2019-01-29T05:05:49Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 18,
              "body": "Filed https://github.com/whatwg/fetch/issues/863",
              "createdAt": "2019-01-29T05:16:35Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 55,
              "body": "Changed to use `<dfn>`. How about this?",
              "createdAt": "2019-01-29T05:36:03Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 327,
              "body": "Changed to check if the result is \"signature_verification_error\" or \"cert_verification_error\" or \"cert_fetch_error\" or \"cert_parse_error\". And added note.",
              "createdAt": "2019-01-29T05:56:01Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Nzk2MDM5",
          "commit": {
            "abbreviatedOid": "e1b6af5"
          },
          "author": "tabatkins",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-29T21:35:10Z",
          "updatedAt": "2019-01-29T21:35:10Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Checking with @plinss about this; the only difference from how Bikeshed normally outputs heading-dfns is that Bikeshed includes a `data-lt`, and it might be that Shepherd (@plinss' tool that parses the specs) relies on the presence of that attribute.\r\n\r\n(Boolean vs empty value on `data-export` doesn't matter.)",
              "createdAt": "2019-01-29T21:35:10Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3ODQ4NDA3",
          "commit": {
            "abbreviatedOid": "e1b6af5"
          },
          "author": "tabatkins",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-30T00:05:15Z",
          "updatedAt": "2019-01-30T00:05:15Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "And fixed, it was a minor bug in Shepherd's scraping logic for ReSpec documents; it was looking for the definition attributes on the *section* rather than the heading (since respec is section-centric). Fixed now, and the definition shows up as of <https://github.com/tabatkins/bikeshed-data/commit/e62a91cf098bc6f293a711660205d5d05cf2e781>",
              "createdAt": "2019-01-30T00:05:15Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3ODc5ODk3",
          "commit": {
            "abbreviatedOid": "a626e6e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-30T02:27:17Z",
          "updatedAt": "2019-01-30T02:27:30Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Thank you @tabatkins.\r\nI removed this line.\r\nhttps://github.com/WICG/webpackage/pull/374/commits/5ef3228375e6e8f17349aae9c731a7f777dd4e1f",
              "createdAt": "2019-01-30T02:27:17Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3ODgwMTkw",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-30T02:28:50Z",
          "updatedAt": "2019-01-30T02:28:50Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "I will remove this after https://github.com/w3c/network-error-logging/pull/100 will be merged.",
              "createdAt": "2019-01-30T02:28:50Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5MDY5OTM5",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-01T13:22:50Z",
          "updatedAt": "2019-02-01T13:22:50Z",
          "comments": [
            {
              "originalPosition": 301,
              "body": "Ping? @dcreager ",
              "createdAt": "2019-02-01T13:22:50Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5NjI2MDMx",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-04T14:56:11Z",
          "updatedAt": "2019-02-04T14:56:12Z",
          "comments": [
            {
              "originalPosition": 301,
              "body": "I think that it should be that [fetch request](https://fetch.spec.whatwg.org/#concept-request) instance that is passed in.  We probably need to update NEL to just be defined in terms of fetch, instead of keeping the currently muddy language that tries to allow NEL to work with non-browser non-fetch HTTP clients.  (So for instance, to update NEL to have it pull out [current URL](https://fetch.spec.whatwg.org/#concept-request-current-url) to fill in the body of the report in a less hand-wavy way.)",
              "createdAt": "2019-02-04T14:56:11Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzQ4NDE5",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T22:08:33Z",
          "updatedAt": "2019-02-07T23:32:57Z",
          "comments": [
            {
              "originalPosition": 388,
              "body": "The inner URL is also a URL record, and needs to be serialized in order to be an ECMAScript String.",
              "createdAt": "2019-02-07T22:08:34Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 385,
              "body": "The [ASCII encoding](https://infra.spec.whatwg.org/#ascii-encode) yields an Infra byte sequence, not an ECMAScript object. It looks like you can just use `The [=URL serializer|serialization=] of ...` directly.",
              "createdAt": "2019-02-07T22:27:17Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 389,
              "body": "This needs to serialize all the URLs and then create an array, perhaps via https://heycam.github.io/webidl/#es-sequence.\r\n\r\nThe whole thing might be simpler if you write a WebIDL dictionary type for this, and then convert it to an ES object all at once.",
              "createdAt": "2019-02-07T22:31:33Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\n            [=queue a signed exchange report=] |report| with\r\n```\r\n\r\nI think.",
              "createdAt": "2019-02-07T22:33:05Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 365,
              "body": "Most of the calls look like `queue a signed exchange report |report| with \"...\" as the result`, so let's make the definition look like that too:\r\n\r\n```suggestion\r\nTo <dfn>queue a signed exchange report</dfn> |report| with |result| as the result, the UA MUST:\r\n```",
              "createdAt": "2019-02-07T23:02:26Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 378,
              "body": "Don't use normative language like \"MUST\" in a Note, and try to avoid passive voice (\"be called\") in general. Instead, describe what happens, and ideally link to where it happens. So, what algorithm winds up calling [deliver a network report](https://github.com/w3c/network-error-logging/pull/100) in this case?",
              "createdAt": "2019-02-07T23:06:06Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 40,
              "body": "I'm uncomfortable that it's allowed to be an empty string. https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/374.html#ref-for-signed-exchange-report-result%E2%91%A0, especially, results in a type of just \"sxg.\" in that case. I think you're just using that as a default, so maybe:\r\n\r\n```suggestion\r\n:: The result string of loading signed exchange. This must be unset or one of \"<dfn>`ok`</dfn>\", ...\r\n```",
              "createdAt": "2019-02-07T23:21:01Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 55,
              "body": "Looks fine to me. I'd still like feedback from @dcreager or @igrigorik about whether we ought to include the \"sxg.\" in most of the values, and especially whether we should omit the \"sxg.\" for \"ok\".",
              "createdAt": "2019-02-07T23:32:56Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzc1ODEy",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-07T23:34:36Z",
          "updatedAt": "2019-02-07T23:36:57Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "That's not quite right: the first \"cert-url\" parameter only has 1 URL, but there may be multiple signature headers, each with its own \"cert-url\".\r\n\r\nDo we need to associate each certificate with its server IP, or is just having an unmatched bag ok?",
              "createdAt": "2019-02-07T23:34:36Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\nstring which indicates an error, as described by the following steps:\r\n```",
              "createdAt": "2019-02-07T23:36:02Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 85,
              "body": "What you have is probably clearer that the result is always set.",
              "createdAt": "2019-02-07T23:36:57Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzc2NTg1",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-02-07T23:37:34Z",
          "updatedAt": "2019-02-07T23:38:03Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "@dcreager, how do you feel about abbreviating vs spelling out \"certificate\"?",
              "createdAt": "2019-02-07T23:37:34Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNDcwODkz",
          "commit": {
            "abbreviatedOid": "5ef3228"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "@jyasskin Thank you for the review. How about this change?",
          "createdAt": "2019-02-08T08:32:20Z",
          "updatedAt": "2019-02-08T09:06:59Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "done",
              "createdAt": "2019-02-08T08:32:20Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 40,
              "body": "done",
              "createdAt": "2019-02-08T08:32:26Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 388,
              "body": "done",
              "createdAt": "2019-02-08T08:33:12Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 385,
              "body": "done",
              "createdAt": "2019-02-08T08:33:15Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 378,
              "body": "Changed to `UA have called [=deliver a network report=] algorithm with the error report`.\r\n\r\nAs @dcreager [says](https://github.com/w3c/network-error-logging/pull/100#discussion_r251683522), unfortunately there is no caller of [deliver a network report](https://github.com/w3c/network-error-logging/pull/100) yet. But I think fetch spec will call it.",
              "createdAt": "2019-02-08T08:35:27Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 389,
              "body": "Changed to ``The [=sequence type=] of the result of [=URL serializer|serialization=] of each element of |report|'s [=signed exchange report/cert URL list=].``\r\nIs this OK?",
              "createdAt": "2019-02-08T08:36:34Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 365,
              "body": "done",
              "createdAt": "2019-02-08T08:49:01Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 55,
              "body": "Changed to ``The list of [=URL=] which first element is the first \"`cert-url`\" parameter of signed exchange, if available. Otherwise, an empty list.``\r\n\r\nI think it is OK, because currently this spec only supports the first cert-url.\r\n\r\nWhen we will support multiple certificates, we must check the all IP address of cert URLs before sending certificate related errors (signature_verification_error, cert_verification_error, cert_fetch_error, cert_parse_error) to avoid cross site information leak. ",
              "createdAt": "2019-02-08T08:50:51Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 77,
              "body": "Done",
              "createdAt": "2019-02-08T08:56:41Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxODM5MDYx",
          "commit": {
            "abbreviatedOid": "fc5e25e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Please wait for @igrigorik and/or @dcreager to weigh in on this, but aside from lots of nits, it looks good to me. (And I won't be around to re-review next week.)",
          "createdAt": "2019-02-09T00:50:57Z",
          "updatedAt": "2019-02-09T01:05:25Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\n:: The list of [=URLs=] in \"`cert-url`\" parameters for the signed exchange's signatures, if available.\r\n```\r\n\r\nThis definition doesn't have to say that we currently only support one signature.",
              "createdAt": "2019-02-09T00:50:57Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\n:: The list of IP addresses of the servers from which the user agent received the certificates listed in [=signed exchange report/cert URL list=].\r\n```",
              "createdAt": "2019-02-09T00:51:54Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 76,
              "body": "```suggestion\r\nreporting to a [=signed exchange report=] |report|, returns an [=exchange=] or a\r\n```",
              "createdAt": "2019-02-09T00:52:25Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\nstring which indicates a [=signed exchange report/result=] as described by the following steps:\r\n```\r\n\r\n?",
              "createdAt": "2019-02-09T00:52:33Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 86,
              "body": "Does the following make reports more clear? Otherwise, I worry people won't know which origin we're talking about.\r\n\r\n```suggestion\r\n    trustworthy origin=], return \"[=signed exchange report/non_secure_distributor=]\".\r\n```",
              "createdAt": "2019-02-09T00:54:06Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 164,
              "body": "```suggestion\r\n1. [=Read a body=] from |stream| into |parsedExchange|'s\r\n```",
              "createdAt": "2019-02-09T00:57:06Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 166,
              "body": "```suggestion\r\n    this returns an error string, return it.\r\n```\r\n\r\nSince I don't think we identify these strings as errors otherwise.",
              "createdAt": "2019-02-09T00:57:45Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 187,
              "body": "```suggestion\r\n[=signed exchange report=] |report|, returns an [=exchange signature=] or\r\n```",
              "createdAt": "2019-02-09T00:58:23Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 188,
              "body": "Similarly, maybe link to the report result, which lists the possible strings.",
              "createdAt": "2019-02-09T00:58:43Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 255,
              "body": "```suggestion\r\n|certSha256| in the context of an [=environment settings object=] |client|,\r\n```",
              "createdAt": "2019-02-09T00:59:09Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 257,
              "body": "As above to describe the possible errors.",
              "createdAt": "2019-02-09T00:59:46Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 305,
              "body": "This needs rebasing (which will remove the line).",
              "createdAt": "2019-02-09T01:01:42Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 378,
              "body": "```suggestion\r\n    of the server and the |policy| don't match. In this case, the UA has called\r\n```",
              "createdAt": "2019-02-09T01:03:05Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 396,
              "body": "My instinct is that the `type` should just be `\"ok\"` in the success case, and not `\"sxg.ok\"`, to match other successful loads, but I defer to @igrigorik or @dcreager.",
              "createdAt": "2019-02-09T01:04:30Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyNDQ5MzM1",
          "commit": {
            "abbreviatedOid": "fc5e25e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you",
          "createdAt": "2019-02-12T02:10:07Z",
          "updatedAt": "2019-02-12T02:27:38Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Done",
              "createdAt": "2019-02-12T02:10:07Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 61,
              "body": "Done",
              "createdAt": "2019-02-12T02:10:40Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 76,
              "body": "Done",
              "createdAt": "2019-02-12T02:11:00Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 77,
              "body": "Done",
              "createdAt": "2019-02-12T02:11:25Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 86,
              "body": "Sounds good.\r\nDone.",
              "createdAt": "2019-02-12T02:12:32Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 164,
              "body": "Done",
              "createdAt": "2019-02-12T02:12:54Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 166,
              "body": "Done.",
              "createdAt": "2019-02-12T02:13:05Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 187,
              "body": "Done",
              "createdAt": "2019-02-12T02:13:20Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 188,
              "body": "Done",
              "createdAt": "2019-02-12T02:14:57Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 257,
              "body": "Done",
              "createdAt": "2019-02-12T02:16:33Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 255,
              "body": "Done",
              "createdAt": "2019-02-12T02:18:27Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 378,
              "body": "Done",
              "createdAt": "2019-02-12T02:18:45Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 305,
              "body": "Done",
              "createdAt": "2019-02-12T02:24:56Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyOTc5MzU5",
          "commit": {
            "abbreviatedOid": "ff79193"
          },
          "author": "dcreager",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Looks good, @horo-t, pending a couple of small nits!  Sorry for the delay in reviewing.",
          "createdAt": "2019-02-13T00:31:54Z",
          "updatedAt": "2019-02-13T00:36:34Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Just merged the NEL issue.",
              "createdAt": "2019-02-13T00:31:54Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 45,
              "body": "I'm okay with that, it actually matches the spelling of the [predefined TLS errors](https://w3c.github.io/network-error-logging/#secure-connection-establishment-errors) in the NEL spec.",
              "createdAt": "2019-02-13T00:33:10Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            },
            {
              "originalPosition": 396,
              "body": "Agreed.  `ok` should be the standard value for \"everything worked as expected\".  I like the `sxg.` prefix for any non-success results.",
              "createdAt": "2019-02-13T00:35:25Z",
              "updatedAt": "2019-02-13T01:30:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyOTkxMzg0",
          "commit": {
            "abbreviatedOid": "ff79193"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you.",
          "createdAt": "2019-02-13T01:22:55Z",
          "updatedAt": "2019-02-13T01:31:25Z",
          "comments": [
            {
              "originalPosition": 7,
              "body": "Deleted.\r\nBut we need to wait [bikeshed-data](https://github.com/tabatkins/bikeshed-data/) to be updated.",
              "createdAt": "2019-02-13T01:22:55Z",
              "updatedAt": "2019-02-13T01:31:25Z"
            },
            {
              "originalPosition": 396,
              "body": "Done.",
              "createdAt": "2019-02-13T01:27:26Z",
              "updatedAt": "2019-02-13T01:31:25Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "aa316858417a452bcbce91d931f37c308edb1945",
      "headRepository": "horo-t/webpackage",
      "headRefName": "errorreport",
      "headRefOid": "7365813db8112555dc374df67f9a90f1cea24587",
      "mergeCommit": {
        "oid": "af4352751ccdf7df0c98e9454f59bb99743925d7"
      }
    },
    {
      "number": 375,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ0Njg3NTUw",
      "title": "Remove go/webpack",
      "url": "https://github.com/WICG/webpackage/pull/375",
      "state": "MERGED",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "PTAL",
      "createdAt": "2019-01-15T06:30:55Z",
      "updatedAt": "2019-01-16T05:41:28Z",
      "closedAt": "2019-01-16T05:41:25Z",
      "mergedAt": "2019-01-16T05:41:25Z",
      "mergedBy": "hajimehoshi",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkyOTY5NzI4",
          "commit": {
            "abbreviatedOid": "41a40ea"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-16T04:28:15Z",
          "updatedAt": "2019-01-16T04:28:15Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "595f72f94b0bbbfa318ad075c83260befd622ede",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "remove-webpack",
      "headRefOid": "41a40eac714bafac7f0c821292b4396ced60dc43",
      "mergeCommit": {
        "oid": "a253005203876c2b3cf59b3464c8728692a20ed2"
      }
    },
    {
      "number": 377,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ1Njk0MDE5",
      "title": "Define a CAA parameter governing CanSignHttpExchanges cert issuance.",
      "url": "https://github.com/WICG/webpackage/pull/377",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This gives a stronger indication that the domain owner has opted into the new\r\nsecurity risks than just that a CA issued a certificate with the extension.\r\n\r\n@AGWA, how's this look? https://tools.ietf.org/html/draft-ietf-acme-caa-06#section-3 has a MUST, which I've downgraded to a SHOULD here after reading draft-ietf-acme-caa's IANA considerations.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/define-caa/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req); [Diff](https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/define-caa/draft-yasskin-http-origin-signed-responses.txt)",
      "createdAt": "2019-01-18T00:45:27Z",
      "updatedAt": "2019-02-06T19:35:52Z",
      "closedAt": "2019-02-06T19:35:49Z",
      "mergedAt": "2019-02-06T19:35:48Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "still lgtm",
          "createdAt": "2019-01-21T05:56:25Z",
          "updatedAt": "2019-01-21T05:56:25Z"
        },
        {
          "author": "AGWA",
          "authorAssociation": "NONE",
          "body": "As current worded, it's OK for a CA which isn't listed in any issue/issuwild property to issue certificates with the CanSignHttpExchanges extension.  Instead, I'd suggest:\r\n\r\n> CA SHOULD NOT issue certificates with the CanSignHttpExchanges extension defined in {{cross-origin-cert-req}} unless an applicable issue or issuewild property exists for the CA, and the \"cansignhttpexchanges\" parameter is present on the property and is equal to \"yes\"",
          "createdAt": "2019-01-22T19:56:04Z",
          "updatedAt": "2019-01-22T19:56:04Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@AGWA Thanks! Done.",
          "createdAt": "2019-01-22T20:20:32Z",
          "updatedAt": "2019-01-22T20:20:32Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm hoping one of the certificate experts (@AGWA, @sleevi, @clintwilson) will approve this before I merge it.",
          "createdAt": "2019-01-28T22:13:39Z",
          "updatedAt": "2019-01-28T22:13:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkzOTY3OTUx",
          "commit": {
            "abbreviatedOid": "7a69583"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-18T06:57:58Z",
          "updatedAt": "2019-01-18T06:57:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTkzOTY4ODUz",
          "commit": {
            "abbreviatedOid": "7a69583"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-18T07:02:35Z",
          "updatedAt": "2019-01-18T07:02:35Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Am I correct that this only applies to CA who issue certificates via ACME protocol?\r\n\r\n",
              "createdAt": "2019-01-18T07:02:35Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0MTc5NTI4",
          "commit": {
            "abbreviatedOid": "7a69583"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-18T16:32:22Z",
          "updatedAt": "2019-01-18T16:32:23Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "No. All CAs are required to check for and respect CAA (if present) by the Baseline Requirements.\r\n\r\nThis change would require that site operators wishing to obtain a CanSignHttpExchanges certificate take affirmative steps to modify their DNS to indicate consent. Combined with the above requirement, this spec change has the effect of declaring how all CAs must obtain consent to issue these certificates, and declaring the means by which site operators can deny consent. It favors 'defenders' (site operators at risk from a CA using a less-than-ideal validation method or being tricked temporarily) by requiring consent by opt-in, rather than opt-out.",
              "createdAt": "2019-01-18T16:32:23Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk0NDUxNjEw",
          "commit": {
            "abbreviatedOid": "d4ba0cc"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-21T05:47:56Z",
          "updatedAt": "2019-01-21T05:47:56Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Thanks for the explanation.",
              "createdAt": "2019-01-21T05:47:56Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1MjE2NDQ5",
          "commit": {
            "abbreviatedOid": "3bb506a"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-22T20:30:43Z",
          "updatedAt": "2019-01-22T20:30:44Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "1) In general, we should avoid SHOULD/SHOULD NOT requirements unless we provide guidance on when there are applicable exceptions. Alternatively, MUST/MUST NOT provides a clearer, unambiguous processing model, modulo what error handling should be (which presumably is MUST NOT issue)\r\n\r\n2) The reference to the BRs may end up being circular. The BRs state the rules for which a CA can include arbitrary extensions (7.1.2.4.), so if there are requirements expressed here, they should trigger the rules of 7.1.2.4 (a) (ii) and 7.1.2.4 (b), and thus require following this spec and whatever it describes.",
              "createdAt": "2019-01-22T20:30:44Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1MjU5MDA0",
          "commit": {
            "abbreviatedOid": "60d4800"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-22T22:16:29Z",
          "updatedAt": "2019-01-22T22:16:29Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "I've moved this to the definition of the CanSignHttpExchanges *extension*, where there's no question that we can MUST CAs. Now I don't need to point at the BRs.",
              "createdAt": "2019-01-22T22:16:29Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3Mjk5MjIw",
          "commit": {
            "abbreviatedOid": "4a4517a"
          },
          "author": "AGWA",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T22:46:55Z",
          "updatedAt": "2019-01-28T22:46:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I just realized that this wording could be interpreted as allowing a CA to include the extension if just one of the dNSNames in the certificate has `cansignhttpexchanges=yes`. :grimacing: Obviously, the intent is that this parameter must be present for every dNSName.  I'll propose some better wording in a little bit unless someone else beats me to it.",
              "createdAt": "2019-01-28T22:46:55Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3MzEwMzIz",
          "commit": {
            "abbreviatedOid": "4a4517a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-28T23:21:37Z",
          "updatedAt": "2019-01-28T23:21:38Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "See, this is why I wait. :)",
              "createdAt": "2019-01-28T23:21:38Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3NzA0NjE1",
          "commit": {
            "abbreviatedOid": "4a4517a"
          },
          "author": "AGWA",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-29T18:11:31Z",
          "updatedAt": "2019-01-29T18:11:32Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "How about:\r\n\r\n> A conforming CA MUST NOT issue certificates with this extension unless, for each dNSName in the subjectAltName extension of the certificate to be issued:\r\n> 1. An \"issue\" or \"issuewild\" CAA property ({{!RFC6844}}) exists that authorizes the CA to issue the certificate; and\r\n> 2. The \"cansignhttpexchanges\" parameter ({{caa-cansignhttpexchanges}}) is present on the property and is equal to \"yes\"",
              "createdAt": "2019-01-29T18:11:32Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk3ODU3NDg4",
          "commit": {
            "abbreviatedOid": "badcb29"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-30T00:43:10Z",
          "updatedAt": "2019-01-30T00:43:10Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Done. RFC6844 manages to avoid saying that a certificate's domains are listed in the dNSName, but if saying it here is a problem, we have plenty of time to revise the wording.",
              "createdAt": "2019-01-30T00:43:10Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk4Mzk0NTE2",
          "commit": {
            "abbreviatedOid": "badcb29"
          },
          "author": "AGWA",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-31T01:53:38Z",
          "updatedAt": "2019-01-31T01:53:39Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "I cribbed the \"each dNSName in the subjectAltName extension\" wording from the BR's section on CAA so it should be solid.",
              "createdAt": "2019-01-31T01:53:38Z",
              "updatedAt": "2019-02-06T19:26:53Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "290c673285ce29d8476b8ae6dad83f37bbd67fce",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "define-caa",
      "headRefOid": "63d38dfa6af5982046c0ffdfb2cc7aab91de95e2",
      "mergeCommit": {
        "oid": "3997c751c327b0be6a7130fb9557283c9d64b297"
      }
    },
    {
      "number": 379,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ2OTU4MDgw",
      "title": "[WIP] Variants",
      "url": "https://github.com/WICG/webpackage/pull/379",
      "state": "OPEN",
      "author": "hajimehoshi",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The implementation is not finished yet. Not all tests pass.\r\n\r\nI used `header.ParseValueAndParams` as the counterpart of `ParseParameterisedList`, but I feel like I'd need to implement the counterpart myself.",
      "createdAt": "2019-01-23T12:56:24Z",
      "updatedAt": "2021-02-17T00:19:08Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "hajimehoshi/webpackage",
      "headRefName": "variants",
      "headRefOid": "5023f85a651b544a24988b0b53b078c75af7b5c5",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "This PR just implements `variants.MatchRequest`. Let's discuss how to implement actual usages later.\r\n\r\nPTAL",
          "createdAt": "2019-01-25T08:04:51Z",
          "updatedAt": "2019-01-25T08:04:51Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "I've updated my Chromium-side patch (https://crrev.com/c/1426205) fixing some TODOs and adding more tests. Would you reflect the diff into this PR? Thanks!",
          "createdAt": "2019-01-29T04:16:06Z",
          "updatedAt": "2019-01-29T04:16:06Z"
        },
        {
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. It looks like I'd need to implement `MatchesMimeType` in Go. I couldn't find a third-party library that does the same thing.",
          "createdAt": "2019-02-14T10:41:45Z",
          "updatedAt": "2019-02-14T10:41:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDU1MzQw",
          "commit": {
            "abbreviatedOid": "5023f85"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-15T02:01:40Z",
          "updatedAt": "2019-02-15T02:01:40Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Please use `structuredheader.ParseListOfLists` (added at #395)",
              "createdAt": "2019-02-15T02:01:40Z",
              "updatedAt": "2019-02-15T02:01:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 380,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MDUzNjU0",
      "title": "Update the references to header-structure to -09.",
      "url": "https://github.com/WICG/webpackage/pull/380",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/update-structured-headers/draft-yasskin-http-origin-signed-responses.html.",
      "createdAt": "2019-01-23T17:27:54Z",
      "updatedAt": "2019-01-23T18:49:41Z",
      "closedAt": "2019-01-23T18:49:36Z",
      "mergedAt": "2019-01-23T18:49:36Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1Njc4MDA4",
          "commit": {
            "abbreviatedOid": "bc21bcb"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-23T18:35:15Z",
          "updatedAt": "2019-01-23T18:40:15Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "In the non-diff above: \"This specification gives no meaning to the identifier itself\". Per httpwg/http-extensions#720, you may want to update this to \"the primary identifier itself\".",
              "createdAt": "2019-01-23T18:35:15Z",
              "updatedAt": "2019-01-23T18:40:15Z"
            },
            {
              "originalPosition": 105,
              "body": "Ditto the next two paragraphs. Not sure if you want to stick \"primary\" in front of all of them, because too verbose. Maybe the first instance per para.",
              "createdAt": "2019-01-23T18:38:30Z",
              "updatedAt": "2019-01-23T18:40:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1NjgzNjcx",
          "commit": {
            "abbreviatedOid": "bc21bcb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-23T18:47:34Z",
          "updatedAt": "2019-01-23T18:47:34Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Hm, https://github.com/httpwg/http-extensions/commit/3c96a9b14e82f0356f09ac680a2943bdca9830fc then removes that term in favor of \"token\". I think I'm going to keep just \"identifier\" here, since I think it's clear enough that it refers to the parameterised thing, and not any of the parameters, but @mnot FYI in case you want dependent specs to do something else.\r\n\r\nThanks for pointing out the question though!",
              "createdAt": "2019-01-23T18:47:34Z",
              "updatedAt": "2019-01-23T18:47:48Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "aa5229e178a936d8686c942f34fac22384be49bc",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-structured-headers",
      "headRefOid": "bc21bcb3f23c1907884be78aa1033c9cebc23cec",
      "mergeCommit": {
        "oid": "f7a7aaccb3122378b772dd372dd7d8f6c65a98c8"
      }
    },
    {
      "number": 381,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MDY3NzU2",
      "title": "Add a privacy consideration about watermarking.",
      "url": "https://github.com/WICG/webpackage/pull/381",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks to @youennf for describing this risk.\r\n\r\nPreview at https://jyasskin.github.io/webpackage/watermarking/draft-yasskin-http-origin-signed-responses.html#priv-watermarking.",
      "createdAt": "2019-01-23T18:16:05Z",
      "updatedAt": "2021-02-17T00:19:09Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "watermarking",
      "headRefOid": "d2ae8d53ada75666f8d8ea6bbecdd812d228162a",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk4NDIyNTky",
          "commit": {
            "abbreviatedOid": "a9e3375"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-31T04:43:54Z",
          "updatedAt": "2019-01-31T04:43:54Z",
          "comments": []
        }
      ]
    },
    {
      "number": 382,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MDg3MjA3",
      "title": "Update the TLS reference to the final RFC.",
      "url": "https://github.com/WICG/webpackage/pull/382",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "idnits caught that I'd forgotten to do this when TLS was published.",
      "createdAt": "2019-01-23T19:24:02Z",
      "updatedAt": "2019-01-23T19:54:19Z",
      "closedAt": "2019-01-23T19:54:16Z",
      "mergedAt": "2019-01-23T19:54:16Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f7a7aaccb3122378b772dd372dd7d8f6c65a98c8",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-tls-ref",
      "headRefOid": "0ea3745ccfbfc5947c5226ea4994cb7bd2c71398",
      "mergeCommit": {
        "oid": "fd45f0333f5ae6e0b429a7d3f5ec347a0aad9564"
      }
    },
    {
      "number": 383,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MTM5Mjk1",
      "title": "Bound validity periods to 90 days.",
      "url": "https://github.com/WICG/webpackage/pull/383",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is not necessarily the limit we'll want in the long run, but it\r\nhelps ensure that any future changes can go into effect reasonably\r\nquickly.\r\n\r\nI won't submit this until I have some indication that the folks who have already started experimenting with signed exchanges can handle 90-day certificates.\r\n\r\n@clintwilson, I want to make sure this doesn't cause any problems for you, since I believe Digicert has been issuing certificates with validity periods longer than 90 days. I don't intend to declare that any of your existing certificates are out of bounds.\r\n\r\n@AGWA, this isn't intended to stop discussion on #378, just to put _some_ limit in place while we figure out what the right limit is.\r\n\r\nPreview: https://jyasskin.github.io/webpackage/90-day-lifetime/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req\r\nDiff: https://tools.ietf.org/rfcdiff?url1=https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.txt&url2=https://jyasskin.github.io/webpackage/90-day-lifetime/draft-yasskin-http-origin-signed-responses.txt",
      "createdAt": "2019-01-23T22:32:15Z",
      "updatedAt": "2019-02-08T19:41:46Z",
      "closedAt": "2019-02-08T19:41:43Z",
      "mergedAt": "2019-02-08T19:41:43Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "clintwilson",
          "authorAssociation": "NONE",
          "body": "We don't, today, enforce a maximum validity outside of the 825 days for all public TLS certs. It'll require a relatively small change to add a lower max validity, but it's not a major issue. My only concern would be a nearish-term change to that max validity again. Meaning that I'd like to see some very rough consensus on max validity before we start working in that update. \r\nIn the meantime, any validity can be issued today between 1-825 days, so we can support testing efforts with shorter lived certificates immediately.\r\nDoes that seem like a fair approach, or would it be better to have that 90 day enforcement in place first?",
          "createdAt": "2019-01-24T04:28:55Z",
          "updatedAt": "2019-01-24T04:28:55Z"
        },
        {
          "author": "shigeki",
          "authorAssociation": "NONE",
          "body": "We are now ordering a SXG certificate to Digicert. Shortening its lifetime affects our budget and operation plan for our SXG trial. Please also consider the issuing process with CA because ACME is not used for it.",
          "createdAt": "2019-01-25T01:24:10Z",
          "updatedAt": "2019-01-25T01:24:10Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "> I won't submit this until I have some indication that the folks who have already started experimenting with signed exchanges can handle 90-day certificates.\r\n\r\nIt'd be probably helpful to clarify what should / would happen to the sites that are already experimenting (or ordering) when this change takes effect, and on any other nearish-term changes.",
          "createdAt": "2019-01-25T09:39:07Z",
          "updatedAt": "2019-01-25T09:39:07Z"
        },
        {
          "author": "clintwilson",
          "authorAssociation": "NONE",
          "body": "@shigeki Just a note that ordering for shorter validity will also automatically prorate/decrease the price of the certificate relative to the validity selected. If you need any help with your account or testing, please don't hesitate to reach out.\r\nI think we could also get ACME to work for provisioning if that's beneficial. We'll have to map the inclusion of the extension out of band, so I'd need to come up with a solution there, but otherwise it should be feasible.",
          "createdAt": "2019-01-25T14:15:57Z",
          "updatedAt": "2019-01-25T14:15:57Z"
        },
        {
          "author": "shigeki",
          "authorAssociation": "NONE",
          "body": "@clintwilson Thank for offering your help. We can purchase only one or two years SXG certs via Cyberturst in Japan. \r\n\r\nACME needs challenge and response so that we can do it to fallbackURL if it is online. Currently fallbackURL is implemented as reqeustURL. That has a risk to renew the existing cert in online .\r\n\r\nI think it is too early to limit the lifetime of SXG cert in 90 days for we do not know if it can really operative. \r\n\r\n6.2. Off-path attackers in Security considerations only describes about an attacker who already possesses a valid certificate. We should add the consideration of how much we need to care about misissuance  of CA before discussing SXG cert lifetime. Do we really need to care about a serious CA incident such as DigiNotar in 2011?",
          "createdAt": "2019-01-28T01:09:07Z",
          "updatedAt": "2019-01-28T01:09:07Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@shigeki Thanks for the feedback and for continuing the conversation via @sisidovski. It looks like you've found a way to get a [<1-year certificate](https://crt.sh/?id=1177695640) that matches the timeline I added here since your comment.\r\n\r\nI wrote up some considerations at https://github.com/WICG/webpackage/issues/378#issuecomment-459831551 that I think mean we should go for a 90-day max-lifetime for this year, and the other 2 people who voted, agreed. Given that, I'm going to merge this change.",
          "createdAt": "2019-02-08T19:37:51Z",
          "updatedAt": "2019-02-08T19:37:51Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3997c751c327b0be6a7130fb9557283c9d64b297",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "90-day-lifetime",
      "headRefOid": "c146253ac23ede473c390d867a9df0782636fba2",
      "mergeCommit": {
        "oid": "aa316858417a452bcbce91d931f37c308edb1945"
      }
    },
    {
      "number": 384,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MjMzMzgw",
      "title": "go: Update verifier to b3 spec",
      "url": "https://github.com/WICG/webpackage/pull/384",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Update spec comments\r\n- Headers must contain `Content-Type` (#354)\r\n- Check request method only for b1 and b2",
      "createdAt": "2019-01-24T07:59:06Z",
      "updatedAt": "2019-01-25T01:40:12Z",
      "closedAt": "2019-01-25T01:39:39Z",
      "mergedAt": "2019-01-25T01:39:39Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTAwODUw",
          "commit": {
            "abbreviatedOid": "1ba3eb4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-24T08:26:00Z",
          "updatedAt": "2019-01-24T08:26:06Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I was wondering why the loggers are different.",
              "createdAt": "2019-01-24T08:26:00Z",
              "updatedAt": "2019-01-24T08:26:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTI1MjAx",
          "commit": {
            "abbreviatedOid": "1ba3eb4"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-24T09:29:05Z",
          "updatedAt": "2019-01-24T09:29:05Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTMwMjk4",
          "commit": {
            "abbreviatedOid": "1ba3eb4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-01-24T09:40:48Z",
          "updatedAt": "2019-01-24T09:40:48Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "Because I don't want to mess up test output when failure is expected (that's why I use `nullLogger` here), while log message could be useful for debug when failure is unexpected (so `stdoutLogger` in the above).\r\n\r\nBTW probably we should use helper functions for these assertions. https://github.com/WICG/webpackage/pull/385",
              "createdAt": "2019-01-24T09:40:48Z",
              "updatedAt": "2019-01-24T09:40:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTQ4NzEx",
          "commit": {
            "abbreviatedOid": "1ba3eb4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-24T10:17:19Z",
          "updatedAt": "2019-01-24T10:17:19Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "414ee596febe25d8136a37a0519b40ccce22a592",
      "headRepository": null,
      "headRefName": "verifier-b3",
      "headRefOid": "1ba3eb448681b03a704cc16127f1fe3c3356ad1a",
      "mergeCommit": {
        "oid": "85f06bb5a575c7c0e78f315c1b57518db1a2e7c0"
      }
    },
    {
      "number": 385,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ3MjU5ODIy",
      "title": "go: Add helper functions for verifier test",
      "url": "https://github.com/WICG/webpackage/pull/385",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-01-24T09:40:28Z",
      "updatedAt": "2019-01-25T01:51:42Z",
      "closedAt": "2019-01-25T01:51:38Z",
      "mergedAt": "2019-01-25T01:51:38Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTM1MDE0",
          "commit": {
            "abbreviatedOid": "5f25dd8"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-24T09:50:27Z",
          "updatedAt": "2019-01-24T09:50:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk1OTQ5MDY1",
          "commit": {
            "abbreviatedOid": "5f25dd8"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-01-24T10:18:08Z",
          "updatedAt": "2019-01-24T10:18:08Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "85f06bb5a575c7c0e78f315c1b57518db1a2e7c0",
      "headRepository": null,
      "headRefName": "test-helper",
      "headRefOid": "859701762ff1d73266d6b784efdc53a52d4e8192",
      "mergeCommit": {
        "oid": "0623de4a4ba5f01ba680c18e4dd756c5032e1781"
      }
    },
    {
      "number": 386,
      "id": "MDExOlB1bGxSZXF1ZXN0MjQ4MzQwNDIz",
      "title": "Security considerations for future-dated OCSP responses and stolen private keys.",
      "url": "https://github.com/WICG/webpackage/pull/386",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@sleevi, how's this look?\r\n\r\nPreview at https://jyasskin.github.io/webpackage/future-dated-ocsp/draft-yasskin-http-origin-signed-responses.html#seccons-off-path",
      "createdAt": "2019-01-29T01:01:03Z",
      "updatedAt": "2019-02-06T19:20:40Z",
      "closedAt": "2019-02-06T19:20:35Z",
      "mergedAt": "2019-02-06T19:20:35Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MTk5ODUwMDg3",
          "commit": {
            "abbreviatedOid": "edb54c2"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-04T22:58:40Z",
          "updatedAt": "2019-02-04T23:04:02Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "s/will/should/",
              "createdAt": "2019-02-04T22:58:40Z",
              "updatedAt": "2019-02-06T19:11:17Z"
            },
            {
              "originalPosition": 78,
              "body": "I'm not sure if this PR is the best place to address it, but it does heavily overlap with the OCSP analysis you provided and the discussion of short-lived certs; namely, the security considerations of validation risks to certificates.\r\n\r\nGrossly oversimplifying:\r\n- Because these certificates can be used without being on path, then exploits in validation practices become more useful\r\n- OCSP is reactive, once an issue is detected\r\n- CAA (and lifetimes) are useful in ensuring robustness at time of issuance\r\n- These methods (CAA, OCSP, reduced lifetime) are existing issues that the ecosystem faces; the only difference is in the calculus about being on-path, hence stronger mitigations than the status-quo",
              "createdAt": "2019-02-04T23:03:06Z",
              "updatedAt": "2019-02-06T19:11:17Z"
            },
            {
              "originalPosition": 78,
              "body": "Oh, and I mention it here because private key compromise and validation compromise are similar in the capabilities they grant, with key compromise being less detectable.",
              "createdAt": "2019-02-04T23:03:45Z",
              "updatedAt": "2019-02-06T19:11:17Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNzUxMTQy",
          "commit": {
            "abbreviatedOid": "edb54c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T19:06:30Z",
          "updatedAt": "2019-02-06T19:11:37Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "It's stronger than \"should\". How about \"a CT log has promised to publish the mis-issued certificate within\"?",
              "createdAt": "2019-02-06T19:06:30Z",
              "updatedAt": "2019-02-06T19:11:37Z"
            },
            {
              "originalPosition": 78,
              "body": "That's a good unifying point. I'm going to send another PR to talk about it after the CAA requirement is merged.",
              "createdAt": "2019-02-06T19:09:57Z",
              "updatedAt": "2019-02-06T19:11:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAwNzU0Nzg4",
          "commit": {
            "abbreviatedOid": "00a921b"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-06T19:14:22Z",
          "updatedAt": "2019-02-06T19:14:23Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "SGTM! Yeah, just wanted to call out 'expected'/'required' from 'actual' behaviour :)",
              "createdAt": "2019-02-06T19:14:22Z",
              "updatedAt": "2019-02-06T19:14:23Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0623de4a4ba5f01ba680c18e4dd756c5032e1781",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "future-dated-ocsp",
      "headRefOid": "00a921b47ccb5dcfec2b71bfd5e2504650c3eaae",
      "mergeCommit": {
        "oid": "290c673285ce29d8476b8ae6dad83f37bbd67fce"
      }
    },
    {
      "number": 392,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUwNjM0NjAw",
      "title": "go: Update structuredheader to header-structure-09",
      "url": "https://github.com/WICG/webpackage/pull/392",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Change the refs to draft-ietf-httpbis-header-structure-09\r\n- Use the new \"key\" type for parameter keys\r\n- Identifier was renamed to Token",
      "createdAt": "2019-02-06T05:01:01Z",
      "updatedAt": "2019-02-08T01:26:09Z",
      "closedAt": "2019-02-08T01:25:58Z",
      "mergedAt": "2019-02-08T01:25:58Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzk1NjQy",
          "commit": {
            "abbreviatedOid": "a5b3bce"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-08T01:01:25Z",
          "updatedAt": "2019-02-08T01:01:25Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0623de4a4ba5f01ba680c18e4dd756c5032e1781",
      "headRepository": null,
      "headRefName": "header-structure-09",
      "headRefOid": "34dac20fc34251910b2f848090e516e47c689dac",
      "mergeCommit": {
        "oid": "b9d939eb47d1568dc82e859f3f89ae6e597c8227"
      }
    },
    {
      "number": 394,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxMjk2NzYw",
      "title": "Fix #393: Use the right type for the integrity header.",
      "url": "https://github.com/WICG/webpackage/pull/394",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n#exchange-signature-integrity-header, #read-a-body\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/394.html\" title=\"Last updated on Feb 7, 2019, 10:49 PM UTC (d8b73dd)\">Preview</a> (<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/394.html#exchange-signature-integrity-header\" title=\"#exchange-signature-integrity-header\">#exchange-signature-\u2026</a>) (<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/394.html#read-a-body\" title=\"#read-a-body\">#read-a-body</a>) | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/394/3997c75...jyasskin:d8b73dd.html\" title=\"Last updated on Feb 7, 2019, 10:49 PM UTC (d8b73dd)\">Diff</a>",
      "createdAt": "2019-02-07T22:47:56Z",
      "updatedAt": "2019-02-08T01:43:37Z",
      "closedAt": "2019-02-08T01:43:30Z",
      "mergedAt": "2019-02-08T01:43:30Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzg0Mzcw",
          "commit": {
            "abbreviatedOid": "d8b73dd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-08T00:09:43Z",
          "updatedAt": "2019-02-08T00:09:43Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxMzk1NzUy",
          "commit": {
            "abbreviatedOid": "d8b73dd"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-08T01:01:55Z",
          "updatedAt": "2019-02-08T01:01:55Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3997c751c327b0be6a7130fb9557283c9d64b297",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fix-integrity-type",
      "headRefOid": "d8b73dd5e9397b61256d51ab13013327904ae334",
      "mergeCommit": {
        "oid": "afa06efbde35745e4190de022fa3fe31e52cb41f"
      }
    },
    {
      "number": 395,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxMzYzMTE4",
      "title": "go: Add structuredheader.ParseListOfLists",
      "url": "https://github.com/WICG/webpackage/pull/395",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This will be used to parse Variant / Variant-Key headers.",
      "createdAt": "2019-02-08T06:17:32Z",
      "updatedAt": "2019-02-15T01:39:51Z",
      "closedAt": "2019-02-15T01:39:26Z",
      "mergedAt": "2019-02-15T01:39:26Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyMTA3Nzg5",
          "commit": {
            "abbreviatedOid": "b40906e"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-11T13:37:07Z",
          "updatedAt": "2019-02-11T13:42:25Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Style nit: https://golang.org/doc/effective_go.html#mixed-caps\r\n\r\nNote to self: I was going to comment `innerList := []Item{}`, but found https://github.com/golang/go/wiki/CodeReviewComments#declaring-empty-slices",
              "createdAt": "2019-02-11T13:37:07Z",
              "updatedAt": "2019-02-12T01:34:09Z"
            },
            {
              "originalPosition": 91,
              "body": "subCamelCase (for other vars too. sorry, should have caught in earlier reviews)",
              "createdAt": "2019-02-11T13:38:17Z",
              "updatedAt": "2019-02-12T01:34:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyNDQwNDEw",
          "commit": {
            "abbreviatedOid": "b40906e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-02-12T01:36:57Z",
          "updatedAt": "2019-02-12T01:37:50Z",
          "comments": [
            {
              "originalPosition": 60,
              "body": "Done",
              "createdAt": "2019-02-12T01:36:57Z",
              "updatedAt": "2019-02-12T01:37:50Z"
            },
            {
              "originalPosition": 91,
              "body": "Oops, done.",
              "createdAt": "2019-02-12T01:37:12Z",
              "updatedAt": "2019-02-12T01:37:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAyNDQxODQx",
          "commit": {
            "abbreviatedOid": "b5d64ea"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-12T01:43:52Z",
          "updatedAt": "2019-02-12T01:43:52Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "afa06efbde35745e4190de022fa3fe31e52cb41f",
      "headRepository": null,
      "headRefName": "list-list",
      "headRefOid": "b5d64ea2583bd50d513f697ad6cd779cce004272",
      "mergeCommit": {
        "oid": "57b2fa566002947571334a0221b0c6244112c409"
      }
    },
    {
      "number": 396,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUxNTc5NjA5",
      "title": "Don't require CAs to cap lifetime or check CAA until May 1.",
      "url": "https://github.com/WICG/webpackage/pull/396",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This makes it clear that existing CAs aren't breaking any rules just because I changed the draft.",
      "createdAt": "2019-02-08T19:53:35Z",
      "updatedAt": "2019-03-01T17:43:05Z",
      "closedAt": "2019-03-01T17:42:58Z",
      "mergedAt": "2019-03-01T17:42:58Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "It was @clintwilson's spot, to be clear. :)",
          "createdAt": "2019-02-08T20:09:57Z",
          "updatedAt": "2019-02-08T20:09:57Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "FYI this updates #377 for #383. (just for the auto-backlinks)",
          "createdAt": "2019-02-21T02:18:11Z",
          "updatedAt": "2019-02-21T02:18:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjAxNzYxMDQw",
          "commit": {
            "abbreviatedOid": "b63bd5f"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "Good spot.\r\n\r\nWhile certificate lifetimes can be 'easily' changed by altering CA's certificate issuing profile, the CAA enforcement will actually require changes to the validation infrastructure, so it makes sense to clearly phase this in for CAs that have or are implementing support, while also setting clear expectations about what the end state will look like.",
          "createdAt": "2019-02-08T19:57:49Z",
          "updatedAt": "2019-02-08T19:57:49Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "aa316858417a452bcbce91d931f37c308edb1945",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "caa-timeline",
      "headRefOid": "b63bd5f106b92fe9e04ddf263a9e5063897e98c8",
      "mergeCommit": {
        "oid": "d39b53783b592724d929e9f0458975bf2eac92f5"
      }
    },
    {
      "number": 398,
      "id": "MDExOlB1bGxSZXF1ZXN0MjUzMjg4NDc3",
      "title": "dump-signedexchange: make validation success/failure more obvious",
      "url": "https://github.com/WICG/webpackage/pull/398",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Prints validation result at the top\r\n- Adds a blank line between validation result and dump\r\n\r\nFixes #389.",
      "createdAt": "2019-02-15T02:24:20Z",
      "updatedAt": "2019-02-15T05:25:22Z",
      "closedAt": "2019-02-15T05:25:16Z",
      "mergedAt": "2019-02-15T05:25:16Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA0MDg0Njcx",
          "commit": {
            "abbreviatedOid": "5a5c7b9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-02-15T05:23:11Z",
          "updatedAt": "2019-02-15T05:23:11Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "57b2fa566002947571334a0221b0c6244112c409",
      "headRepository": null,
      "headRefName": "dump-sxg",
      "headRefOid": "5a5c7b9c8e62c0f3e2a04fc00b43b16bfa097f99",
      "mergeCommit": {
        "oid": "70386c3750f2ba5fbcb6e66835df0578b2a55c13"
      }
    },
    {
      "number": 401,
      "id": "MDExOlB1bGxSZXF1ZXN0MjU2OTI5NjA0",
      "title": "Add an example of Signed Exchange Report",
      "url": "https://github.com/WICG/webpackage/pull/401",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://github.com/WICG/webpackage/issues/400\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/401.html\" title=\"Last updated on Mar 5, 2019, 5:06 AM UTC (544592e)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/401/af43527...horo-t:544592e.html\" title=\"Last updated on Mar 5, 2019, 5:06 AM UTC (544592e)\">Diff</a>",
      "createdAt": "2019-02-28T04:37:32Z",
      "updatedAt": "2019-03-06T22:46:14Z",
      "closedAt": "2019-03-06T22:46:14Z",
      "mergedAt": "2019-03-06T22:46:14Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Please review this.",
          "createdAt": "2019-02-28T04:39:14Z",
          "updatedAt": "2019-02-28T04:39:14Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjA5NzAwNTI3",
          "commit": {
            "abbreviatedOid": "8e7e75b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-01T17:35:37Z",
          "updatedAt": "2019-03-01T18:28:50Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Use one of the assigned example IPv4 addresses from https://tools.ietf.org/html/rfc5737#section-3 or IPv6 addresses from https://tools.ietf.org/html/rfc3849#section-2, for example, `192.0.2.42`.",
              "createdAt": "2019-03-01T17:35:38Z",
              "updatedAt": "2019-03-05T05:05:52Z"
            },
            {
              "originalPosition": 9,
              "body": "```suggestion\r\n    If a [=NEL policy=] was received from the distributor's origin, `distributor.example`, this step\r\n```",
              "createdAt": "2019-03-01T17:39:35Z",
              "updatedAt": "2019-03-05T05:05:52Z"
            },
            {
              "originalPosition": 10,
              "body": "```suggestion\r\n    will send the following JSON data to describe an invalid signature:\r\n```\r\n\r\nI'm not tied to using an invalid signature as the error type, but I think I'd like to say something about the kind of error.",
              "createdAt": "2019-03-01T17:49:10Z",
              "updatedAt": "2019-03-05T05:05:52Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\n        \"type\": \"sxg.signature_verification_error\",\r\n```\r\n\r\n`sxg.failed` happens in pretty specific cases that don't seem likely to apply to the rest of this example.",
              "createdAt": "2019-03-01T17:50:12Z",
              "updatedAt": "2019-03-05T05:05:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEwNDkzNjk4",
          "commit": {
            "abbreviatedOid": "8e7e75b"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-05T05:02:07Z",
          "updatedAt": "2019-03-05T05:07:33Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "Done",
              "createdAt": "2019-03-05T05:02:07Z",
              "updatedAt": "2019-03-05T05:07:33Z"
            },
            {
              "originalPosition": 10,
              "body": "Done",
              "createdAt": "2019-03-05T05:02:34Z",
              "updatedAt": "2019-03-05T05:07:33Z"
            },
            {
              "originalPosition": 20,
              "body": "Done",
              "createdAt": "2019-03-05T05:03:11Z",
              "updatedAt": "2019-03-05T05:07:33Z"
            },
            {
              "originalPosition": 26,
              "body": "Done",
              "createdAt": "2019-03-05T05:03:25Z",
              "updatedAt": "2019-03-05T05:07:33Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "af4352751ccdf7df0c98e9454f59bb99743925d7",
      "headRepository": "horo-t/webpackage",
      "headRefName": "add_example",
      "headRefOid": "544592e8ce17bb539c38edd90997073a73341193",
      "mergeCommit": {
        "oid": "6067529edfbcbae4f54fcfd26e41915f46a29277"
      }
    },
    {
      "number": 404,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYwNjUyMDEx",
      "title": "go: Add strucured header writer",
      "url": "https://github.com/WICG/webpackage/pull/404",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds ToString() method to the structured header types, and\r\nuses it from signer.go.",
      "createdAt": "2019-03-13T07:30:09Z",
      "updatedAt": "2019-03-15T01:04:22Z",
      "closedAt": "2019-03-15T01:04:18Z",
      "mergedAt": "2019-03-15T01:04:18Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzNzk1MTg2",
          "commit": {
            "abbreviatedOid": "92da76c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-13T07:41:15Z",
          "updatedAt": "2019-03-13T07:41:16Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "`String` is more idiomatic in Go.",
              "createdAt": "2019-03-13T07:41:15Z",
              "updatedAt": "2019-03-13T08:55:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzODAyMjY5",
          "commit": {
            "abbreviatedOid": "92da76c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-13T08:04:49Z",
          "updatedAt": "2019-03-13T08:04:49Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Doesn't `String()` usually return just a `string`? This returns an `error` too.",
              "createdAt": "2019-03-13T08:04:49Z",
              "updatedAt": "2019-03-13T08:55:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzODE1OTAx",
          "commit": {
            "abbreviatedOid": "92da76c"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-13T08:41:50Z",
          "updatedAt": "2019-03-13T08:41:51Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Right, but using `To` is not common in Go.\r\n\r\nThere is an actual usecase of `String` that also returns error: https://godoc.org/golang.org/x/text/encoding#Decoder.String",
              "createdAt": "2019-03-13T08:41:50Z",
              "updatedAt": "2019-03-13T08:55:20Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzODIyMzk3",
          "commit": {
            "abbreviatedOid": "3b2b24a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-13T08:56:55Z",
          "updatedAt": "2019-03-13T08:56:56Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Got it, thanks for finding the example. Done.",
              "createdAt": "2019-03-13T08:56:55Z",
              "updatedAt": "2019-03-13T08:56:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjEzODg1MzM1",
          "commit": {
            "abbreviatedOid": "3b2b24a"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-03-13T11:07:45Z",
          "updatedAt": "2019-03-13T11:07:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE0ODI2NDY5",
          "commit": {
            "abbreviatedOid": "3b2b24a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-15T00:42:44Z",
          "updatedAt": "2019-03-15T00:42:44Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6067529edfbcbae4f54fcfd26e41915f46a29277",
      "headRepository": null,
      "headRefName": "writer",
      "headRefOid": "3b2b24a5450b98bf9015be9c92f0917af85a3ea4",
      "mergeCommit": {
        "oid": "f8735d286cdcc4f99b79a63cc701ab3a7d7c2408"
      }
    },
    {
      "number": 406,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYxNzI5NDYz",
      "title": "Define -impl-03",
      "url": "https://github.com/WICG/webpackage/pull/406",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "See #350.\r\n\r\nDoes what's here match what we actually implemented?\r\n\r\nI'm thinking of also removing [`Accept-Signature`](https://jyasskin.github.io/webpackage/define-03/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#accept-signature) and [transferring a signed exchange as a same-origin response](https://jyasskin.github.io/webpackage/define-03/draft-yasskin-httpbis-origin-signed-exchanges-impl.html#same-origin-response). Do you think we'll want to implement those with the definitions here before we go to -b4?",
      "createdAt": "2019-03-15T23:57:00Z",
      "updatedAt": "2019-07-03T23:54:21Z",
      "closedAt": "2019-07-03T23:54:17Z",
      "mergedAt": "2019-07-03T23:54:17Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'll add a mention that [the Variants-04 header implies variants-05 processing](https://groups.google.com/a/chromium.org/d/topic/webpackage-dev/KTKvQTT9FKI/discussion) in a future PR, after variants-05 is published.",
          "createdAt": "2019-03-20T20:32:20Z",
          "updatedAt": "2019-03-20T20:32:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE2OTcwNzgz",
          "commit": {
            "abbreviatedOid": "34123d8"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "I don't think AMP's first signer & SXG cache will produce or consume same-origin responses _or_ PUSH_PROMISEs in the near term. I can't speak for Chromium folks.",
          "createdAt": "2019-03-20T20:41:59Z",
          "updatedAt": "2019-03-20T22:05:45Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Perhaps rephrase \"an HTTP response (including content negotiation information)\", for clarity later on that the conneg gets signed over.",
              "createdAt": "2019-03-20T20:41:59Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 440,
              "body": "Oops, this and `Variant-Key` are not actually versioned AMP-side, so this snapshot paid off. Leave it as-is here; I'll fix that in our impl.",
              "createdAt": "2019-03-20T21:58:55Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 589,
              "body": "Should header-structure 07 -> 09 be in this changelog somewhere?",
              "createdAt": "2019-03-20T22:03:56Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE3NTYyNTkz",
          "commit": {
            "abbreviatedOid": "34123d8"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-22T01:46:56Z",
          "updatedAt": "2019-03-22T01:47:43Z",
          "comments": [
            {
              "originalPosition": 500,
              "body": "Does this imply that implementation must not fallback-redirect if they don't match?\r\n",
              "createdAt": "2019-03-22T01:46:56Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 547,
              "body": "`integrity=\"digest/mi-sha256-03\"`?",
              "createdAt": "2019-03-22T01:47:01Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDQ1MTgy",
          "commit": {
            "abbreviatedOid": "9b01a79"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-23T16:14:41Z",
          "updatedAt": "2019-03-23T16:16:54Z",
          "comments": [
            {
              "originalPosition": 395,
              "body": "Should we align to draft-yasskin-http-origin-signed-responses.md here to rely on \"The above requirements on CAs...\" paragraph?",
              "createdAt": "2019-03-23T16:14:41Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIyOTcwNDA1",
          "commit": {
            "abbreviatedOid": "972ce5e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I've also removed Accept-Signature and same-origin responses for this -impl draft.",
          "createdAt": "2019-04-04T19:53:47Z",
          "updatedAt": "2019-04-04T20:26:05Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "This is the text from the main spec, so if we change it, we should change it in both places. The text below about the dedicated format says content negotiation is encoded with Variants, which is a response header, so I'm inclined not to change anything.",
              "createdAt": "2019-04-04T19:53:47Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 395,
              "body": "draft-yasskin-http-origin-signed-responses is written the way it is so that all the bits that won't go into the final RFC are sitting in one place. That makes it harder to read than it needs to be, so I moved the timeline up into the main section for the -impl draft. I think this is fine?",
              "createdAt": "2019-04-04T19:55:19Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 440,
              "body": "Thanks.",
              "createdAt": "2019-04-04T19:55:31Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 500,
              "body": "It does imply that, and I think that's the right choice: the server has full control over its `Content-Type` header and should make sure that matches the file signature. However, let me know if this doesn't match our implementation and I'll change it in the -impl draft.",
              "createdAt": "2019-04-04T19:58:50Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 589,
              "body": "It's covered in \"Updates to match {{I-D.yasskin-http-origin-signed-responses-05}}.\"",
              "createdAt": "2019-04-04T20:05:50Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            },
            {
              "originalPosition": 547,
              "body": "Done, thanks.",
              "createdAt": "2019-04-04T20:06:40Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIzMDcwNzYz",
          "commit": {
            "abbreviatedOid": "f88a3ea"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-05T01:37:35Z",
          "updatedAt": "2019-04-05T01:37:36Z",
          "comments": [
            {
              "originalPosition": 500,
              "body": "Current Chromium implementation does fallback redirect in this case.\r\n\r\nLet's continue discussing in #397 on when we should fallback.",
              "createdAt": "2019-04-05T01:37:35Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjI3MDk4MTQ3",
          "commit": {
            "abbreviatedOid": "f88a3ea"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-16T10:00:37Z",
          "updatedAt": "2019-04-16T10:00:38Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "Update line 636 so that `main-certificate`'s validity period is checked too?\r\n\r\nBTW Chrome doesn't implement this yet. I'll try to implement this in M75. https://crbug.com/953165",
              "createdAt": "2019-04-16T10:00:38Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU3Nzc4ODIy",
          "commit": {
            "abbreviatedOid": "97af4c2"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-03T23:49:48Z",
          "updatedAt": "2019-07-03T23:49:49Z",
          "comments": [
            {
              "originalPosition": 564,
              "body": "Done.",
              "createdAt": "2019-07-03T23:49:48Z",
              "updatedAt": "2019-07-03T23:50:13Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "8c799580a0824503dd072114f67b634fe769fafc",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "define-03",
      "headRefOid": "ed2280411dee5dae0c4501685561a09d7178825f",
      "mergeCommit": {
        "oid": "812b981c2cc039d77b01d61727b60b4d78f22579"
      }
    },
    {
      "number": 407,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYyMjY1MzEx",
      "title": "UTF-8 decode the fallback URL",
      "url": "https://github.com/WICG/webpackage/pull/407",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "And a miscellaneous fix to a reference.",
      "createdAt": "2019-03-18T23:50:36Z",
      "updatedAt": "2019-03-20T19:41:50Z",
      "closedAt": "2019-03-20T19:41:47Z",
      "mergedAt": "2019-03-20T19:41:47Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE1OTA2NDU3",
          "commit": {
            "abbreviatedOid": "5013726"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-18T23:53:43Z",
          "updatedAt": "2019-03-18T23:53:43Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f8735d286cdcc4f99b79a63cc701ab3a7d7c2408",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fixes",
      "headRefOid": "50137261295f38590bb400c304041c69667deaa7",
      "mergeCommit": {
        "oid": "7aef9b9bd97ab3ea432f4cec22cc7020267f7c29"
      }
    },
    {
      "number": 408,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYyMjY3ODE1",
      "title": "Promote the privacy-preserving prefetch use case to \"Essential\"",
      "url": "https://github.com/WICG/webpackage/pull/408",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It's what our current most enthusiastic customer (AMP) depends on, so we\r\nshould be sure not to break it.",
      "createdAt": "2019-03-19T00:05:06Z",
      "updatedAt": "2019-03-23T20:20:57Z",
      "closedAt": "2019-03-23T20:20:54Z",
      "mergedAt": "2019-03-23T20:20:54Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDQzNDk4",
          "commit": {
            "abbreviatedOid": "f31de2d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-23T15:28:08Z",
          "updatedAt": "2019-03-23T15:28:08Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f8735d286cdcc4f99b79a63cc701ab3a7d7c2408",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "promote-private-prefetch",
      "headRefOid": "f31de2d853cff3929eb825732c348aa4d5ab95ba",
      "mergeCommit": {
        "oid": "9683bb4f81e7c980c677d18829c8c3c62c7d7ca3"
      }
    },
    {
      "number": 410,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYzMDc0NzYw",
      "title": "Change gen-signedexchange default to b3.",
      "url": "https://github.com/WICG/webpackage/pull/410",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-20T23:36:06Z",
      "updatedAt": "2019-03-23T15:26:57Z",
      "closedAt": "2019-03-23T15:26:57Z",
      "mergedAt": "2019-03-23T15:26:57Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "cc @jeffjose",
          "createdAt": "2019-03-20T23:42:29Z",
          "updatedAt": "2019-03-20T23:42:29Z"
        },
        {
          "author": "jeffjose",
          "authorAssociation": "NONE",
          "body": "Can we update b2 -> b3 here too please? https://github.com/WICG/webpackage/blob/master/examples/firebase.json",
          "createdAt": "2019-03-21T00:02:44Z",
          "updatedAt": "2019-03-21T00:02:44Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "@jeffjose Yep, that's in this PR.",
          "createdAt": "2019-03-21T00:13:46Z",
          "updatedAt": "2019-03-21T00:13:46Z"
        },
        {
          "author": "jeffjose",
          "authorAssociation": "NONE",
          "body": "Ah yes, missed it the first time around. Thank you, @twifkak!",
          "createdAt": "2019-03-21T00:26:03Z",
          "updatedAt": "2019-03-21T00:26:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDQzNDM5",
          "commit": {
            "abbreviatedOid": "68ac72a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-23T15:26:31Z",
          "updatedAt": "2019-03-23T15:26:31Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7aef9b9bd97ab3ea432f4cec22cc7020267f7c29",
      "headRepository": "twifkak/webpackage",
      "headRefName": "cmdb3",
      "headRefOid": "68ac72a0af5ecb00b491c3464a5f69bb40dab287",
      "mergeCommit": {
        "oid": "2a9ff702850870764efb0663414355f3fde27bf6"
      }
    },
    {
      "number": 412,
      "id": "MDExOlB1bGxSZXF1ZXN0MjYzODQ0NjA2",
      "title": "Update go readme",
      "url": "https://github.com/WICG/webpackage/pull/412",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-23T16:38:04Z",
      "updatedAt": "2019-03-25T14:38:32Z",
      "closedAt": "2019-03-25T14:38:31Z",
      "mergedAt": "2019-03-25T14:38:31Z",
      "mergedBy": "nyaxt",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for your review. Will commit once CI pass",
          "createdAt": "2019-03-25T13:32:10Z",
          "updatedAt": "2019-03-25T13:32:10Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDU4MTU0",
          "commit": {
            "abbreviatedOid": "afad7d6"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-03-23T22:10:38Z",
          "updatedAt": "2019-03-23T22:16:49Z",
          "comments": [
            {
              "originalPosition": 31,
              "body": "Nit:\r\n\r\n```suggestion\r\nYour signed exchange needs to be signed with a certificate with the [\"CanSignHttpExchanges\" extension](https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req).\r\n```",
              "createdAt": "2019-03-23T22:10:38Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\n1. Get a certificate from a CA. You have to use prime256v1 ecdsa keys, as you did in the previous section. Please follow the CA's instructions. (For example, [DigiCert](https://www.digicert.com/account/ietf/http-signed-exchange.php) offers the right kind of certificates.)\r\n```",
              "createdAt": "2019-03-23T22:11:47Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            },
            {
              "originalPosition": 44,
              "body": "I think it's still worthwhile to describe the chrome://flags/#allow-sxg-certs-without-extension flag until someone's offering free CanSignHttpExchanges certificates. The old text for it, of course, isn't right, and I don't mind getting the new text in a separate PR.",
              "createdAt": "2019-03-23T22:16:41Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MDc3NTk5",
          "commit": {
            "abbreviatedOid": "0a5b841"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-24T11:44:55Z",
          "updatedAt": "2019-03-24T11:44:55Z",
          "comments": [
            {
              "originalPosition": 44,
              "body": "Added #allow-sxg-certs-without-extension instructions back",
              "createdAt": "2019-03-24T11:44:55Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MTEwMzY3",
          "commit": {
            "abbreviatedOid": "381ec42"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-24T23:57:12Z",
          "updatedAt": "2019-03-24T23:57:27Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Since a self-signed certificate is used in this section, mentioning about `--ignore-certificate-errors-spki-list` would be still useful.",
              "createdAt": "2019-03-24T23:57:12Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MzIwMjAz",
          "commit": {
            "abbreviatedOid": "381ec42"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-25T13:17:37Z",
          "updatedAt": "2019-03-25T13:17:38Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done.",
              "createdAt": "2019-03-25T13:17:37Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE4MzIxNDg5",
          "commit": {
            "abbreviatedOid": "eece0e0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-25T13:19:59Z",
          "updatedAt": "2019-03-25T13:23:02Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "```suggestion\r\n      # Note that --user-data-dir is required for --ignore-certificate-errors-spki-list\r\n```",
              "createdAt": "2019-03-25T13:19:59Z",
              "updatedAt": "2019-03-25T13:31:41Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2a9ff702850870764efb0663414355f3fde27bf6",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "update-go-readme",
      "headRefOid": "be92d71aebba4b3511fbb184f01e122338a81c2e",
      "mergeCommit": {
        "oid": "ed41f713c1203e0c5cfa103355e5ed7b5de35760"
      }
    },
    {
      "number": 414,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY0ODEyMjc0",
      "title": "go/bundle: Add support for the manifest section",
      "url": "https://github.com/WICG/webpackage/pull/414",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Please take a look when you have time.",
      "createdAt": "2019-03-27T07:48:31Z",
      "updatedAt": "2019-03-29T02:17:31Z",
      "closedAt": "2019-03-29T02:17:19Z",
      "mergedAt": "2019-03-29T02:17:19Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5MzM2MDA2",
          "commit": {
            "abbreviatedOid": "66768d5"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-27T09:06:08Z",
          "updatedAt": "2019-03-27T09:06:28Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Can we make Manifest section optional?",
              "createdAt": "2019-03-27T09:06:08Z",
              "updatedAt": "2019-03-28T03:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5MzM5NjE4",
          "commit": {
            "abbreviatedOid": "66768d5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-27T09:14:06Z",
          "updatedAt": "2019-03-27T09:14:06Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "It's optional. If `b.ManifestURL` is nil, `newManifestSection` returns nil and the manifest section won't be emitted.",
              "createdAt": "2019-03-27T09:14:06Z",
              "updatedAt": "2019-03-28T03:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5MzUwOTIz",
          "commit": {
            "abbreviatedOid": "66768d5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-27T09:37:05Z",
          "updatedAt": "2019-03-27T09:37:12Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Can we use `WriteTo` instead of getter property interface?\r\n\r\nhttps://golang.org/pkg/io/#WriterTo",
              "createdAt": "2019-03-27T09:37:05Z",
              "updatedAt": "2019-03-28T03:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5MzU3Nzk3",
          "commit": {
            "abbreviatedOid": "66768d5"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-27T09:50:43Z",
          "updatedAt": "2019-03-27T09:50:43Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Thanks for explanation. I think we want to make that clear from reading only this part of the code.\r\n`newManifestSection` returning `nil, nil` is a surprising behavior to me.\r\n\r\nSome ideas:\r\n- `if url != \"\"` before newManifestSection\r\n- Alternate namings? `tryCreateManifestSection`?\r\n- Add comment explaining the behavior here?",
              "createdAt": "2019-03-27T09:50:43Z",
              "updatedAt": "2019-03-28T03:57:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODI0MDU2",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T03:59:01Z",
          "updatedAt": "2019-03-28T03:59:01Z",
          "comments": [
            {
              "originalPosition": 155,
              "body": "Thanks for the suggestions. Chenged to check `b.ManifestURL != nil` before newManifestSection.",
              "createdAt": "2019-03-28T03:59:01Z",
              "updatedAt": "2019-03-28T03:59:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODI0MTkx",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T03:59:54Z",
          "updatedAt": "2019-03-28T03:59:55Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done.",
              "createdAt": "2019-03-28T03:59:54Z",
              "updatedAt": "2019-03-28T03:59:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODcxMjI1",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T07:53:44Z",
          "updatedAt": "2019-03-28T07:53:44Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Ah sorry but I meant to remove section interface and use `io.WriterTo` instead",
              "createdAt": "2019-03-28T07:53:44Z",
              "updatedAt": "2019-03-28T07:53:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODczMTQ1",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T08:00:02Z",
          "updatedAt": "2019-03-28T08:00:02Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Hmm. We need to write (name, length) pair and section content separately, so just a `WriterTo` doesn't suffice.",
              "createdAt": "2019-03-28T08:00:02Z",
              "updatedAt": "2019-03-28T08:00:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODc1MDc3",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-28T08:06:07Z",
          "updatedAt": "2019-03-28T08:06:07Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTU4NDUx",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T11:16:11Z",
          "updatedAt": "2019-03-28T11:16:11Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Oh I see.\r\n\r\nIn this case, I prefer to define e.g. `MarshalCbor` function that takes cbor's encoder to having getters, but that's optional.",
              "createdAt": "2019-03-28T11:16:11Z",
              "updatedAt": "2019-03-28T11:16:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTU4NDgz",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-03-28T11:16:16Z",
          "updatedAt": "2019-03-28T11:16:16Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjIwMzUwNjEz",
          "commit": {
            "abbreviatedOid": "e309097"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-29T02:16:31Z",
          "updatedAt": "2019-03-29T02:16:31Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Let me merge this as-is, and do the refactoring separately.",
              "createdAt": "2019-03-29T02:16:31Z",
              "updatedAt": "2019-03-29T02:16:31Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ed41f713c1203e0c5cfa103355e5ed7b5de35760",
      "headRepository": null,
      "headRefName": "manifest",
      "headRefOid": "e3090976bb14246868d7c528088402e5e4281d2d",
      "mergeCommit": {
        "oid": "ba2b3b6807e1fec9e0b2ea11fbf2532f2f0f9e22"
      }
    },
    {
      "number": 415,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY1MTYxNzgx",
      "title": "Fix gen-signedexchange example -date value",
      "url": "https://github.com/WICG/webpackage/pull/415",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`Z` doesn't have an offset suffix.",
      "createdAt": "2019-03-28T02:10:55Z",
      "updatedAt": "2019-03-28T02:37:46Z",
      "closedAt": "2019-03-28T02:37:43Z",
      "mergedAt": "2019-03-28T02:37:43Z",
      "mergedBy": "twifkak",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5ODA5NDMy",
          "commit": {
            "abbreviatedOid": "3a8a9f0"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-28T02:33:19Z",
          "updatedAt": "2019-03-28T02:33:19Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ed41f713c1203e0c5cfa103355e5ed7b5de35760",
      "headRepository": "WICG/webpackage",
      "headRefName": "twifkak-date",
      "headRefOid": "3a8a9f02532f044592654482ae9405634b577411",
      "mergeCommit": {
        "oid": "1752d9879c0b620595e763779adbee4d1e77ef5e"
      }
    },
    {
      "number": 416,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY1MjI5ODU2",
      "title": "TravisCI: Test go code",
      "url": "https://github.com/WICG/webpackage/pull/416",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-28T08:28:12Z",
      "updatedAt": "2019-08-22T04:26:12Z",
      "closedAt": "2019-08-22T04:26:12Z",
      "mergedAt": "2019-08-22T04:26:12Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Gentle ping",
          "createdAt": "2019-04-15T00:47:26Z",
          "updatedAt": "2019-04-15T00:47:26Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "I'm going to manually rebase and merge this, and will create a separate PR for the Jeffrey's suggestion.",
          "createdAt": "2019-08-22T04:24:24Z",
          "updatedAt": "2019-08-22T04:24:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNjgyMTYz",
          "commit": {
            "abbreviatedOid": "22df502"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This looks great! I'd like it to run in parallel if possible. Does it still work if you remove the `stages` section and replace `stage: go` with `name: \"Go\"` and `stage: spec` with `name: \"Specifications\"`?",
          "createdAt": "2019-08-08T16:10:33Z",
          "updatedAt": "2019-08-08T16:10:33Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "1752d9879c0b620595e763779adbee4d1e77ef5e",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "travis-go",
      "headRefOid": "22df502ba2e3578cc609c50c60748652c0574fa8",
      "mergeCommit": {
        "oid": "22df502ba2e3578cc609c50c60748652c0574fa8"
      }
    },
    {
      "number": 417,
      "id": "MDExOlB1bGxSZXF1ZXN0MjY1MjUxOTIz",
      "title": "go: Add basic test for bundle.go",
      "url": "https://github.com/WICG/webpackage/pull/417",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-03-28T09:37:51Z",
      "updatedAt": "2019-03-29T02:22:04Z",
      "closedAt": "2019-03-29T02:21:56Z",
      "mergedAt": "2019-03-29T02:21:56Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTIzNjAx",
          "commit": {
            "abbreviatedOid": "f75bf71"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T10:00:25Z",
          "updatedAt": "2019-03-28T10:00:32Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "can we use bundle.Bundle instead of `.` import?",
              "createdAt": "2019-03-28T10:00:25Z",
              "updatedAt": "2019-03-28T10:00:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTU2ODU2",
          "commit": {
            "abbreviatedOid": "f75bf71"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-03-28T11:12:22Z",
          "updatedAt": "2019-03-28T11:12:22Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "I think using a dot in a test package is common, but I'm fine with both.",
              "createdAt": "2019-03-28T11:12:22Z",
              "updatedAt": "2019-03-28T11:12:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjE5OTY4MjQx",
          "commit": {
            "abbreviatedOid": "f75bf71"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-03-28T11:40:18Z",
          "updatedAt": "2019-03-28T11:40:18Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "1752d9879c0b620595e763779adbee4d1e77ef5e",
      "headRepository": null,
      "headRefName": "bundle-test",
      "headRefOid": "f75bf71f4434e14d825579cfe44458e81c5ed6d4",
      "mergeCommit": {
        "oid": "487734b9b561644052b31814b504436e5edd0c16"
      }
    },
    {
      "number": 424,
      "id": "MDExOlB1bGxSZXF1ZXN0MjczMzIyMDY0",
      "title": "Commit the threat model from #422",
      "url": "https://github.com/WICG/webpackage/pull/424",
      "state": "OPEN",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@johnwilander, here's an attempt to make your threat model a little more formal so that we can evaluate a range of attacks and mitigations against it. Did I capture roughly what the WebKit team is thinking? Thanks for engaging!",
      "createdAt": "2019-04-24T22:33:59Z",
      "updatedAt": "2021-02-17T00:19:09Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "tracking-threat-model",
      "headRefOid": "4aa4813763ffaa6eb7cd77573ce6e21dfbd1ebb6",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "How is this doing as a first draft of the anti-tracking threat model? I'm hoping to send some more PRs digging into the proposed mitigations, but I'd like to have rough agreement on the base first.",
          "createdAt": "2019-05-01T19:45:20Z",
          "updatedAt": "2019-05-01T19:45:20Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "NONE",
          "body": "Jeffrey cited this PR in an email, and just reading through the text, I'm confused.  Are you really attempting to prevent two cooperating origins from exchanging information?",
          "createdAt": "2019-05-10T01:35:37Z",
          "updatedAt": "2019-05-10T01:35:37Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "My understanding from #422 is that @johnwilander and Safari's ITP2 are indeed trying to prevent two cooperating origins from exchanging information. Specifically, when following a link from AdTech to News, if AdTech can send AdTech's notion of the user's ID to News in any request where News also gets its own notion of the user's ID, then News can remember that association and use it augment AdTech's profile of the user or request user-specific ads from AdTech on all subsequent pages.\r\n\r\nThere may be limitations on AdTech's ability to get News to cooperate (see \"Attacker Non-Capabilities\"), but I haven't been able to get a description of those that I believe in.",
          "createdAt": "2019-05-13T18:56:27Z",
          "updatedAt": "2019-05-13T18:56:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMTE0MDM1",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T11:50:34Z",
          "updatedAt": "2019-04-26T11:57:53Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Nit: the points are not written as attacker goals",
              "createdAt": "2019-04-26T11:50:34Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            },
            {
              "originalPosition": 117,
              "body": "With Server Timing, we have response headers that are directly readable from JS, so embedding the UID through them might be feasible even without on-the-fly signing. So we need to make sure that the distributor cannot add arbitrary non-signed headers to the internal response, as well as that the external response Server Timing headers are not exposed to the navigated page.\r\nI believe that's already the case, tbh, but IMO it's worthwhile to explicitly note that.",
              "createdAt": "2019-04-26T11:54:16Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            },
            {
              "originalPosition": 171,
              "body": "It also seems like the distributor can use the referrer in order to include a UID (e.g. redirect through a unique path, and have a permissive ReferrerPolicy). Mitigation can be to enforce stricter ReferrerPolicy on redirects or in general.",
              "createdAt": "2019-04-26T11:57:45Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjYyOTk4",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:03:10Z",
          "updatedAt": "2019-04-26T17:03:10Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'd say web rather than Internet since we're talking about web browsers here. I don't think the success of our efforts remains to be seen, and even if it were, this comment comes across as opinionated.",
              "createdAt": "2019-04-26T17:03:10Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjYzMTEz",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:03:29Z",
          "updatedAt": "2019-04-26T17:03:30Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "browsers \u2013> browser engines",
              "createdAt": "2019-04-26T17:03:30Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY0MzY3",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:06:45Z",
          "updatedAt": "2019-04-26T17:06:45Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "\"We\" has become confused here. It shouldn't be the same \"we\" criticizing tracking vectors and \"we\" are told. I would rewrite this without attribution.",
              "createdAt": "2019-04-26T17:06:45Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY1MjQz",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:08:56Z",
          "updatedAt": "2019-04-26T17:08:57Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I don't think \"that other work\" is defined here. The other work is potentially years into the future and I don't think we should indicate that Web Packaging can punt on tracking issues in wait for such \"other work.\"",
              "createdAt": "2019-04-26T17:08:57Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY2MTY0",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:11:07Z",
          "updatedAt": "2019-04-26T17:11:07Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "We should add that AdTech can help or convince News to set up a signing *service* as an alternative to handing over keys. With such a service, AdTech can create the package, calculate its hash, and send the hash over for signing, all on the fly.\r\n\r\nAlso, we should stick to one term. Currently we mention both certificates and private keys. I think private keys are the most accurate term.",
              "createdAt": "2019-04-26T17:11:07Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY2OTI1",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:12:41Z",
          "updatedAt": "2019-04-26T17:12:41Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "See my comment above on certificates vs private keys.",
              "createdAt": "2019-04-26T17:12:41Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY3NTUx",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:14:07Z",
          "updatedAt": "2019-04-26T17:14:07Z",
          "comments": [
            {
              "originalPosition": 110,
              "body": "Here the potential for a service is mentioned. See my comment on this above.",
              "createdAt": "2019-04-26T17:14:07Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY5Mjg4",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:18:25Z",
          "updatedAt": "2019-04-26T17:18:25Z",
          "comments": [
            {
              "originalPosition": 159,
              "body": "I've only given casual thought to how a webpage can instruct the browser to restrict a load because it is for a signed package. Two ideas: 1) a /.well-known/ location or 2) a special HTTP redirect similar to an upgrade.",
              "createdAt": "2019-04-26T17:18:25Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjY5NzM3",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:19:29Z",
          "updatedAt": "2019-04-26T17:19:29Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "I think there\u2019s value in continuing to separate these concepts.\r\n\r\nIt would seem that your threat considerations consider the following scenarios:\r\n1. AdTech creates a private key and obtains a certificate on News\u2019 behalf (e.g. as CDNs commonly do)\r\n1. News generates the key and then shares with AdTech\r\n1. News holds the private key, but then signs on AdTech\u2019s behalf (as commonly practiced by CDNs, typically called Split-TLS)\r\n1. TLS Delegated Creds have a fourth model, where News generates the key, and then authorizes a key for AdTech\r\n\r\nThese each seem to represent different combinations, with the last being particularly relevant in the discussion of certificates and keys",
              "createdAt": "2019-04-26T17:19:29Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjcwMTIw",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "sleevi",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:20:19Z",
          "updatedAt": "2019-04-26T17:20:20Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Isn\u2019t this correct as is? For example, Brave shares the same Browser Engine as Edge and Chromium, but represent their own approaches to reduce tracking ability.",
              "createdAt": "2019-04-26T17:20:19Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjcxNzY5",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "johnwilander",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T17:23:57Z",
          "updatedAt": "2019-04-26T17:23:57Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "WebKit is an engine used in multiple browsers and web rendering applications. If the text should indeed refer to browsers, it should be Safari. But web technologies are mostly about engines.",
              "createdAt": "2019-04-26T17:23:57Z",
              "updatedAt": "2019-04-26T23:52:55Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMzU4NDk2",
          "commit": {
            "abbreviatedOid": "32627f6"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T21:00:58Z",
          "updatedAt": "2019-04-26T23:56:15Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "+1 for being consistent, and I'm happy to follow John's preference to keep this with WebKit and \"engines\".",
              "createdAt": "2019-04-26T21:00:59Z",
              "updatedAt": "2019-04-26T23:56:15Z"
            },
            {
              "originalPosition": 4,
              "body": "Sorry, removed.",
              "createdAt": "2019-04-26T21:05:12Z",
              "updatedAt": "2019-04-26T23:56:15Z"
            },
            {
              "originalPosition": 159,
              "body": "I don't think we need to write down all the details in this document, but I'm thinking of:\r\n\r\n1. In https://wicg.github.io/webpackage/loading.html#mp-http-network-or-cache-fetch 20.2, add\r\n   * httpRequest\u2019s [credentials mode](https://fetch.spec.whatwg.org/#concept-request-credentials-mode) is `\"omit\"`\"\r\n   * httpRequest\u2019s method is `GET`\r\n   * etc.\r\n\r\n   to the constraints on \"setting _response_ to httpRequest\u2019s stashed exchange's response.\"\r\n2. Add an attribute to `<a>` tags to let them cause credential-less fetches, and similarly anywhere else we want to enable signed packages that [`crossorigin`](https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attribute) isn't sufficient. There may be a more ergonomic way to do this with `/.well-known/` or [origin policy](https://wicg.github.io/origin-policy/).\r\n\r\nIf we wind up thinking this is the right mitigation for this problem, I think we'll propose and discuss the new `credentials=\"omit\"` mechanism in a separate repository, since it could also be useful independent of web packaging.",
              "createdAt": "2019-04-26T21:25:24Z",
              "updatedAt": "2019-04-26T23:56:15Z"
            },
            {
              "originalPosition": 20,
              "body": "Rewritten. I'm not sure if I've preserved the important bits from your original issue, so please double-check.",
              "createdAt": "2019-04-26T22:42:14Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 27,
              "body": "Indeed. I was trying to get at the idea that we can assume the other changes are done when designing fixes for Web Packaging, but I'm not sure the best way to say that.\r\n\r\nFor example, if AdTech can convey user IDs through the Referer header, we'll want to strip that header when redirecting cross-origin regardless of the cause of the redirect. The Web Packaging design should be able to assume that's done, rather than adding a special case for just the [redirect](https://wicg.github.io/webpackage/loading.html#mp-http-fetch) embedded in the Web Packaging processing model.\r\n\r\nMaybe the new text explains that thought better?",
              "createdAt": "2019-04-26T22:56:28Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 64,
              "body": "I've elaborated this section with @sleevi's 4 possibilities. I think they mostly differ in how visible AdTech's misbehavior would be to News, and how long that misbehavior could keep affecting users after News terminated the relationship with AdTech.\r\n\r\nI agree that we need to be precise about which of \"certificate\" or \"private key\" is correct in each location, but because they mean different things, I don't think we can talk about just one of them. I'm using phrasing that implies that a certificate signs the package, which matches https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#cross-origin-cert-req, but strictly a private key (or keypair?) signs the package and the certificate just vouches for the authority of that key. I'm happy to take better wording.",
              "createdAt": "2019-04-26T23:20:06Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 87,
              "body": "Indeed. https://increment.com/security/approachable-threat-modeling/ would call these \"Invariants\", but it's not clear that would be intuitive to random folks reading this. I'll rephrase them.",
              "createdAt": "2019-04-26T23:29:55Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 110,
              "body": "I've rephrased this as a reference to the new wording in Attacker Capabilities and removed the sub-item.",
              "createdAt": "2019-04-26T23:33:00Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 117,
              "body": "It's a security requirement that the distributor can't add response headers to the post-redirect response. https://wicg.github.io/webpackage/draft-yasskin-http-origin-signed-responses.html#signed-headers mentions that idea, although it's in a section nobody's implementing. The application/signed-exchange format just can't represent such unsigned post-redirect response headers.\r\n\r\nI don't think Server-Timing response headers on a 303 response get exposed to the post-redirect javascript. So I'm not sure there's really anything to say here.",
              "createdAt": "2019-04-26T23:51:45Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            },
            {
              "originalPosition": 171,
              "body": "As I'm saying in https://github.com/WICG/webpackage/pull/424#discussion_r279031642, I think we'll need to block that communication route on all redirects, so it's not special to web packages. Do you want me to add a separate attack describing it below?",
              "createdAt": "2019-04-26T23:56:09Z",
              "updatedAt": "2019-04-26T23:56:16Z"
            }
          ]
        }
      ]
    },
    {
      "number": 425,
      "id": "MDExOlB1bGxSZXF1ZXN0MjczNzAyOTA3",
      "title": "Use Case: Least Authority CDN Serving",
      "url": "https://github.com/WICG/webpackage/pull/425",
      "state": "OPEN",
      "author": "davidstrauss",
      "authorAssociation": "FIRST_TIME_CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While working on the security architecture for Drupal's planned auto-update features, I realized that many of our use cases could be solvable using SXG rather than rolling our own signing mechanism (as APT and Yum have) to support offline signatures for metadata from update servers. We already intend to distribute the metadata via a CDN that has appropriate certificates for drupal.org, but we also don't want the attack surface introduced by every POP being a potential point of compromise. Given that we control the client side in these scenarios, SXG represents one brightly lit path to trusting the metadata without relying solely on TLS or using baroque integrations with GnuPG.",
      "createdAt": "2019-04-25T22:22:24Z",
      "updatedAt": "2021-02-17T00:19:09Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "davidstrauss/webpackage",
      "headRefName": "patch-1",
      "headRefOid": "2e76b5e99014c80a3d49619f28579bd5635b8d47",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "davidstrauss",
          "authorAssociation": "NONE",
          "body": "> I believe I convinced @davidstrauss a couple months ago that his underlying use case was better served by signify or minisign.\r\n\r\nWe were convinced! We have a working implementation in testing now:\r\n\r\n* https://github.com/drupal/php-signify\r\n* https://github.com/mbaynton/drupal-signing-oracle\r\n\r\nHowever, we extended the Signify design to support expiring intermediate keypairs. We did this for two reasons, which I'll mention here because SXG does support this use case (via X.509) better than Signify's design:\r\n\r\nFirst, Drupal needs to sign artifacts produced in its online build infrastructure. These artifacts include builds of community-provided code that may be malicious. Signing these builds requires the key -- or the ability to sign -- to be available to this high-risk system. However, most cloud HSMs don't support ed25519. We don't have a natural place to deploy custom hardware for the Drupal Association, so we opted for using a VM as a signing oracle (to still create some isolation in case of build server compromise). Still, we wanted to anchor trust in something other than a key deployed to a VM in the cloud.\r\n\r\nSecond, Drupal lacks a natural key rotation interval akin to OpenBSD's six-month-ish release cycle. Drupal's major releases get support for years, and users expect to be able to upgrade across fairly arbitrary point releases. This creates tension between (a) rotating across point releases (perhaps not every one) and potentially breaking the ability of older point releases to validate current builds versus (b) rotating across major releases and having keys live for 5+ years. It would also be possible to have (c) older point releases \"walk\" their way to trusting the current build key, but that seemed fragile. An intermediate keypair makes rotation a question of operations effort versus security -- with no end-user impacts.\r\n\r\nSo, an intermediate keypair seemed like an elegant way to keep the root offline and support arbitrary rotations of the secrets in the deployed build infrastructure. (We currently hope to rotate intermediate keys quarterly.) Otherwise, we were quite happy with what Signify provided as a design.\r\n\r\nWe plan to secure the offline root by using YubiHSM hardware.",
          "createdAt": "2019-10-17T21:38:20Z",
          "updatedAt": "2019-10-17T21:40:01Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMjU1OTY4",
          "commit": {
            "abbreviatedOid": "2e76b5e"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Fly-by comment; not a full review, which I'll leave to @jyasskin.",
          "createdAt": "2019-04-26T16:46:08Z",
          "updatedAt": "2019-04-26T16:53:47Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I wonder if Must-Staple is a closer analogy to what is required. An origin could not enforce that their CDN includes a certain HTTP header on all responses, but they could enforce that the only certificate they bestow upon the CDN has a given extension. (As to whether that extension could or should be marked critical, I'm not sure.) Supporting clients would, when confronted with a TLS connection backed by such a cert, only honor responses that are signed with an SXG cert.",
              "createdAt": "2019-04-26T16:46:08Z",
              "updatedAt": "2019-04-26T16:53:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMzczODcx",
          "commit": {
            "abbreviatedOid": "2e76b5e"
          },
          "author": "davidstrauss",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-04-26T21:52:11Z",
          "updatedAt": "2019-04-26T21:52:11Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "> I wonder if Must-Staple is a closer analogy to what is required.\r\n\r\nPerhaps I should rephrase the text, as the forward-looking idea is less about the mechanism (HSTS-style, Must-Staple, or otherwise) and more about allowing a site to inform clients to expect SXG responses. That expectation should be sticky or, at least, resistant to downgrade attacks.\r\n\r\nI agree that an extension applied to the TLS certificate would be a technologically elegant way to solve the issue. I'd argue that such an extension should be non-critical, as that would allow existing clients to interact as before, while clients aware of the extension could enforce SXG on responses. SXG enforcement is a defense-in-depth against POP/proxy compromise, which I think is another argument for a non-critical designation.\r\n\r\nI try to push back against new certificate extensions for practical reasons, though. They create a barrier to entry for people who implement or deploy the design. That raises some reasons I looked first to HSTS: it's broadly used, doesn't require external facilitation (e.g. by a CA), and has no up-front or ongoing costs to web site administrators.\r\n\r\n> An origin could not enforce that their CDN includes a certain HTTP header on all responses, but they could enforce that the only certificate they bestow upon the CDN has a given extension.\r\n\r\nThis is true, but what I had in mind was the broader world of HSTS rather than just the header. In practice, qualifying HSTS headers get cached in browsers and bundled into the HSTS Preload List, both of which continue enforcement even if the header goes missing. (So, while a compromised POP could stop sending an SXG enforcement header, clients would still expect SXG.) I'm unsure whether this is the most desirable approach to SXG enforcement, but it's one established pattern that's possible to apply here.",
              "createdAt": "2019-04-26T21:52:11Z",
              "updatedAt": "2019-04-26T23:20:11Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwOTUxNjI2",
          "commit": {
            "abbreviatedOid": "2e76b5e"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "First, sorry for leaving this review for so long.\r\n\r\nI believe I convinced @davidstrauss a couple months ago that his underlying use case was better served by [signify](https://www.openbsd.org/papers/bsdcan-signify.html) or [minisign](https://jedisct1.github.io/minisign/). (I found those via https://latacora.micro.blog/2019/07/16/the-pgp-problem.html.)\r\n\r\nHowever, I believe there are two interesting use cases here:\r\n\r\n1. The one in the title, letting CDNs serve a site without letting them change the content. This one is *difficult* and requires at least two exciting components beyond signed exchanges:\r\n   1. The CDN, by definition, gets the traffic that looked your origin up in DNS. That means it also gets the traffic from a CA trying to verify who owns the domain using method [3.2.2.4.6 Agreed-Upon Change to Website](https://cabforum.org/wp-content/uploads/CA-Browser-Forum-BR-1.6.6.pdf), so it can just get a new certificate as your origin. This might be solvable using [CAA](https://en.wikipedia.org/wiki/DNS_Certification_Authority_Authorization) and some \"I got here first\" account restriction with the allowed CAs, but that seems fragile, so it might be worth designing something else.\r\n   1. As @mnot [pointed out](https://www.iab.org/wp-content/IAB-uploads/2019/06/mnot.pdf), when the browser tries to create a connection to your origin, it checks that the target (the CDN) has the private key for a trusted certificate for that origin, which the CDN of course can't have if we don't want them forging content. As Mark said, we'd need to invent a way for the server to tell your browser to create the \"TLS\" connection but only accept content within valid SXGs. And to preserve confidentiality against network attackers other than the CDN, we'd need to actually authenticate the CDN itself in some other way. And I don't see a way for a server to migrate to this scheme while still supporting old clients. Mark suggests [LURK](https://datatracker.ietf.org/wg/lurk/charter/), which I don't understand well enough to endorse.\r\n\r\n1. Ensuring users get correct content even if your frontend is compromised. (And it might be reasonable to think of an evil CDN like a compromised frontend.) I think the HSTS-like mechanism proposed here actually accomplishes this, and we don't need the complexity of origin-trusted certificates to get here. Instead, you'd serve a `TBD-Content-Public-Key-Pins: ed25519=(*base64-public-key* ...), max-age=seconds` header which the client would trust on first use, and subsequent responses would only be trusted if they were signed by that public key. You'd store the private key in your build system but keep it away from frontends. This is similar to [Signature-based SRI](https://github.com/mikewest/signature-based-sri) but works on top-level resources. Note that this has [footguns](https://groups.google.com/a/chromium.org/d/topic/blink-dev/he9tr7p3rZ8/discussion) very similar to [Public Key Pinning](https://en.wikipedia.org/wiki/HTTP_Public_Key_Pinning). Apps like end-to-end encrypted messaging systems and password managers would probably be interested in using this.\r\n\r\nI propose to add both use cases to this document with descriptions like above, with a note that I don't expect the CDN use case to happen any time soon. I'll send 2 PRs.",
          "createdAt": "2019-10-11T22:20:29Z",
          "updatedAt": "2019-10-11T22:20:29Z",
          "comments": []
        }
      ]
    },
    {
      "number": 426,
      "id": "MDExOlB1bGxSZXF1ZXN0MjczNzU5NjA3",
      "title": "go/signedexchange: ParsePrivateKey takes pem text, not DER bytes",
      "url": "https://github.com/WICG/webpackage/pull/426",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "To make it consistent with ParseCertificates().",
      "createdAt": "2019-04-26T04:44:28Z",
      "updatedAt": "2019-04-26T08:21:45Z",
      "closedAt": "2019-04-26T08:21:36Z",
      "mergedAt": "2019-04-26T08:21:36Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMDI0NDg3",
          "commit": {
            "abbreviatedOid": "e05e667"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-26T08:00:18Z",
          "updatedAt": "2019-04-26T08:00:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMxMDI1MzQ2",
          "commit": {
            "abbreviatedOid": "e05e667"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-04-26T08:02:29Z",
          "updatedAt": "2019-04-26T08:02:29Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "487734b9b561644052b31814b504436e5edd0c16",
      "headRepository": null,
      "headRefName": "parsekey",
      "headRefOid": "e05e667a0965d77eb39800e71c1cbf0132a0814a",
      "mergeCommit": {
        "oid": "9634466eaf43068113c2648d76760c354f1f8192"
      }
    },
    {
      "number": 427,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1MDgyMjQ3",
      "title": "Add support for JSON output",
      "url": "https://github.com/WICG/webpackage/pull/427",
      "state": "MERGED",
      "author": "ithinkihaveacat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Adds a switch, `-json` to `dump-signedexchange` (fixes #418):\r\n\r\n```sh\r\n$ curl -sS -H 'accept: application/signed-exchange;v=b3' -H 'amp-cache-transform: google;v=\"1\"' https://amp.dev/ | ./dump-signedexchange -json\r\n{\r\n  \"Valid\": true,\r\n  \"Payload\": \"\",\r\n  \"SignatureHeaderValue\": {\r\n    \"cert-sha256\": \"lWfYk+0jeC/HkleYD4fj98y6GixIjocIkMpjsB8dToA=\",\r\n    \"cert-url\": \"https://amp.dev/amppkg/cert/lWfYk-0jeC_HkleYD4fj98y6GixIjocIkMpjsB8dToA\",\r\n    \"date\": 1559608738,\r\n    \"expires\": 1560213538,\r\n    \"integrity\": \"digest/mi-sha256-03\",\r\n    \"sig\": \"MEYCIQDNXSYTBrsbJVJrm79lPTRXITmvraoQj77axnslJa7HUwIhAOwTFoVFhQwfYICNHa+fSewH6mxaD5K6YPdcGbbgIG6w\",\r\n    \"validity-url\": \"https://amp.dev/amppkg/validity\"\r\n  },\r\n  \"Version\": \"1b3\",\r\n\u2026\r\n```\r\n\r\nCan be used with e.g. https://stedolan.github.io/jq/ to extract specific properties such as the cert-url:\r\n\r\n```sh\r\n$ curl -sS -H 'accept: application/signed-exchange;v=b3' -H 'amp-cache-transform: google;v=\"1\"' https://amp.dev/ | ./dump-signedexchange -json | jq -r '.SignatureHeaderValue|.\"cert-url\"'\r\nhttps://amp.dev/amppkg/cert/lWfYk-0jeC_HkleYD4fj98y6GixIjocIkMpjsB8dToA\r\n```\r\n\r\n(FYI @patrickkettner re #418, had a quick look and just figured I'd have a go at this!)",
      "createdAt": "2019-05-01T16:40:26Z",
      "updatedAt": "2019-06-06T05:29:23Z",
      "closedAt": "2019-06-06T05:29:23Z",
      "mergedAt": "2019-06-06T05:29:23Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "/cc @nyaxt",
          "createdAt": "2019-05-02T10:53:57Z",
          "updatedAt": "2019-05-02T10:53:57Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the review @nyaxt! I think it's ready for another pass now.",
          "createdAt": "2019-06-05T00:43:52Z",
          "updatedAt": "2019-06-05T00:43:52Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@nyaxt Updated, PTAL!",
          "createdAt": "2019-06-05T11:55:11Z",
          "updatedAt": "2019-06-05T11:55:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNjQ4NjY5",
          "commit": {
            "abbreviatedOid": "2f78984"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T16:41:50Z",
          "updatedAt": "2019-05-01T16:41:51Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "To make `golint` happy.",
              "createdAt": "2019-05-01T16:41:51Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzUxNjk0",
          "commit": {
            "abbreviatedOid": "2f78984"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you!",
          "createdAt": "2019-05-03T07:42:55Z",
          "updatedAt": "2019-05-03T07:51:24Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "I'd like to avoid duplicating struct def if possible.\r\n\r\nWould you mind omitting payload via `json:\"-\"` for now?",
              "createdAt": "2019-05-03T07:42:55Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 54,
              "body": "If we omit payload,\r\n```\r\nstruct {\r\n  Valid bool\r\n  *Exchange\r\n  Payload string\r\n}{\r\n  ok,\r\n  e,\r\n  payload\r\n}\r\n```",
              "createdAt": "2019-05-03T07:46:26Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 24,
              "body": "Would you pass `certFetcher` via this func's argument?",
              "createdAt": "2019-05-03T07:47:29Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 22,
              "body": "I feel like this should live in dump-signedexchange, since users who wish to use this Go code as a library is unlikely to need this.",
              "createdAt": "2019-05-03T07:49:20Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 23,
              "body": "Would you pass verificationTime via this func's argument?",
              "createdAt": "2019-05-03T07:50:14Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY1OTA1",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:41:03Z",
          "updatedAt": "2019-06-05T00:41:04Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Done (kinda\u2014I couldn't get `json:\"-\"` to work quite as expected).",
              "createdAt": "2019-06-05T00:41:03Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY1OTc3",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:41:26Z",
          "updatedAt": "2019-06-05T00:41:26Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Reworked a bit, but I think this is done.",
              "createdAt": "2019-06-05T00:41:26Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY1OTg5",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:41:32Z",
          "updatedAt": "2019-06-05T00:41:33Z",
          "comments": [
            {
              "originalPosition": 24,
              "body": "Done.",
              "createdAt": "2019-06-05T00:41:32Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY2MzI2",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:43:23Z",
          "updatedAt": "2019-06-05T00:43:23Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done. (FWIW, I originally put it here because the signature matched that of `PrettyPrintHeaders()`.)",
              "createdAt": "2019-06-05T00:43:23Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1NzY2MzQ3",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T00:43:29Z",
          "updatedAt": "2019-06-05T00:43:30Z",
          "comments": [
            {
              "originalPosition": 23,
              "body": "Done.",
              "createdAt": "2019-06-05T00:43:29Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1Nzc2MDMy",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T01:36:14Z",
          "updatedAt": "2019-06-05T01:40:20Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "Would you try `omitempty`?",
              "createdAt": "2019-06-05T01:36:14Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            },
            {
              "originalPosition": 39,
              "body": "would you factor this part out so jsonPrintHeaders can also use `*flagCert` if available?\r\n\r\nI think we can create a `func initCertFetcher() (func(url string) ([]byte, error), error)` which returns signedexchange.DefaultCertFetcher if no `*flagCert` and read `*flagCert` if avail.",
              "createdAt": "2019-06-05T01:39:57Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1OTQ3NjEw",
          "commit": {
            "abbreviatedOid": "bf78f0d"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T11:28:18Z",
          "updatedAt": "2019-06-05T11:28:19Z",
          "comments": [
            {
              "originalPosition": 67,
              "body": "That works, thanks!",
              "createdAt": "2019-06-05T11:28:19Z",
              "updatedAt": "2019-06-05T11:53:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ1OTU3NDg4",
          "commit": {
            "abbreviatedOid": "f14841a"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-05T11:53:59Z",
          "updatedAt": "2019-06-05T11:53:59Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Nice, done!",
              "createdAt": "2019-06-05T11:53:59Z",
              "updatedAt": "2019-06-05T11:53:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MzYwODAx",
          "commit": {
            "abbreviatedOid": "f14841a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-06T04:44:55Z",
          "updatedAt": "2019-06-06T04:44:56Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "The return type can be written as `(signedexchange.CertFetcher, error)`",
              "createdAt": "2019-06-06T04:44:56Z",
              "updatedAt": "2019-06-06T04:44:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2MzY3NDA4",
          "commit": {
            "abbreviatedOid": "f14841a"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\nLet's merge this (I may create a follow up patch for function signature, etc.).\r\nThank you for the patch!",
          "createdAt": "2019-06-06T05:26:13Z",
          "updatedAt": "2019-06-06T05:26:13Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5408bf1388d2d86a68dbf3e542d75a852777ff34",
      "headRepository": "ithinkihaveacat/webpackage",
      "headRefName": "json-output",
      "headRefOid": "f14841ae856490a972c76efc48c4747611c3f3de",
      "mergeCommit": {
        "oid": "d618944953082234c6d789886a477f0cfddfa2a9"
      }
    },
    {
      "number": 428,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1MTM5NTk2",
      "title": "Remove credentials from the certificate fetch.",
      "url": "https://github.com/WICG/webpackage/pull/428",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This removes one avenue by which a distributor could send its notion of\na user's ID to another origin, for server-side correlation with that\norigin's cookies. That correlation would violate the goals in #422 and seems easy to block.\n\nThanks @kristoferbaxter and @twifkak for pointing this out.\n\nI don't *think* it's useful to customize the content of a certificate chain to a particular user, especially since the hash of the certificate itself is locked in by the SXG's signature. But if anyone sees a way this'll break things, please speak up.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/428.html\" title=\"Last updated on May 1, 2019, 8:05 PM UTC (1321699)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/428/9634466...jyasskin:1321699.html\" title=\"Last updated on May 1, 2019, 8:05 PM UTC (1321699)\">Diff</a>",
      "createdAt": "2019-05-01T20:05:33Z",
      "updatedAt": "2019-05-01T22:26:20Z",
      "closedAt": "2019-05-01T20:34:58Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzQxNTcw",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "PR description LGTM; I'll defer to y'all on whether the syntax/semantics of the implementation are correct.",
          "createdAt": "2019-05-01T20:28:24Z",
          "updatedAt": "2019-05-01T20:28:39Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Pardon my naivete wrt the fetch monkeypatch,\r\n\r\nhttps://fetch.spec.whatwg.org/#concept-request-credentials-mode says:\r\n> Unless stated otherwise, it is \"`omit`\".\r\n\r\nIs it stated otherwise somewhere? Or is duplicate to avoid confusion?",
              "createdAt": "2019-05-01T20:28:24Z",
              "updatedAt": "2019-05-01T20:28:39Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzQ0Mjcw",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T20:34:56Z",
          "updatedAt": "2019-05-01T20:34:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Argh, thanks for pointing that out. Yep, this PR is a no-op. Never mind!",
              "createdAt": "2019-05-01T20:34:56Z",
              "updatedAt": "2019-05-01T20:34:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzY5NDQw",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "kristoferbaxter",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T21:39:18Z",
          "updatedAt": "2019-05-01T21:39:19Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Thanks for taking a look anyway. I thought this value default was changed, https://github.com/whatwg/fetch/pull/585. \r\n\r\nIt might still be worthwhile to ensure it's set to \"omit\".",
              "createdAt": "2019-05-01T21:39:18Z",
              "updatedAt": "2019-05-01T21:39:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzczMzA5",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T21:50:41Z",
          "updatedAt": "2019-05-01T21:50:41Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "It seems like \"same-origin\" would still address the threat mentioned in the PR description (\"another origin\"); is there another threat you had in mind?",
              "createdAt": "2019-05-01T21:50:41Z",
              "updatedAt": "2019-05-01T21:50:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMyNzgzNDQy",
          "commit": {
            "abbreviatedOid": "1321699"
          },
          "author": "kristoferbaxter",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-01T22:26:08Z",
          "updatedAt": "2019-05-01T22:26:08Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Making the value `omit` would only be for completeness sake \u2013 I believe `same-origin` gives the same level of protection but unnecessarily sends cookies for same origin cert requests.",
              "createdAt": "2019-05-01T22:26:08Z",
              "updatedAt": "2019-05-01T22:26:20Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9634466eaf43068113c2648d76760c354f1f8192",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "anonymous-cert-fetch",
      "headRefOid": "1321699a569dec942cb77c05eeed6d8e616e971e",
      "mergeCommit": null
    },
    {
      "number": 429,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjc1NTE3ODky",
      "title": "Adds support for URI input to dump-signedexchange",
      "url": "https://github.com/WICG/webpackage/pull/429",
      "state": "MERGED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This PR makes some quality of life improvements for the dump-signedexchange tool\r\n\r\n- Adds support for reading a signed exchange from an HTTPS endpoint rather than from the file system. This feels much more natural to use and allows for faster debugging.\r\n- Allows for more granular control over the output. Generally when I dump a signed exchange, I don't want to see the entire HTML, I'm interested in the signature and the headers.\r\n\r\nEDIT:\r\n- The tool will also warn the user if -i or -uri is not passed instead of simply hanging indefinitely\r\n\r\nEDIT 2:\r\n- Allows the version to be specified with the `-version` flag which defaults to the latest version\r\n- Allows a header such as `AMP-Cache-Transform: google;v=1` to be sent along with the `-uri` request with the `-requestHeader` flag\r\n- Fixes a few instances of `singedexchange` and makes them `signedexchange`\r\n\r\nEDIT 3:\r\n- Added info about json flag to README\r\n- Allows more than one header to be passed with -requestHeader flag\r\n- Mime type factored to version.go\r\n- Input flags take precedence over pipe",
      "createdAt": "2019-05-02T21:00:29Z",
      "updatedAt": "2019-06-13T02:34:56Z",
      "closedAt": "2019-06-13T02:34:56Z",
      "mergedAt": "2019-06-13T02:34:56Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @gabbifish @twifkak ",
          "createdAt": "2019-05-02T21:01:28Z",
          "updatedAt": "2019-05-02T21:01:28Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "Comments should be addressed at this point, let me know if there are further improvements that should be made.",
          "createdAt": "2019-05-03T16:55:45Z",
          "updatedAt": "2019-05-03T16:55:45Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "What do people here think about defaulting `-payload` to false and `-verify` to true? When I use this tool I only really care about the headers/verification and don't want the payload printed. I feel that's probably typical and those would make sensible defaults. That said, I don't want to change the default behavior of the tool w/o explicit buy-in.",
          "createdAt": "2019-05-03T19:12:55Z",
          "updatedAt": "2019-05-03T19:12:55Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Quick comment, haven\u2019t looked at this PR closely: with these changes, is it possible to cleanly output just the payload? Am wondering because this is something I\u2019m interested in extracting (to pass to other tooling).\r\n\r\nHaving convenient access to the payload was part of the original purpose of my PR #427 (edit), but I think after the comments are addressed it won\u2019t output the payload at all, so it would be nice to be able to get it via this PR ;-). (Don\u2019t care whether it\u2019s the default or not.)",
          "createdAt": "2019-05-03T21:26:50Z",
          "updatedAt": "2019-05-03T21:27:21Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "> Quick comment, haven\u2019t looked at this PR closely: with these changes, is it possible to cleanly output just the payload? \r\n\r\nYes! You can simply pass `-headers=false` and only the payload will be printed :)\r\n\r\n",
          "createdAt": "2019-05-03T21:32:36Z",
          "updatedAt": "2019-05-03T21:32:36Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori @nyaxt comments should be addressed",
          "createdAt": "2019-06-10T19:35:02Z",
          "updatedAt": "2019-06-10T19:35:02Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "The newly added `-json` flag coerces the strings `<` `>` and `&` to UTF-8. For instance, when outputting the `Link` header it will look like this:\r\n\r\n```    \r\n\"Link\": [\r\n      \"\\u003chttps://cdn.ampproject.org/v0.js\\u003e;rel=preload;as=script\"\r\n    ],\r\n```\r\n\r\nI have a fix that will print the JSON w/proper encoding that I can include in this PR if y'all think it would be beneficial. \r\n\r\nAfter:\r\n\r\n```\r\n\"Link\": [\r\n   \"<https://cdn.ampproject.org/v0.js>;rel=preload;as=script\"\r\n],\r\n```",
          "createdAt": "2019-06-10T20:22:39Z",
          "updatedAt": "2019-06-10T20:23:53Z"
        },
        {
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@EverlastingBugstopper Ah, I didn't notice that! Yes I think that would be good to fix here (or in a different PR). It seems like the reason to encode those characters is to try to protect against problems that result from embedding JSON within HTML but that seems a bit unlikely in this case.",
          "createdAt": "2019-06-10T22:35:26Z",
          "updatedAt": "2019-06-10T22:35:26Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "I've pushed fix for JSON encoding (don't feel a separate PR is necessary, the change is small) and removed the unnecessary `\"\"` pointers from the README",
          "createdAt": "2019-06-11T14:43:17Z",
          "updatedAt": "2019-06-11T14:43:17Z"
        },
        {
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori Comments addressed",
          "createdAt": "2019-06-12T22:06:27Z",
          "updatedAt": "2019-06-12T22:06:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMjcxNDkz",
          "commit": {
            "abbreviatedOid": "31ebe5d"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-02T22:48:11Z",
          "updatedAt": "2019-05-02T22:48:11Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I use `dump-signedexchange` at the end of a pipe sometimes. I'd prefer if you updated this to allow the case where stdin != /dev/pty or whatever. Alternatively, maybe we could make `-i -` a valid syntax if it isn't already.",
              "createdAt": "2019-05-02T22:48:11Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMjg2ODAx",
          "commit": {
            "abbreviatedOid": "31ebe5d"
          },
          "author": "gabbifish",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "Some small comments below! The error handling might play better with the piping use pattern Devin described.",
          "createdAt": "2019-05-02T23:55:13Z",
          "updatedAt": "2019-05-03T00:00:16Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "I'd rename this flagFilename to emphasize this pertains to local files, especially since flagURI has been added.",
              "createdAt": "2019-05-02T23:55:13Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 83,
              "body": "consistent with error returning above, I might make this an error: \r\n```suggestion\r\n\t\tfmt.Errorf(\"Need to pass -uri with URI of sxg or -i with file location of sxg \\n\")\r\n```",
              "createdAt": "2019-05-02T23:58:59Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzI0NDc5",
          "commit": {
            "abbreviatedOid": "2cdeb59"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T05:13:03Z",
          "updatedAt": "2019-05-03T05:13:04Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "I didn't know you could use `dump-signedexchange` like that! Makes a lot of sense though. I've added that functionality back and documented a use case in the README.",
              "createdAt": "2019-05-03T05:13:03Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzI0NjQ4",
          "commit": {
            "abbreviatedOid": "2cdeb59"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T05:14:43Z",
          "updatedAt": "2019-05-03T05:14:44Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Turns out the `flag` library can print the usage. I've changed this message to simply print the usage, though it doesn't return anything. Do you think that pattern is OK even though the function doesn't return an error?",
              "createdAt": "2019-05-03T05:14:43Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzI1Njcy",
          "commit": {
            "abbreviatedOid": "60ea74d"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T05:23:53Z",
          "updatedAt": "2019-05-03T05:24:54Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "These four lines are the same in each branch of the if. Maybe just `var in` outside the `if` and set it in each branch.",
              "createdAt": "2019-05-03T05:24:19Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzI1ODAz",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T05:25:20Z",
          "updatedAt": "2019-05-03T05:25:20Z",
          "comments": [
            {
              "originalPosition": 83,
              "body": "Nice! Thanks.",
              "createdAt": "2019-05-03T05:25:20Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzU5NzEz",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T08:09:55Z",
          "updatedAt": "2019-05-03T08:18:42Z",
          "comments": [
            {
              "originalPosition": 10,
              "body": "Should we use b3 since it is now the default version?",
              "createdAt": "2019-05-03T08:09:55Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 13,
              "body": "ditto",
              "createdAt": "2019-05-03T08:10:01Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 45,
              "body": "Would you specify `any` here or add a commandline flag to modify this? (I'd like to avoid having `google` as default)",
              "createdAt": "2019-05-03T08:14:38Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 44,
              "body": "Would you make `b3` part configurable via command line flag?",
              "createdAt": "2019-05-03T08:15:34Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 55,
              "body": "I think we can rely on `strings.TrimSpace(*flagFilename) == \"-\"` instead",
              "createdAt": "2019-05-03T08:18:24Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzYzNzU2",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T08:22:58Z",
          "updatedAt": "2019-05-03T08:22:58Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "Maybe even best to leave AMP-Cache-Transform out of this binary entirely and have a generic -requestHeader flag.",
              "createdAt": "2019-05-03T08:22:58Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzMzY0MjM4",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T08:24:34Z",
          "updatedAt": "2019-05-03T08:24:34Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Either works for me, but I like the current approach the best. Allows pipe usage to work without specifying `-i` at all, while still presenting the usage info when not in a pipe.",
              "createdAt": "2019-05-03T08:24:34Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNTIzNjYx",
          "commit": {
            "abbreviatedOid": "51a7faa"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T15:12:08Z",
          "updatedAt": "2019-05-03T15:12:09Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "I prefer early returns:\r\n\r\n```\r\nif e == nil {\r\n    flag.PrintDefaults()\r\n    return nil\r\n}\r\n```",
              "createdAt": "2019-05-03T15:12:09Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNTcwMzgz",
          "commit": {
            "abbreviatedOid": "77cd1a7"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T16:54:47Z",
          "updatedAt": "2019-05-03T16:54:47Z",
          "comments": [
            {
              "originalPosition": 45,
              "body": "This should be done, if there is an obvious better way to do this, please let me know.",
              "createdAt": "2019-05-03T16:54:47Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNTcwNTc4",
          "commit": {
            "abbreviatedOid": "77cd1a7"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-03T16:55:19Z",
          "updatedAt": "2019-05-03T16:55:19Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "I've kept this as is, input can come from the pipe, the -i flag or the -uri flag",
              "createdAt": "2019-05-03T16:55:19Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNTg3OTQ2",
          "commit": {
            "abbreviatedOid": "77cd1a7"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks! Some nits. If @nyaxt approves before I do, don't wait for my approval. I'll defer that to him anyway.",
          "createdAt": "2019-05-03T17:36:35Z",
          "updatedAt": "2019-05-03T17:43:23Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Use [`strings.SplitN`](https://golang.org/pkg/strings/#SplitN), as it's possible for values to contain colons (e.g. `Location` or `Link`).",
              "createdAt": "2019-05-03T17:36:36Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 103,
              "body": "(opt, nit) Set `in` to `nil` at declaration time and compare to `nil` here.",
              "createdAt": "2019-05-03T17:39:18Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjMzNzIyODc0",
          "commit": {
            "abbreviatedOid": "a61232d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-04T05:21:44Z",
          "updatedAt": "2019-05-04T05:27:22Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "Would you factor this out as `func (v Version) MimeType() string` in `version.go`?",
              "createdAt": "2019-05-04T05:21:45Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 34,
              "body": "Would you do this in a way similar to https://github.com/WICG/webpackage/blob/master/go/signedexchange/cmd/gen-signedexchange/main.go#L52 ?",
              "createdAt": "2019-05-04T05:25:54Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM0MzI3Mzgx",
          "commit": {
            "abbreviatedOid": "a61232d"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-05-07T06:26:08Z",
          "updatedAt": "2019-05-07T06:28:49Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "Currently this tool prints mice-decoded payload if `-verify` is given (because `verify()` decodes the payload), but after this patch payload is not decoded at this point.\r\n\r\nI know this is confusing and we should fix it (#431), but can we keep the current behavior for now?\r\n",
              "createdAt": "2019-05-07T06:26:08Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 64,
              "body": "Would you move this branch to the last? I think the flags should take precedence.",
              "createdAt": "2019-05-07T06:26:14Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ3NzAxMjIx",
          "commit": {
            "abbreviatedOid": "a61232d"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-10T16:07:58Z",
          "updatedAt": "2019-06-10T16:07:59Z",
          "comments": [
            {
              "originalPosition": 122,
              "body": "I believe this behavior is unchanged",
              "createdAt": "2019-06-10T16:07:58Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4MDE3ODYz",
          "commit": {
            "abbreviatedOid": "6929aeb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-11T08:18:47Z",
          "updatedAt": "2019-06-11T08:20:52Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "> the value should be enclosed with double quotations `\"\"`\r\n\r\nThis might be confusing, as `dump-signedexchange` itself doesn't interpret quotations. Quotations may be needed by command-line shells, but exact rules for quotation / escaping could be different by shells (so it's probably out of scope of this document).",
              "createdAt": "2019-06-11T08:18:48Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 64,
              "body": "`defer in.Close()` here?",
              "createdAt": "2019-06-11T08:18:54Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4MDcxMjQz",
          "commit": {
            "abbreviatedOid": "6929aeb"
          },
          "author": "ithinkihaveacat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-11T09:57:41Z",
          "updatedAt": "2019-06-11T09:57:41Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "I'm not sure if I'm reading the docs right, but the examples don't seem to match the docs\u2014?\r\n\r\nThe examples seem to match curl's syntax (aside from the actual switch name), which seems like a good approach--well-understood by developers, and various tools seem to now output curl syntax for debugging (e.g. Chrome and Safari developer tools).",
              "createdAt": "2019-06-11T09:57:41Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4MjIzMTkx",
          "commit": {
            "abbreviatedOid": "6929aeb"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-11T14:39:01Z",
          "updatedAt": "2019-06-11T14:39:01Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Not sure exactly what needs to happen here as `io.Reader has no field or method Close`",
              "createdAt": "2019-06-11T14:39:01Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4MjI0Nzk5",
          "commit": {
            "abbreviatedOid": "6929aeb"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-11T14:41:13Z",
          "updatedAt": "2019-06-11T14:41:14Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "@ithinkihaveacat The examples should match? Could you point out what specifically is confusing? After this PR the tool will be able to take sxg input from a curl command and also by passing the URI via flag",
              "createdAt": "2019-06-11T14:41:13Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ4NTExOTY2",
          "commit": {
            "abbreviatedOid": "f006f58"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks, looking good.",
          "createdAt": "2019-06-12T01:38:34Z",
          "updatedAt": "2019-06-12T01:58:59Z",
          "comments": [
            {
              "originalPosition": 64,
              "body": "Ah, then how about this:\r\n```\r\nf, err := os.Open(*flagFilename)\r\nif err != nil {\r\n  return err\r\n}\r\ndefer f.Close()\r\nin = f\r\n```",
              "createdAt": "2019-06-12T01:38:34Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n`dump-signedexchange` can also operate on piped input. For instance, you could run the following command to retrieve a b3 signed exchange.\r\n```",
              "createdAt": "2019-06-12T01:49:33Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 17,
              "body": "```suggestion\r\nIf the specified URI requires a special header to serve a signed exchange, you can pass request headers via the `-requestHeader` flag. The header key and value should be separated by a `:`.\r\n```",
              "createdAt": "2019-06-12T01:53:02Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nWhen the `-uri` flag is passed to `dump-signedexchange`, you can specify the sxg version to request by passing a `-version` flag. For instance, if you wanted to request a `1b2` signed exchange, you would run the following command. By default, the version is `1b3`.\r\n```",
              "createdAt": "2019-06-12T01:55:55Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            },
            {
              "originalPosition": 37,
              "body": "```suggestion\r\nIf you would like only the signature to be printed, pass the `-signature` flag.\r\n```",
              "createdAt": "2019-06-12T01:56:03Z",
              "updatedAt": "2019-06-12T22:05:43Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5MTAyMTMy",
          "commit": {
            "abbreviatedOid": "a38020b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2019-06-13T02:33:28Z",
          "updatedAt": "2019-06-13T02:33:28Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0a7d6e6a4014a1ef9d4f6b62ebc1cce67894a315",
      "headRepository": "EverlastingBugstopper/webpackage",
      "headRefName": "avery/dump-sxg",
      "headRefOid": "a38020b3671b17b5a20a865350d48a0b7a983aee",
      "mergeCommit": {
        "oid": "e9e2e3d4f4d6e906cdb4dadd8fa02197f949d09f"
      }
    },
    {
      "number": 437,
      "id": "MDExOlB1bGxSZXF1ZXN0MjgwNDI2NjE5",
      "title": "Fix minor typo",
      "url": "https://github.com/WICG/webpackage/pull/437",
      "state": "MERGED",
      "author": "nyaxt",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-05-20T14:53:42Z",
      "updatedAt": "2019-05-20T15:22:41Z",
      "closedAt": "2019-05-20T15:22:40Z",
      "mergedAt": "2019-05-20T15:22:40Z",
      "mergedBy": "nyaxt",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjM5NTY1OTM4",
          "commit": {
            "abbreviatedOid": "c7ef1c4"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-05-20T15:17:04Z",
          "updatedAt": "2019-05-20T15:17:04Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9634466eaf43068113c2648d76760c354f1f8192",
      "headRepository": "nyaxt/webpackage",
      "headRefName": "minortypo",
      "headRefOid": "c7ef1c4bce81c7d1d3a60d5c17df4dcd0afb3cd3",
      "mergeCommit": {
        "oid": "446016cf0033cd4d501ab558e4408bdecf3a3e8d"
      }
    },
    {
      "number": 439,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg1NjU1NDc4",
      "title": "dump-signedexchange: Refactor main.go",
      "url": "https://github.com/WICG/webpackage/pull/439",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Create certFetcher and verificationTime outside of jsonPrintHeaders()\r\n- Simplify initCertFetcher() function signature\r\n- Dump all signatures in the signature header",
      "createdAt": "2019-06-06T06:07:54Z",
      "updatedAt": "2019-06-06T09:17:00Z",
      "closedAt": "2019-06-06T09:16:49Z",
      "mergedAt": "2019-06-06T09:16:49Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ2Mzk2NDk1",
          "commit": {
            "abbreviatedOid": "985cb96"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-06-06T07:17:28Z",
          "updatedAt": "2019-06-06T07:17:28Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d618944953082234c6d789886a477f0cfddfa2a9",
      "headRepository": null,
      "headRefName": "dump-sxg",
      "headRefOid": "985cb963ed3739c66fd2cc3c173a840078197817",
      "mergeCommit": {
        "oid": "916c069dc6f791608b2358209766555fb8af0e1f"
      }
    },
    {
      "number": 440,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg2MzUxMzk2",
      "title": "sinature -> signature",
      "url": "https://github.com/WICG/webpackage/pull/440",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Fix typo in error message.",
      "createdAt": "2019-06-07T22:31:25Z",
      "updatedAt": "2020-08-07T18:36:50Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "916c069dc6f791608b2358209766555fb8af0e1f",
      "headRepository": "WICG/webpackage",
      "headRefName": "twifkak-sinature",
      "headRefOid": "2d852b49e1075ee8d8801b6dcac7ef794b0a5581",
      "closedAt": "2019-06-08T00:20:47Z",
      "mergedAt": "2019-06-08T00:20:47Z",
      "mergedBy": "irori",
      "mergeCommit": {
        "oid": "0a7d6e6a4014a1ef9d4f6b62ebc1cce67894a315"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ3MzQ1NTU3",
          "commit": {
            "abbreviatedOid": "2d852b4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-06-08T00:20:23Z",
          "updatedAt": "2019-06-08T00:20:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 443,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4MTQ0NjMy",
      "title": "Correct logic to display warnings on unused flags",
      "url": "https://github.com/WICG/webpackage/pull/443",
      "state": "MERGED",
      "author": "ibnesayeed",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Currently, the warning is displayed when unnecessary flags are not specified, but it should be the other way.",
      "createdAt": "2019-06-14T00:46:01Z",
      "updatedAt": "2019-06-14T05:14:35Z",
      "closedAt": "2019-06-14T05:14:35Z",
      "mergedAt": "2019-06-14T05:14:35Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NzExMzYw",
          "commit": {
            "abbreviatedOid": "97082b6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2019-06-14T05:14:18Z",
          "updatedAt": "2019-06-14T05:14:18Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e9e2e3d4f4d6e906cdb4dadd8fa02197f949d09f",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "97082b628b65b36ba6c9ef32da301c58f116e352",
      "mergeCommit": {
        "oid": "7affc71533cf856a28f463ccfb449ab9cf401801"
      }
    },
    {
      "number": 444,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjg4MjEyODUw",
      "title": "dump-certurl: Add check for certificate's validity period",
      "url": "https://github.com/WICG/webpackage/pull/444",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Print warning or error message if main certificate has a validity period\r\nlonger than 90 days.",
      "createdAt": "2019-06-14T07:27:11Z",
      "updatedAt": "2019-06-17T01:32:07Z",
      "closedAt": "2019-06-17T01:32:01Z",
      "mergedAt": "2019-06-17T01:32:01Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @yutakahirano",
          "createdAt": "2019-06-14T07:27:40Z",
          "updatedAt": "2019-06-14T07:27:40Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjQ5NzcyMDg2",
          "commit": {
            "abbreviatedOid": "1793d93"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-06-14T08:30:27Z",
          "updatedAt": "2019-06-14T08:30:27Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7affc71533cf856a28f463ccfb449ab9cf401801",
      "headRepository": null,
      "headRefName": "dump-certurl",
      "headRefOid": "1793d930cd66c6f00e2fa580d6303c63ca3a882d",
      "mergeCommit": {
        "oid": "a54fe21f9bc94c3d6b5d62ea94651cd7ba306ab8"
      }
    },
    {
      "number": 447,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyNjg2ODIw",
      "title": "Make dump-signedexchange show header integrity value",
      "url": "https://github.com/WICG/webpackage/pull/447",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This header integrity value will be used in \"allowed-alt-sxg\" link header to support subresource signed exchange loading.\r\n\r\nhttps://github.com/WICG/webpackage/issues/347#issuecomment-467743010",
      "createdAt": "2019-06-28T04:49:30Z",
      "updatedAt": "2019-06-28T07:43:16Z",
      "closedAt": "2019-06-28T07:43:16Z",
      "mergedAt": "2019-06-28T07:43:15Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "kumagi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "LGTM, It's very helpful feature for implementing subresource handling functions!",
          "createdAt": "2019-06-28T05:01:08Z",
          "updatedAt": "2019-06-28T05:01:08Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> Please re-run gofmt to fix indent around flag definitions.\r\n\r\ndone.\r\n",
          "createdAt": "2019-06-28T07:17:36Z",
          "updatedAt": "2019-06-28T07:17:36Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2019-06-28T07:43:04Z",
          "updatedAt": "2019-06-28T07:43:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg0MzQ3",
          "commit": {
            "abbreviatedOid": "8f2491b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T04:57:08Z",
          "updatedAt": "2019-06-28T05:05:53Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "I don't think we need a flag - always printing header integrity is fine.",
              "createdAt": "2019-06-28T04:57:09Z",
              "updatedAt": "2019-06-28T07:16:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg4MjY1",
          "commit": {
            "abbreviatedOid": "044a439"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T05:20:48Z",
          "updatedAt": "2019-06-28T05:20:48Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Done.\r\nMoved into \"if *flagHeaders {}\"",
              "createdAt": "2019-06-28T05:20:48Z",
              "updatedAt": "2019-06-28T07:16:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg5MDU1",
          "commit": {
            "abbreviatedOid": "044a439"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Please re-run gofmt to fix indent around flag definitions.",
          "createdAt": "2019-06-28T05:24:47Z",
          "updatedAt": "2019-06-28T05:24:47Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5c3b51f9d92a67e5bd3153c752e7fbc07a6ee41b",
      "headRepository": "horo-t/webpackage",
      "headRefName": "master",
      "headRefOid": "102cdb67bb3606c3ed5c18008bc8044cd9b900ed",
      "mergeCommit": {
        "oid": "dace65fc5feb2a23de1e3d71b16ba80fe3f7ca13"
      }
    },
    {
      "number": 448,
      "id": "MDExOlB1bGxSZXF1ZXN0MjkyNjg5NjA3",
      "title": "CBOR header key must not contain UPPERCASE alphabet",
      "url": "https://github.com/WICG/webpackage/pull/448",
      "state": "MERGED",
      "author": "kumagi",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://tools.ietf.org/html/draft-yasskin-http-origin-signed-responses-05#section-3.2\r\n\r\n```\r\nFor each response header field, the header field's lowercase name\r\n      as a byte string to the header field's value as a byte string.\r\n```\r\n\r\nWe should check response header's key does not contains uppercase name along with this spec.",
      "createdAt": "2019-06-28T05:09:17Z",
      "updatedAt": "2019-06-28T07:49:46Z",
      "closedAt": "2019-06-28T07:49:46Z",
      "mergedAt": "2019-06-28T07:49:46Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "kumagi",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I appended the same logic into `decodeRequestMap` too.",
          "createdAt": "2019-06-28T05:45:39Z",
          "updatedAt": "2019-06-28T05:45:39Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTg5NjM4",
          "commit": {
            "abbreviatedOid": "c4d2e0c"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Could you add the same check in `decodeRequestMap` too? Current version of SXG (b3) only have response headers, but b1 and b2 have request headers which also must be lower-cased.",
          "createdAt": "2019-06-28T05:27:47Z",
          "updatedAt": "2019-06-28T05:35:24Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Please assign `string(key)` to a temporary variable and use it here and line 209 ([]byte -> string conversion makes a copy).",
              "createdAt": "2019-06-28T05:27:47Z",
              "updatedAt": "2019-06-28T05:43:27Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NTkyNjQ1",
          "commit": {
            "abbreviatedOid": "b3b5fd8"
          },
          "author": "kumagi",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-06-28T05:44:21Z",
          "updatedAt": "2019-06-28T05:44:21Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "OK, I'll assign it into `key_str`.",
              "createdAt": "2019-06-28T05:44:21Z",
              "updatedAt": "2019-06-28T05:44:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU1NjI4MTEw",
          "commit": {
            "abbreviatedOid": "b3b5fd8"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM, thanks!",
          "createdAt": "2019-06-28T07:48:59Z",
          "updatedAt": "2019-06-28T07:48:59Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5c3b51f9d92a67e5bd3153c752e7fbc07a6ee41b",
      "headRepository": "kumagi/webpackage",
      "headRefName": "master",
      "headRefOid": "b3b5fd8c817688fadcfceaa370774b9023d6f552",
      "mergeCommit": {
        "oid": "8c799580a0824503dd072114f67b634fe769fafc"
      }
    },
    {
      "number": 450,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk0NzM0NzA1",
      "title": "Update the bundle format",
      "url": "https://github.com/WICG/webpackage/pull/450",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/update-bundle-format/draft-yasskin-wpack-bundled-exchanges.html.\r\n\r\nSorry for the late mail: I belatedly realized the [IETF deadline](https://datatracker.ietf.org/meeting/105/important-dates/) is Monday, and it\u2019d be nice to have an update to the bundle format published then. We\u2019ll be able to publish another revision at the beginning of the IETF week.\r\n\r\nThis update includes:\r\n\r\n* An invariant fallback URL, like signed exchanges have.\r\n* A version number, so we can easily know to fall back to a redirect.\r\n* Some infrastructure to identify what kind of error broke the parse, which can feed into both Network Error Logging and #397\u2019s discussion of when to fall back.\r\n* The [index](https://jyasskin.github.io/webpackage/update-bundle-format/draft-yasskin-wpack-bundled-exchanges.html#index-section) maps URLs to a Variants value + a list of the responses for each possible Variant-Key.\r\n* A new [signatures](https://jyasskin.github.io/webpackage/update-bundle-format/draft-yasskin-wpack-bundled-exchanges.html#signatures-section) section allows authorities to vouch for particular subsets of the bundle. For cross-origin trust, which I think will get defined in the loading spec, I think the requirement that the validity-url is same-origin is going to force us to make those single-origin subsets, even when there might be a certificate that is trusted to sign multiple origins. I\u2019ve run the basic structure by @sleevi who liked that the signed fields are all together in a byte string.\r\n",
      "createdAt": "2019-07-05T05:01:01Z",
      "updatedAt": "2019-07-10T17:56:50Z",
      "closedAt": "2019-07-08T18:41:05Z",
      "mergedAt": "2019-07-08T18:41:05Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NjY0ODUx",
          "commit": {
            "abbreviatedOid": "dbb60f6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm from my side",
          "createdAt": "2019-07-08T02:27:00Z",
          "updatedAt": "2019-07-08T04:24:45Z",
          "comments": [
            {
              "originalPosition": 151,
              "body": "A \"format error\" with `fallbackUrl`?",
              "createdAt": "2019-07-08T02:27:00Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            },
            {
              "originalPosition": 320,
              "body": "Say that `location-in-responses` is the second and the third element of `responses`?",
              "createdAt": "2019-07-08T03:09:53Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            },
            {
              "originalPosition": 413,
              "body": "Remove \"N/A\"?",
              "createdAt": "2019-07-08T03:55:16Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU4NzgzNjE2",
          "commit": {
            "abbreviatedOid": "dbb60f6"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm % some comments.",
          "createdAt": "2019-07-08T09:24:43Z",
          "updatedAt": "2019-07-08T09:39:19Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "fallback URL == primaryUrl, is that right?  Felt it could be more clearly written out somewhere earlier than 3.3, step 21.",
              "createdAt": "2019-07-08T09:24:43Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            },
            {
              "originalPosition": 188,
              "body": "At this point we must have primaryUrl (or we can't return an error with fallbackUrl)?",
              "createdAt": "2019-07-08T09:29:58Z",
              "updatedAt": "2019-07-08T18:33:10Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MDQ5MDQ1",
          "commit": {
            "abbreviatedOid": "dbb60f6"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-08T17:25:44Z",
          "updatedAt": "2019-07-08T18:34:24Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Indeed, I've added a statement of that in 2.2.",
              "createdAt": "2019-07-08T17:25:44Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            },
            {
              "originalPosition": 151,
              "body": "Thanks, done.",
              "createdAt": "2019-07-08T18:27:59Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            },
            {
              "originalPosition": 188,
              "body": "Yep, I've moved this to an Assert on the previous line.",
              "createdAt": "2019-07-08T18:29:14Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            },
            {
              "originalPosition": 320,
              "body": "Good idea. Done.",
              "createdAt": "2019-07-08T18:30:59Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            },
            {
              "originalPosition": 413,
              "body": "Whoops, done.",
              "createdAt": "2019-07-08T18:31:12Z",
              "updatedAt": "2019-07-08T18:34:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5ODc4NTc2",
          "commit": {
            "abbreviatedOid": "a39514f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-10T05:40:31Z",
          "updatedAt": "2019-07-10T05:40:32Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Oh, I had overlooked this... Now the top-level array has 6 elements, so this should be \"86 48 ...\".",
              "createdAt": "2019-07-10T05:40:31Z",
              "updatedAt": "2019-07-10T05:40:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYwMjYxMjky",
          "commit": {
            "abbreviatedOid": "a39514f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-10T17:56:49Z",
          "updatedAt": "2019-07-10T17:56:50Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Thanks! https://github.com/WICG/webpackage/pull/454",
              "createdAt": "2019-07-10T17:56:50Z",
              "updatedAt": "2019-07-10T17:56:50Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "812b981c2cc039d77b01d61727b60b4d78f22579",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-bundle-format",
      "headRefOid": "a39514f0f0a992be817eff70faaaa2c3f16fa441",
      "mergeCommit": {
        "oid": "744dffc6eccbc3d3bd9627e9d7ce89eca3d994dd"
      }
    },
    {
      "number": 451,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NTIwNDg3",
      "title": "Update load-response for the new return value of load-metadata.",
      "url": "https://github.com/WICG/webpackage/pull/451",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This should just be a bookkeeping change, so I'm going to merge it right away to make the IETF deadline, but please let me know if I got any of these changes wrong, and I'll fix them later.\r\n\r\nPreview at https://jyasskin.github.io/webpackage/update-load-response/draft-yasskin-wpack-bundled-exchanges.html#semantics-load-response.",
      "createdAt": "2019-07-08T22:35:11Z",
      "updatedAt": "2019-07-09T05:02:43Z",
      "closedAt": "2019-07-08T22:41:59Z",
      "mergedAt": "2019-07-08T22:41:59Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5MjY5OTQz",
          "commit": {
            "abbreviatedOid": "d492607"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2019-07-09T05:02:43Z",
          "updatedAt": "2019-07-09T05:02:43Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "91f590255b177c7ad14309df560c8ed1767c7499",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-load-response",
      "headRefOid": "d4926078f5b7f15f87ad273830b89f811fc6b42b",
      "mergeCommit": {
        "oid": "66acc74e9fb597d3fbdca9c2bf4cdb04418e684b"
      }
    },
    {
      "number": 452,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1NTM2NTgw",
      "title": "Improve impl 03",
      "url": "https://github.com/WICG/webpackage/pull/452",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/improve-impl-03/draft-yasskin-httpbis-origin-signed-exchanges-impl.html. Have I missed anything in describing how Chrome uses the b3 format? I'll publish -impl-03 on July 21.",
      "createdAt": "2019-07-08T23:59:42Z",
      "updatedAt": "2019-07-22T14:39:55Z",
      "closedAt": "2019-07-22T14:39:53Z",
      "mergedAt": "2019-07-22T14:39:53Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks @irori. That's fixed now.",
          "createdAt": "2019-07-10T16:48:43Z",
          "updatedAt": "2019-07-10T16:48:43Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5Mzc3NjEw",
          "commit": {
            "abbreviatedOid": "3519551"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\n> Have I missed anything in describing how Chrome uses the b3 format?\r\n\r\nI only see just one minor thing; otherwise I think this matches Chrome's behavior.\r\n\r\nSection 5.3. application/signed-exchange format\r\n> 1. 8 bytes consisting of the ASCII characters \u201csxg1-b3\u201d followed by a 0 byte, to serve as a file signature. This is redundant with the MIME type, and recipients that receive both MUST check that they match and stop parsing if they don\u2019t. \r\n\r\nChrome continues parsing until `fallbackUrl`, to perform fallback redirect in this case (version mismatch).\r\n",
          "createdAt": "2019-07-09T09:26:54Z",
          "updatedAt": "2019-07-09T09:26:54Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7e56fde70663ad69b3fa2a3a793cb3acf47bce4e",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "improve-impl-03",
      "headRefOid": "df944bcc5aabcad9e10fa4c338610e7320bbee72",
      "mergeCommit": {
        "oid": "a13fb075b11c23361dd2c92584e28b7b96b4c2d3"
      }
    },
    {
      "number": 453,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk1ODk3NDAy",
      "title": "Provide error message for unexpected mime type",
      "url": "https://github.com/WICG/webpackage/pull/453",
      "state": "MERGED",
      "author": "EverlastingBugstopper",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When fetching with the `-uri` flag, the go http client can give us a more helpful error message than `unknown magic bytes: [60 33 100 111 99 116 121 112]`\r\n\r\nThis PR checks the mime type of the response against the expected mime type for the version it is requesting and if they do not equal, it will error with `GET \"https://example.com\" responded with unexpected content type \"text/html; charset=utf-8\"`",
      "createdAt": "2019-07-09T19:56:24Z",
      "updatedAt": "2019-07-16T05:25:47Z",
      "closedAt": "2019-07-16T05:25:47Z",
      "mergedAt": "2019-07-16T05:25:47Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjU5ODQxMDQ5",
          "commit": {
            "abbreviatedOid": "31cc678"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-07-10T02:15:17Z",
          "updatedAt": "2019-07-10T02:15:17Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cc0ae8aaf6eb64b4487e0d5369588670e216c9fd",
      "headRepository": "EverlastingBugstopper/webpackage",
      "headRefName": "avery/dump-sxg-check-content-type",
      "headRefOid": "31cc678dd02841882c4e17b541a0d95af648133c",
      "mergeCommit": {
        "oid": "9192e36144b4234e7818401a9d0b2bd9c07a516b"
      }
    },
    {
      "number": 454,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk2MjgxMDM2",
      "title": "Use the right initial byte for the top-level 6-element array.",
      "url": "https://github.com/WICG/webpackage/pull/454",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks irori for noticing!",
      "createdAt": "2019-07-10T17:56:41Z",
      "updatedAt": "2019-07-22T14:37:52Z",
      "closedAt": "2019-07-22T14:37:50Z",
      "mergedAt": "2019-07-22T14:37:50Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYwNDI2MDQw",
          "commit": {
            "abbreviatedOid": "e37aefc"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm % comment",
          "createdAt": "2019-07-11T01:06:36Z",
          "updatedAt": "2019-07-11T01:06:53Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Magic number in Section 6.1 should be updated as well.\r\n",
              "createdAt": "2019-07-11T01:06:36Z",
              "updatedAt": "2019-07-22T14:27:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY0ODUzOTY4",
          "commit": {
            "abbreviatedOid": "07c00e4"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-22T14:28:42Z",
          "updatedAt": "2019-07-22T14:28:43Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done, thanks.",
              "createdAt": "2019-07-22T14:28:42Z",
              "updatedAt": "2019-07-22T14:28:43Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7e56fde70663ad69b3fa2a3a793cb3acf47bce4e",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fix-bundles-array",
      "headRefOid": "07c00e475cf8a6c93e3bc9515a58da2f412b05b8",
      "mergeCommit": {
        "oid": "16c93ae2d24574c2097b9ebb527f9976a4b77584"
      }
    },
    {
      "number": 455,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk2Mjg5Nzk1",
      "title": "Fix a couple badly-padded base64 strings.",
      "url": "https://github.com/WICG/webpackage/pull/455",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Thanks @yuizumi!",
      "createdAt": "2019-07-10T18:23:45Z",
      "updatedAt": "2019-08-09T18:38:15Z",
      "closedAt": "2019-08-09T18:38:04Z",
      "mergedAt": "2019-08-09T18:38:04Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyOTE0NTM3",
          "commit": {
            "abbreviatedOid": "64b0c0e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-09T01:55:44Z",
          "updatedAt": "2019-08-09T01:55:44Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cc0ae8aaf6eb64b4487e0d5369588670e216c9fd",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "base64-format",
      "headRefOid": "64b0c0ed78d666053bb3130ed30b190df18a1006",
      "mergeCommit": {
        "oid": "2a8bef651eaa218886b2e51520cc1f44b2a862c9"
      }
    },
    {
      "number": 456,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3NzU4OTE0",
      "title": "Delete buick.png",
      "url": "https://github.com/WICG/webpackage/pull/456",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It is unused, and its creation commit offers no hint of its purpose.",
      "createdAt": "2019-07-15T19:38:18Z",
      "updatedAt": "2019-07-15T20:41:31Z",
      "closedAt": "2019-07-15T20:41:27Z",
      "mergedAt": "2019-07-15T20:41:27Z",
      "mergedBy": "twifkak",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMDM1MTI1",
          "commit": {
            "abbreviatedOid": "7826b3c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks. The use was removed in #131.",
          "createdAt": "2019-07-15T19:45:29Z",
          "updatedAt": "2019-07-15T19:45:29Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "cc0ae8aaf6eb64b4487e0d5369588670e216c9fd",
      "headRepository": "WICG/webpackage",
      "headRefName": "twifkak-rm-buick",
      "headRefOid": "7826b3ce8c32d0d6881b0eb30e67ed5a2454c073",
      "mergeCommit": {
        "oid": "06c454bd70fac4738501db252eeaebad8f29dbc0"
      }
    },
    {
      "number": 457,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3ODA2MzE3",
      "title": "`dump-signedexchange -verify`: decode MICE again.",
      "url": "https://github.com/WICG/webpackage/pull/457",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This functionality was reverted in #429 (I think unintentionally);\r\nre-enabling, to allow use of this tool as a hacky way to extract\r\nMICE-decoded payload, via something like:\r\n\r\n$ cat sxg | dump-signedexchange -verify | sed '0,/^payload /d' >html",
      "createdAt": "2019-07-15T22:12:57Z",
      "updatedAt": "2019-07-16T04:59:58Z",
      "closedAt": "2019-07-16T04:59:58Z",
      "mergedAt": "2019-07-16T04:59:58Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMTExODk0",
          "commit": {
            "abbreviatedOid": "453a4ca"
          },
          "author": "EverlastingBugstopper",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "oops \ud83d\ude1b ",
          "createdAt": "2019-07-15T22:42:58Z",
          "updatedAt": "2019-07-15T22:42:58Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMTg3NzE1",
          "commit": {
            "abbreviatedOid": "453a4ca"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-07-16T04:59:38Z",
          "updatedAt": "2019-07-16T04:59:38Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "06c454bd70fac4738501db252eeaebad8f29dbc0",
      "headRepository": "twifkak/webpackage",
      "headRefName": "dump-decodemice",
      "headRefOid": "453a4cad84a40713f8a0d2d8cc4cf2456c8ea733",
      "mergeCommit": {
        "oid": "fac26ae7b30f8fd1a68efeb62dcf8eb6565a508e"
      }
    },
    {
      "number": 458,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3OTA2NzU5",
      "title": "go/bundle: Add support for multiple versions",
      "url": "https://github.com/WICG/webpackage/pull/458",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a preparation for supporting the new bundle format (#450).\r\n\r\n- Introduces `Version` type to represent spec versions. `version.Unversioned` represents the old format before #450.\r\n- `gen-bundle` now accepts `-version` flag. Note that it doesn't generate valid bundle in the new format yet.",
      "createdAt": "2019-07-16T07:17:01Z",
      "updatedAt": "2019-07-18T07:38:30Z",
      "closedAt": "2019-07-18T07:38:24Z",
      "mergedAt": "2019-07-18T07:38:24Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @yutakahirano @toyoshim",
          "createdAt": "2019-07-16T07:28:09Z",
          "updatedAt": "2019-07-16T07:28:09Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@nyaxt @hajimehoshi PTAL when you have time.",
          "createdAt": "2019-07-18T02:28:03Z",
          "updatedAt": "2019-07-18T02:28:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMjI1NTQ2",
          "commit": {
            "abbreviatedOid": "7ba49dd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-16T07:17:26Z",
          "updatedAt": "2019-07-16T07:17:26Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "@jyasskin What implementation-specific version string should we use?",
              "createdAt": "2019-07-16T07:17:26Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzMjUzOTU5",
          "commit": {
            "abbreviatedOid": "40a5980"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-17T18:58:29Z",
          "updatedAt": "2019-07-17T18:58:30Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "I\u2019d take \u201cb1\\0\\0\u201d for now, roughly matching signed exchanges.",
              "createdAt": "2019-07-17T18:58:30Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzNDAyNjYw",
          "commit": {
            "abbreviatedOid": "40a5980"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-18T02:27:23Z",
          "updatedAt": "2019-07-18T02:27:24Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "OK, let's use \"b1\\0\\0\" for now.",
              "createdAt": "2019-07-18T02:27:24Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzNDcwNzUx",
          "commit": {
            "abbreviatedOid": "40a5980"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm w/ nits",
          "createdAt": "2019-07-18T07:24:39Z",
          "updatedAt": "2019-07-18T07:25:54Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "The comment should start with `HeaderMagicBytesUnversioned is ...`",
              "createdAt": "2019-07-18T07:24:39Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            },
            {
              "originalPosition": 24,
              "body": "ditto",
              "createdAt": "2019-07-18T07:24:45Z",
              "updatedAt": "2019-07-18T07:33:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzNDc1NDky",
          "commit": {
            "abbreviatedOid": "bd71e13"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-18T07:35:21Z",
          "updatedAt": "2019-07-18T07:35:39Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "done.",
              "createdAt": "2019-07-18T07:35:21Z",
              "updatedAt": "2019-07-18T07:35:39Z"
            },
            {
              "originalPosition": 24,
              "body": "done.",
              "createdAt": "2019-07-18T07:35:27Z",
              "updatedAt": "2019-07-18T07:35:39Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9192e36144b4234e7818401a9d0b2bd9c07a516b",
      "headRepository": null,
      "headRefName": "version",
      "headRefOid": "bd71e139f8b443f93c56280eedb7adfd75a2c65d",
      "mergeCommit": {
        "oid": "d212ecba5d90057e3664b6ba430b7f8774b2d826"
      }
    },
    {
      "number": 459,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk3OTIyMjc2",
      "title": "certs.go: Remove PKCS#1 handling in parsePrivateKeyBlock()",
      "url": "https://github.com/WICG/webpackage/pull/459",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This was a leftover from RSA keys support, which was removed in #330.",
      "createdAt": "2019-07-16T08:06:59Z",
      "updatedAt": "2019-07-17T00:53:54Z",
      "closedAt": "2019-07-17T00:53:49Z",
      "mergedAt": "2019-07-17T00:53:49Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMzA3Nzkw",
          "commit": {
            "abbreviatedOid": "b15659f"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-16T09:56:18Z",
          "updatedAt": "2019-07-16T09:56:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYyMzgwOTIx",
          "commit": {
            "abbreviatedOid": "b15659f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-16T12:32:54Z",
          "updatedAt": "2019-07-16T12:32:54Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9192e36144b4234e7818401a9d0b2bd9c07a516b",
      "headRepository": null,
      "headRefName": "pkcs1",
      "headRefOid": "b15659f6d268aca36fde16428a50d7de507e690c",
      "mergeCommit": {
        "oid": "52cbfdcac917bf0109b99324360f9e1b5e4d83d1"
      }
    },
    {
      "number": 460,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk4Nzk0MDk2",
      "title": "go/bundle: Move decoder / encoder code to separate files",
      "url": "https://github.com/WICG/webpackage/pull/460",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This patch splits `bundle.go` into three files:\r\n\r\n- `bundle.go` - definition of common data types and some utility functions\r\n- `encoder.go` - bundle generation code\r\n- `decoder.go` - bundle parsing code\r\n\r\nCode moves only, no functional changes.\r\n",
      "createdAt": "2019-07-18T07:51:11Z",
      "updatedAt": "2019-07-18T08:04:08Z",
      "closedAt": "2019-07-18T08:03:48Z",
      "mergedAt": "2019-07-18T08:03:48Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @toyoshim @yutakahirano",
          "createdAt": "2019-07-18T07:51:48Z",
          "updatedAt": "2019-07-18T07:51:48Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the quick review!",
          "createdAt": "2019-07-18T08:04:04Z",
          "updatedAt": "2019-07-18T08:04:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjYzNDg3MzA2",
          "commit": {
            "abbreviatedOid": "5a15e6d"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-18T08:00:15Z",
          "updatedAt": "2019-07-18T08:00:15Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d212ecba5d90057e3664b6ba430b7f8774b2d826",
      "headRepository": null,
      "headRefName": "split-bundle-go",
      "headRefOid": "5a15e6dae443d1e3411f105c8634159a5e6730e2",
      "mergeCommit": {
        "oid": "7e56fde70663ad69b3fa2a3a793cb3acf47bce4e"
      }
    },
    {
      "number": 461,
      "id": "MDExOlB1bGxSZXF1ZXN0Mjk4ODI2MDAx",
      "title": "go/bundle: Add support for PrimaryURL (aka fallbackURL)",
      "url": "https://github.com/WICG/webpackage/pull/461",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Adds `PrimaryURL` field to `Bundle` struct, and adds parsing / serializing code for that\r\n- Updates loadMetadata() to reflect the spec changes of #450\r\n  - Now it returns a fallback URL if available\r\n  - Updated spec ref comments\r\n",
      "createdAt": "2019-07-18T09:23:11Z",
      "updatedAt": "2019-07-24T04:53:35Z",
      "closedAt": "2019-07-24T04:53:25Z",
      "mergedAt": "2019-07-24T04:53:25Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @toyoshim @yutakahirano",
          "createdAt": "2019-07-18T09:23:35Z",
          "updatedAt": "2019-07-18T09:23:35Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for the review!",
          "createdAt": "2019-07-24T04:53:32Z",
          "updatedAt": "2019-07-24T04:53:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NTE1NDMx",
          "commit": {
            "abbreviatedOid": "515a2c1"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-23T16:02:14Z",
          "updatedAt": "2019-07-23T16:12:06Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "I'd like to keep `error` as the last return arg list.\r\n\r\ntwo ideas:\r\n1. reorder the return arg list, or\r\n2. create a struct which implements error interface, which allows fallbackUrl extraction",
              "createdAt": "2019-07-23T16:02:14Z",
              "updatedAt": "2019-07-24T01:34:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NzU0NzA0",
          "commit": {
            "abbreviatedOid": "25135da"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-07-24T01:36:51Z",
          "updatedAt": "2019-07-24T01:36:51Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Created LoadMetadataError struct which embeds an error interface.",
              "createdAt": "2019-07-24T01:36:51Z",
              "updatedAt": "2019-07-24T01:36:51Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1NzYzODEy",
          "commit": {
            "abbreviatedOid": "25135da"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-24T02:23:00Z",
          "updatedAt": "2019-07-24T02:23:00Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7e56fde70663ad69b3fa2a3a793cb3acf47bce4e",
      "headRepository": null,
      "headRefName": "primary-url",
      "headRefOid": "25135dae5fa303b2e5170ec19610911e54db1a65",
      "mergeCommit": {
        "oid": "a3cef2cd86053aef5f1d8805d1e4d93c78366a9f"
      }
    },
    {
      "number": 464,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwMDM0MzIz",
      "title": "Pin -impl-03 on header-structure-10.",
      "url": "https://github.com/WICG/webpackage/pull/464",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Preview at https://jyasskin.github.io/webpackage/impl-03-on-header-structure-10/draft-yasskin-httpbis-origin-signed-exchanges-impl.html. This was needed because header-structure released a -11 which isn't used by the sxg-03 implementations.",
      "createdAt": "2019-07-22T20:51:31Z",
      "updatedAt": "2019-07-23T01:52:35Z",
      "closedAt": "2019-07-23T01:52:33Z",
      "mergedAt": "2019-07-23T01:52:33Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY1MTM2NTM0",
          "commit": {
            "abbreviatedOid": "a98eca4"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-07-23T01:48:48Z",
          "updatedAt": "2019-07-23T01:48:48Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a13fb075b11c23361dd2c92584e28b7b96b4c2d3",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "impl-03-on-header-structure-10",
      "headRefOid": "a98eca4fcca4092a2cf1932e6b923cc6a9c229cb",
      "mergeCommit": {
        "oid": "74caee6c9abaa8a753b5592c157b57911cac9518"
      }
    },
    {
      "number": 466,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwNTc3MTIy",
      "title": "go/bundle: Add support for the new index section format",
      "url": "https://github.com/WICG/webpackage/pull/466",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds parsing / serializing code of the index section in the new (b1) format (#450).\r\nCurrently, multiple responses for a single URL is not supported.\r\n\r\nAfter this patch, gen-bundle generates valid bundles in b1 format.\r\n\r\ncc: @toyoshim @yutakahirano",
      "createdAt": "2019-07-24T06:23:11Z",
      "updatedAt": "2019-08-06T01:47:18Z",
      "closedAt": "2019-08-06T01:47:10Z",
      "mergedAt": "2019-08-06T01:47:10Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@hajimehoshi @nyaxt PTAL when you have time.\r\nThanks!",
          "createdAt": "2019-07-30T07:55:28Z",
          "updatedAt": "2019-07-30T07:55:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcwNzU1MDM3",
          "commit": {
            "abbreviatedOid": "a9e5b8a"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-05T13:09:26Z",
          "updatedAt": "2019-08-05T13:23:20Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Optional Nit: make err msg prefix consistent with others?\r\n\"bundle.index: Failed to...\"",
              "createdAt": "2019-08-05T13:09:26Z",
              "updatedAt": "2019-08-06T01:08:09Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcxMDcyOTE1",
          "commit": {
            "abbreviatedOid": "1878af5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-06T01:09:45Z",
          "updatedAt": "2019-08-06T01:09:46Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Done.",
              "createdAt": "2019-08-06T01:09:46Z",
              "updatedAt": "2019-08-06T01:09:46Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a3cef2cd86053aef5f1d8805d1e4d93c78366a9f",
      "headRepository": null,
      "headRefName": "newfmt",
      "headRefOid": "1878af531b3856525bfbde11a81f9f70df2f4cdd",
      "mergeCommit": {
        "oid": "31e18476e9280b1c96988fbb851b85597554d998"
      }
    },
    {
      "number": 467,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAwODU2Njk4",
      "title": "Replace the second -impl author with Kunihiko, who's now in charge of implementation.",
      "url": "https://github.com/WICG/webpackage/pull/467",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-07-24T19:09:01Z",
      "updatedAt": "2019-07-25T03:27:47Z",
      "closedAt": "2019-07-25T03:27:45Z",
      "mergedAt": "2019-07-25T03:27:45Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY2MzgzMzQy",
          "commit": {
            "abbreviatedOid": "fcfdf8f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-07-25T03:24:00Z",
          "updatedAt": "2019-07-25T03:24:00Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a3cef2cd86053aef5f1d8805d1e4d93c78366a9f",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "change-author",
      "headRefOid": "fcfdf8fa4e766fab70872525440192a51056c0aa",
      "mergeCommit": {
        "oid": "5d96740b2ff9ab62d0afc27b6130dd525f1d3588"
      }
    },
    {
      "number": 474,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAyNDIxMjU2",
      "title": "Update go/signedexchange/README.md",
      "url": "https://github.com/WICG/webpackage/pull/474",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Use `-days 90` when creating a self-signed certificate, as certificate\r\nlifetime is limited to maximum 90 days. (#383)",
      "createdAt": "2019-07-30T09:57:34Z",
      "updatedAt": "2019-07-31T05:29:56Z",
      "closedAt": "2019-07-31T05:29:50Z",
      "mergedAt": "2019-07-31T05:29:50Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY4NzkxMjcx",
          "commit": {
            "abbreviatedOid": "e0a55a8"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-07-31T05:29:00Z",
          "updatedAt": "2019-07-31T05:29:00Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "5d96740b2ff9ab62d0afc27b6130dd525f1d3588",
      "headRepository": null,
      "headRefName": "readme",
      "headRefOid": "e0a55a80ee59c3f61407fb1c71069a481772a8cb",
      "mergeCommit": {
        "oid": "ce24b25d587c891a45aa6602fef2ded1854d45fa"
      }
    },
    {
      "number": 475,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAzMjMyMjI4",
      "title": "CBOR decoder: block  resource exhaustion attacks",
      "url": "https://github.com/WICG/webpackage/pull/475",
      "state": "MERGED",
      "author": "tomokinat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "As stated in https://tools.ietf.org/html/rfc7049#section-8, CBOR decoder should be careful about resource exhaustion attacks. Typical one could be passing `0x5BFFFFFFFFFFFFFFFF`, a header saying \"I am a byte string of length 2^64 - 1\", without actual data followed.\r\n\r\nCurrent implementation allocates memory for following bytes exactly as the header requested:\r\nhttps://github.com/WICG/webpackage/blob/ce24b25d587c891a45aa6602fef2ded1854d45fa/go/signedexchange/cbor/decoder.go#L93-L98\r\n\r\nFor instance, Chromium checks the size of rest bytes beforehand to defend against this:\r\nhttps://github.com/chromium/chromium/blob/6efa1184771ace08f3e2162b0255c93526d1750d/components/cbor/reader.cc#L352-L355\r\n\r\nDisclaimer: I'm not familiar with golang so if there is any better solution, please go that way.\r\n\r\nGolang's `io.Reader` seems a sort of \"stream\" interface therefore the same solution cannot be applicable.\r\nAlternatives could be\r\n- Stop using `io.Reader`\r\n- Read byte by byte into growing buffer\r\n- Try to read by doubling the size (read 1 byte, 2 byte, 4byte, 8 byte...)\r\n(The last two are almost same in terms of amortized complexity trick but the latter can be faster if the read operation costs)\r\n\r\nCurrent choice is to use `bytes.Buffer`, which is, to my understanding, a wrapped growing byte vector which can behave as `io.Writer`. That's because changing to this is super-easy and doesn't cost computation time a lot, very similar to the second solution above.\r\n\r\n",
      "createdAt": "2019-08-01T06:12:33Z",
      "updatedAt": "2019-08-01T07:50:25Z",
      "closedAt": "2019-08-01T07:50:25Z",
      "mergedAt": "2019-08-01T07:50:25Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thank you for reviewing! I added one.",
          "createdAt": "2019-08-01T07:46:26Z",
          "updatedAt": "2019-08-01T07:46:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5NDI0MDcz",
          "commit": {
            "abbreviatedOid": "9c563eb"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you! Code change lgtm.\r\n\r\nWould you add a test in `decoder_test.go` which just checks that the decoder doesn't crash on such an input?\r\n",
          "createdAt": "2019-08-01T06:47:56Z",
          "updatedAt": "2019-08-01T06:47:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5NDQ4NTg0",
          "commit": {
            "abbreviatedOid": "8a25098"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-08-01T07:49:32Z",
          "updatedAt": "2019-08-01T07:49:32Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ce24b25d587c891a45aa6602fef2ded1854d45fa",
      "headRepository": null,
      "headRefName": "cbor-resource-management",
      "headRefOid": "8a250980717a0d57c855fd5212dc67fd0c78573a",
      "mergeCommit": {
        "oid": "0852609cfcf6e9b97d1edd18c6a791893ab4945b"
      }
    },
    {
      "number": 476,
      "id": "MDExOlB1bGxSZXF1ZXN0MzAzMjYyMTg2",
      "title": "Fix error message: mix-up between encode and decode",
      "url": "https://github.com/WICG/webpackage/pull/476",
      "state": "MERGED",
      "author": "tomokinat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "While working on #475 I happened to find tiny errata in the file.",
      "createdAt": "2019-08-01T07:52:15Z",
      "updatedAt": "2019-08-01T07:55:55Z",
      "closedAt": "2019-08-01T07:55:55Z",
      "mergedAt": "2019-08-01T07:55:55Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjY5NDUwOTY3",
          "commit": {
            "abbreviatedOid": "301a1b3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-08-01T07:54:10Z",
          "updatedAt": "2019-08-01T07:54:10Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0852609cfcf6e9b97d1edd18c6a791893ab4945b",
      "headRepository": null,
      "headRefName": "cbor-decoder-test-typo",
      "headRefOid": "301a1b3b89cee547f70a026d02a9b19f32596998",
      "mergeCommit": {
        "oid": "87f7a4fe409239a61cdd8b5376e8d0a9f4851d71"
      }
    },
    {
      "number": 479,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDE0NzM0",
      "title": "gen-bundle: Better support for b1 and refactoring",
      "url": "https://github.com/WICG/webpackage/pull/479",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Behavioral changes:\r\n- -startURL flag is renamed to -primaryURL, and now it's required\r\n- -startURL and -manifestURL must be absolute\r\n\r\nNon-behavioral changes:\r\n- Move fromHar() and its helpers to a separate file (fromhar.go)\r\n- Now fromHar() and fromDir() return a list of exchanges\r\n",
      "createdAt": "2019-08-08T05:33:14Z",
      "updatedAt": "2019-08-08T07:34:12Z",
      "closedAt": "2019-08-08T07:34:12Z",
      "mergedAt": "2019-08-08T07:34:12Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "(Trying to re-run Travis CI)",
          "createdAt": "2019-08-08T07:25:45Z",
          "updatedAt": "2019-08-08T07:25:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyMzgyODgz",
          "commit": {
            "abbreviatedOid": "df78f5f"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T07:20:26Z",
          "updatedAt": "2019-08-08T07:20:26Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "31e18476e9280b1c96988fbb851b85597554d998",
      "headRepository": null,
      "headRefName": "gen-bundle",
      "headRefOid": "df78f5f2c2b2be9cd969ff2737b1eb8808d19174",
      "mergeCommit": {
        "oid": "100dfc8906675ebef22fefe8967c05649c7d85f2"
      }
    },
    {
      "number": 480,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDIxNDY2",
      "title": "cbor/encoder.go: EncodeMap() should fail on duplicated map keys",
      "url": "https://github.com/WICG/webpackage/pull/480",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-08T06:03:44Z",
      "updatedAt": "2019-08-08T07:17:19Z",
      "closedAt": "2019-08-08T07:17:14Z",
      "mergedAt": "2019-08-08T07:17:14Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyMzgwMDcy",
          "commit": {
            "abbreviatedOid": "856abb8"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T07:13:27Z",
          "updatedAt": "2019-08-08T07:13:27Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "31e18476e9280b1c96988fbb851b85597554d998",
      "headRepository": null,
      "headRefName": "cbor-enc",
      "headRefOid": "856abb858a645b644839f2a107c60885891f90d1",
      "mergeCommit": {
        "oid": "79cc3efcca4809edd3056af4b4d484875b9fc4c6"
      }
    },
    {
      "number": 481,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDg0NjU0",
      "title": "gen-bundle: Do not create multiple exchanges for single URL",
      "url": "https://github.com/WICG/webpackage/pull/481",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-08T09:20:31Z",
      "updatedAt": "2019-08-08T09:30:31Z",
      "closedAt": "2019-08-08T09:30:26Z",
      "mergedAt": "2019-08-08T09:30:25Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNDQ2NTEz",
          "commit": {
            "abbreviatedOid": "dae6384"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T09:23:55Z",
          "updatedAt": "2019-08-08T09:23:55Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "100dfc8906675ebef22fefe8967c05649c7d85f2",
      "headRepository": null,
      "headRefName": "dedup",
      "headRefOid": "dae63846d92e008d99a82cf5ccd0f4265a1eda95",
      "mergeCommit": {
        "oid": "f683f8883cd86c641b8d63c56165d6ecee2a52ea"
      }
    },
    {
      "number": 482,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDg1NzYz",
      "title": "gen-bundle: Remove warning for -primaryURL with -har",
      "url": "https://github.com/WICG/webpackage/pull/482",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Forgot to remove in #479.",
      "createdAt": "2019-08-08T09:23:13Z",
      "updatedAt": "2019-08-08T09:30:54Z",
      "closedAt": "2019-08-08T09:30:49Z",
      "mergedAt": "2019-08-08T09:30:49Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNDQ5NDY5",
          "commit": {
            "abbreviatedOid": "b4e9020"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T09:29:15Z",
          "updatedAt": "2019-08-08T09:29:15Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "100dfc8906675ebef22fefe8967c05649c7d85f2",
      "headRepository": null,
      "headRefName": "remove-warning",
      "headRefOid": "b4e9020e093bf6381cd3e70b499babe8aac8415c",
      "mergeCommit": {
        "oid": "3d6b2bf1877380a3b54b57948fed514887c9ec8d"
      }
    },
    {
      "number": 483,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NDg3MDY4",
      "title": "gen-bundle: Update the default format version to b1",
      "url": "https://github.com/WICG/webpackage/pull/483",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-08-08T09:26:32Z",
      "updatedAt": "2019-08-08T09:31:20Z",
      "closedAt": "2019-08-08T09:31:13Z",
      "mergedAt": "2019-08-08T09:31:13Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyNDQ5NTky",
          "commit": {
            "abbreviatedOid": "96d59cb"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-08T09:29:27Z",
          "updatedAt": "2019-08-08T09:29:27Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "100dfc8906675ebef22fefe8967c05649c7d85f2",
      "headRepository": null,
      "headRefName": "default-b1",
      "headRefOid": "96d59cbc5bcfd97b676b627a2029a68542d0eb3e",
      "mergeCommit": {
        "oid": "e3c4cffdd428216e6ec8dcc524a341f0148510c1"
      }
    },
    {
      "number": 484,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA1NzkzMjk2",
      "title": "Fix #445: Empty responses like redirections don't need a content type.",
      "url": "https://github.com/WICG/webpackage/pull/484",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Does this make sense?",
      "createdAt": "2019-08-09T00:20:07Z",
      "updatedAt": "2019-08-09T18:37:40Z",
      "closedAt": "2019-08-09T18:37:38Z",
      "mergedAt": "2019-08-09T18:37:38Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjcyOTE0MjYx",
          "commit": {
            "abbreviatedOid": "139e65e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-08-09T01:54:18Z",
          "updatedAt": "2019-08-09T01:54:18Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e3c4cffdd428216e6ec8dcc524a341f0148510c1",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "content-type-empty-payload",
      "headRefOid": "139e65ecd79d3a5de5de3cf5921882adc133dcbb",
      "mergeCommit": {
        "oid": "e84582f564fe5b7a90ad328e2aab2e01d7ab64a0"
      }
    },
    {
      "number": 485,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA3MTc2MzQx",
      "title": "Move go/signedexchange/internal/signingalgorithm package to go/internal/",
      "url": "https://github.com/WICG/webpackage/pull/485",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This package will be used from go/bundle too.",
      "createdAt": "2019-08-14T05:42:26Z",
      "updatedAt": "2019-08-14T10:40:30Z",
      "closedAt": "2019-08-14T06:20:54Z",
      "mergedAt": "2019-08-14T06:20:54Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0Njg1NjEy",
          "commit": {
            "abbreviatedOid": "607850d"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-14T06:18:56Z",
          "updatedAt": "2019-08-14T06:18:56Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc0ODAzMzI0",
          "commit": {
            "abbreviatedOid": "607850d"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "LGTM",
          "createdAt": "2019-08-14T10:40:30Z",
          "updatedAt": "2019-08-14T10:40:30Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2a8bef651eaa218886b2e51520cc1f44b2a862c9",
      "headRepository": null,
      "headRefName": "signingalgorithm",
      "headRefOid": "607850db9c9ea626f28240e6151d2ba8d330aac5",
      "mergeCommit": {
        "oid": "1a80a9b4826bd2fe208f3989ecc5c4ad24d78072"
      }
    },
    {
      "number": 486,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA3OTY0OTY2",
      "title": "go: Refactor certchain.go",
      "url": "https://github.com/WICG/webpackage/pull/486",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- `CertChainItem` struct is renamed to `AugmentedCertificate` (to match the spec).\r\n- Added methods that {encode,decode} an `AugmentedCertificate` {to,from}\r\n  `cbor.{Encoder,Decoder}`. These will be used from go/bundle to process the\r\n  signatures section.\r\n- Utility methods `Validate()` and `CertSha256()` are added.",
      "createdAt": "2019-08-16T07:02:15Z",
      "updatedAt": "2019-08-16T07:28:48Z",
      "closedAt": "2019-08-16T07:28:20Z",
      "mergedAt": "2019-08-16T07:28:20Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc1ODAyNDcy",
          "commit": {
            "abbreviatedOid": "18b9831"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-16T07:08:04Z",
          "updatedAt": "2019-08-16T07:10:05Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Would you describe what `AugmentedCertificate` is as a comment?",
              "createdAt": "2019-08-16T07:08:05Z",
              "updatedAt": "2019-08-16T07:22:19Z"
            },
            {
              "originalPosition": 16,
              "body": "(Would you add a specref?)",
              "createdAt": "2019-08-16T07:10:01Z",
              "updatedAt": "2019-08-16T07:22:19Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc1ODA3MjY5",
          "commit": {
            "abbreviatedOid": "ed747b2"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-16T07:23:14Z",
          "updatedAt": "2019-08-16T07:23:15Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Spec ref added.",
              "createdAt": "2019-08-16T07:23:14Z",
              "updatedAt": "2019-08-16T07:23:15Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "1a80a9b4826bd2fe208f3989ecc5c4ad24d78072",
      "headRepository": null,
      "headRefName": "certchain",
      "headRefOid": "ed747b29bf3b8a645dc40cc0e087598ab1f03f73",
      "mergeCommit": {
        "oid": "d865d4e2040fca062ed9d1b9f2087e20dbcee6f1"
      }
    },
    {
      "number": 487,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4NDIxNDg4",
      "title": "go: Refactor mice versioning code",
      "url": "https://github.com/WICG/webpackage/pull/487",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Pure refactoring, no behavioral changes.",
      "createdAt": "2019-08-19T02:28:51Z",
      "updatedAt": "2019-08-19T05:32:18Z",
      "closedAt": "2019-08-19T05:32:03Z",
      "mergedAt": "2019-08-19T05:32:03Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzIwMjA0",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T02:38:26Z",
          "updatedAt": "2019-08-19T02:38:32Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I was wondering if this change keeps this behavior.",
              "createdAt": "2019-08-19T02:38:27Z",
              "updatedAt": "2019-08-19T02:38:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzI2Mzk0",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T03:18:03Z",
          "updatedAt": "2019-08-19T03:18:03Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzI3Mjgy",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T03:23:54Z",
          "updatedAt": "2019-08-19T03:23:54Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Any counter examples? `IntegrityIdentifier()` returns `\"digest/mi-sha256-03\"` for `Draft03Encoding`, which matches `\"digest/\" + enc.ContentEncoding()`.",
              "createdAt": "2019-08-19T03:23:54Z",
              "updatedAt": "2019-08-19T03:23:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzQzNTQx",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T05:11:01Z",
          "updatedAt": "2019-08-19T05:11:05Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Hm, I could not see the assumption from this PR.",
              "createdAt": "2019-08-19T05:11:01Z",
              "updatedAt": "2019-08-19T05:11:05Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2MzQ3MDM5",
          "commit": {
            "abbreviatedOid": "bb1dfb9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-19T05:30:05Z",
          "updatedAt": "2019-08-19T05:30:05Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Well, the original code assumed that the digest algorithm and the HTTP content encoding share the same name. This holds for [http-mice-03](https://tools.ietf.org/html/draft-thomson-http-mice-03#section-6), but it's not necessarily true.",
              "createdAt": "2019-08-19T05:30:05Z",
              "updatedAt": "2019-08-19T05:30:05Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d865d4e2040fca062ed9d1b9f2087e20dbcee6f1",
      "headRepository": null,
      "headRefName": "mice-versioning",
      "headRefOid": "bb1dfb9f01e7a7dc90cdd65580eff555812e49a4",
      "mergeCommit": {
        "oid": "e341c118cb6c3487af4e7a415c7ed47d5654fb5e"
      }
    },
    {
      "number": 488,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4NTI2Nzgy",
      "title": "go/bundle: Implement encoder / decoder for the signatures section",
      "url": "https://github.com/WICG/webpackage/pull/488",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds data structures for the signature section [1], and encoder / decoder for the section. Signing and verification code will be added in follow-up PRs.\r\n\r\n[1] https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#signatures-section",
      "createdAt": "2019-08-19T09:42:51Z",
      "updatedAt": "2019-08-20T01:10:11Z",
      "closedAt": "2019-08-20T01:10:06Z",
      "mergedAt": "2019-08-20T01:10:06Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thank you for your review!",
          "createdAt": "2019-08-20T01:02:33Z",
          "updatedAt": "2019-08-20T01:02:33Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NDY3OTUw",
          "commit": {
            "abbreviatedOid": "3a4b250"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T10:24:31Z",
          "updatedAt": "2019-08-19T10:25:14Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "nit: You can write `{}` instead of `struct{}{}`",
              "createdAt": "2019-08-19T10:24:31Z",
              "updatedAt": "2019-08-20T01:01:59Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2NTkwNzYw",
          "commit": {
            "abbreviatedOid": "3a4b250"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-19T14:18:38Z",
          "updatedAt": "2019-08-19T14:18:38Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc2ODg1NzA1",
          "commit": {
            "abbreviatedOid": "6ac59c6"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-20T01:02:23Z",
          "updatedAt": "2019-08-20T01:02:23Z",
          "comments": [
            {
              "originalPosition": 107,
              "body": "Done.",
              "createdAt": "2019-08-20T01:02:23Z",
              "updatedAt": "2019-08-20T01:02:23Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e341c118cb6c3487af4e7a415c7ed47d5654fb5e",
      "headRepository": null,
      "headRefName": "signatures-section",
      "headRefOid": "6ac59c6bf652d5ca9390ef3e4eef8c7d506d3391",
      "mergeCommit": {
        "oid": "c8892c9f9027fd64b84be1162b9fe73826d05adc"
      }
    },
    {
      "number": 489,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4ODI1ODI5",
      "title": "Provisionally register media types.",
      "url": "https://github.com/WICG/webpackage/pull/489",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Once this is in, I'll send the actual requests to\r\nhttps://www.iana.org/form/media-types.",
      "createdAt": "2019-08-19T23:55:05Z",
      "updatedAt": "2019-09-26T23:04:54Z",
      "closedAt": "2019-09-04T04:54:30Z",
      "mergedAt": "2019-09-04T04:54:30Z",
      "mergedBy": "kinu",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgzMzc1MjY4",
          "commit": {
            "abbreviatedOid": "6a22190"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Sorry for the delay. This lgtm!",
          "createdAt": "2019-09-04T04:54:15Z",
          "updatedAt": "2019-09-04T04:54:15Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e341c118cb6c3487af4e7a415c7ed47d5654fb5e",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "provisional-registration",
      "headRefOid": "6a22190105ba49a27092a15664613ef1f2195acb",
      "mergeCommit": {
        "oid": "ab0e18a2113c41c99afc0fa39d75114324666b32"
      }
    },
    {
      "number": 490,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA4OTEyMjEz",
      "title": "go/bundle: Add sign-bundle tool",
      "url": "https://github.com/WICG/webpackage/pull/490",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds `sign-bundle` command line tool. It takes an existing bundle, a certificate chain (generated by `gen-certurl`) and a private key, and creates a new bundle with a \"signatures\" section added.\r\n\r\nThe generated signatures section includes a signature that covers all exchanges whose hostname matches the certificate. Also, this tool encodes those exchanges with the mi-sha256-03 content encoding.",
      "createdAt": "2019-08-20T07:27:28Z",
      "updatedAt": "2019-08-26T01:38:02Z",
      "closedAt": "2019-08-26T01:37:53Z",
      "mergedAt": "2019-08-26T01:37:53Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Could you review `signer.go` to see if the signing message is correct?",
          "createdAt": "2019-08-20T07:27:42Z",
          "updatedAt": "2019-08-20T07:27:42Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the reviews!",
          "createdAt": "2019-08-26T01:32:29Z",
          "updatedAt": "2019-08-26T01:32:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjU3MTU4",
          "commit": {
            "abbreviatedOid": "2d9897c"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Non-authoritative lgtm",
          "createdAt": "2019-08-22T08:14:53Z",
          "updatedAt": "2019-08-22T08:20:55Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "nit: thils -> this",
              "createdAt": "2019-08-22T08:14:53Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            },
            {
              "originalPosition": 27,
              "body": "a \"signed-subset\" structure",
              "createdAt": "2019-08-22T08:18:08Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjY4NDYx",
          "commit": {
            "abbreviatedOid": "6f1d017"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-22T08:36:33Z",
          "updatedAt": "2019-08-22T08:36:34Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "fixed",
              "createdAt": "2019-08-22T08:36:34Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjY4NTQx",
          "commit": {
            "abbreviatedOid": "6f1d017"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-22T08:36:41Z",
          "updatedAt": "2019-08-22T08:36:42Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "fixed",
              "createdAt": "2019-08-22T08:36:41Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4OTg3NjIx",
          "commit": {
            "abbreviatedOid": "6f1d017"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-23T13:09:08Z",
          "updatedAt": "2019-08-23T13:17:23Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Optional nit: we may want to copy main()/run() idiom: https://github.com/WICG/webpackage/blob/master/go/bundle/cmd/dump-bundle/main.go#L62",
              "createdAt": "2019-08-23T13:09:08Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc5MjUwODQx",
          "commit": {
            "abbreviatedOid": "6f1d017"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "The signature format looks right, thanks!",
          "createdAt": "2019-08-23T22:48:22Z",
          "updatedAt": "2019-08-23T22:52:45Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "I think this is ok, but it may lead to duplicate intermediate certificates in the authorities list.",
              "createdAt": "2019-08-23T22:48:22Z",
              "updatedAt": "2019-08-26T01:30:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc5MzY3NjY0",
          "commit": {
            "abbreviatedOid": "f50a840"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-26T01:30:42Z",
          "updatedAt": "2019-08-26T01:30:42Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Done.",
              "createdAt": "2019-08-26T01:30:42Z",
              "updatedAt": "2019-08-26T01:30:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc5MzY3ODE2",
          "commit": {
            "abbreviatedOid": "f50a840"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-26T01:32:01Z",
          "updatedAt": "2019-08-26T01:32:01Z",
          "comments": [
            {
              "originalPosition": 150,
              "body": "Added a TODO comment to deduplicate intermediate certificates.",
              "createdAt": "2019-08-26T01:32:01Z",
              "updatedAt": "2019-08-26T01:32:01Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c8892c9f9027fd64b84be1162b9fe73826d05adc",
      "headRepository": null,
      "headRefName": "sign-bundle",
      "headRefOid": "f50a8409f5e17a068f313b4e95d145754f1b579f",
      "mergeCommit": {
        "oid": "074074983dddbc331ddd752200b14d418b97b5f8"
      }
    },
    {
      "number": 491,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA5Nzc4NDU5",
      "title": "TravisCI: Run jobs in parallel",
      "url": "https://github.com/WICG/webpackage/pull/491",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a follow up to https://github.com/WICG/webpackage/pull/416.",
      "createdAt": "2019-08-22T04:43:26Z",
      "updatedAt": "2019-08-22T20:33:25Z",
      "closedAt": "2019-08-22T20:33:24Z",
      "mergedAt": "2019-08-22T20:33:24Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "OK, this seems to be working well.\r\nhttps://travis-ci.org/WICG/webpackage/builds/575171117",
          "createdAt": "2019-08-22T04:50:51Z",
          "updatedAt": "2019-08-22T04:50:51Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Thanks!",
          "createdAt": "2019-08-22T20:33:13Z",
          "updatedAt": "2019-08-22T20:33:13Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4NjcwNzQ0",
          "commit": {
            "abbreviatedOid": "a968db1"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-22T20:33:06Z",
          "updatedAt": "2019-08-22T20:33:06Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0b3180d4cfe99730a3677335aa5cb93435daa5a7",
      "headRepository": null,
      "headRefName": "travis",
      "headRefOid": "a968db1b9b32b5dcdf4de4f014503ef33445856a",
      "mergeCommit": {
        "oid": "d40a7e467dc5f0fbea81ab7859d8b084aa30515f"
      }
    },
    {
      "number": 492,
      "id": "MDExOlB1bGxSZXF1ZXN0MzA5ODMzMjY0",
      "title": "README: link to bundle tool",
      "url": "https://github.com/WICG/webpackage/pull/492",
      "state": "MERGED",
      "author": "proppy",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "- add link to bundle too\r\n- fix signedexchange `go install` url",
      "createdAt": "2019-08-22T08:12:08Z",
      "updatedAt": "2019-08-23T01:17:50Z",
      "closedAt": "2019-08-23T01:17:50Z",
      "mergedAt": "2019-08-23T01:17:50Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjU2NTk4",
          "commit": {
            "abbreviatedOid": "97d627b"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "The tools are still being updated but could be good to have links...",
          "createdAt": "2019-08-22T08:13:47Z",
          "updatedAt": "2019-08-22T08:13:47Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4MjY2NzE3",
          "commit": {
            "abbreviatedOid": "97d627b"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-22T08:33:09Z",
          "updatedAt": "2019-08-22T08:33:09Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mjc4NjcxMzQ3",
          "commit": {
            "abbreviatedOid": "97d627b"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-22T20:34:19Z",
          "updatedAt": "2019-08-22T20:34:19Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0b3180d4cfe99730a3677335aa5cb93435daa5a7",
      "headRepository": "proppy/webpackage",
      "headRefName": "patch-1",
      "headRefOid": "97d627bd24ed87bcd956535c9a69ac26d364a5ba",
      "mergeCommit": {
        "oid": "4f0c5b72d92cb5a9fcff2679fe6efaa34e43ae83"
      }
    },
    {
      "number": 493,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEwNzU2MjU0",
      "title": "go/bundle: Add signature verifier",
      "url": "https://github.com/WICG/webpackage/pull/493",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After this patch, `dump-bundle` tool will verify exchanges based on the\r\ncontent of the `signatures` section.\r\n\r\nThe `Dump` method in `bundle.go` is moved to `dump-bundle/main.go` to avoid\r\ncircular package dependency between `go/bundle` and `go/bundle/signature`.",
      "createdAt": "2019-08-26T04:17:16Z",
      "updatedAt": "2019-08-28T09:14:19Z",
      "closedAt": "2019-08-28T09:14:14Z",
      "mergedAt": "2019-08-28T09:14:14Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNjgxODg0",
          "commit": {
            "abbreviatedOid": "67af904"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-28T08:54:01Z",
          "updatedAt": "2019-08-28T08:55:12Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Is it OK not to take io.Writer?",
              "createdAt": "2019-08-28T08:54:01Z",
              "updatedAt": "2019-08-28T09:04:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNjg2MjU5",
          "commit": {
            "abbreviatedOid": "67af904"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-08-28T09:01:28Z",
          "updatedAt": "2019-08-28T09:01:29Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I think stdout-only is fine for now, as user can redirect the output.",
              "createdAt": "2019-08-28T09:01:28Z",
              "updatedAt": "2019-08-28T09:04:45Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0ba30c461d20ab2503a38301f548593613afb810",
      "headRepository": null,
      "headRefName": "verifier",
      "headRefOid": "602bf02f55325236577d6904acc05ea4dd48f866",
      "mergeCommit": {
        "oid": "d9710a2be33b4d4d1cc6425b52822b41045594eb"
      }
    },
    {
      "number": 494,
      "id": "MDExOlB1bGxSZXF1ZXN0MzExNzMzODkz",
      "title": "go/bundle: Fix CBOR type in signing message",
      "url": "https://github.com/WICG/webpackage/pull/494",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`variants-value` is a [byte string](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#index-section), not a text string.",
      "createdAt": "2019-08-28T08:50:06Z",
      "updatedAt": "2019-08-28T12:01:44Z",
      "closedAt": "2019-08-28T08:56:46Z",
      "mergedAt": "2019-08-28T08:56:46Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNjc5OTE1",
          "commit": {
            "abbreviatedOid": "e93cdb2"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-08-28T08:50:37Z",
          "updatedAt": "2019-08-28T08:50:37Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgwNzc3MzYy",
          "commit": {
            "abbreviatedOid": "e93cdb2"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2019-08-28T12:01:44Z",
          "updatedAt": "2019-08-28T12:01:44Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "074074983dddbc331ddd752200b14d418b97b5f8",
      "headRepository": null,
      "headRefName": "signature-fix",
      "headRefOid": "e93cdb21570b762c84a0185220a3f182864d4d92",
      "mergeCommit": {
        "oid": "0ba30c461d20ab2503a38301f548593613afb810"
      }
    },
    {
      "number": 495,
      "id": "MDExOlB1bGxSZXF1ZXN0MzEzNDMzODIy",
      "title": "gen-bundle: Add option to create a bundle from URL list",
      "url": "https://github.com/WICG/webpackage/pull/495",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After this patch, `gen-bundle -URLList urls.txt` will fetch URLs listed\r\nin `urls.txt` and create a bundle from their responses.\r\n",
      "createdAt": "2019-09-03T06:02:43Z",
      "updatedAt": "2019-09-03T07:17:33Z",
      "closedAt": "2019-09-03T07:17:27Z",
      "mergedAt": "2019-09-03T07:17:27Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgyNzc4MDgw",
          "commit": {
            "abbreviatedOid": "765b06e"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2019-09-03T06:17:39Z",
          "updatedAt": "2019-09-03T06:18:51Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "nit:\r\n\r\n# A line starting with '#' is a comment.",
              "createdAt": "2019-09-03T06:17:39Z",
              "updatedAt": "2019-09-03T06:25:01Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgyNzgwNzQy",
          "commit": {
            "abbreviatedOid": "4710bf3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-09-03T06:25:49Z",
          "updatedAt": "2019-09-03T06:25:49Z",
          "comments": [
            {
              "originalPosition": 35,
              "body": "done",
              "createdAt": "2019-09-03T06:25:49Z",
              "updatedAt": "2019-09-03T06:25:49Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MjgyNzk5MTI1",
          "commit": {
            "abbreviatedOid": "4710bf3"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-09-03T07:14:37Z",
          "updatedAt": "2019-09-03T07:14:37Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d9710a2be33b4d4d1cc6425b52822b41045594eb",
      "headRepository": null,
      "headRefName": "from-url-list",
      "headRefOid": "4710bf3c8efabcd45b806068e34985a50085770c",
      "mergeCommit": {
        "oid": "f55af48be5784a4bd82d32486103ff6b80251f4e"
      }
    },
    {
      "number": 501,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI0ODU0ODM4",
      "title": "Add a rough draft charter for the IETF WPACK WG.",
      "url": "https://github.com/WICG/webpackage/pull/501",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This is based on the problem statement and scope drafted in https://docs.google.com/document/d/1OUZcl6yQSJ5eZxMrbo6O2tVRW_U_bv0PZUxAVtR1GYA/edit and discussed at https://mailarchive.ietf.org/arch/msg/wpack/ctrnRXXda2X6z0Z6creNcTQX9AM.",
      "createdAt": "2019-10-04T21:23:25Z",
      "updatedAt": "2019-10-10T17:45:18Z",
      "closedAt": "2019-10-10T17:45:17Z",
      "mergedAt": "2019-10-10T17:45:17Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e5240d82bcfe504f8ee8b260d4770c319599f9f5",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "charter",
      "headRefOid": "37478cd092d333f7ae3686ea85d9ac0470236e5a",
      "mergeCommit": {
        "oid": "71829d8d5a56a46ef0b756168e71a51166a1dc96"
      }
    },
    {
      "number": 503,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI2OTIwMzM1",
      "title": "Add a pre-installation use case.",
      "url": "https://github.com/WICG/webpackage/pull/503",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I don't fully understand this use case, and why other solutions don't work well, so please suggest improvements.\r\n\r\n@bkardell @riju",
      "createdAt": "2019-10-10T20:40:13Z",
      "updatedAt": "2019-10-14T19:40:52Z",
      "closedAt": "2019-10-14T19:40:51Z",
      "mergedAt": "2019-10-14T19:40:51Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "riju",
          "authorAssociation": "NONE",
          "body": "I basically meant use cases like a Digital Signage, similar to [Chrome's kiosk mode](https://developer.chrome.com/apps/manifest/kiosk_enabled), without PlayStore/WebStore and user's ability to install apps. The device can be a Point of Sale device or a Shopping mall / Library Catalog system, usually single-purpose, where the app is managed by some admin. \r\n\r\nChrome Apps on CrOS in kiosk mode fills this gap, but if someone wants to run say, their downstream chromium on Linux and not use Chrome extensions but Web Standards, WebPackaging might help to pre-install their app in such a scenario.",
          "createdAt": "2019-10-11T11:44:48Z",
          "updatedAt": "2019-10-11T11:44:48Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "> I basically meant use cases like a Digital Signage, similar to [Chrome's kiosk mode](https://developer.chrome.com/apps/manifest/kiosk_enabled), without PlayStore/WebStore and user's ability to install apps. The device can be a Point of Sale device or a Shopping mall / Library Catalog system, usually single-purpose, where the app is managed by some admin.\r\n\r\nIf the device comes with web packaging in the way @jyasskin described in the change I think it'd work like that but are there something specifically more you wanted to see / evolve?",
          "createdAt": "2019-10-11T14:13:48Z",
          "updatedAt": "2019-10-11T14:13:48Z"
        },
        {
          "author": "bkardell",
          "authorAssociation": "NONE",
          "body": "I'd like to + in @zdobersek here..",
          "createdAt": "2019-10-11T15:44:08Z",
          "updatedAt": "2019-10-11T15:44:08Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@riju In the Digital Signage/Point of Sale/Shopping mall/Library Catalog case, would the device likely be completely disconnected from the internet? Or is it that it's easier to manage a single-app device by pushing the app to it, rather than hosting the app on a web server?\r\n\r\nIf these kiosk apps don't use the Service Worker mechanism to stay up to date, this may actually be a different use case than pre-installed apps.\r\n\r\nI'm also happy if you want to just send me the change to the text that you think would improve the description.\r\n\r\n",
          "createdAt": "2019-10-11T16:42:19Z",
          "updatedAt": "2019-10-11T16:42:19Z"
        },
        {
          "author": "bkardell",
          "authorAssociation": "NONE",
          "body": "@jyasskin I'm not entirely sure - It seems like connecting to the internet to stay up to date is optional in any case once you have the pwa? It's quite possible that you never update because the device works just fine and they have no interwebs... Is there a reason it requires an entirely different architecture or solution really?  It feels like it can fit the same model very well.  Of course, they don't do that now, or if they do they do some very custom/complex stuff to achieve it - but this is rather simple and elegant, it seems to me.",
          "createdAt": "2019-10-11T22:22:12Z",
          "updatedAt": "2019-10-11T22:23:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@bkardell I think the no-internet case is enabled by the yes-internet design, but because the package in that case is not really \"on the web\", I've had more trouble justifying why it should be an IETF goal. But maybe folks will be easier to convince than my mental model of them. :)",
          "createdAt": "2019-10-11T22:30:44Z",
          "updatedAt": "2019-10-11T22:30:44Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm going to merge this, but @riju, feel free to suggest changes at any point.",
          "createdAt": "2019-10-14T19:40:29Z",
          "updatedAt": "2019-10-14T19:40:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMzc1NDI4",
          "commit": {
            "abbreviatedOid": "0a29188"
          },
          "author": "bkardell",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-10T21:58:55Z",
          "updatedAt": "2019-10-10T21:58:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "it's also a pretty weird build step, isn't it?   If you built a million devices each of them would do some browsing before shipping?  and if you have actual user profiles that will be established somehow along the way, I'm not sure how that would work either.",
              "createdAt": "2019-10-10T21:58:55Z",
              "updatedAt": "2019-10-10T22:16:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwMzgwNTY3",
          "commit": {
            "abbreviatedOid": "0a29188"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-10T22:12:55Z",
          "updatedAt": "2019-10-10T22:12:55Z",
          "comments": [
            {
              "originalPosition": 27,
              "body": "Yeah, maybe you can build images from the post-browsing filesystem, but now all your cookies are shared. And the browser's out-of-box experience is gone.",
              "createdAt": "2019-10-10T22:12:55Z",
              "updatedAt": "2019-10-10T22:16:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAwNzEwNTk0",
          "commit": {
            "abbreviatedOid": "a9bafcd"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks for starting this, this aligns pretty much with what I've been thinking about.",
          "createdAt": "2019-10-11T14:08:56Z",
          "updatedAt": "2019-10-11T14:08:56Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "71829d8d5a56a46ef0b756168e71a51166a1dc96",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "pre-install-use-case",
      "headRefOid": "a9bafcd381913a0a4b5b047ccaa9ceb85ceda0e6",
      "mergeCommit": {
        "oid": "0f92cd90d8f1ca3546653a439e3a908a5b23a3e4"
      }
    },
    {
      "number": 504,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI3OTYyNjA1",
      "title": "Frontend compromise use case",
      "url": "https://github.com/WICG/webpackage/pull/504",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I think this describes the easier half of #425, with the second use case mentioned in https://github.com/WICG/webpackage/pull/425#pullrequestreview-300951626 left for another PR.\r\n\r\n@davidstrauss, does it make sense to use this instead of your PR?\r\n\r\nRendered version at https://jyasskin.github.io/webpackage/frontend-compromise-use-case/draft-yasskin-webpackage-use-cases.html#compromised-frontend.",
      "createdAt": "2019-10-14T20:35:54Z",
      "updatedAt": "2019-10-30T22:33:26Z",
      "closedAt": "2019-10-30T22:33:25Z",
      "mergedAt": "2019-10-30T22:33:25Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "davidstrauss",
          "authorAssociation": "NONE",
          "body": "> @davidstrauss, does it make sense to use this instead of your PR?\r\n\r\nI believe it does, yes. Thank you for the write-up!",
          "createdAt": "2019-10-17T21:02:43Z",
          "updatedAt": "2019-10-17T21:02:43Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0a9b47b58b3dbd995815792648ab43ef6315c3a1",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "frontend-compromise-use-case",
      "headRefOid": "132a8f05bf74355a817a39bb7530b82060248241",
      "mergeCommit": {
        "oid": "9ea647d78aefbb046bb95efe31ac9062d44be10e"
      }
    },
    {
      "number": 505,
      "id": "MDExOlB1bGxSZXF1ZXN0MzI4MTAwMjk4",
      "title": "Make manifest section of Bundled HTTP Exchanges optional",
      "url": "https://github.com/WICG/webpackage/pull/505",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently there is no need to make \"manifest\" section mandatory.\r\n\r\nChromium side CL: https://crrev.com/c/1861614\r\n",
      "createdAt": "2019-10-15T06:31:50Z",
      "updatedAt": "2019-10-16T23:52:01Z",
      "closedAt": "2019-10-16T01:37:16Z",
      "mergedAt": "2019-10-16T01:37:16Z",
      "mergedBy": "horo-t",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "(This fixes #499)",
          "createdAt": "2019-10-15T06:40:43Z",
          "updatedAt": "2019-10-15T06:40:43Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "[Abstract](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.abstract), [section 2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.2) and [section 2.2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.2.2) are also mentioning about manifest as mandatory resource. Would you change those as well?",
          "createdAt": "2019-10-15T06:42:49Z",
          "updatedAt": "2019-10-15T06:42:49Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "> [Abstract](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.abstract), [section 2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.2) and [section 2.2](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#rfc.section.2.2) are also mentioning about manifest as mandatory resource. Would you change those as well?\r\n\r\nDone",
          "createdAt": "2019-10-15T07:13:18Z",
          "updatedAt": "2019-10-15T07:13:18Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-15T07:16:57Z",
          "updatedAt": "2019-10-15T07:16:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzEwMjg4",
          "commit": {
            "abbreviatedOid": "a3eb454"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T07:48:19Z",
          "updatedAt": "2019-10-15T07:59:29Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "No need to mention manifest here. How about this?\r\n```\r\nA bundle is logically a set of HTTP exchanges, with a URL identifying the\r\nprimary resource of the bundle.\r\n```\r\n",
              "createdAt": "2019-10-15T07:48:19Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            },
            {
              "originalPosition": 28,
              "body": "I think you can just remove the `manifest` item below (L160-164) and leave the other text in this section unchanged. Section 3.3.2 has all the information about the manifest section.",
              "createdAt": "2019-10-15T07:49:54Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            },
            {
              "originalPosition": 48,
              "body": "s/keys/key/",
              "createdAt": "2019-10-15T07:53:22Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzI5Nzcx",
          "commit": {
            "abbreviatedOid": "2362cfa"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:23:58Z",
          "updatedAt": "2019-10-15T08:23:59Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "done",
              "createdAt": "2019-10-15T08:23:59Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzI5ODAy",
          "commit": {
            "abbreviatedOid": "2362cfa"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:24:02Z",
          "updatedAt": "2019-10-15T08:24:02Z",
          "comments": [
            {
              "originalPosition": 28,
              "body": "done",
              "createdAt": "2019-10-15T08:24:02Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzI5ODIy",
          "commit": {
            "abbreviatedOid": "2362cfa"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:24:04Z",
          "updatedAt": "2019-10-15T08:24:04Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "done",
              "createdAt": "2019-10-15T08:24:04Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzQ2MzM1",
          "commit": {
            "abbreviatedOid": "2362cfa"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:50:53Z",
          "updatedAt": "2019-10-15T08:51:03Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "s/entries/an entry/\r\n(sorry for not noticing in the previous round)",
              "createdAt": "2019-10-15T08:50:53Z",
              "updatedAt": "2019-10-15T08:58:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzUxODAx",
          "commit": {
            "abbreviatedOid": "d985754"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-15T08:59:16Z",
          "updatedAt": "2019-10-15T08:59:16Z",
          "comments": [
            {
              "originalPosition": 40,
              "body": "done",
              "createdAt": "2019-10-15T08:59:16Z",
              "updatedAt": "2019-10-15T08:59:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAxNzUzMTE2",
          "commit": {
            "abbreviatedOid": "d985754"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-10-15T09:01:25Z",
          "updatedAt": "2019-10-15T09:01:25Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzAyOTM5ODE0",
          "commit": {
            "abbreviatedOid": "d985754"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "LGTM. I'll add the changelog entry at least by the time I publish draft-03.",
          "createdAt": "2019-10-16T23:52:01Z",
          "updatedAt": "2019-10-16T23:52:01Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0f92cd90d8f1ca3546653a439e3a908a5b23a3e4",
      "headRepository": "horo-t/webpackage",
      "headRefName": "make_manifest_optional",
      "headRefOid": "d9857540a099380a05770301d1b0447d74bd70ca",
      "mergeCommit": {
        "oid": "95aeed7a5d9ee2c286497746e46d6cd07daddf1a"
      }
    },
    {
      "number": 506,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMwMjgyMjA1",
      "title": "Add JavaScript library for generating bundles",
      "url": "https://github.com/WICG/webpackage/pull/506",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The `gen-bundle` Go tool is convenient for simple use cases, but developers who want to support WebBundle generation for their site may need more fine-grained control.\r\n\r\nThis adds a simple JavaScript library (npm package) for creating application/webbundle resources, which could be used as a building block of popular frontend development toolchain (such as plugins for gulp, webpack, etc.).\r\n",
      "createdAt": "2019-10-21T08:30:04Z",
      "updatedAt": "2019-10-25T07:41:37Z",
      "closedAt": "2019-10-25T07:41:36Z",
      "mergedAt": "2019-10-25T07:41:36Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-21T08:34:36Z",
          "updatedAt": "2019-10-21T08:34:36Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "If you want to try this, download [webbundle-0.0.1.tgz](https://drive.google.com/file/d/1kWZQDei8paRk5fyiBRHszYlmP6IHExME/view?usp=sharing) and run `npm install webbundle-0.0.1.tgz`.",
          "createdAt": "2019-10-21T08:37:37Z",
          "updatedAt": "2019-10-21T08:37:37Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin @kinu WDYT?\r\n\r\nI think having JS-based tool would lower the hurdle for developers who want to integrate bundle generation step to their workflow.",
          "createdAt": "2019-10-21T08:53:55Z",
          "updatedAt": "2019-10-21T08:53:55Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems we can't publish `webbundle` package because the name is too similar to existing package `web-bundle` (which is not related to web packaing).\r\n\r\nSo I've renamed this package to `wicg-webbundle`.\r\n",
          "createdAt": "2019-10-25T01:44:01Z",
          "updatedAt": "2019-10-25T01:44:01Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems `wbn` is still available for package name. Let's use it.",
          "createdAt": "2019-10-25T07:35:26Z",
          "updatedAt": "2019-10-25T07:35:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1NjcwMTAx",
          "commit": {
            "abbreviatedOid": "0855518"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lg to me.  @jyasskin if you have any thoughts on how / if these tools should be placed here or else please chime in!",
          "createdAt": "2019-10-23T07:04:36Z",
          "updatedAt": "2019-10-23T07:09:17Z",
          "comments": [
            {
              "originalPosition": 124,
              "body": "This could throw if urlString is a relative URL, right?  Maybe write about that somewhere?\r\n\r\nShould we also error out if protocol is not http/https?",
              "createdAt": "2019-10-23T07:04:37Z",
              "updatedAt": "2019-10-25T07:31:41Z"
            },
            {
              "originalPosition": 2,
              "body": "Maybe also write out that currently it doesn't support origin-signed exchanges.",
              "createdAt": "2019-10-23T07:06:01Z",
              "updatedAt": "2019-10-25T07:31:41Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA1NjkyMDQ1",
          "commit": {
            "abbreviatedOid": "9bc5960"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-23T07:50:40Z",
          "updatedAt": "2019-10-23T07:54:02Z",
          "comments": [
            {
              "originalPosition": 2,
              "body": "Done.",
              "createdAt": "2019-10-23T07:50:40Z",
              "updatedAt": "2019-10-25T07:31:41Z"
            },
            {
              "originalPosition": 124,
              "body": "Done.",
              "createdAt": "2019-10-23T07:53:54Z",
              "updatedAt": "2019-10-25T07:31:41Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "95aeed7a5d9ee2c286497746e46d6cd07daddf1a",
      "headRepository": "irori/webpackage",
      "headRefName": "js",
      "headRefOid": "f2e2b7c5f1b3c22e7a0c678635dc96ffc3b71647",
      "mergeCommit": {
        "oid": "ea630715516507822e3d5ede1c5926e9d3819e34"
      }
    },
    {
      "number": 508,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxODY2MDMx",
      "title": "gen-bundle: Add -headerOverride flag",
      "url": "https://github.com/WICG/webpackage/pull/508",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This can be used to inject arbitrary headers to bundled responses. For example, `Access-Control-Allow-Origin: *` may be added to workaround CORS errors in untrusted bundles.",
      "createdAt": "2019-10-24T05:47:59Z",
      "updatedAt": "2019-10-24T08:33:37Z",
      "closedAt": "2019-10-24T08:28:26Z",
      "mergedAt": "2019-10-24T08:28:26Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-24T05:55:23Z",
          "updatedAt": "2019-10-24T05:55:23Z"
        },
        {
          "author": "marcoscaceres",
          "authorAssociation": "MEMBER",
          "body": "Marked as  substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-24T05:58:38Z",
          "updatedAt": "2019-10-24T05:58:38Z"
        },
        {
          "author": "marcoscaceres",
          "authorAssociation": "MEMBER",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-24T05:58:41Z",
          "updatedAt": "2019-10-24T05:58:41Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2019-10-24T08:28:35Z",
          "updatedAt": "2019-10-24T08:28:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2Mzg2Njc5",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm w/ nits",
          "createdAt": "2019-10-24T08:06:14Z",
          "updatedAt": "2019-10-24T08:07:41Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "I'd write\r\n\r\n```go\r\nfunc (h headerArgs) String() string {\r\n\treturn fmt.Sprintf(\"%v\", h)\r\n}\r\n```",
              "createdAt": "2019-10-24T08:06:14Z",
              "updatedAt": "2019-10-24T08:07:41Z"
            },
            {
              "originalPosition": 19,
              "body": "ditto",
              "createdAt": "2019-10-24T08:06:22Z",
              "updatedAt": "2019-10-24T08:07:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2Mzk2MzQw",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T08:23:24Z",
          "updatedAt": "2019-10-24T08:23:24Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "We cannot use non-pointer `headerArgs` here because this function overwrites the pointed value.",
              "createdAt": "2019-10-24T08:23:24Z",
              "updatedAt": "2019-10-24T08:23:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2Mzk4Mzkz",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T08:26:52Z",
          "updatedAt": "2019-10-24T08:26:53Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Let me keep using `*headerArgs` here for consistency with `Set()`.\r\n\r\nAlso, `fmt.Sprintf(\"%v\", h)` would recursively call `h.String()` so we'll need a type conversion to prevent that, which is a bit unfortunate.",
              "createdAt": "2019-10-24T08:26:52Z",
              "updatedAt": "2019-10-24T08:26:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NDAyMzEy",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T08:33:23Z",
          "updatedAt": "2019-10-24T08:33:24Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Oh you're right.",
              "createdAt": "2019-10-24T08:33:24Z",
              "updatedAt": "2019-10-24T08:33:24Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NDAyNDM5",
          "commit": {
            "abbreviatedOid": "7b60ba5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T08:33:37Z",
          "updatedAt": "2019-10-24T08:33:37Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Ack",
              "createdAt": "2019-10-24T08:33:37Z",
              "updatedAt": "2019-10-24T08:33:37Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "95aeed7a5d9ee2c286497746e46d6cd07daddf1a",
      "headRepository": "irori/webpackage",
      "headRefName": "header-override",
      "headRefOid": "7b60ba5f76af9fcf3c131375fe4f16cd2a0d7266",
      "mergeCommit": {
        "oid": "0e6fe524f64904dc922c08377752dced388bddad"
      }
    },
    {
      "number": 509,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMxOTI0ODM1",
      "title": "Add \"Using Bundles\" section to go/bundle/README",
      "url": "https://github.com/WICG/webpackage/pull/509",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "with caveats for unsigned bundles.\r\n\r\nPreview: https://github.com/irori/webpackage/tree/readme/go/bundle#using-bundles",
      "createdAt": "2019-10-24T08:39:58Z",
      "updatedAt": "2019-10-28T06:42:11Z",
      "closedAt": "2019-10-28T06:42:10Z",
      "mergedAt": "2019-10-28T06:42:10Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-28T03:25:20Z",
          "updatedAt": "2019-10-28T03:25:20Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2NDU2ODc0",
          "commit": {
            "abbreviatedOid": "c940769"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T10:00:51Z",
          "updatedAt": "2019-10-24T10:01:01Z",
          "comments": [
            {
              "originalPosition": 12,
              "body": "'current', 'currently' --> as of Chrome 80 ?\r\n\r\nAs of Chrome 80, only unsigned bundles are supported and they can only be loaded from local files. Such bundles are loaded as \"untrusted\" pages, where:",
              "createdAt": "2019-10-24T10:00:51Z",
              "updatedAt": "2019-10-28T01:24:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTIyODAy",
          "commit": {
            "abbreviatedOid": "c940769"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-24T23:52:55Z",
          "updatedAt": "2019-10-24T23:52:55Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "All these problems below are only for Chrome.\r\nI think we should have a doc about these information in chromium repository, and this document should have a link to that.\r\nSo can we can update the information when we change the implementation synchronously.\r\n\r\nHow about this?\r\n\r\nChrome (80+) experimentally supports Web Bundles with some limitations. See [this document](https://chromium.googlesource.com/chromium/src/+/refs/heads/master/content/browser/web_package/web_bundles.md) for more details.\r\n",
              "createdAt": "2019-10-24T23:52:55Z",
              "updatedAt": "2019-10-28T01:24:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTQ1ODUy",
          "commit": {
            "abbreviatedOid": "c940769"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T01:43:52Z",
          "updatedAt": "2019-10-25T01:43:52Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Having this doc in chromium repository and linking from here sounds good, so +1",
              "createdAt": "2019-10-25T01:43:52Z",
              "updatedAt": "2019-10-28T01:24:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA2OTYyNjEx",
          "commit": {
            "abbreviatedOid": "c940769"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-25T03:07:34Z",
          "updatedAt": "2019-10-25T03:07:35Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "OK, created https://chromium-review.googlesource.com/c/chromium/src/+/1880413.",
              "createdAt": "2019-10-25T03:07:34Z",
              "updatedAt": "2019-10-28T01:24:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NjE3OTI0",
          "commit": {
            "abbreviatedOid": "95f0fc9"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-10-28T02:14:01Z",
          "updatedAt": "2019-10-28T02:14:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NjI5MjM0",
          "commit": {
            "abbreviatedOid": "95f0fc9"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-28T03:25:54Z",
          "updatedAt": "2019-10-28T03:25:54Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "Done",
              "createdAt": "2019-10-28T03:25:54Z",
              "updatedAt": "2019-10-28T03:25:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA3NjQ5OTcw",
          "commit": {
            "abbreviatedOid": "95f0fc9"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-28T05:47:14Z",
          "updatedAt": "2019-10-28T05:47:14Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0e6fe524f64904dc922c08377752dced388bddad",
      "headRepository": "irori/webpackage",
      "headRefName": "readme",
      "headRefOid": "95f0fc99fe92c5b0458869a6b5a5ec0e471a34ce",
      "mergeCommit": {
        "oid": "0a9b47b58b3dbd995815792648ab43ef6315c3a1"
      }
    },
    {
      "number": 510,
      "id": "MDExOlB1bGxSZXF1ZXN0MzMzNDE0MjQ2",
      "title": "gen-bundle: Verify that an exchange for primary URL exists",
      "url": "https://github.com/WICG/webpackage/pull/510",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "After this patch, bundle.Write() fails if the bundle doesn't have\r\nan exchange for its primary URL.\r\n\r\nAlso add `-primaryURL` flag to the command-line examples in README.",
      "createdAt": "2019-10-29T03:20:45Z",
      "updatedAt": "2019-10-29T03:26:36Z",
      "closedAt": "2019-10-29T03:26:36Z",
      "mergedAt": "2019-10-29T03:26:35Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA4MjU3NTMy",
          "commit": {
            "abbreviatedOid": "1997eef"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-29T03:23:00Z",
          "updatedAt": "2019-10-29T03:23:00Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0a9b47b58b3dbd995815792648ab43ef6315c3a1",
      "headRepository": "irori/webpackage",
      "headRefName": "primary-url",
      "headRefOid": "1997eef01b6f4c47fa7d24ebc2c4956f59d0cea3",
      "mergeCommit": {
        "oid": "b4a5152c73d75d19464fe1082d528f6a4baba492"
      }
    },
    {
      "number": 511,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0MTE0ODQ4",
      "title": "Mention \"Web Bundles\" in README",
      "url": "https://github.com/WICG/webpackage/pull/511",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'm a bit afraid people coming from \"Web Bundles\" article may feel lost if they don't see anything that says \"Web Bundles\". Wdyt?",
      "createdAt": "2019-10-30T09:21:13Z",
      "updatedAt": "2019-10-30T23:16:45Z",
      "closedAt": "2019-10-30T23:16:44Z",
      "mergedAt": "2019-10-30T23:16:44Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-10-30T22:31:00Z",
          "updatedAt": "2019-10-30T22:31:00Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5NTU2NzAw",
          "commit": {
            "abbreviatedOid": "f6f713d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-30T22:21:27Z",
          "updatedAt": "2019-10-30T22:23:22Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "We could just switch the primary name here.\r\n\r\n```suggestion\r\n1. [Web Bundles (previously called Bundled HTTP exchanges)](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html)\r\n```\r\n\r\nAnd I could change the title of the IETF draft.",
              "createdAt": "2019-10-30T22:21:27Z",
              "updatedAt": "2019-10-30T23:08:51Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "b4a5152c73d75d19464fe1082d528f6a4baba492",
      "headRepository": "kinu/webpackage",
      "headRefName": "mention-web-bundles",
      "headRefOid": "f77890a5bbb0e1a7235b1881ac114ebf68eb996b",
      "mergeCommit": {
        "oid": "c87d6d4ea8a83956b21ef7c181741cff4b4efeb0"
      }
    },
    {
      "number": 512,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0NzExNDgw",
      "title": "Add explainer for navigation with Web Bundles",
      "url": "https://github.com/WICG/webpackage/pull/512",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [
        "jyasskin"
      ],
      "labels": [],
      "body": "Text is still rough, but it'd be useful to have something like this.",
      "createdAt": "2019-10-31T07:10:00Z",
      "updatedAt": "2019-11-04T02:19:16Z",
      "closedAt": "2019-11-04T02:19:15Z",
      "mergedAt": "2019-11-04T02:19:15Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@kinu, could you formally [join the WICG](https://www.w3.org/community/wicg/participants) and [link your Github and W3C accounts](https://labs.w3.org/repo-manager/pr/id/WICG/webpackage/512)?",
          "createdAt": "2019-10-31T20:05:17Z",
          "updatedAt": "2019-10-31T20:05:17Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review! I've linked my github and w3c account, and requesting to join WICG.",
          "createdAt": "2019-11-01T03:29:27Z",
          "updatedAt": "2019-11-01T03:29:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjA2MTA1",
          "commit": {
            "abbreviatedOid": "3ea7e98"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-31T22:00:43Z",
          "updatedAt": "2019-10-31T22:26:53Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "I think we can leave this back-reference in the commit message instead of the body.",
              "createdAt": "2019-10-31T22:00:43Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 13,
              "body": "```suggestion\r\nToday, loading a website basically means retrieving multiple resources from one or multiple web servers. This gives the web the great strengths of being linkable, indexable, composable and ephemeral, but it also makes it difficult for a website to:\r\n```",
              "createdAt": "2019-10-31T22:06:09Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 19,
              "body": "I think you can drop the quotes around \"full\". This phrasing doesn't imply that you *have to* include the full website, just that it's possible.\r\n\r\n```suggestion\r\nInstead, imagine if we could bundle up a full website in a single resource file, so that the website could be shared via a SD card or over some p2p protocol, or could be retrieved from a fast cache or a nearby proxy. It would open up several interesting use cases.\r\n```",
              "createdAt": "2019-10-31T22:08:57Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nThe **Web Bundles** proposal tries to achieve this. It\u2019s a format that can represent a collection of HTTP resources, and therefore can represent one or multiple web pages in a single file, including their subresources like scripts, images and styles.  It\u2019s a part of the [Web Packaging](https://github.com/WICG/webpackage) project and is also known as \"**Bundled HTTP Exchanges**\" ([spec proposal](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html)).\r\n```",
              "createdAt": "2019-10-31T22:11:24Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 23,
              "body": "```suggestion\r\nThis document explains how a browser can navigate to a Web Bundle so that a user can open one.\r\n```",
              "createdAt": "2019-10-31T22:12:45Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 25,
              "body": "```suggestion\r\n## Example Scenarios: Save and browse unsigned content\r\n```",
              "createdAt": "2019-10-31T22:12:57Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 26,
              "body": "```suggestion\r\nA UA can provide a **'Save as bundle'** feature that dynamically generates an unsigned bundle of the page that its user is currently browsing.  Then anyone can create a bundled representation of the current page, and they can browse it later themself or share it with a nearby friend via one of several native file-sharing apps.\r\n```",
              "createdAt": "2019-10-31T22:16:00Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 28,
              "body": "@estark37 commented that showing the original URL is probably a bad idea. It sounds like we'll show the package's URL and/or a chip describing what's happening.\r\n\r\n```suggestion\r\nWhen someone else browses the unsigned bundle, they can browse around and see the site, including the results of its JavaScript executing.  Note that in this case the page inside the unsigned bundle is not given any access to the cookies or storage of the original site.\r\n```",
              "createdAt": "2019-10-31T22:18:37Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 36,
              "body": "```suggestion\r\n# Details of how the browser handles navigation\r\n```\r\n\r\nI'm not doing a detailed review of the text below, because it's intrinsically more technical than we want to make an explainer's audience read. It'll eventually move into the specification.",
              "createdAt": "2019-10-31T22:20:01Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 32,
              "body": "```suggestion\r\nThe author of a site creates a bundle for part or all of their site, signs the bundle with the site\u2019s certificate, and then publishes the bundle in a way that interested users can find it. Users can then share this bundle peer-to-peer until its expiration time.\r\n```",
              "createdAt": "2019-10-31T22:21:19Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 31,
              "body": "```suggestion\r\n## Example Scenarios: Publishing signed content\r\n```",
              "createdAt": "2019-10-31T22:21:25Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 34,
              "body": "```suggestion\r\nLater, when a user receives the bundle, maybe by opening it from an SD card or by navigating to the distribution URL where the bundle is published, they can open it with their UA.  The UA parses and verifies the bundle\u2019s signature, and then opens the pages inside the bundle, without actually connecting to the site's server, but with assurance that it's safe to show the real site in the URL bar and use the site's local storage.  If the bundle represents multiple pages for the site, the user can browse those pages without worrying about connectivity.\r\n```",
              "createdAt": "2019-10-31T22:25:06Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            },
            {
              "originalPosition": 82,
              "body": "This is incorporated into https://docs.google.com/document/d/1BYQEi8xkXDAg9lxm3PaoMzEutuQAZi1r8Y0pLaFJQoo/edit, so I think we don't need it here. \r\n\r\n```suggestion\r\n```\r\n",
              "createdAt": "2019-10-31T22:26:23Z",
              "updatedAt": "2019-11-01T03:28:23Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjc3ODU1",
          "commit": {
            "abbreviatedOid": "7a977a0"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T03:28:54Z",
          "updatedAt": "2019-11-01T03:28:55Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Good idea, done.",
              "createdAt": "2019-11-01T03:28:55Z",
              "updatedAt": "2019-11-01T03:28:55Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c87d6d4ea8a83956b21ef7c181741cff4b4efeb0",
      "headRepository": "kinu/webpackage",
      "headRefName": "bundle-navigation",
      "headRefOid": "7a977a035a29f2a5459728f8a37dada2882b581e",
      "mergeCommit": {
        "oid": "14316c61c817bbac2440bd2e496ce6d33121ce22"
      }
    },
    {
      "number": 513,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM0NzY4NDU4",
      "title": "js/bundle: Add decoder",
      "url": "https://github.com/WICG/webpackage/pull/513",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-10-31T09:27:10Z",
      "updatedAt": "2019-11-01T05:12:53Z",
      "closedAt": "2019-11-01T05:12:52Z",
      "mergedAt": "2019-11-01T05:12:52Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODAyODAw",
          "commit": {
            "abbreviatedOid": "5b1b3ac"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-10-31T11:13:36Z",
          "updatedAt": "2019-10-31T11:13:36Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "I'd use `const` for `bundle`, `exchanges`, `url`, and `resp` (no reassignments)",
              "createdAt": "2019-10-31T11:13:36Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzA5ODA0Nzgw",
          "commit": {
            "abbreviatedOid": "5b1b3ac"
          },
          "author": "nyaxt",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-10-31T11:17:24Z",
          "updatedAt": "2019-10-31T11:17:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjQwMTYx",
          "commit": {
            "abbreviatedOid": "5b1b3ac"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-01T00:01:31Z",
          "updatedAt": "2019-11-01T00:29:02Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "for (const resp of responses) {",
              "createdAt": "2019-11-01T00:01:31Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 60,
              "body": "const indexEntry",
              "createdAt": "2019-11-01T00:02:01Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 64,
              "body": "const",
              "createdAt": "2019-11-01T00:02:13Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 71,
              "body": "const",
              "createdAt": "2019-11-01T00:02:47Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 92,
              "body": "const",
              "createdAt": "2019-11-01T00:03:55Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 104,
              "body": "const",
              "createdAt": "2019-11-01T00:04:04Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 109,
              "body": "const",
              "createdAt": "2019-11-01T00:04:25Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 114,
              "body": "status = Number(val);",
              "createdAt": "2019-11-01T00:09:27Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 20,
              "body": "semicolon",
              "createdAt": "2019-11-01T00:17:50Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 81,
              "body": "Unnecessary semicolon",
              "createdAt": "2019-11-01T00:18:21Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 11,
              "body": "!==",
              "createdAt": "2019-11-01T00:19:42Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 89,
              "body": "!==",
              "createdAt": "2019-11-01T00:20:00Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 86,
              "body": "\"public\" modifier not needed.",
              "createdAt": "2019-11-01T00:24:30Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 4,
              "body": "Sorry I'm not familiar with TS.\r\nWhy are you using trailing \"_\"?",
              "createdAt": "2019-11-01T00:26:31Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 3,
              "body": "Can we have JSDoc comments for this?",
              "createdAt": "2019-11-01T00:28:09Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 83,
              "body": "Can we have JSDoc comments for this?",
              "createdAt": "2019-11-01T00:28:17Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjU3Mzcz",
          "commit": {
            "abbreviatedOid": "5b1b3ac"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "All fixed. I'll create another PR for style fixes of `encoder.ts`.",
          "createdAt": "2019-11-01T01:36:49Z",
          "updatedAt": "2019-11-01T02:21:08Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "done",
              "createdAt": "2019-11-01T01:36:50Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 11,
              "body": "done",
              "createdAt": "2019-11-01T01:37:45Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 20,
              "body": "done",
              "createdAt": "2019-11-01T01:37:58Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 33,
              "body": "done",
              "createdAt": "2019-11-01T01:50:15Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 60,
              "body": "done",
              "createdAt": "2019-11-01T01:50:28Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 64,
              "body": "done",
              "createdAt": "2019-11-01T01:50:34Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 71,
              "body": "done",
              "createdAt": "2019-11-01T01:50:41Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 81,
              "body": "done",
              "createdAt": "2019-11-01T01:50:53Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 86,
              "body": "done",
              "createdAt": "2019-11-01T01:51:21Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 89,
              "body": "done",
              "createdAt": "2019-11-01T01:51:31Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 92,
              "body": "done",
              "createdAt": "2019-11-01T01:51:39Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 104,
              "body": "done",
              "createdAt": "2019-11-01T01:51:50Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 109,
              "body": "done",
              "createdAt": "2019-11-01T01:51:58Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 114,
              "body": "done",
              "createdAt": "2019-11-01T01:52:08Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 4,
              "body": "This was to avoid conflict with the `version` getter function, but I changed it to a public field.",
              "createdAt": "2019-11-01T02:01:09Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 3,
              "body": "Added, although I'm not really sure if we should require JSDocs in this package.",
              "createdAt": "2019-11-01T02:09:19Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            },
            {
              "originalPosition": 83,
              "body": "done",
              "createdAt": "2019-11-01T02:09:35Z",
              "updatedAt": "2019-11-01T04:08:15Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjkzOTM4",
          "commit": {
            "abbreviatedOid": "26804cf"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-01T05:10:52Z",
          "updatedAt": "2019-11-01T05:10:52Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c87d6d4ea8a83956b21ef7c181741cff4b4efeb0",
      "headRepository": "irori/webpackage",
      "headRefName": "js-decoder",
      "headRefOid": "26804cf26d89fb07456525f8bb2c38ce6b1de145",
      "mergeCommit": {
        "oid": "2b1a823193c1e5c77991ac62fe85b599e17dd8c4"
      }
    },
    {
      "number": 514,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1Mjc1NDcw",
      "title": "js/bundle: Style fix for encoder.ts",
      "url": "https://github.com/WICG/webpackage/pull/514",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-01T04:30:40Z",
      "updatedAt": "2019-11-01T05:25:28Z",
      "closedAt": "2019-11-01T05:25:28Z",
      "mergedAt": "2019-11-01T05:25:28Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwMjk2MTAw",
          "commit": {
            "abbreviatedOid": "d78582c"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-01T05:24:07Z",
          "updatedAt": "2019-11-01T05:24:07Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "efc5d6881a9e08f3859e95b8892be9b4a8e05e62",
      "headRepository": "irori/webpackage",
      "headRefName": "style-fix",
      "headRefOid": "d78582cda2d51560f43cac8f9741807198304e78",
      "mergeCommit": {
        "oid": "2fc0d9901de1d777f0a647d61e575162454ed4c4"
      }
    },
    {
      "number": 515,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM1Mjg5MzY0",
      "title": "js/bundle: Add tests",
      "url": "https://github.com/WICG/webpackage/pull/515",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Also bumps package version to 0.0.2.",
      "createdAt": "2019-11-01T05:58:09Z",
      "updatedAt": "2019-11-06T01:31:07Z",
      "closedAt": "2019-11-06T01:31:06Z",
      "mergedAt": "2019-11-06T01:31:06Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNTE3MTg4",
          "commit": {
            "abbreviatedOid": "b0a79f3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-05T06:11:15Z",
          "updatedAt": "2019-11-05T06:20:11Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I think we should have a pre-generated test bundle file to detect unexpected regressions (or format change).",
              "createdAt": "2019-11-05T06:11:16Z",
              "updatedAt": "2019-11-05T08:14:25Z"
            },
            {
              "originalPosition": 6,
              "body": "We should have no-manifest wbn test case.",
              "createdAt": "2019-11-05T06:15:08Z",
              "updatedAt": "2019-11-05T08:14:25Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNTU3NDcy",
          "commit": {
            "abbreviatedOid": "b0a79f3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-05T08:14:41Z",
          "updatedAt": "2019-11-05T08:15:42Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done.",
              "createdAt": "2019-11-05T08:14:42Z",
              "updatedAt": "2019-11-05T08:15:42Z"
            },
            {
              "originalPosition": 6,
              "body": "The pre-generated wbn doesn't have a manifest.",
              "createdAt": "2019-11-05T08:14:59Z",
              "updatedAt": "2019-11-05T08:15:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyMTQ4NDU3",
          "commit": {
            "abbreviatedOid": "50a3f7e"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-06T01:29:50Z",
          "updatedAt": "2019-11-06T01:29:50Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2fc0d9901de1d777f0a647d61e575162454ed4c4",
      "headRepository": "irori/webpackage",
      "headRefName": "js-test",
      "headRefOid": "50a3f7e3f946509b1e6cd7f9647b35123d0b95ba",
      "mergeCommit": {
        "oid": "d91f24c194b45e448f489bc133a6e485dbb15f6a"
      }
    },
    {
      "number": 516,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2MTAxNTk3",
      "title": "Replace bundle demo link to a newer one",
      "url": "https://github.com/WICG/webpackage/pull/516",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "https://youtu.be/xAujz66la3Y this one uses the term \"Web Bundles\"\r\n(Same scenario & materials with the previous one, with a little more editing)",
      "createdAt": "2019-11-04T02:24:07Z",
      "updatedAt": "2019-11-04T06:14:46Z",
      "closedAt": "2019-11-04T06:14:45Z",
      "mergedAt": "2019-11-04T06:14:45Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "I probably should have merged this into the previous commit... just replacing a link.  (The video can be replaced/re-edited further though)",
          "createdAt": "2019-11-04T02:25:09Z",
          "updatedAt": "2019-11-04T02:25:09Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEwODcyMzEz",
          "commit": {
            "abbreviatedOid": "e0a6e60"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-11-04T03:55:51Z",
          "updatedAt": "2019-11-04T03:55:51Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "14316c61c817bbac2440bd2e496ce6d33121ce22",
      "headRepository": "WICG/webpackage",
      "headRefName": "Replace-web-bundle-video",
      "headRefOid": "e0a6e602cb0742020b8dfe165c29f43805373e51",
      "mergeCommit": {
        "oid": "9a9a1b62f411571b460c5fc382a6f9a2217146b8"
      }
    },
    {
      "number": 517,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NDk4Mzky",
      "title": "Improve the signed-exchanges privacy considerations.",
      "url": "https://github.com/WICG/webpackage/pull/517",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Maybe I can make the 23:59 UTC IETF draft deadline in 2 hours?\r\n\r\nPreview at https://jyasskin.github.io/webpackage/privacy-tweaks/draft-yasskin-http-origin-signed-responses.html#privacy-considerations.",
      "createdAt": "2019-11-04T21:54:44Z",
      "updatedAt": "2019-11-04T23:35:42Z",
      "closedAt": "2019-11-04T23:35:41Z",
      "mergedAt": "2019-11-04T23:35:41Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNDI1NzIx",
          "commit": {
            "abbreviatedOid": "638d9f9"
          },
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-04T23:32:15Z",
          "updatedAt": "2019-11-04T23:32:15Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9a9a1b62f411571b460c5fc382a6f9a2217146b8",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "privacy-tweaks",
      "headRefOid": "638d9f98d7c4e13ddd8c3d1da02e9287569fbc9e",
      "mergeCommit": {
        "oid": "6cc3237b36c2f9ce75343d1ad39d7f138f07c87f"
      }
    },
    {
      "number": 518,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM2NjA1OTM5",
      "title": "Update go/bundle/README.md",
      "url": "https://github.com/WICG/webpackage/pull/518",
      "state": "MERGED",
      "author": "kinu",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Make it explicit that manifestUrl is optional (and also added some texts).\r\n\r\nUsers should ultimately refer to the code or run the tool to see detailed parameter options, but wanted to add some info to unconfuse. Wdyt?",
      "createdAt": "2019-11-05T05:49:33Z",
      "updatedAt": "2019-11-06T08:25:04Z",
      "closedAt": "2019-11-06T08:25:02Z",
      "mergedAt": "2019-11-06T08:25:02Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "(Closing and re-opening to kick Travis CI)",
          "createdAt": "2019-11-06T01:14:15Z",
          "updatedAt": "2019-11-06T01:14:15Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzExNTE5MjQ1",
          "commit": {
            "abbreviatedOid": "72ae510"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-11-05T06:19:51Z",
          "updatedAt": "2019-11-05T06:19:51Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d91f24c194b45e448f489bc133a6e485dbb15f6a",
      "headRepository": "WICG/webpackage",
      "headRefName": "bundle-nit-text",
      "headRefOid": "8550deae55b07b2d36d9f326890b00a3a67124e2",
      "mergeCommit": {
        "oid": "96e0cd39ea52eab2c919c0e194f424f8fa1943ca"
      }
    },
    {
      "number": 519,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MTI2ODIz",
      "title": "TravisCI: Test nodejs module",
      "url": "https://github.com/WICG/webpackage/pull/519",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-06T01:48:00Z",
      "updatedAt": "2020-08-07T19:12:59Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f978cb7186f5f730aa1094d64bc2927cd7d5d22a",
      "headRepository": "irori/webpackage",
      "headRefName": "travis",
      "headRefOid": "e8ce88449a30a43f2fceb8fa5a9400744309ed13",
      "closedAt": "2020-08-07T19:12:59Z",
      "mergedAt": "2020-08-07T19:12:59Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "2ab2cca9b8e211c6dff98ef3ebc4c694d7927446"
      },
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Would you take a look?",
          "createdAt": "2019-11-06T02:27:51Z",
          "updatedAt": "2019-11-06T02:27:51Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyOTIwNDg4",
          "commit": {
            "abbreviatedOid": "75fd340"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Sorry that I entirely missed this. Looks good. I've rebased, will let Travis double-check it, and then will merge.",
          "createdAt": "2020-08-06T22:34:45Z",
          "updatedAt": "2020-08-06T22:34:45Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDYyOTIyMDg3",
          "commit": {
            "abbreviatedOid": "75fd340"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-06T22:38:48Z",
          "updatedAt": "2020-08-06T22:38:48Z",
          "comments": [
            {
              "originalPosition": 9,
              "body": "There is an [`npm ci`](https://docs.npmjs.com/cli/ci.html) command that would probably be better here.",
              "createdAt": "2020-08-06T22:38:48Z",
              "updatedAt": "2020-08-07T18:35:24Z"
            }
          ]
        }
      ]
    },
    {
      "number": 520,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3MjU2Njk2",
      "title": "Add \"Using Bundles\" section to js/bundle/README.md",
      "url": "https://github.com/WICG/webpackage/pull/520",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The content is copied from go/bundle/README.md. Having this information\r\nhere too would be useful.",
      "createdAt": "2019-11-06T09:28:06Z",
      "updatedAt": "2019-11-07T00:52:15Z",
      "closedAt": "2019-11-07T00:52:14Z",
      "mergedAt": "2019-11-07T00:52:14Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyODA1OTM5",
          "commit": {
            "abbreviatedOid": "249c3c7"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-06T23:07:50Z",
          "updatedAt": "2019-11-06T23:07:50Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEyODI2MTM5",
          "commit": {
            "abbreviatedOid": "249c3c7"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-06T23:26:51Z",
          "updatedAt": "2019-11-06T23:26:51Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "96e0cd39ea52eab2c919c0e194f424f8fa1943ca",
      "headRepository": "irori/webpackage",
      "headRefName": "js-readme",
      "headRefOid": "249c3c711649bef20601d3fbd0207614c25d159e",
      "mergeCommit": {
        "oid": "8a83408adef264d56763c502e684c3cc080b96f1"
      }
    },
    {
      "number": 521,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM3ODE4Njc5",
      "title": "Update the header of js/bundle/README.md",
      "url": "https://github.com/WICG/webpackage/pull/521",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This README is also shown in the [npm package page](https://www.npmjs.com/package/wbn), so having \"js/bundle\" as title is a bit confusing.",
      "createdAt": "2019-11-07T02:04:56Z",
      "updatedAt": "2019-11-08T07:23:00Z",
      "closedAt": "2019-11-08T07:22:59Z",
      "mergedAt": "2019-11-08T07:22:59Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzEzOTI0NTY4",
          "commit": {
            "abbreviatedOid": "e1c7fee"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-08T07:21:55Z",
          "updatedAt": "2019-11-08T07:21:55Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "8a83408adef264d56763c502e684c3cc080b96f1",
      "headRepository": "irori/webpackage",
      "headRefName": "js-readme",
      "headRefOid": "e1c7fee90d4edcce136b5c530904a4f1819e88b3",
      "mergeCommit": {
        "oid": "271865a105c1f88d5338216d7871703175626084"
      }
    },
    {
      "number": 523,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4NTM3Njc5",
      "title": "js/bundle: Make sure to give CBOR encoder sufficient buffer size",
      "url": "https://github.com/WICG/webpackage/pull/523",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`CBOR.encode()` chokes and generates broken output if given data is\r\nlarger than its `highWaterMark` option value [1].\r\n\r\nSo, this patch:\r\n\r\n- Give sufficient buffer size when encoding\r\n- Add checks for encoded results (throws if it doesn't fit the buffer)\r\n- `encodedLength()` internally uses `encode()`, so avoid using it for\r\n  potentially large objects\r\n\r\nThis fixes #522.\r\n\r\n[1] https://github.com/hildjj/node-cbor#highwatermark",
      "createdAt": "2019-11-08T06:50:49Z",
      "updatedAt": "2019-11-12T01:16:12Z",
      "closedAt": "2019-11-12T01:16:11Z",
      "mergedAt": "2019-11-12T01:16:10Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@sisidovski Would you please take a look?\r\nThanks!",
          "createdAt": "2019-11-08T06:52:18Z",
          "updatedAt": "2019-11-08T06:52:18Z"
        },
        {
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Looks good to me! @irori",
          "createdAt": "2019-11-11T11:05:21Z",
          "updatedAt": "2019-11-11T11:05:21Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@horo-t @kinu Would you stamp this? Looks like an approval from a reviewer with write access is needed.",
          "createdAt": "2019-11-12T00:19:28Z",
          "updatedAt": "2019-11-12T00:19:28Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0MTczODMx",
          "commit": {
            "abbreviatedOid": "f9aa6c3"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T12:35:45Z",
          "updatedAt": "2019-11-08T13:06:56Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "This line just checks duplication and doesn't use return value, correct? If so, it would be more clear to use `array.some` instead of `.find`!",
              "createdAt": "2019-11-08T12:35:46Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            },
            {
              "originalPosition": 57,
              "body": "`const` is preferable to make sure this variable won't be changed.",
              "createdAt": "2019-11-08T12:42:46Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            },
            {
              "originalPosition": 59,
              "body": "I'm not sure what this comment means. It looks using `encodedLength` in below.",
              "createdAt": "2019-11-08T12:46:35Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTIzNjM4",
          "commit": {
            "abbreviatedOid": "f9aa6c3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks!",
          "createdAt": "2019-11-09T00:30:55Z",
          "updatedAt": "2019-11-09T00:56:57Z",
          "comments": [
            {
              "originalPosition": 52,
              "body": "Done.",
              "createdAt": "2019-11-09T00:30:55Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            },
            {
              "originalPosition": 57,
              "body": "This can't be `const` since the value is assigned in the if-else statement below.",
              "createdAt": "2019-11-09T00:41:31Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            },
            {
              "originalPosition": 59,
              "body": "Oh, you are right. I meant `encodedLength(content)` shouldn't be used. Updated the comment.\r\n\r\nThe trick used here needs some knowledge about CBOR encoding to understand.\r\n\r\nThe `responses` section is an array, and CBOR's array encoding is the concatenation of:\r\n\r\n1. variable-length integer encoding of the array length\r\n2. CBOR-encoded contents of the array elements\r\n\r\n`this.currentResponsesOffset` holds the length of 2, and the length of 1 can be calculated by `encodedLength(this.responses.length)`. The `encodedLength` operation is cheap heare, because the argument is just a number.\r\n",
              "createdAt": "2019-11-09T00:54:25Z",
              "updatedAt": "2019-11-09T01:05:37Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0ODE4Nzcw",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-11T10:42:28Z",
          "updatedAt": "2019-11-11T11:03:50Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "Oh I just thought you can write something like\r\n\r\n```js\r\nconst length = (name === 'responses') ? this.currentResponsesOffset + encodedLength(this.responses.length) : encodedLength(content)\r\n```\r\n\r\nBut it's okay, you don't have to rewrite it.",
              "createdAt": "2019-11-11T10:42:29Z",
              "updatedAt": "2019-11-11T11:03:50Z"
            },
            {
              "originalPosition": 59,
              "body": "Gotcha. Thanks for the clarification. ",
              "createdAt": "2019-11-11T11:03:50Z",
              "updatedAt": "2019-11-11T11:03:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0ODI5Mzk0",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-11T11:04:32Z",
          "updatedAt": "2019-11-11T11:04:32Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjMwMDMz",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks @sisidovski!",
          "createdAt": "2019-11-12T00:16:46Z",
          "updatedAt": "2019-11-12T00:17:26Z",
          "comments": [
            {
              "originalPosition": 57,
              "body": "I see.\r\nLet me keep current code. I think it's slightly easier to understand.",
              "createdAt": "2019-11-12T00:16:46Z",
              "updatedAt": "2019-11-12T00:17:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjQzNTc5",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Lgtm",
          "createdAt": "2019-11-12T01:09:28Z",
          "updatedAt": "2019-11-12T01:10:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjQ0MTY5",
          "commit": {
            "abbreviatedOid": "72275b7"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-12T01:11:45Z",
          "updatedAt": "2019-11-12T01:11:45Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7bfeac1235ab991b35430a5035b884536f4a8f3c",
      "headRepository": "irori/webpackage",
      "headRefName": "wbn-buffer-fix",
      "headRefOid": "72275b7cef1167768cf9e0e5b7057c55b7570d98",
      "mergeCommit": {
        "oid": "bcd6608ab0172885a8d795d9ffe4bee9f5ba6843"
      }
    },
    {
      "number": 524,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4Njg3NDc4",
      "title": "js/bundle: Support node 8.x",
      "url": "https://github.com/WICG/webpackage/pull/524",
      "state": "MERGED",
      "author": "sisidovski",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Just a tiny fix.\r\n\r\nI'm not sure this is intended or not, but global `URL` class was added from Node 10.x.\r\n\r\nThis change will support 8.x which is still at the maintenance LTS stage, actually it will be eol [soon](https://github.com/nodejs/Release) though. Even if doesn't support 8.x, at least supported node version should be specified via \"engines\" field in package.json.\r\n\r\n@irori Could you have a look? Thanks!",
      "createdAt": "2019-11-08T13:55:31Z",
      "updatedAt": "2019-11-09T01:02:39Z",
      "closedAt": "2019-11-09T01:02:38Z",
      "mergedAt": "2019-11-09T01:02:38Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-11-09T01:01:52Z",
          "updatedAt": "2019-11-09T01:01:52Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NTI4NDA5",
          "commit": {
            "abbreviatedOid": "e0f699e"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-11-09T01:02:17Z",
          "updatedAt": "2019-11-09T01:02:17Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "271865a105c1f88d5338216d7871703175626084",
      "headRepository": "sisidovski/webpackage",
      "headRefName": "specify-node-version",
      "headRefOid": "e0f699e64c482ea773f3baef19ee5602467e823e",
      "mergeCommit": {
        "oid": "7bfeac1235ab991b35430a5035b884536f4a8f3c"
      }
    },
    {
      "number": 525,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM4ODI1MTAz",
      "title": "Rename \"Bundled Exchanges\" to \"Web Bundles\" everywhere.",
      "url": "https://github.com/WICG/webpackage/pull/525",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The bundled things aren't really exchanges anymore: they're a request\nURL and a response that is expected to include its content negotiation\ninformation in the Variants header.\n\n@jpmedley @uskay FYI.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/525.html\" title=\"Last updated on Nov 8, 2019, 7:29 PM UTC (30cb778)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/525/271865a...jyasskin:30cb778.html\" title=\"Last updated on Nov 8, 2019, 7:29 PM UTC (30cb778)\">Diff</a>",
      "createdAt": "2019-11-08T19:29:24Z",
      "updatedAt": "2019-11-08T20:32:35Z",
      "closedAt": "2019-11-08T20:32:34Z",
      "mergedAt": "2019-11-08T20:32:34Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NDM1OTA5",
          "commit": {
            "abbreviatedOid": "30cb778"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-08T20:14:06Z",
          "updatedAt": "2019-11-08T20:15:34Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We might want to change the file name as well eventually?",
              "createdAt": "2019-11-08T20:14:07Z",
              "updatedAt": "2019-11-08T20:15:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE0NDM5OTYx",
          "commit": {
            "abbreviatedOid": "30cb778"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-08T20:23:21Z",
          "updatedAt": "2019-11-08T20:23:22Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "We might, but it's a bit more difficult to rename IETF drafts. The point at which they get adopted by the working group will be a rename anyway, so we can fix up filenames then, both here and for signed exchanges.",
              "createdAt": "2019-11-08T20:23:21Z",
              "updatedAt": "2019-11-08T20:23:22Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "271865a105c1f88d5338216d7871703175626084",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "rename-web-bundles",
      "headRefOid": "30cb778b0b3bdfc4d88be138a995d380244eb3e7",
      "mergeCommit": {
        "oid": "424a50e020e5dd77c6f6b34742f84326a6f14e6d"
      }
    },
    {
      "number": 529,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5NjQzNjkx",
      "title": "Explainer on the anti-tracking problem for signed packages",
      "url": "https://github.com/WICG/webpackage/pull/529",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@johnwilander @davidben @bslassey Here's a description of how we could prevent distributors from using packages to transfer user IDs between sites. What holes do you still see in it? Do you have any favorite options for the places I've listed several possible choices?\r\n\r\nThanks!\r\n\r\n[Preview](https://github.com/WICG/webpackage/blob/anti-tracking/explainers/anti-tracking.md)",
      "createdAt": "2019-11-11T22:27:51Z",
      "updatedAt": "2019-12-12T22:59:11Z",
      "closedAt": "2019-12-12T22:59:10Z",
      "mergedAt": "2019-12-12T22:59:10Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE3ODY5MzM4",
          "commit": {
            "abbreviatedOid": "b6f9af0"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-15T21:06:27Z",
          "updatedAt": "2019-11-15T21:30:09Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Ideally we'd be able to talk about which network partition this uses too, but I'm not sure if the spec framework for that exists yet. :-/",
              "createdAt": "2019-11-15T21:06:28Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 226,
              "body": "This is a bit contrived, but here's an odd scenario.\r\n\r\npublisher.example makes some content only available to paying subscribers. This website is written to the web of today and doesn't need fancy client-side machinery, so it uses server-side logic on the top-level HTML fetch by checking some first-party cookie.\r\n\r\n Some user subscribes and pays this publisher. The attacker now directs the user to some article but it's uncredentialed. Now even though the top-level URL says publisher.example and the user is a paying customer, the user is greeted with a request for money. The user now gets upset at the publisher for asking for even more money.\r\n\r\n(Realistically the user will probably just thing something weird happened, click the \"login\" button, and things will probably settle quickly enough. But it is rather weird.)",
              "createdAt": "2019-11-15T21:17:26Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 231,
              "body": "Something that might be worth mentioning: SXGs ensures the credentialed and uncredentialed versions of the top-level resources are the same, which motivates for the package-only options.",
              "createdAt": "2019-11-15T21:25:17Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 62,
              "body": "Something that might be worth writing out explicitly:\r\n\r\nIf I'm understanding things right, this option and the second option are qualitatively different from the remaining ones and prenavigate. These say that there are two ways a referrer may choose to enter a first-party site, credentialed or uncredentialed. The other options don't change the semantics of top-level navigations (aside from the SXG origin substitution capability itself), but are trying to slot an uncredentialed package fetch somehow.",
              "createdAt": "2019-11-15T21:29:15Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NTM1NTcw",
          "commit": {
            "abbreviatedOid": "b6f9af0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T01:12:22Z",
          "updatedAt": "2019-12-10T01:15:36Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "Which do we want it to use? I think it's the uncredentialed partition from the origin of the SXG, and the contents get to cross into the credentialed partition for the origin that signed them?",
              "createdAt": "2019-12-10T01:12:22Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 62,
              "body": "I've written this.",
              "createdAt": "2019-12-10T01:12:33Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 226,
              "body": "I've now described this as \"surprising users\". I agree that the user will probably just click \"login\" or \"reload\" in that case, although we'd need to run a user study to be confident of that, if folks think it's important.",
              "createdAt": "2019-12-10T01:13:47Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            },
            {
              "originalPosition": 231,
              "body": "They don't guarantee they're the same. They basically allow the site to assert that the uncredentialed version is good enough, which is similar to the assertion with the `Allow-Uncredentialed-Navigation` header.",
              "createdAt": "2019-12-10T01:14:35Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTA5MzUw",
          "commit": {
            "abbreviatedOid": "e3b1b44"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T20:03:28Z",
          "updatedAt": "2019-12-10T20:03:28Z",
          "comments": [
            {
              "originalPosition": 231,
              "body": "Ah yeah, that's a better phrasing.",
              "createdAt": "2019-12-10T20:03:28Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMwMTExOTM5",
          "commit": {
            "abbreviatedOid": "e3b1b44"
          },
          "author": "davidben",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T20:08:01Z",
          "updatedAt": "2019-12-10T20:08:01Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "There isn't really a singular uncredentialed partition right now. We do partition credentialed and uncredentialed connections, but it was more a consequence of not confusing connection-based auth (client certs, NTLM, Channel ID at one point, etc) than an actual partition. In theory a smarter connection pool could pool across those without messing that up.\r\n\r\nI don't think anyone is partitioning the HTTP cache by credentialed vs uncredentialed. (I'm *sure* sites always correctly labels their `Vary: Cookie` resources. :-) ) And pages can freely make uncredentialed subresource requests and either write data via URLs or read data via CORS-readable responses. I believe that means credentialed vs uncredentialed is useful for threat models that consider intentional state mechanisms (so CSRF and such), but that it's not useful for threat models which consider random caches being misused as state (which we seem to be converging on for anti-tracking).\r\n\r\nhttps://github.com/kinu/speculative-loading talks about using a temporary partition, which would probably require a bit of spec machinery if that's what we settle on.",
              "createdAt": "2019-12-10T20:08:01Z",
              "updatedAt": "2019-12-12T22:39:38Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNTcyMTgw",
          "commit": {
            "abbreviatedOid": "d9eb40a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-12T22:40:21Z",
          "updatedAt": "2019-12-12T22:40:22Z",
          "comments": [
            {
              "originalPosition": 49,
              "body": "I've added some handwaving about figuring this out. I'll merge this now, but we can update it as we get the spec text worked out.",
              "createdAt": "2019-12-12T22:40:21Z",
              "updatedAt": "2019-12-12T22:40:22Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3f0145a1e15f0482ab19a2c286e220a0c9637be8",
      "headRepository": "WICG/webpackage",
      "headRefName": "anti-tracking",
      "headRefOid": "d9eb40a012219687655f82835fb63921470c415c",
      "mergeCommit": {
        "oid": "9853105259907c60bd6ca6c41a11878bdcc2c67b"
      }
    },
    {
      "number": 530,
      "id": "MDExOlB1bGxSZXF1ZXN0MzM5NjcyNjY3",
      "title": "js/bundle: Bump version to 0.0.3",
      "url": "https://github.com/WICG/webpackage/pull/530",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'll merge this after #523 and publish to npm.",
      "createdAt": "2019-11-12T00:25:31Z",
      "updatedAt": "2019-11-12T01:16:48Z",
      "closedAt": "2019-11-12T01:16:47Z",
      "mergedAt": "2019-11-12T01:16:47Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjQ0MDQz",
          "commit": {
            "abbreviatedOid": "5e68d30"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-12T01:11:20Z",
          "updatedAt": "2019-11-12T01:11:20Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzE1MjQ0MjI1",
          "commit": {
            "abbreviatedOid": "5e68d30"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-12T01:11:56Z",
          "updatedAt": "2019-11-12T01:11:56Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7bfeac1235ab991b35430a5035b884536f4a8f3c",
      "headRepository": "irori/webpackage",
      "headRefName": "v0.0.3",
      "headRefOid": "5e68d302742a34a29ca6f677299d15a6483523dd",
      "mergeCommit": {
        "oid": "d9f9141ae9f2caa20185e91c6eacb94a29266906"
      }
    },
    {
      "number": 534,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQxODE4Njc5",
      "title": "Charter edits to align with BoF chair and AD's advice",
      "url": "https://github.com/WICG/webpackage/pull/534",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-11-17T04:29:43Z",
      "updatedAt": "2019-11-17T08:20:34Z",
      "closedAt": "2019-11-17T08:20:33Z",
      "mergedAt": "2019-11-17T08:20:33Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d9f9141ae9f2caa20185e91c6eacb94a29266906",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "edit-charter",
      "headRefOid": "953f8346207f53ecd1766cb5c1cfd3f0ecc2ae27",
      "mergeCommit": {
        "oid": "0b0a67a71c983b9dc91f89edf8ebb2a5758568b3"
      }
    },
    {
      "number": 536,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQzOTAwMzQ5",
      "title": "gen-bundle: Add -ignoreErrors flag",
      "url": "https://github.com/WICG/webpackage/pull/536",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Sometimes we need to create invalid bundles (e.g. for testing).",
      "createdAt": "2019-11-21T08:20:53Z",
      "updatedAt": "2019-11-21T08:25:59Z",
      "closedAt": "2019-11-21T08:25:58Z",
      "mergedAt": "2019-11-21T08:25:58Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIwNzA1MDA3",
          "commit": {
            "abbreviatedOid": "f88809f"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-11-21T08:23:59Z",
          "updatedAt": "2019-11-21T08:23:59Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2a78f2930a228ee6872630ecb023fa71151cc164",
      "headRepository": "irori/webpackage",
      "headRefName": "ignore-errors",
      "headRefOid": "f88809fb592bac275233124d9e61fd3d3c9cef8d",
      "mergeCommit": {
        "oid": "c160c53da519411ff32e7b6c632ec68f961fdb06"
      }
    },
    {
      "number": 537,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ0MzY1ODI1",
      "title": "js/bundle: interpret the critical section",
      "url": "https://github.com/WICG/webpackage/pull/537",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "WebBundle parser must fail if the `critical` section includes unknown section names.\r\n\r\nhttps://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#name-parsing-the-critical-sectio",
      "createdAt": "2019-11-22T06:09:54Z",
      "updatedAt": "2020-04-06T03:11:52Z",
      "closedAt": "2020-04-06T03:11:33Z",
      "mergedAt": "2020-04-06T03:11:33Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@sisidovski Could you take a look?",
          "createdAt": "2019-11-22T06:11:30Z",
          "updatedAt": "2019-11-22T06:11:30Z"
        },
        {
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@irori Sorry to be late to review PR.",
          "createdAt": "2019-12-23T06:30:07Z",
          "updatedAt": "2019-12-23T06:30:07Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@sisidovski No worries, thanks!\r\n@kinu for approving review",
          "createdAt": "2019-12-23T09:37:31Z",
          "updatedAt": "2019-12-23T09:37:31Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry, somehow totally overlooked this. (Is this still not stale?)",
          "createdAt": "2020-04-06T02:37:08Z",
          "updatedAt": "2020-04-06T02:37:08Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! (I also forgot this...)",
          "createdAt": "2020-04-06T03:11:46Z",
          "updatedAt": "2020-04-06T03:11:46Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1NzI2Nzc4",
          "commit": {
            "abbreviatedOid": "3dff0bc"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-12-23T06:29:27Z",
          "updatedAt": "2019-12-23T06:29:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3OTAzNjM0",
          "commit": {
            "abbreviatedOid": "3dff0bc"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-04-06T02:36:14Z",
          "updatedAt": "2020-04-06T02:36:14Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "afa2f204b99bdb891ecdbe41a866e0f3e22d3950",
      "headRepository": "irori/webpackage",
      "headRefName": "js-critical",
      "headRefOid": "3dff0bc8fce81ed42001875783375fa29e55fc18",
      "mergeCommit": {
        "oid": "88837914bcb808f55b5b5d37906ba8584fcf2939"
      }
    },
    {
      "number": 538,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ0ODA1MzMy",
      "title": "Add \"X-Content-Type-Options: nosniff\" to example of firebase hosting config",
      "url": "https://github.com/WICG/webpackage/pull/538",
      "state": "MERGED",
      "author": "sykmhmh",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "fixed for\r\n```\r\nSigned exchange response without \"X-Content-Type-Options: nosniff\" header is not supported.\r\n```",
      "createdAt": "2019-11-23T12:37:54Z",
      "updatedAt": "2019-11-26T01:29:03Z",
      "closedAt": "2019-11-26T01:29:03Z",
      "mergedAt": "2019-11-26T01:29:03Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "marcoscaceres",
          "authorAssociation": "MEMBER",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-11-25T09:40:57Z",
          "updatedAt": "2019-11-25T09:40:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzIyNjgxMjc4",
          "commit": {
            "abbreviatedOid": "7bd9236"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thank you!",
          "createdAt": "2019-11-26T01:28:49Z",
          "updatedAt": "2019-11-26T01:28:49Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "c160c53da519411ff32e7b6c632ec68f961fdb06",
      "headRepository": "sykmhmh/webpackage",
      "headRefName": "master",
      "headRefOid": "7bd923638fa96b4bc1ca758cd5b6cc0ab75ec7e3",
      "mergeCommit": {
        "oid": "743d89d98195e9906bcf9023a13f502120093851"
      }
    },
    {
      "number": 539,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ2NTIzMTEw",
      "title": "gen-bundle: Add support for Variants",
      "url": "https://github.com/WICG/webpackage/pull/539",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "The index section of bundle maps URLs to a Variants value + a list of\r\nthe responses for each possible Variant-Key (#450). But before this\r\npatch gen-bundle could not generate a bundle that have multiple variants\r\nfor single URL.\r\n\r\nThis patch teaches indexSection.Finalize() to generate entries with\r\nnon-empty variants-value, based on the responses' Variant and\r\nVariant-Key headers [1].\r\n\r\n[1] https://tools.ietf.org/html/draft-ietf-httpbis-variants-05",
      "createdAt": "2019-11-28T05:05:26Z",
      "updatedAt": "2019-11-28T08:41:46Z",
      "closedAt": "2019-11-28T08:41:45Z",
      "mergedAt": "2019-11-28T08:41:45Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MTA1NzY4",
          "commit": {
            "abbreviatedOid": "5c2a61b"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2019-11-28T07:58:14Z",
          "updatedAt": "2019-11-28T07:58:14Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "743d89d98195e9906bcf9023a13f502120093851",
      "headRepository": "irori/webpackage",
      "headRefName": "variants",
      "headRefOid": "5c2a61bd33c288b52383ea7cfe5073eef4bcd80f",
      "mergeCommit": {
        "oid": "8048ed7b75e25053fd0bc3da33d04c48a0e1a897"
      }
    },
    {
      "number": 540,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ2NjAxMzA1",
      "title": "go/bundle: Support non-empty variants in decoder",
      "url": "https://github.com/WICG/webpackage/pull/540",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This enables dump-bundle to read bundles that have multiple variants\r\nfor single URL.\r\n\r\nAlso this adds a roundtrip test (serialize and then deserialize) for a\r\nbundle with variants.",
      "createdAt": "2019-11-28T09:28:12Z",
      "updatedAt": "2019-11-29T01:56:13Z",
      "closedAt": "2019-11-29T01:56:12Z",
      "mergedAt": "2019-11-29T01:56:12Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MjIxMDIz",
          "commit": {
            "abbreviatedOid": "77d6973"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-28T11:20:15Z",
          "updatedAt": "2019-11-28T11:20:16Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "optional: `SupportsVariants`?",
              "createdAt": "2019-11-28T11:20:15Z",
              "updatedAt": "2019-11-29T01:50:32Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0MjIyMDgx",
          "commit": {
            "abbreviatedOid": "77d6973"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-11-28T11:22:29Z",
          "updatedAt": "2019-11-28T11:22:29Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI0NDkyMjky",
          "commit": {
            "abbreviatedOid": "97910b3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-11-29T01:51:09Z",
          "updatedAt": "2019-11-29T01:51:10Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Done.",
              "createdAt": "2019-11-29T01:51:09Z",
              "updatedAt": "2019-11-29T01:51:10Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "8048ed7b75e25053fd0bc3da33d04c48a0e1a897",
      "headRepository": "irori/webpackage",
      "headRefName": "variants",
      "headRefOid": "97910b3c72a69d15215bb3335446761631a22552",
      "mergeCommit": {
        "oid": "a5ecf9c07e603a060cfc3e5ce0c8658a7fff19c0"
      }
    },
    {
      "number": 541,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ4MjE1ODgy",
      "title": "gen-bundle: Allow multiple entries for single URL",
      "url": "https://github.com/WICG/webpackage/pull/541",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This enables `gen-bundle -har` to create bundles that have multiple\r\nentries for single URL, if all responses have `Variants:` header.",
      "createdAt": "2019-12-03T09:26:16Z",
      "updatedAt": "2019-12-04T00:54:32Z",
      "closedAt": "2019-12-04T00:54:31Z",
      "mergedAt": "2019-12-04T00:54:31Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI2MTMxNjYw",
          "commit": {
            "abbreviatedOid": "b8c4ea5"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-03T13:20:43Z",
          "updatedAt": "2019-12-03T13:20:43Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a5ecf9c07e603a060cfc3e5ce0c8658a7fff19c0",
      "headRepository": "irori/webpackage",
      "headRefName": "fromhar",
      "headRefOid": "b8c4ea50c38091f130c979f2ca7de7c52d07496e",
      "mergeCommit": {
        "oid": "3f0145a1e15f0482ab19a2c286e220a0c9637be8"
      }
    },
    {
      "number": 542,
      "id": "MDExOlB1bGxSZXF1ZXN0MzQ4NjU2NzI5",
      "title": "Add an explainer for subresource signed exchanges",
      "url": "https://github.com/WICG/webpackage/pull/542",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I uploaded explainer documents of subresource signed exchanges to my\r\nrepository (https://github.com/horo-t/subresource-signed-exchange).\r\nBut they should be in this webpackage repository.\r\nSo this patch copies them from \"horo-t/subresource-signed-exchange\"\r\nrepository.\r\n\r\nSpec issue: https://github.com/WICG/webpackage/issues/347\r\nTAG review: https://github.com/w3ctag/design-reviews/issues/352",
      "createdAt": "2019-12-04T02:05:19Z",
      "updatedAt": "2020-01-06T04:12:28Z",
      "closedAt": "2020-01-06T04:12:27Z",
      "mergedAt": "2020-01-06T04:12:27Z",
      "mergedBy": "horo-t",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI3MTgwMjcz",
          "commit": {
            "abbreviatedOid": "ba63b10"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "I didn't get to the Signed Exchange subresource substitution or fully review the security questionnaire for the rel=alternate explainer.",
          "createdAt": "2019-12-04T21:54:40Z",
          "updatedAt": "2019-12-05T00:54:38Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nWe want to allow the publisher of a resource to declare that a signed exchange is available holding the content of either that resource or one of its subresources. We expect aggregator sites (SNS, News site, search engine..) to use this to cache the signed version of a resource in order to serve it to their users. We expect UAs to use this to allow users to save the page in signed exchange format. When the publisher identifies a same-origin signed exchange for a cross-origin subresource, the UA can use that information to recursively prefetch the subresource without exposing its speculative activity across origins.\r\n\r\n[`<link rel=\"alternate\" type=\"application/signed-exchange\" href=...>`](https://html.spec.whatwg.org/multipage/links.html#rel-alternate) and the equivalent `Link` header are already defined to declare that the referenced document is a reformulation of the current document as a signed exchange. To offer signed exchanges for subresources, we propose to use the [`anchor` parameter](https://tools.ietf.org/html/rfc8288#section-3.2) to identify the replaced subresource. This may be the first use of the `anchor` parameter in the web platform.\r\n```",
              "createdAt": "2019-12-04T21:54:40Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 3,
              "body": "Could you wrap lines at 80 columns?",
              "createdAt": "2019-12-04T23:56:05Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nWe want to extend the usage of the existing [rel=alternate](https://html.spec.whatwg.org/multipage/links.html#rel-alternate) link header for signed exchange. Using this link header, the content publishers can declare that the resource is available in signed exchange format. This can be used both by the crawlers of aggregator sites  (social networks, News site, search engine..) and by the UAs. The crawlers can cache and serve the signed exchange of the content in their own server. The UAs can provide the users with a way to save the page in signe exchange format. And also signed exchange alternate links can be used to recursively prefetch appropriate subresource signed exchanges while prefetching the main resource signed exchange.\r\n```\r\n\r\nI think SNS means \"social networking service\", from https://en.wikipedia.org/wiki/SNS, but I had to look it up. We should expand acronyms at least the first time we use them, but I think we can just avoid this one.",
              "createdAt": "2019-12-04T23:57:02Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 3,
              "body": "```suggestion\r\nWe want to extend the usage of the existing [rel=alternate](https://html.spec.whatwg.org/multipage/links.html#rel-alternate) link header for signed exchange. Using this link header, the content publishers can declare that the resource is available in signed exchange format. This can be used both by the crawlers of aggregator sites  (SNS, News site, search engine..) and by the UAs. The crawlers can cache and serve the signed exchange of the content in their own server. The UAs can provide the users with a way to save the page in signed exchange format. And also signed exchange alternate links can be used to recursively prefetch appropriate subresource signed exchanges while prefetching the main resource signed exchange.\r\n```",
              "createdAt": "2019-12-04T23:57:43Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 29,
              "body": "```suggestion\r\n   - While the user of the UA is browsing an article (article.html), and if there is a signed exchange alternate link, the UA can provide the user with a way to save the page in signed exchange format. The saved file can be used to share with other users.\r\n```",
              "createdAt": "2019-12-04T23:57:54Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\n### Discovery of a signed exchange for the main resource\r\n```\r\n\r\nHowever, I'm not sure this use needs to be in an explainer at all. The \"Otherwise\" branch in https://html.spec.whatwg.org/multipage/links.html#rel-alternate already says that \"The keyword creates a hyperlink referencing an alternate representation of the current document. The nature of the referenced document is given by the hreflang, and type attributes.\" There's nothing new in saying that a signed exchange can be an alternate representation of a document. So maybe delete this whole sub-section.",
              "createdAt": "2019-12-05T00:01:01Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 13,
              "body": "Omit an `anchor` parameter if it's the same URL as the resource it appears in.\r\n```suggestion\r\n```",
              "createdAt": "2019-12-05T00:01:54Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 7,
              "body": "\r\n```suggestion\r\n1. A publisher can offer a signed exchange version of a resource using either a `Link` header on that resource of a `<link rel=\"alternate\">` element within the resource.\r\n```",
              "createdAt": "2019-12-05T00:04:17Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 7,
              "body": "I don't think the paragraphs in this section are really an ordered list.\r\n\r\n```suggestion\r\nContent publishers can declare the URL of signed exchange format of the content using an alternate link HTTP header or using an alternate link HTML element.\r\n```",
              "createdAt": "2019-12-05T00:04:54Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 20,
              "body": "Also omit this one.\r\n```suggestion\r\n            >\r\n```",
              "createdAt": "2019-12-05T00:05:47Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 32,
              "body": "I don't think crawlers are likely to respect subresource signed exchanges. They can just go to the original host, which can offer the signed exchange as a same-document alternative. So remove from here down to \"The aggregator site will serve\"?",
              "createdAt": "2019-12-05T00:17:22Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nWhile a user is browsing an aggregator site (https://feed.example), the aggregator guesses that the user is likely to want to read a particular article (https://publisher.example/article.html) and so inserts a prefetch link pointing to a signed exchange version of that article.\r\n```",
              "createdAt": "2019-12-05T00:19:36Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 65,
              "body": "```suggestion\r\nWhen the UA prefetches the signed exchange (article.html.sxg), the aggregator server includes a declaration that one of `article.html`'s subresources (https://cdn.publisher.example/lib.js) is also available from the same aggregator.\r\n```",
              "createdAt": "2019-12-05T00:21:03Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\nTo prevent an attacker from loading an incompatible version of the subresource, the resource _inside_ the signed exchange has to identify the exact version of the replacement signed exchange using a `Link: ... rel=\"allowed-alt-sxg\"` with the hash of the signed headers (which themselves include a hash of the content).\r\n\r\nTo prevent a tracker from conveying a user ID in their choice of which subresources to prefetch, the inner resource has to preload the same subresources that the aggregator prefetches.\r\n```",
              "createdAt": "2019-12-05T00:27:02Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\nIf the user navigates to the expected article, both the main resource of the article and the script subresource are loaded from the prefetched signed exchanges.\r\n```",
              "createdAt": "2019-12-05T00:27:41Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 128,
              "body": "Also, to prevent tracking (user ID transfer), if the aggregator failed to prefetch a subresource that the main resource preloads, the UA must drop all of the subresource prefetches. If the aggregator prefetches a superset of the preloaded subresources, the UA must drop the ones that weren't preloaded.",
              "createdAt": "2019-12-05T00:30:41Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 92,
              "body": "Probably just remove this sub-header.",
              "createdAt": "2019-12-05T00:47:35Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 86,
              "body": "```suggestion\r\nWhile prefetching an HTML resource:\r\n```\r\n\r\nThen write an explicit loop that checks if every preload has a matching and allowed prefetch before deciding to use all of the prefetches.",
              "createdAt": "2019-12-05T00:53:30Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI3Mzc1NDcw",
          "commit": {
            "abbreviatedOid": "ba63b10"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you for the review.",
          "createdAt": "2019-12-05T08:30:30Z",
          "updatedAt": "2019-12-05T09:41:28Z",
          "comments": [
            {
              "originalPosition": 3,
              "body": "Done",
              "createdAt": "2019-12-05T08:30:30Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 3,
              "body": "done",
              "createdAt": "2019-12-05T08:32:25Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 6,
              "body": "Deleted this whole sub-section.",
              "createdAt": "2019-12-05T08:35:22Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 61,
              "body": "Done.",
              "createdAt": "2019-12-05T08:42:17Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 32,
              "body": "Done.",
              "createdAt": "2019-12-05T08:42:22Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 65,
              "body": "done",
              "createdAt": "2019-12-05T08:47:17Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 73,
              "body": "done",
              "createdAt": "2019-12-05T08:47:26Z",
              "updatedAt": "2019-12-23T08:23:06Z"
            },
            {
              "originalPosition": 83,
              "body": "Done",
              "createdAt": "2019-12-05T08:48:57Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 92,
              "body": "Done",
              "createdAt": "2019-12-05T08:56:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 128,
              "body": "Done",
              "createdAt": "2019-12-05T09:22:22Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 86,
              "body": "Done",
              "createdAt": "2019-12-05T09:37:34Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 3,
              "body": "done",
              "createdAt": "2019-12-05T09:37:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4NDk4OTQ1",
          "commit": {
            "abbreviatedOid": "3a44a08"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-06T22:49:39Z",
          "updatedAt": "2019-12-07T00:20:18Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I wonder if \"replaceable\" would be a better word than \"replaced\", since the UA isn't required to replace it.\r\n\r\n```suggestion\r\nidentify the replaceable subresource. This may be the first use of the `anchor`\r\n```",
              "createdAt": "2019-12-06T22:49:39Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nsubresources. We expect aggregator sites (social networks, news sites, search\r\n```",
              "createdAt": "2019-12-06T22:50:28Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 6,
              "body": "```suggestion\r\nengines, etc.) to use this to cache the signed version of a resource in order to\r\n```",
              "createdAt": "2019-12-06T22:50:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 8,
              "body": "```suggestion\r\npage in signed exchange format so they can share it with their peers. When the publisher identifies a same-origin\r\n```",
              "createdAt": "2019-12-06T22:51:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 36,
              "body": "I think this could join the previous paragraph. \r\n```suggestion\r\nThe aggregator server expresses this by serving `article.html.sxg` with a `Link` header identifying the subresource's alternate form:\r\n```",
              "createdAt": "2019-12-06T23:18:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 73,
              "body": "```suggestion\r\nWhile prefetching an HTML resource in signed exchange format:\r\n```",
              "createdAt": "2019-12-06T23:19:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 75,
              "body": "```suggestion\r\n1. When the UA detects a \"preload\" link HTTP header in the inner response,\r\n```",
              "createdAt": "2019-12-06T23:19:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 76,
              "body": "```suggestion\r\ncheck whether a matching \u201callowed-alt-sxg\u201d link HTTP header in the inner response\r\n```",
              "createdAt": "2019-12-06T23:19:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 77,
              "body": "```suggestion\r\nexists or not. (Note that multiple `allowed-alt-sxg` links can be present for the same preload if they include `variants` and `variant-key` attributes. In that case, the UA uses the algorithm ...\r\n```",
              "createdAt": "2019-12-06T23:21:45Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\n1. If an `allowed-alt-sxg` link exists, check whether the signed exchange was served with a matching \u201calternate\u201d link HTTP header.\r\n```",
              "createdAt": "2019-12-06T23:23:02Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 83,
              "body": "```suggestion\r\n1. If the outer signed exchange did identify an alternate version of the subresource, prefetch the subresource signed exchange instead ...\r\n```",
              "createdAt": "2019-12-06T23:24:16Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 149,
              "body": "The state of the cache for another origin is potentially sensitive, and this specification avoids exposing it by making the decision to fetch an alternative not depend on the presence or absence of the subresource in its cache.",
              "createdAt": "2019-12-06T23:28:53Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 152,
              "body": "Prefetched resources, including signed exchanges, are stored to the HTTP cache as normal, but the association of a signed exchange with its contained resource is not persisted. Right now, the contained resource is not independently stored in the HTTP cache, although that decision may be revisited.",
              "createdAt": "2019-12-06T23:30:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 157,
              "body": "The use of Variants exposes the UA's content negotiation preferences to the aggregator's origin, but that's already exposed by the UA's Accept headers.",
              "createdAt": "2019-12-06T23:31:37Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 167,
              "body": "Well, yes, loading a script from a signed exchange is different from loading it over TLS. We think it's not *significantly* different.",
              "createdAt": "2019-12-06T23:38:12Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 175,
              "body": "```suggestion\r\n   - None\r\n```",
              "createdAt": "2019-12-06T23:38:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 189,
              "body": "There's active discussion about how signed exchanges are a downgrade compared to TLS, and this particular specification allows recursive use of signed exchanges.",
              "createdAt": "2019-12-06T23:40:35Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 90,
              "body": "I believe it's this content negotiation that makes subresource signed exchanges continue to be interesting even after we ship signed bundles. Could you discuss that here?",
              "createdAt": "2019-12-06T23:44:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 1,
              "body": "It's not clear to me how this explainer is different from the explainer above. If the one above had only use cases that didn't use `rel=allowed-alt-sxg` (for example, to allow a page to declaratively replace its own cross-origin subresources with same-origin SXGs), they'd be clearly different, but its use cases do use `rel=allowed-alt-sxg`. Could you either merge them or make them more distinct?",
              "createdAt": "2019-12-06T23:45:57Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 5,
              "body": "The introduction should start with the user problem we want to solve, rather than the technical solution we think solves it.",
              "createdAt": "2019-12-06T23:46:19Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 23,
              "body": "We should say what's problematic, not just declare that it is. Specifically,\r\n\r\n```suggestion\r\nfile while the user is browsing the feed site. But this leaks that the user's search results include a page using this JS library before the user has consented by clicking on the link.\r\n```",
              "createdAt": "2019-12-06T23:48:58Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 25,
              "body": "This seems to overlap with the `rel=prenavigate` discussion. Could you link to the most recent state of that discussion, and if it doesn't completely solve the problem, add a separate section here, maybe an appendix, that explains how prenavigate isn't sufficient.",
              "createdAt": "2019-12-06T23:54:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 27,
              "body": "```suggestion\r\nSigned Exchanges solve this\r\n```",
              "createdAt": "2019-12-06T23:55:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 36,
              "body": "The publisher doesn't have to independently provide the header integrity value, right? That's computable from the SXG itself?",
              "createdAt": "2019-12-07T00:05:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\n1. The signed HTTP response inside the signed exchange (https://publisher.example/article.html) has an `allowed-alt-sxg` link header to declare\r\n```",
              "createdAt": "2019-12-07T00:06:56Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 40,
              "body": "```suggestion\r\nexactly what version of the subresource is compatible with this main resource.\r\n```",
              "createdAt": "2019-12-07T00:07:16Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "I think this paragraph can go away?",
              "createdAt": "2019-12-07T00:10:22Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 51,
              "body": "This is probably better solved by bundles.",
              "createdAt": "2019-12-07T00:10:39Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 69,
              "body": "These seem like Chromium-internal concepts rather than things the TAG needs to think about.",
              "createdAt": "2019-12-07T00:11:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 88,
              "body": "This seems very similar to other explainer's algorithm. Maybe add anything that's missing there and remove this one?",
              "createdAt": "2019-12-07T00:12:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 126,
              "body": "```suggestion\r\nfor this purpose, because SRI\u2019s integrity only covers the content body and not any of the headers.\r\n```",
              "createdAt": "2019-12-07T00:14:35Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 132,
              "body": "This section is covered in the other explainer.",
              "createdAt": "2019-12-07T00:15:33Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 109,
              "body": "```suggestion\r\nThe `header-integrity` parameter of the `allowed-alt-sxg` link is the SHA256 hash value of the *signedHeaders* value from the\r\n```",
              "createdAt": "2019-12-07T00:16:26Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 115,
              "body": "```suggestion\r\nagain or changes the signing key. This header-integrity value also guarantees the content body hasn't changed, because the signed headers are required to include a `Digest` header with a hash of the content body.\r\n```",
              "createdAt": "2019-12-07T00:17:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 188,
              "body": "Only include this section in one of the explainers.",
              "createdAt": "2019-12-07T00:18:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 137,
              "body": "And to prevent the distributor from selecting a version of the subresource that isn't compatible with the selected version of the main resource, which might introduce a security hole.",
              "createdAt": "2019-12-07T00:20:14Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI4NjkyODg5",
          "commit": {
            "abbreviatedOid": "3a44a08"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Merged to one explainer.\r\nhttps://github.com/horo-t/webpackage/blob/add-subresource-signed-exchange/explainers/signed-exchange-subresource-subtitution-explainer.md\r\n\r\nPlease review this.",
          "createdAt": "2019-12-09T05:23:11Z",
          "updatedAt": "2019-12-09T09:58:56Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "done",
              "createdAt": "2019-12-09T05:23:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 6,
              "body": "done",
              "createdAt": "2019-12-09T05:23:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 8,
              "body": "done",
              "createdAt": "2019-12-09T05:24:12Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 18,
              "body": "done",
              "createdAt": "2019-12-09T05:24:43Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 36,
              "body": "done",
              "createdAt": "2019-12-09T05:25:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 75,
              "body": "done",
              "createdAt": "2019-12-09T05:26:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 77,
              "body": "done",
              "createdAt": "2019-12-09T05:26:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 76,
              "body": "done",
              "createdAt": "2019-12-09T05:26:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 81,
              "body": "done",
              "createdAt": "2019-12-09T05:29:57Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 83,
              "body": "done",
              "createdAt": "2019-12-09T05:30:06Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 175,
              "body": "done",
              "createdAt": "2019-12-09T05:37:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 90,
              "body": "Sorry, what topic do you want to discuss?\r\nWeb Bundles have similar content negotiation logic using `variants-value`.\r\n",
              "createdAt": "2019-12-09T05:45:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 149,
              "body": "Added.",
              "createdAt": "2019-12-09T05:47:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 152,
              "body": "Done.",
              "createdAt": "2019-12-09T05:48:37Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 157,
              "body": "done.",
              "createdAt": "2019-12-09T05:49:09Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 167,
              "body": "Changed.",
              "createdAt": "2019-12-09T05:50:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 189,
              "body": "Done.",
              "createdAt": "2019-12-09T05:50:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 23,
              "body": "Done",
              "createdAt": "2019-12-09T06:38:02Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 27,
              "body": "Done",
              "createdAt": "2019-12-09T06:38:27Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 39,
              "body": "I think `allowed-alt-sxg` should work even when the HTML is not a signed exchange.",
              "createdAt": "2019-12-09T06:41:04Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 40,
              "body": "Done.",
              "createdAt": "2019-12-09T06:41:37Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 51,
              "body": "Removed.",
              "createdAt": "2019-12-09T06:44:17Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 109,
              "body": "Done",
              "createdAt": "2019-12-09T06:47:16Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 115,
              "body": "Done.",
              "createdAt": "2019-12-09T06:48:20Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 126,
              "body": "Done.",
              "createdAt": "2019-12-09T06:50:01Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "Done.",
              "createdAt": "2019-12-09T06:54:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 36,
              "body": "That's computable. Removed \"along with...\".",
              "createdAt": "2019-12-09T06:55:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 137,
              "body": "Done.",
              "createdAt": "2019-12-09T07:01:38Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 73,
              "body": "Done",
              "createdAt": "2019-12-09T07:12:55Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 25,
              "body": "Done",
              "createdAt": "2019-12-09T07:55:55Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 69,
              "body": "I think it is easy to understand the logic if we have name of  the two cache mechanism.",
              "createdAt": "2019-12-09T08:02:56Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 5,
              "body": "Done",
              "createdAt": "2019-12-09T09:30:48Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 1,
              "body": "Merged.",
              "createdAt": "2019-12-09T09:31:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 88,
              "body": "Merged",
              "createdAt": "2019-12-09T09:31:20Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 132,
              "body": "Merged",
              "createdAt": "2019-12-09T09:31:34Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 188,
              "body": "Merged.",
              "createdAt": "2019-12-09T09:31:48Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5MzE3MzEz",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "",
          "createdAt": "2019-12-09T22:10:54Z",
          "updatedAt": "2019-12-10T00:51:27Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This should start by describing the user-facing problem we want to solve, as described in https://github.com/w3ctag/w3ctag.github.io/blob/master/explainers.md.\r\n\r\nHere, that might be the following, but please double-check that it actually captures what you mean, and that it's reasonable readable:\r\n\r\n> Users want to see the result of their clicks as fast as possible. This goal benefits from letting a site tell the UA to `prenavigate` to the particular outbound link(s) it thinks the user is most likely to click on. However, naively prenavigating to a cross-origin link [leaks that user visited](https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-privacy-preserving-prefetch) the referring page, which the referrer shouldn't do before the user has clicked. The referrer can safely prenavigate to a referrer-origin signed exchange for the top-level HTML of that link, but the UA still can't prefetch that link's subresources without leaking the same information about the user.\r\n>\r\n> We want the referrer to be able to identify that a particular subresource of a prenavigated link is available as a signed exchange served by their own organization. The [`Link: <subresource.sxg>; rel=\"alternate\", type=\"application/signed-exchange\"; anchor=\"subresource\"` header](https://html.spec.whatwg.org/multipage/links.html#rel-alternate) is already defined to identify such alternate forms, where the [`anchor` parameter](https://tools.ietf.org/html/rfc8288#section-3.2) states that the alternate form is for a resource other than the one the `Link` header is attached to.\r\n>\r\n> Arbitrarily replacing a target link's subresources is unsafe for several reasons, so we propose that the target link opt into particular replacements by including a link with `rel=allowed-alt-sxg`.\r\n>\r\n> We think the `<link rel=\"alternate\" type=\"application/signed-exchange\"> formulation is also useful for two other purposes:\r\n> 1. Identifying to a UA or web crawler that the page they're visiting is available as a signed exchange that the user or crawler could download and then send to other users peer-to-peer. This doesn't need either `rel=allowed-alt-sxg` or the `anchor` parameter.\r\n> 2. Identifying that some cross-origin subresources are available as same-origin signed exchanges. This needs the `anchor` parameter, but as long as the instruction to replace subresources is embedded in the document whose subresources are being replaced, it doesn't need `rel=allowed-alt-sxg`.",
              "createdAt": "2019-12-09T22:10:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "I think you can omit the discussion of why double-keyed caching is proposed.",
              "createdAt": "2019-12-09T22:26:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "```suggestion\r\ncross-origin navigation prefetch work with double-keyed caching which is proposed\r\n```",
              "createdAt": "2019-12-09T22:26:21Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 50,
              "body": "```suggestion\r\n[still leaks information before the user has clicked on a link](https://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#private-prefetch).\r\n```",
              "createdAt": "2019-12-09T22:27:15Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 53,
              "body": "```suggestion\r\nSigned Exchanges solve this privacy-preserving prefetching problem for main\r\n```",
              "createdAt": "2019-12-09T22:27:49Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 53,
              "body": "If you take my suggestion for the introduction, I think this paragraph is redundant with it. This section should go into more detail about how the aggregator and publisher solve the use case, but not restate the overall problem.",
              "createdAt": "2019-12-09T23:39:58Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 65,
              "body": "We've teased the `rel=allowed-alt-sxg` link in the introduction. I think it'll read better if we put its definition before we use it again. So ... maybe put at least some part of the \"Proposal\" and \"Header integrity of signed exchange\" sections before this section of how to solve the use cases?",
              "createdAt": "2019-12-09T23:43:32Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 75,
              "body": "This section looks like the same use case as the \"Privacy-preserving prefetching subresources\" section. Either make them more clearly distinct or remove one.",
              "createdAt": "2019-12-09T23:45:02Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 127,
              "body": "This reads like these are Chrome internals. Folks reading an explainer don't want to see Chrome internals, and most of them don't even want to see the internal variables that'll eventually be used to specify the behavior. If this is important, you might be able to say that, while a document is open, it collects the resources that it prefetches, and then transfers a subset of them across the next navigation.",
              "createdAt": "2019-12-09T23:52:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 140,
              "body": "`ref-for` fragments aren't generally stable. Do you mean https://wicg.github.io/webpackage/loading.html#parsing-a-signed-exchange?",
              "createdAt": "2019-12-09T23:53:29Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 147,
              "body": "This is going to alarm people. Could you include a link to a description of how this doesn't allow servers to pass a user ID from one top-level context to another?",
              "createdAt": "2019-12-09T23:55:43Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 135,
              "body": "Are these still expected to be `prefetch`es or are they now `prenavigate`s?",
              "createdAt": "2019-12-09T23:56:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 134,
              "body": "```suggestion\r\n1. While processing a\r\n```",
              "createdAt": "2019-12-09T23:56:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 138,
              "body": "```suggestion\r\n   - If the UA successfully prefetches the signed exchange (including the merkle integrity\r\n```",
              "createdAt": "2019-12-09T23:57:31Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 139,
              "body": "```suggestion\r\n   check of the body), it stores the parsedExchange which is the result of\r\n```",
              "createdAt": "2019-12-09T23:57:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 144,
              "body": "Presumably except for the one that serves the navigation itself?",
              "createdAt": "2019-12-10T00:03:57Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 148,
              "body": "This step should set up what it's trying to do. I think that's something like\r\n\r\n> The navigated-to document has a set of preloads for which it uses the `allowed-alt-sxg` link relation to declare that they can be served by signed exchanges. The UA either serves all of them from SXGs prefetched by the previous page, or none of them.",
              "createdAt": "2019-12-10T00:06:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 161,
              "body": "\"request\" hasn't been introduced yet.",
              "createdAt": "2019-12-10T00:07:28Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 167,
              "body": "This also looks like the same scenario as the previous section.",
              "createdAt": "2019-12-10T00:08:59Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 190,
              "body": "There should probably be a section that starts with a definition of the `allowed-alt-sxg` link relation, including an example header expressing it.",
              "createdAt": "2019-12-10T00:15:04Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 219,
              "body": "I don't follow \"defined in the header\". ",
              "createdAt": "2019-12-10T00:16:31Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 217,
              "body": "Maybe\r\n\r\n```suggestion\r\nany of the signed exchanges (eg: sig matching, URL matching, Merkle Integrity\r\n```\r\n\r\n?",
              "createdAt": "2019-12-10T00:16:43Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 215,
              "body": "It's not clear what \"matching\" means here. I think you're referring to subresource preloads that are provided by prefetches on the previous page?",
              "createdAt": "2019-12-10T00:18:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 240,
              "body": "This might be easier to read as something like, \"However, the imagesrcset attribute allows a single preload link to declare multiple different target URLs, and it's difficult to embed a `header-integrity` value for each of those URLs into the existing syntax. Instead, we use a separate link that gives a hash of the expected content for each of the possible URLs, while the preload tag continues to select which of the URLs is actually used.\"\r\n\r\n(I do want to double-check that you can defend that claim that it's difficult to embed. Why couldn't it just come after the XXXw field?)",
              "createdAt": "2019-12-10T00:23:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 334,
              "body": "```suggestion\r\nIf a UA supports WebP, the UA must prefetch **image_webp.sxg** holding a WebP image.\r\n```\r\n\r\nThis isn't \"should\", since it's defined by the variants algorithm.",
              "createdAt": "2019-12-10T00:25:10Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 344,
              "body": "```suggestion\r\nwere prefetched in the immediate referrer page. This is intended to avoid leaking the\r\n```\r\n\r\nIt's not clear to me exactly what information gets leaked if we do allow a series of navigations, especially same-origin navigations, to continue using the same set of prefetches. Maye the benefit isn't there, since the first page can just re-prefetch the same-origin content, but then we should say that instead of being vague about the leak.",
              "createdAt": "2019-12-10T00:33:46Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 351,
              "body": "\"The UA needs to check that the signed request URL matches the preload link and not just that the header-integrity value matches, since the header-integrity hash doesn't cover the request URL.\"",
              "createdAt": "2019-12-10T00:36:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 359,
              "body": "```suggestion\r\neven if the HTTP cache already contains the original subresource (http://cdn.publisher.example/lib.js)\r\n```\r\n\r\nAlthough it's not clear to me in this system how the UA would even know what the original subresource URL is before fetching the SXG.",
              "createdAt": "2019-12-10T00:36:29Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 362,
              "body": "This is a duplicate of the previous bullet point.",
              "createdAt": "2019-12-10T00:37:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 365,
              "body": "This is very similar to the first bullet in this list. Put them next to each other.",
              "createdAt": "2019-12-10T00:38:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 369,
              "body": "This one should probably start, \"If a replaced subresource prefetch hasn't completed by the time the UA would start fetching it in the course of loading the next page, the UA must cancel that prefetch and fetch the resource from its original URL. This prevents the distributor from ...\"",
              "createdAt": "2019-12-10T00:40:31Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 377,
              "body": "Isn't this the same as the \"To prevent tracking (user ID transfer)\" item?",
              "createdAt": "2019-12-10T00:41:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 383,
              "body": "Is this true? Who is it exposed to and under what circumstances? When is the alternative SXG even in the HTTP cache? Which partition?",
              "createdAt": "2019-12-10T00:44:23Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 386,
              "body": "Say what the limitations accomplish here, not just that some phrases exist in other parts of this document.",
              "createdAt": "2019-12-10T00:45:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 391,
              "body": "Also, any personal information that was incorrectly included in a signed exchange would be the information of the aggregator that fetched the SXG, and not the end user.\r\n\r\nThe use of `<link rel=alternate>` to identify the SXG for the current page could inform the UA to omit credentials in fetching that SXG, which would prevent any personal information from being accidentally included.",
              "createdAt": "2019-12-10T00:49:18Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NTYyNjA5",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T02:52:54Z",
          "updatedAt": "2019-12-10T02:52:55Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "I have one question.\r\n\r\nI think \"allowed-alt-sxg\" is useful even when the HTML is not served via signed exchange.\r\n\r\n1. An aggregator site prefetches \"https://aggregator.example/publisher.example/lib.js.sxg\".\r\n2. The user clicks a link to \"https://publisher.example/article.html\".\r\n3. The HTTP response header has `Link: <https://publisher.example/lib.js>; rel=\"allowed-alt-sxg\"; header-integrity=\"sha256-...\"` header.\r\n4. When the UA detects <script src=\"./lib.js\">, the UA checks the header-integrity attribute value of the link rel=\"allowed-alt-sxg\" header and the header-integrity value of \"lib.js.sxg\" in cache:\r\n   - If they match, the UA will use \"lib.js.sxg\" in the cache.\r\n   - Otherwise, the UA will fetch \"https://publisher.example/lib.js\".\r\n\r\nDo you think this use case is not useful?\r\nIf so, I will remove this use case and make \"allowed-alt-sxg\" work only when the HTML is served via signed exchange.",
              "createdAt": "2019-12-10T02:52:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NTgyODEy",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T04:25:10Z",
          "updatedAt": "2019-12-10T04:25:10Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "I feel like that's unlikely to be helpful: the referrer has to guess that a page with a particular set of preloaded and replaceable subresources will be the next link clicked, without being able to predict exactly which link it is? I do agree that it's technically possible.",
              "createdAt": "2019-12-10T04:25:10Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NTkxMzY1",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-10T05:06:58Z",
          "updatedAt": "2019-12-10T05:06:58Z",
          "comments": [
            {
              "originalPosition": 75,
              "body": "OK. I agree with you.\r\nI will remove this use case, and merge \"Privacy-preserving prefetching subresources\" and \"Recursive subresource signed exchange prefetch\".",
              "createdAt": "2019-12-10T05:06:58Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzI5NjM1Mjc4",
          "commit": {
            "abbreviatedOid": "02ab3eb"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you very much for reviewing.",
          "createdAt": "2019-12-10T07:39:50Z",
          "updatedAt": "2019-12-10T09:27:24Z",
          "comments": [
            {
              "originalPosition": 240,
              "body": "Done.\r\nIf we change the syntax of imagesrcset, existing browsers may not understand the new syntax. I think we should avoid it.",
              "createdAt": "2019-12-10T07:39:50Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 219,
              "body": "Removed",
              "createdAt": "2019-12-10T07:40:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 334,
              "body": "done.",
              "createdAt": "2019-12-10T07:41:20Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 344,
              "body": "Done.\r\nAh, yes. We may be able to allow same-origin navigations.\r\nBut I prefer stricter restrictions for privacy and security.",
              "createdAt": "2019-12-10T07:44:17Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 351,
              "body": "Done",
              "createdAt": "2019-12-10T08:05:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 362,
              "body": "Removed",
              "createdAt": "2019-12-10T08:06:42Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 365,
              "body": "Moved.",
              "createdAt": "2019-12-10T08:08:11Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 369,
              "body": "Done.",
              "createdAt": "2019-12-10T08:10:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 377,
              "body": "Removed",
              "createdAt": "2019-12-10T08:10:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 383,
              "body": "Changed to\r\n> This feature exposes the 1 bit information \"the referrer page has prefetched the signed exchange subresources or not\" to the publisher.",
              "createdAt": "2019-12-10T08:20:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 386,
              "body": "Added\r\n> Thanks to these limitations, this feature exposes only 1 bit information to the publisher.",
              "createdAt": "2019-12-10T08:26:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 391,
              "body": "Added.",
              "createdAt": "2019-12-10T08:30:56Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 5,
              "body": "I think we don't need \"We think ...\" in this explainer.\r\nThey are out of scope of this explainer.",
              "createdAt": "2019-12-10T08:54:02Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "Removed.",
              "createdAt": "2019-12-10T08:54:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 46,
              "body": "Removed.",
              "createdAt": "2019-12-10T08:56:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 50,
              "body": "Removed",
              "createdAt": "2019-12-10T08:56:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 53,
              "body": "Removed.",
              "createdAt": "2019-12-10T08:57:25Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 53,
              "body": "Removed.",
              "createdAt": "2019-12-10T08:57:44Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 135,
              "body": "Done.",
              "createdAt": "2019-12-10T09:00:35Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 138,
              "body": "Done.",
              "createdAt": "2019-12-10T09:00:49Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 139,
              "body": "Done.",
              "createdAt": "2019-12-10T09:01:04Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 140,
              "body": "Done.",
              "createdAt": "2019-12-10T09:01:12Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 144,
              "body": "Yes.\r\nAdded.",
              "createdAt": "2019-12-10T09:01:21Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 147,
              "body": "Added\r\n> (Note that [header integrity check](#header-integrity-of-signed-exchange) prohibits the distributor from passing a tracking ID to the publisher.)",
              "createdAt": "2019-12-10T09:01:49Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 161,
              "body": "Changed to refer \"linked resource fetch setup steps\".",
              "createdAt": "2019-12-10T09:02:09Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 167,
              "body": "Removed \"Privacy-preserving prefetching subresources\".",
              "createdAt": "2019-12-10T09:03:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 148,
              "body": "Added.",
              "createdAt": "2019-12-10T09:04:27Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 190,
              "body": "Done.\r\nHow about this?",
              "createdAt": "2019-12-10T09:04:40Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 215,
              "body": "Changed to\r\n> If there are multiple subresource preloads that are provided by prefetches on\r\nthe previous page in signed exchange format",
              "createdAt": "2019-12-10T09:12:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 217,
              "body": "Done",
              "createdAt": "2019-12-10T09:12:13Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 359,
              "body": "Done.\r\n\r\nIf we don't need to think about privacy, when the HTTP cache has \"lib.js\", UAs don't need to fetch \"lib.js.sxg\" when the UA see rel=preload and rel=allowed-alt-sxg and rel=alternate for better performance. But we can't do that for the privacy reason.",
              "createdAt": "2019-12-10T09:18:12Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNjA0NTQy",
          "commit": {
            "abbreviatedOid": "82bbcba"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "This looks much better! Thank you for bearing with the long review.\r\n\r\nI'm approving now, but feel free to ask for another round if you have more questions about my comments here.",
          "createdAt": "2019-12-13T00:17:00Z",
          "updatedAt": "2019-12-13T01:14:39Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "I don't have a feeling for whether we're going to want `prefetch` or `prenavigate` here. I bet the TAG will ask too, so have an answer ready.",
              "createdAt": "2019-12-13T00:17:00Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 61,
              "body": "```suggestion\r\nThis means that the inner response of the main resource signed exchange (article.html.sxg)\r\n```",
              "createdAt": "2019-12-13T00:18:41Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 59,
              "body": "```suggestion\r\nsubresources to prefetch, the inner resource also has to preload the same\r\n```",
              "createdAt": "2019-12-13T00:18:48Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 81,
              "body": "\"prenavigating\" or \"prefetching\"?",
              "createdAt": "2019-12-13T00:23:07Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 92,
              "body": "I think we're not doing cross-origin recursive prefetches (if we are, the top of this document says that's a privacy problem), so you can drop \"instead of ...\".",
              "createdAt": "2019-12-13T00:24:52Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 99,
              "body": "Which `Document`? Since they're triggered by the top-level SXG's response, I *think* we could attach them to that response, so they're only used on a navigation to that particular response. They could also be attached as prefetches to the source document and then used for any acceptable navigation, but that seems less obviously safe.",
              "createdAt": "2019-12-13T00:30:36Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 95,
              "body": "This may be more detail than readers want. Would it make sense to just say that if the resulting signed exchange is valid and matches the `allowed-alt-sxg` link, we attach it to the top-level prefetch?",
              "createdAt": "2019-12-13T00:35:31Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 102,
              "body": "```suggestion\r\nthe UA copies the signed exchanges that were prefetched above to the\r\n```",
              "createdAt": "2019-12-13T00:38:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 104,
              "body": "```suggestion\r\n    - Note that as browsers move toward partitioned HTTP caches, the source document's cache will likely be separate from the target's cache, so we can't just pass prefetched content through the cache.\r\n```",
              "createdAt": "2019-12-13T00:40:10Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 106,
              "body": "This has been mentioned a couple times already, so maybe we can skip it here. If not, it deserves a separate bullet point.",
              "createdAt": "2019-12-13T00:47:14Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 115,
              "body": "These steps need to be consistent about whether we're talking about a single preload header or the whole set of them. It'll probably be shorter (==easier to read) if we consistently talk about the whole set, so something like\r\n\r\n> 1. For each preload, use the imagesrcset and imagesizes attributes to pick a single URL to preload.\r\n> 2. Identify the subset _SxgPreloads_ of those preloads with an `allowed-alt-sxg` link for that selected URL.\r\n> 3. If every member of _SxgPreloads_ has a valid signed exchange that was transferred from the referring document, use the signed contents of those resources to satisfy the preloads. Ignore any other prefetched signed exchanges.\r\n> 4. Otherwise, ignore all prefetched signed exchanges and re-fetch the preloads from their original URLs.",
              "createdAt": "2019-12-13T00:56:30Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 131,
              "body": "```suggestion\r\n## Identifying exactly one version of a signed exchange\r\n```",
              "createdAt": "2019-12-13T00:57:18Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 160,
              "body": "```suggestion\r\n[SRI `integrity` attribute](https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity)\r\n```",
              "createdAt": "2019-12-13T00:59:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 161,
              "body": "```suggestion\r\nfor this purpose, because SRI\u2019s `integrity` attribute only covers the content body and not\r\n```",
              "createdAt": "2019-12-13T00:59:19Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 163,
              "body": "```suggestion\r\n`allowed-alt-sxg` link header, a tracker can use signed exchanges that differ in headers like their `Content-Type` to transfer a user ID via a pattern of parsing failures.\r\n```",
              "createdAt": "2019-12-13T01:00:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 154,
              "body": "I *think* this paragraph is already explained elsewhere.",
              "createdAt": "2019-12-13T01:00:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 150,
              "body": "```suggestion\r\nagain or changes the signing key, but it does change if any of the headers or body change. (It catches changes to the body because a valid signed exchange's headers have to include a `Digest` value that covers the body.)\r\n```",
              "createdAt": "2019-12-13T01:02:24Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 79,
              "body": "```suggestion\r\n# Algorithm sketch\r\n```",
              "createdAt": "2019-12-13T01:02:51Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 170,
              "body": "This \"must\" is covered above. Is there anything in this section that's not already covered? If there is, try to prune out the repetitive bits by referring to the algorithm. If not, just remove this section.",
              "createdAt": "2019-12-13T01:05:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 219,
              "body": "```suggestion\r\n[signature expiration time](https://wicg.github.io/webpackage/loading.html#exchange-signature-expiration-time)\r\n```",
              "createdAt": "2019-12-13T01:06:21Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 288,
              "body": "```suggestion\r\n# Security and Privacy Considerations\r\n```",
              "createdAt": "2019-12-13T01:08:47Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 298,
              "body": "```suggestion\r\nwere prefetched in the immediate referrer page. This is intended to avoid\r\n```",
              "createdAt": "2019-12-13T01:10:04Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 307,
              "body": "It's more that the UA's decision of whether to fetch signed exchange subresources MUST NOT depend on whether the HTTP cache already contains the original subresource. The UA is free to avoid fetching them for other reasons.",
              "createdAt": "2019-12-13T01:11:08Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 317,
              "body": "```suggestion\r\ndistributor from interfering the publisher\u2019s page. (Eg. intentionally blocking or delaying...\r\n```",
              "createdAt": "2019-12-13T01:11:26Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 300,
              "body": "```suggestion\r\n- The UA checks the header integrity value, so the distributor of the subresource\r\n```",
              "createdAt": "2019-12-13T01:11:42Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 302,
              "body": "```suggestion\r\nprevents distributors from sending mismatched versions or tracking IDs to the publisher\u2019s page.\r\n```",
              "createdAt": "2019-12-13T01:11:52Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            },
            {
              "originalPosition": 381,
              "body": "I think the publisher's site winds up treated as a first-party origin, since it gets to be top-level after the navigation.\r\n\r\nThe behavior doesn't line neatly up under the heading of first- vs third-party, but I think we're trying to treat the distributor as a third-party, and of course cross-origin subresources are third-parties.",
              "createdAt": "2019-12-13T01:13:54Z",
              "updatedAt": "2019-12-23T08:23:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1Njk3MjM0",
          "commit": {
            "abbreviatedOid": "82bbcba"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you very much!",
          "createdAt": "2019-12-23T03:10:43Z",
          "updatedAt": "2019-12-23T08:23:56Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Added Note.",
              "createdAt": "2019-12-23T03:10:43Z",
              "updatedAt": "2019-12-23T08:23:56Z"
            },
            {
              "originalPosition": 59,
              "body": "Done",
              "createdAt": "2019-12-23T03:11:00Z",
              "updatedAt": "2019-12-23T08:23:56Z"
            },
            {
              "originalPosition": 61,
              "body": "Done",
              "createdAt": "2019-12-23T03:11:30Z",
              "updatedAt": "2019-12-23T08:23:56Z"
            },
            {
              "originalPosition": 79,
              "body": "Done",
              "createdAt": "2019-12-23T03:11:44Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 92,
              "body": "Done.",
              "createdAt": "2019-12-23T03:17:07Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 99,
              "body": "In the current Chromium implementation, the prefetched subresource signed exchanges can be used for any navigation from the source document.\r\nBut I think it is OK to restrict to the particular navigation.\r\n(I need to change the implementation, though.)",
              "createdAt": "2019-12-23T03:25:09Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 104,
              "body": "Done",
              "createdAt": "2019-12-23T03:28:23Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 106,
              "body": "Done.",
              "createdAt": "2019-12-23T03:28:28Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 115,
              "body": "Done",
              "createdAt": "2019-12-23T03:31:07Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 131,
              "body": "Done",
              "createdAt": "2019-12-23T03:31:26Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 150,
              "body": "Done.",
              "createdAt": "2019-12-23T03:32:02Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 154,
              "body": "Removed.",
              "createdAt": "2019-12-23T03:32:57Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 160,
              "body": "Done.",
              "createdAt": "2019-12-23T03:33:13Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 161,
              "body": "Done.",
              "createdAt": "2019-12-23T03:34:20Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 163,
              "body": "done.",
              "createdAt": "2019-12-23T03:34:43Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 170,
              "body": "Removed",
              "createdAt": "2019-12-23T07:49:48Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 219,
              "body": "Done",
              "createdAt": "2019-12-23T07:50:10Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 288,
              "body": "Done",
              "createdAt": "2019-12-23T07:50:21Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 298,
              "body": "Done.",
              "createdAt": "2019-12-23T07:50:37Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 300,
              "body": "Done",
              "createdAt": "2019-12-23T07:56:12Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 302,
              "body": "Done",
              "createdAt": "2019-12-23T07:56:55Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 307,
              "body": "Done.",
              "createdAt": "2019-12-23T07:58:36Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 317,
              "body": "Done.",
              "createdAt": "2019-12-23T07:58:56Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 381,
              "body": "Done.",
              "createdAt": "2019-12-23T08:05:49Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 81,
              "body": "Added a link to the github issue.",
              "createdAt": "2019-12-23T08:13:36Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            },
            {
              "originalPosition": 102,
              "body": "Done.",
              "createdAt": "2019-12-23T08:15:27Z",
              "updatedAt": "2019-12-23T08:23:57Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3f0145a1e15f0482ab19a2c286e220a0c9637be8",
      "headRepository": "horo-t/webpackage",
      "headRefName": "add-subresource-signed-exchange",
      "headRefOid": "a67da352a41a99e7481c1cd7b3737615476315c2",
      "mergeCommit": {
        "oid": "f1a5a962b0f41a1c755a835c5909463aef5491b6"
      }
    },
    {
      "number": 543,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUyMzYxNTUw",
      "title": "make certurl.CreateOCSPRequest compliant with rfc5019",
      "url": "https://github.com/WICG/webpackage/pull/543",
      "state": "MERGED",
      "author": "tomokinat",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "https://tools.ietf.org/html/rfc5019#section-5 requires a OCSP client to use GET for small enough OCSP requests. Although [this is mainly for enabling HTTP caching](https://tools.ietf.org/html/rfc2560#appendix-A.1.1) and `certurl.FetchOCSPResponse` doesn't cache any response, it's worth supporting as `certurl.CreateOCSPRequest` is also exported.\r\n\r\nIn order to add a test which checks the \"POST\" side of the function, we need data of `len(\"http://<responder>/<encoded OCSP req>\") > 255`. I though like creating a dummy cert whose responder url is super long was the easiest (as I wrote in the test tentatively), I don't know where the existing `test-cert.pem` came from, which has a responder url \"http://ocsp.digicert.com\" and doesn't look like a \"dummy\". Would appreciate some guidance.",
      "createdAt": "2019-12-12T11:17:12Z",
      "updatedAt": "2019-12-16T06:45:22Z",
      "closedAt": "2019-12-16T06:45:22Z",
      "mergedAt": "2019-12-16T06:45:22Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-12-13T07:21:21Z",
          "updatedAt": "2019-12-13T07:21:21Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks. Would you add `test-cert-long.pem` and unskip the new test?",
          "createdAt": "2019-12-16T02:06:24Z",
          "updatedAt": "2019-12-16T02:06:24Z"
        },
        {
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I was going to wait for response from @hajimehoshi , but anyway I added one and started to count that test. I believe this PR is now ready to merge, except for few points I forgot to mention:\r\n\r\n- I only added test-cert-long.pem to align with existing test-cert.pem although there were several intermediate products.\r\n- I made command-line preferGET flag default to false for backwards compatibility and as there's no strong reason to use GET if we don't cache the response.\r\n\r\nDo they look good to you?",
          "createdAt": "2019-12-16T06:24:54Z",
          "updatedAt": "2019-12-16T06:24:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNzAwOTk1",
          "commit": {
            "abbreviatedOid": "23ecc92"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Using a dummy cert sgtm.\r\n(The existing `test-cert.pem` was originally added in https://github.com/WICG/webpackage/commit/0d992f8b4db6223e9e343974d230a032de0272b6. @hajimehoshi do you remember where it came from?)\r\n\r\nPlease record the command line used to generate the cert, in a comment.\r\n",
          "createdAt": "2019-12-13T07:27:29Z",
          "updatedAt": "2019-12-13T07:48:01Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Per https://tools.ietf.org/html/rfc2560#appendix-A.1.1, `getUrl` should be constructed as follows:\r\n```\r\n{url}/{url-encoding of base-64 encoding of the DER encoding of the OCSPRequest}\r\n```\r\n`ocspUrl.Parse(...)` may produce different result, for example if `ocspUrl` is `http://example.com/ocsp`.",
              "createdAt": "2019-12-13T07:27:30Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            },
            {
              "originalPosition": 16,
              "body": "Samll -> Small",
              "createdAt": "2019-12-13T07:31:54Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNzYzOTk3",
          "commit": {
            "abbreviatedOid": "be7ca28"
          },
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-13T09:52:54Z",
          "updatedAt": "2019-12-13T09:52:54Z",
          "comments": [
            {
              "originalPosition": 42,
              "body": "Thanks, fixed it.",
              "createdAt": "2019-12-13T09:52:54Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMxNzY0MDk3",
          "commit": {
            "abbreviatedOid": "be7ca28"
          },
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-13T09:53:05Z",
          "updatedAt": "2019-12-13T09:53:05Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Done.",
              "createdAt": "2019-12-13T09:53:05Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMzEwMTk4",
          "commit": {
            "abbreviatedOid": "be7ca28"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-16T01:57:01Z",
          "updatedAt": "2019-12-16T02:06:38Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "I'm not sure if we should collapse double slashes.\r\n\r\nFYI Chromium uses simple string concatenation:\r\nhttps://cs.chromium.org/chromium/src/net/cert/internal/ocsp.cc?l=1041&rcl=5aabd083f5e0f99abce0a06a8aab4c18e5bb13df\r\n",
              "createdAt": "2019-12-16T01:57:01Z",
              "updatedAt": "2019-12-16T06:14:47Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMzU2NzAx",
          "commit": {
            "abbreviatedOid": "17055c8"
          },
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-16T06:16:22Z",
          "updatedAt": "2019-12-16T06:16:22Z",
          "comments": [
            {
              "originalPosition": 16,
              "body": "Then I'd make it align with Chromium, thanks!",
              "createdAt": "2019-12-16T06:16:22Z",
              "updatedAt": "2019-12-16T06:16:22Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMzYzNzc1",
          "commit": {
            "abbreviatedOid": "17055c8"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "All lgtm :)\r\nThank you for your contribution!",
          "createdAt": "2019-12-16T06:44:20Z",
          "updatedAt": "2019-12-16T06:44:20Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "3f0145a1e15f0482ab19a2c286e220a0c9637be8",
      "headRepository": null,
      "headRefName": "master",
      "headRefOid": "17055c8c5470e8692a82e52b42bf3b67d6ca8701",
      "mergeCommit": {
        "oid": "b3244a4e6004bfe8c2d175de779b9d2bab23e18a"
      }
    },
    {
      "number": 545,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUyNzEzNjA5",
      "title": "Fix typo",
      "url": "https://github.com/WICG/webpackage/pull/545",
      "state": "MERGED",
      "author": "gaul",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2019-12-13T04:13:43Z",
      "updatedAt": "2019-12-16T07:52:47Z",
      "closedAt": "2019-12-16T06:32:28Z",
      "mergedAt": "2019-12-16T06:32:28Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2019-12-16T06:31:35Z",
          "updatedAt": "2019-12-16T06:31:35Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyMzYwNjE4",
          "commit": {
            "abbreviatedOid": "3311358"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2019-12-16T06:32:01Z",
          "updatedAt": "2019-12-16T06:32:01Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "9853105259907c60bd6ca6c41a11878bdcc2c67b",
      "headRepository": "gaul/webpackage",
      "headRefName": "typo",
      "headRefOid": "331135826506ca9d16281ba5eccf7c46f428fa6f",
      "mergeCommit": {
        "oid": "0283781aa5432f3d250f3f6039c5356564307f83"
      }
    },
    {
      "number": 546,
      "id": "MDExOlB1bGxSZXF1ZXN0MzUzNDMwMDUy",
      "title": "go: Fix test names in sct_test.go",
      "url": "https://github.com/WICG/webpackage/pull/546",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Thanks @kumagi for noticing this.",
      "createdAt": "2019-12-16T08:11:15Z",
      "updatedAt": "2019-12-16T09:53:26Z",
      "closedAt": "2019-12-16T09:53:25Z",
      "mergedAt": "2019-12-16T09:53:25Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "tomokinat",
          "authorAssociation": "CONTRIBUTOR",
          "body": "nit: I'd suggest `t.Fatalf` rather than `t.Errorf` and then `return`",
          "createdAt": "2019-12-16T08:14:21Z",
          "updatedAt": "2019-12-16T08:14:21Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "> nit: I'd suggest `t.Fatalf` rather than `t.Errorf` and then `return`\r\n\r\nDone.",
          "createdAt": "2019-12-16T08:18:24Z",
          "updatedAt": "2019-12-16T08:18:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMyNDI4NzU0",
          "commit": {
            "abbreviatedOid": "c1ca7a1"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-16T09:23:10Z",
          "updatedAt": "2019-12-16T09:23:10Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "b3244a4e6004bfe8c2d175de779b9d2bab23e18a",
      "headRepository": "irori/webpackage",
      "headRefName": "sct_test",
      "headRefOid": "c1ca7a1666b1eeb401cb614ee3cd165c774aecb3",
      "mergeCommit": {
        "oid": "19b98dfbd8a0e3cc1966cacb0ac10b77eb59ac90"
      }
    },
    {
      "number": 547,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU0NDY2NTg2",
      "title": "js/bundle: Add command line tool",
      "url": "https://github.com/WICG/webpackage/pull/547",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This adds `gen-webbundle` CLI tool to the `wbn` package, which enables JS developers to build a web bundle from a local directory, without having to install the Go tools.\r\n\r\nInternally it uses `addFilesRecursively`, a new high-level method of `BundleBuilder`.",
      "createdAt": "2019-12-18T07:18:44Z",
      "updatedAt": "2019-12-19T03:40:42Z",
      "closedAt": "2019-12-19T03:40:41Z",
      "mergedAt": "2019-12-19T03:40:41Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@sisidovski Thank you for the review!\r\n@kinu Would you approve this PR?",
          "createdAt": "2019-12-18T10:24:54Z",
          "updatedAt": "2019-12-18T10:24:54Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Tweaked a bit: changed the argument order of `addFiles(Recursively)` to take URL as first argument, for consistency with `addExchange()`.",
          "createdAt": "2019-12-19T03:34:16Z",
          "updatedAt": "2019-12-19T03:34:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzODI5Mzg3",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Put one question, but overall looks good.",
          "createdAt": "2019-12-18T09:22:14Z",
          "updatedAt": "2019-12-18T09:24:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "My understanding might be wrong though, if there is a file located at `/foo/bar/baz/index.html`, this code looks redirecting to `baseURL/index.html`. Is that a correct behavior?",
              "createdAt": "2019-12-18T09:22:14Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzODMzNzIx",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-18T09:29:23Z",
          "updatedAt": "2019-12-18T09:29:24Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "IMO: Just using package name (wbn) as a command name does more make sense for me. Why do you make this name?",
              "createdAt": "2019-12-18T09:29:23Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzODM3NjAx",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-18T09:35:43Z",
          "updatedAt": "2019-12-18T09:43:18Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Note that the recursive call at line 88 updates `baseURL` adding the directory name.\r\n\r\nHere, `baseURL`'s value should be `<user-specified-baseURL>/foo/bar/baz/`, so this exchange would redirect `<user-specified-baseURL>/foo/bar/baz/index.html` to `<user-specified-baseURL>/foo/bar/baz/`.",
              "createdAt": "2019-12-18T09:35:43Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzMzODUxNjYz",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-18T09:57:33Z",
          "updatedAt": "2019-12-18T09:58:14Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Yeah, that makes sense to me. Renamed the command.\r\n\r\nWe may add other CLI features in the future (such as `dump-bundle` equivalent), but then we could switch to the subcommand style (e.g. `wbn gen ...` / `wbn dump ...`).\r\n",
              "createdAt": "2019-12-18T09:57:34Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0MDc4MTcy",
          "commit": {
            "abbreviatedOid": "683afdd"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2019-12-18T15:59:41Z",
          "updatedAt": "2019-12-18T15:59:42Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Ah! I was missing it! Thank you for the comment!",
              "createdAt": "2019-12-18T15:59:41Z",
              "updatedAt": "2019-12-19T03:33:28Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0Mzg1MDM1",
          "commit": {
            "abbreviatedOid": "bf91878"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-12-19T02:59:59Z",
          "updatedAt": "2019-12-19T02:59:59Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "19b98dfbd8a0e3cc1966cacb0ac10b77eb59ac90",
      "headRepository": "irori/webpackage",
      "headRefName": "gen-webbundle",
      "headRefOid": "7000282b841ae39aa0d87ba15541b4d3bdf6ec61",
      "mergeCommit": {
        "oid": "afa2f204b99bdb891ecdbe41a866e0f3e22d3950"
      }
    },
    {
      "number": 548,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU0OTM3OTY3",
      "title": "js/bundle: Allow method chaining in bundle builder",
      "url": "https://github.com/WICG/webpackage/pull/548",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes BundleBuilder methods return the builder itself, so that callers can chain method calls, like this:\r\n```javascript\r\n  const bundle = (new BundleBuilder(primaryURL))\r\n    .setManifestURL(...)\r\n    .addExchange(...)\r\n    .addExchange(...)\r\n    .createBundle();\r\n```\r\nThis is a common idiom of Builder classes.",
      "createdAt": "2019-12-19T04:25:14Z",
      "updatedAt": "2019-12-20T06:18:59Z",
      "closedAt": "2019-12-20T06:18:58Z",
      "mergedAt": "2019-12-20T06:18:58Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "@kinu ptl",
          "createdAt": "2019-12-20T05:20:56Z",
          "updatedAt": "2019-12-20T05:20:56Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM0NDA2Njk0",
          "commit": {
            "abbreviatedOid": "a4b6321"
          },
          "author": "sisidovski",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-12-19T04:46:35Z",
          "updatedAt": "2019-12-19T04:46:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1MDgzMjMx",
          "commit": {
            "abbreviatedOid": "a4b6321"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2019-12-20T06:14:49Z",
          "updatedAt": "2019-12-20T06:14:49Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "afa2f204b99bdb891ecdbe41a866e0f3e22d3950",
      "headRepository": "irori/webpackage",
      "headRefName": "chain",
      "headRefOid": "a4b6321179378470e3fbb59b9d938027c32501e0",
      "mergeCommit": {
        "oid": "5d6a0ed1d962577421fc80a8b5e143faa179d969"
      }
    },
    {
      "number": 549,
      "id": "MDExOlB1bGxSZXF1ZXN0MzU1NTM0OTgz",
      "title": "js/bundle: Bump version to 0.0.4",
      "url": "https://github.com/WICG/webpackage/pull/549",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "@kinu ptl",
      "createdAt": "2019-12-20T05:21:13Z",
      "updatedAt": "2019-12-20T06:19:46Z",
      "closedAt": "2019-12-20T06:19:45Z",
      "mergedAt": "2019-12-20T06:19:45Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzM1MDgzMzQw",
          "commit": {
            "abbreviatedOid": "9caadce"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2019-12-20T06:15:20Z",
          "updatedAt": "2019-12-20T06:15:20Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "afa2f204b99bdb891ecdbe41a866e0f3e22d3950",
      "headRepository": "irori/webpackage",
      "headRefName": "v0.0.4",
      "headRefOid": "9caadce462cf9bb4551f9929849c70a525aceeb3",
      "mergeCommit": {
        "oid": "fe146df97320af64a99be4eb37fa76d8755b2257"
      }
    },
    {
      "number": 552,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMDkyODc0",
      "title": "Update the unsigned-bundle explainer",
      "url": "https://github.com/WICG/webpackage/pull/552",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "To prepare for TAG and Mozilla review.",
      "createdAt": "2020-02-04T22:59:11Z",
      "updatedAt": "2020-02-18T08:01:10Z",
      "closedAt": "2020-02-07T21:54:48Z",
      "mergedAt": "2020-02-07T21:54:48Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDc0MzM1",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T05:31:14Z",
          "updatedAt": "2020-02-05T05:31:14Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "I'm slightly worried if this may sound like it excludes any types of signatures, e.g. raw-key signed bundles or app-level signatures... while some use cases would need that.  Could \"without origin signatures\" work?\r\n(While, I agree that limiting the focus would be useful/necessary here)",
              "createdAt": "2020-02-05T05:31:14Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDg0MTA2",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:08:57Z",
          "updatedAt": "2020-02-05T06:08:58Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Oh so are we considering literally reusing the Service-Worker-Allowed header here?  It feels weird to me as they are different spec for different features (while I agreed that it could work in the similar way to how SW scope works).",
              "createdAt": "2020-02-05T06:08:57Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDg1NDUx",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:13:43Z",
          "updatedAt": "2020-02-05T06:13:43Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Here this sounds like it's excluding navigations while the text below mentions navigations too",
              "createdAt": "2020-02-05T06:13:43Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDEzOTY0",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T01:20:46Z",
          "updatedAt": "2020-02-05T06:14:35Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Does this mean the browser must parse manifest (if any) before making redirect to the primary URL?",
              "createdAt": "2020-02-05T01:20:46Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 139,
              "body": "Unfinished sentence",
              "createdAt": "2020-02-05T01:29:08Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDg2MDg4",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:15:54Z",
          "updatedAt": "2020-02-05T06:15:55Z",
          "comments": [
            {
              "originalPosition": 143,
              "body": "\"It's not clear\" -> \"It'll need more discussion\" ?",
              "createdAt": "2020-02-05T06:15:54Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDg3NzUw",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:21:35Z",
          "updatedAt": "2020-02-05T06:21:35Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "So here do we suppose we'll have some flag inside the format to say trusted vs untrusted?  Should we explicitly mention that the resulting 'trusted' flag set inside the browser may be different from the claimed one, e.g. if unsigned bundle says it wants to be trusted but it's served from different origins?  Or, should the flag only be able to say that it should be treated as 'untrusted' (i.e. downgrading only) even if an unsigned bundle is served from the same origin?",
              "createdAt": "2020-02-05T06:21:35Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDkyNjg1",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:38:42Z",
          "updatedAt": "2020-02-05T06:38:43Z",
          "comments": [
            {
              "originalPosition": 245,
              "body": "Could we also mention content negotiation, or ability to have multiple resources for single location?\r\nhttps://wicg.github.io/webpackage/draft-yasskin-wpack-use-cases.html#name-essential-2\r\n\r\nAlso maybe virtue of being a binary format (no need to worry about line ending fixups), being able to satisfy subsetting/reordering needs etc etc?",
              "createdAt": "2020-02-05T06:38:42Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDk0NjU4",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:45:17Z",
          "updatedAt": "2020-02-05T06:45:17Z",
          "comments": [
            {
              "originalPosition": 252,
              "body": "Could we start with the basic shortcomings stem from the format (e.g. content negotiation etc) before talking about a specific wontfix'ed issue?",
              "createdAt": "2020-02-05T06:45:17Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDk1NzI0",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-05T06:48:40Z",
          "updatedAt": "2020-02-05T06:48:41Z",
          "comments": [
            {
              "originalPosition": 229,
              "body": "nit: problems -> shortcomings for the usage described in this explainer ...or something?  (For some particular use cases there can be reasons to prefer them to WBN, I suppose)",
              "createdAt": "2020-02-05T06:48:40Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzUzNDk2MjUw",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thanks! Some comments...",
          "createdAt": "2020-02-05T06:50:24Z",
          "updatedAt": "2020-02-05T06:50:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MTI1NzM1",
          "commit": {
            "abbreviatedOid": "7b8e89f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T00:03:33Z",
          "updatedAt": "2020-02-06T18:14:37Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I think we should consider it: we need a header that says that \"something served under this path can have an effect outside that path\", and that's what `Service-Worker-Allowed` does. The name isn't perfect, so it don't hate the idea of using something else. The TAG might have a preference.",
              "createdAt": "2020-02-06T00:03:33Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 104,
              "body": "It would, although that's probably fast compared to receiving the bytes for either the manifest or the main resource. Do you think we should just drop this part? I can see an argument that the manifest `scope` key in particular is meant to control how an app captures navigations, and it doesn't make sense to have it limit what a bundle that contains the app can also hold.",
              "createdAt": "2020-02-06T00:12:34Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 48,
              "body": "Yep, switched to \"without origin-trusted signatures\", thanks. I've also added a section in open design questions to talk about what we might use such signatures for.",
              "createdAt": "2020-02-06T00:24:28Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 85,
              "body": "I think we should make sure that the browser actually uses the value of the 'trusted' flag in the bundle. So, a 'trusted' bundle downloaded from a different origin would result in a redirect rather than a use of the bundle (maybe with UI to let the user explicitly change the flag in the bundle they downloaded), and an 'untrusted' same-origin bundle would get the `package:` URL scheme and be treated as cross-origin from the origin that served it. That's a way for a site to create a kind of [suborigin](https://w3c.github.io/webappsec-suborigins/). I've added a paragraph mentioning this. (FYI @mikewest @metromoxie @devd)",
              "createdAt": "2020-02-06T00:38:02Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 132,
              "body": "Fixed, thanks.",
              "createdAt": "2020-02-06T00:42:10Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 139,
              "body": "Oops, finished.",
              "createdAt": "2020-02-06T00:42:42Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 143,
              "body": "Done, thanks.",
              "createdAt": "2020-02-06T00:43:05Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 229,
              "body": "Yeah, especially WARC.",
              "createdAt": "2020-02-06T00:52:13Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 245,
              "body": "Mentioned.",
              "createdAt": "2020-02-06T01:00:17Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 252,
              "body": "I've added content negotiation to the list, but the bigger problem is the lack of documentation. It's hard to tell even what capabilities the format has.",
              "createdAt": "2020-02-06T18:07:54Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTIwNzk1",
          "commit": {
            "abbreviatedOid": "42c4add"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T04:04:11Z",
          "updatedAt": "2020-02-07T04:04:12Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Treating it like a suborigin for same-origin untrusted bundle makes sense to me. I'm not so sure about the redirect for 'trusted' but cross-origin bundle, but no strong opinion on that one for now. (Quick cross-checking appreciated for potential subresource loading cases @horo-t @irori @hayatoito)",
              "createdAt": "2020-02-07T04:04:11Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTQ0MDYw",
          "commit": {
            "abbreviatedOid": "42c4add"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T05:56:39Z",
          "updatedAt": "2020-02-07T05:56:40Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "I'm agreeing that we need something. Okay, maybe we can start with this and see what people say...",
              "createdAt": "2020-02-07T05:56:40Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0OTYyNTAx",
          "commit": {
            "abbreviatedOid": "42c4add"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-07T07:04:47Z",
          "updatedAt": "2020-02-07T07:04:47Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "I'm feeling inclined to drop this. PWAs having subresources out of its manifest's navigation scope is legitimate, but cannot be bundled as-is under this rule.\r\n\r\nProbably the overhead of (waiting for the bytes + parsing) manifest is small, but since the internal redirect to the primary URL is on the critical path of bundle navigation I would like to keep it as fast as possible.",
              "createdAt": "2020-02-07T07:04:47Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU1Mzc1MTU1",
          "commit": {
            "abbreviatedOid": "42c4add"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I'm going to merge this, but feel free to keep commenting.",
          "createdAt": "2020-02-07T19:11:07Z",
          "updatedAt": "2020-02-07T21:47:58Z",
          "comments": [
            {
              "originalPosition": 104,
              "body": "Done, thanks.",
              "createdAt": "2020-02-07T19:11:07Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            },
            {
              "originalPosition": 85,
              "body": "My thinking about 'trusted'-but-cross-origin comes from using the same flag for signed-but-expired packages. We've talked about a need for non-publishers to be able to pick between having a signed-but-expired package redirect vs act-as-unsigned, and the 'trusted' flag seems appropriate for that, and cross-origin is a similar \"can't verify the trust\" situation.",
              "createdAt": "2020-02-07T21:47:09Z",
              "updatedAt": "2020-02-07T21:48:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU3MjAxNTQz",
          "commit": {
            "abbreviatedOid": "93829ff"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-12T05:46:55Z",
          "updatedAt": "2020-02-12T05:46:56Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Re: potential subresource loading cases\r\n\r\nFor subresource loading cases like [this demo](https://docs.google.com/document/d/18fFrURT6xD1GnqJwCx2K3Z81Te9Iv-r2ZsCkOvDH_04/edit#), I don't think we need this 'trusted' flag in the bundle. And also we don\u2019t need primaryUrl/fallbackUrl for subresource web bundle. So we may need to make primaryUrl/fallbackUrl optional.",
              "createdAt": "2020-02-12T05:46:55Z",
              "updatedAt": "2020-02-12T05:46:56Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwMTMwMjM1",
          "commit": {
            "abbreviatedOid": "93829ff"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-18T08:01:09Z",
          "updatedAt": "2020-02-18T08:01:10Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "Thanks. It'd be nice if the format can just accommodate both while loading spec part can differ on how to interpret these flags.  While... for navigation case we're probably good to start with this text.",
              "createdAt": "2020-02-18T08:01:09Z",
              "updatedAt": "2020-02-18T08:01:10Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "12519adf903b303a3416d42cb0e7d4ecbac770ca",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "unsigned-bundle-explainer",
      "headRefOid": "93829ff3a861501d24c60744151cf0848e89e349",
      "mergeCommit": {
        "oid": "130f77f09ef0db07327f48c83d0bd3ca11001108"
      }
    },
    {
      "number": 553,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxMDkyODc1",
      "title": "Update the unsigned-bundle explainer",
      "url": "https://github.com/WICG/webpackage/pull/553",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "To prepare for TAG and Mozilla review.",
      "createdAt": "2020-02-04T22:59:11Z",
      "updatedAt": "2020-02-04T23:04:50Z",
      "closedAt": "2020-02-04T23:04:36Z",
      "mergedAt": null,
      "mergedBy": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Duplicate issue.",
          "createdAt": "2020-02-04T23:04:36Z",
          "updatedAt": "2020-02-04T23:04:36Z"
        }
      ],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6121352912cd43731627d6c2030b53176f0c6e52",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "unsigned-bundle-explainer",
      "headRefOid": "7b8e89f822fc787f1be10df009b047b4dfe0c774",
      "mergeCommit": null
    },
    {
      "number": 554,
      "id": "MDExOlB1bGxSZXF1ZXN0MzcxNjc2OTQw",
      "title": "dump-bundle: Treat JavaScript resources as text",
      "url": "https://github.com/WICG/webpackage/pull/554",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "So that dump-bundle will print response body by default.",
      "createdAt": "2020-02-06T02:26:35Z",
      "updatedAt": "2020-02-06T06:57:12Z",
      "closedAt": "2020-02-06T06:57:04Z",
      "mergedAt": "2020-02-06T06:57:04Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjE1NDcw",
          "commit": {
            "abbreviatedOid": "c147eff"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T05:58:55Z",
          "updatedAt": "2020-02-06T05:59:01Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "`HasPrefix` for `application/javascript` seems a little odd. I think this can be `application/foobar+javascript`.",
              "createdAt": "2020-02-06T05:58:56Z",
              "updatedAt": "2020-02-06T06:49:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjIxODE3",
          "commit": {
            "abbreviatedOid": "c147eff"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T06:21:56Z",
          "updatedAt": "2020-02-06T06:21:56Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "The intention here is that this function should return true for all of the followings:\r\n\r\n- `text/*`\r\n- `application/javascript`\r\n- `application/javascript; charset=utf-8` (this seems not very rare today)\r\n\r\nIt seems there's no registered media type of the form `application/foobar+javascript`.\r\nhttps://www.iana.org/assignments/media-types/media-types.xhtml\r\n\r\n(There're many `*/*+xml` and `*/*+json` types, but this patch is not trying to interpret those.)\r\n",
              "createdAt": "2020-02-06T06:21:56Z",
              "updatedAt": "2020-02-06T06:49:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjI1MTA3",
          "commit": {
            "abbreviatedOid": "c147eff"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T06:33:29Z",
          "updatedAt": "2020-02-06T06:33:30Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Oh I see. How about using `mime` package?\r\n\r\nhttps://play.golang.org/p/gLepcpuj_4a",
              "createdAt": "2020-02-06T06:33:29Z",
              "updatedAt": "2020-02-06T06:49:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjMwMzc1",
          "commit": {
            "abbreviatedOid": "b5cc663"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-06T06:50:36Z",
          "updatedAt": "2020-02-06T06:50:36Z",
          "comments": [
            {
              "originalPosition": 14,
              "body": "Done.",
              "createdAt": "2020-02-06T06:50:36Z",
              "updatedAt": "2020-02-06T06:50:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzU0MjMwNDY5",
          "commit": {
            "abbreviatedOid": "b5cc663"
          },
          "author": "hajimehoshi",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-02-06T06:50:59Z",
          "updatedAt": "2020-02-06T06:50:59Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6121352912cd43731627d6c2030b53176f0c6e52",
      "headRepository": "irori/webpackage",
      "headRefName": "dump-js",
      "headRefOid": "b5cc663c7b117bc902145ae556f8f87143c65201",
      "mergeCommit": {
        "oid": "12519adf903b303a3416d42cb0e7d4ecbac770ca"
      }
    },
    {
      "number": 557,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc1MTQ3NTY3",
      "title": "Add non-browser feedback about unsigned bundles.",
      "url": "https://github.com/WICG/webpackage/pull/557",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@dauwhe, am I representing your position well here? Is there a better description of your opinion on how we make browsers navigate to unsigned books?",
      "createdAt": "2020-02-14T00:01:14Z",
      "updatedAt": "2020-07-20T20:20:44Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f38446044e22e98165063363a9516b634ccd94e6",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "unsigned-bundle-dev-support",
      "headRefOid": "78dfceb7e00a41b74025f11789ead689998854d7",
      "closedAt": "2020-07-20T20:20:30Z",
      "mergedAt": "2020-07-20T20:20:30Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "6f5c95524edc3afe0d8e8b4d4bf8e09ab306f358"
      },
      "comments": [
        {
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "body": "Would this be the right section to add use cases such as the ones that Dan York had in mind, e.g. making documentation for internet infra grant available for offline consumption (see https://www.internetsociety.org/grants/chapterthon/2019/)?",
          "createdAt": "2020-04-06T23:59:13Z",
          "updatedAt": "2020-04-06T23:59:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@KenjiBaheux It would, but I would appreciate if you or @danyork could suggest some text.",
          "createdAt": "2020-04-08T22:27:54Z",
          "updatedAt": "2020-04-08T22:27:54Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTgyMDU1",
          "commit": {
            "abbreviatedOid": "27a672d"
          },
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T02:45:04Z",
          "updatedAt": "2020-06-03T02:45:04Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": " * [Dan York of Internet Society](https://www.iab.org/wp-content/IAB-uploads/2019/06/dan-york.pdf) offered use cases for packaging web content focused on availability in low bandwidth / high latency environments. More specifically, part of the ISOC's mission involves reaching people who only have have limited connectivity to the Internet, e.g. WiFi at a few local places that people visit to download content that they want to read or watch later. The ability to package web content would be useful in such context. The ISOC is also working with communities where the electricity is unreliable, which negatively impacts Internet access as a result. Here again, these communities could benefit from the ability to download a package of content, either for learning or reading even in the absence of connectivity.",
              "createdAt": "2020-06-03T02:45:04Z",
              "updatedAt": "2020-07-08T22:03:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDIzMTgyMjA5",
          "commit": {
            "abbreviatedOid": "27a672d"
          },
          "author": "KenjiBaheux",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-03T02:45:40Z",
          "updatedAt": "2020-06-03T02:45:41Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Sorry for the delay, I think this captures what Dan wrote in his position paper but would welcome any feedback or direct edits.",
              "createdAt": "2020-06-03T02:45:40Z",
              "updatedAt": "2020-07-08T22:03:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MDc0NDI5",
          "commit": {
            "abbreviatedOid": "774bbee"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T19:40:40Z",
          "updatedAt": "2020-07-08T19:40:41Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Thanks for the text. After a long delay, it's merged. Everything look good now?",
              "createdAt": "2020-07-08T19:40:40Z",
              "updatedAt": "2020-07-08T22:03:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MTQ5OTAw",
          "commit": {
            "abbreviatedOid": "774bbee"
          },
          "author": "danyork",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T21:43:13Z",
          "updatedAt": "2020-07-08T21:43:13Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "@jyasskin and @KenjiBaheux - Thanks for the summary and my apologies for a delay in replying. The text looks good overall, but I'd suggest two changes:\r\n\r\n- we like to spell out \"Internet Society\" versus using \"ISOC\" (two many acronym conflicts in the larger world)\r\n- I would add in a mention of satellite connectivity.\r\n\r\nPerhaps the text would be better as:\r\n\r\nDan York of Internet Society offered use cases for packaging web content focused on availability in low bandwidth / high latency environments. More specifically, part of the Internet Society's work involves reaching people who only have have limited connectivity to the Internet, e.g. WiFi at a few local places that people visit to download content that they want to read or watch later. The ability to package web content would be useful in such context. The Internet Society is also working with communities where the electricity is unreliable, which negatively impacts Internet access as a result. There are also cases where communities only have periodic connectivity via satellite connections. Here again, these communities could benefit from the ability to download a package of content, either for learning or reading even in the absence of connectivity.\r\n",
              "createdAt": "2020-07-08T21:43:13Z",
              "updatedAt": "2020-07-08T22:03:26Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MTYwMTEz",
          "commit": {
            "abbreviatedOid": "78dfceb"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T22:03:39Z",
          "updatedAt": "2020-07-08T22:03:39Z",
          "comments": [
            {
              "originalPosition": 34,
              "body": "Thanks! I've taken that wording.",
              "createdAt": "2020-07-08T22:03:39Z",
              "updatedAt": "2020-07-08T22:03:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 558,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc2OTExNDQ0",
      "title": "Security/privacy questionnaire for unsigned bundles",
      "url": "https://github.com/WICG/webpackage/pull/558",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I haven't double-checked all the answers, and this needs some more links. I'll go over it again tomorrow.",
      "createdAt": "2020-02-19T01:00:38Z",
      "updatedAt": "2020-02-21T21:38:27Z",
      "closedAt": "2020-02-21T06:03:38Z",
      "mergedAt": "2020-02-21T06:03:38Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Still lgtm.",
          "createdAt": "2020-02-21T06:03:29Z",
          "updatedAt": "2020-02-21T06:03:29Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODEwNDY5",
          "commit": {
            "abbreviatedOid": "e69e5dd"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-19T02:45:12Z",
          "updatedAt": "2020-02-19T02:45:13Z",
          "comments": [
            {
              "originalPosition": 85,
              "body": "```suggestion\r\n[section](#network-access) in the explainer about how network requests from untrusted bundles\r\n```",
              "createdAt": "2020-02-19T02:45:13Z",
              "updatedAt": "2020-02-20T03:58:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODEwOTgw",
          "commit": {
            "abbreviatedOid": "e69e5dd"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-02-19T02:47:04Z",
          "updatedAt": "2020-02-19T02:47:05Z",
          "comments": [
            {
              "originalPosition": 136,
              "body": "```suggestion\r\nif `Service-Worker-Allowed` response header is given the default scope can be also extended```\r\n\r\nThe original text was probably a bit garbled.. (feel free to modify further)",
              "createdAt": "2020-02-19T02:47:04Z",
              "updatedAt": "2020-02-20T03:58:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwODExMDM2",
          "commit": {
            "abbreviatedOid": "e69e5dd"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-02-19T02:47:17Z",
          "updatedAt": "2020-02-19T02:47:17Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYwOTQwNDQx",
          "commit": {
            "abbreviatedOid": "e69e5dd"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with nits",
          "createdAt": "2020-02-19T09:07:05Z",
          "updatedAt": "2020-02-19T09:13:29Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nBundle will be loaded within its unique origin with [package: scheme](#urls-for-bundle-components), which is\r\n```",
              "createdAt": "2020-02-19T09:07:06Z",
              "updatedAt": "2020-02-20T03:58:52Z"
            },
            {
              "originalPosition": 129,
              "body": "```suggestion\r\nSee the [security considerations](https://wicg.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.html#security)\r\nin the format spec, [security and privacy considerations](#security-and-privacy-considerations)\r\nin the explainer, and [open design questions](#open-design-questions) in the\r\nexplainer.\r\n```",
              "createdAt": "2020-02-19T09:12:26Z",
              "updatedAt": "2020-02-20T03:58:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzYxNDkxMjA5",
          "commit": {
            "abbreviatedOid": "7a82316"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "Sorry for losing a bunch of your links when I copied this to Markdown. I've now rewritten several of the answers in https://github.com/WICG/webpackage/pull/558/commits/7a82316c5d09f32fe774b6ee56161bc4bd6ae04c. PTAL.",
          "createdAt": "2020-02-19T22:38:09Z",
          "updatedAt": "2020-02-19T22:38:09Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e035bfb33249e4cec2cb074dc524d9a1942c32c3",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "sec-priv-questionnaire",
      "headRefOid": "d0e33e0fd78cbd23be40364218a51c8296511a50",
      "mergeCommit": {
        "oid": "2578456138c197456c4243902b4e9d81effd0639"
      }
    },
    {
      "number": 559,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzc4NDg2NjU2",
      "title": "Fix #556: describe the origin-computation algorithm better.",
      "url": "https://github.com/WICG/webpackage/pull/559",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "I believe that with the encoding suggested here, we can just add \"package\" to the list at https://url.spec.whatwg.org/#concept-url-origin that includes \"https\", and that'll make the origin algorithm work for the new scheme. @annevk pointed out that my explanation was too brief; does this do a better job, or is there some other wording that would express it better?",
      "createdAt": "2020-02-21T21:47:03Z",
      "updatedAt": "2020-04-07T00:12:42Z",
      "closedAt": "2020-04-07T00:12:40Z",
      "mergedAt": "2020-04-07T00:12:40Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Seems fine. Is there a normative description available too somewhere?",
          "createdAt": "2020-02-24T08:47:43Z",
          "updatedAt": "2020-02-24T08:47:43Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "There's no specification yet.",
          "createdAt": "2020-02-24T22:31:45Z",
          "updatedAt": "2020-02-24T22:31:45Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Njk4MDg3",
          "commit": {
            "abbreviatedOid": "744e1b2"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\nSorry for the delay.",
          "createdAt": "2020-04-06T23:58:50Z",
          "updatedAt": "2020-04-06T23:58:50Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2578456138c197456c4243902b4e9d81effd0639",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fix-origin-algorithm",
      "headRefOid": "744e1b2beb966aa4df95f217e1955a1ec08a17e6",
      "mergeCommit": {
        "oid": "7412e313f959808ed927cfd4156acffb8bbd9420"
      }
    },
    {
      "number": 560,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgwNTcyNzA2",
      "title": "Sketch how package: URLs should be rendered.",
      "url": "https://github.com/WICG/webpackage/pull/560",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@annevk requested more information on how `package:` URLs should be rendered, so here's a sketch.\r\n\r\nI haven't yet run this by @estark37 and her team. Emily, does this look like a reasonable start? Are you running away in horror? Do y'all have any better ideas?",
      "createdAt": "2020-02-27T00:18:12Z",
      "updatedAt": "2020-07-08T19:53:19Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "83a83ee876ebd4d59aaf3909c3be262a9a59c1c0",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "untrusted-url-rendering",
      "headRefOid": "faefc1cffc4b9fbb374a006f5d798ec83bbcabe6",
      "closedAt": "2020-07-08T19:52:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "annevk",
          "authorAssociation": "NONE",
          "body": "Doesn't that mean that as far as the user is concerned the authority is with the publisher? (I.e., same as with HTTP URLs today.) And if that's the case, what warrants all the complexity again?",
          "createdAt": "2020-03-02T10:17:11Z",
          "updatedAt": "2020-03-02T10:17:11Z"
        },
        {
          "author": "estark37",
          "authorAssociation": "NONE",
          "body": "I'd like to see if we can avoid exposing `package:` URLs in browser UI all together. They look terrifying :) Are there strong use cases for editing them directly? Could we say that either the MVP does not involve editing `package:` URLs _or_ the MVP must involve some sort of custom UI for selecting resources within the package?\r\n\r\nShowing the publisher hostname seems technically correct, but also could potentially lead to a proliferation of \"double address bars\" like we saw with AMP documents; the publisher and/or distributor thinks that it will be confusing to have the distributor hostname showing in the omnibox, so they add a second address bar in the web content showing the publisher hostname -- leading to confusion and sadness. I'm still getting my head around the use cases for unsigned/untrusted bundles so I'm not sure if this seems likely to be a big problem or if I can come up with a better suggestion. Is it likely that the distributor hostname will be meaningless to humans, like a generic CDN domain? Or do you expect distributor hostnames to usually be pretty meaningful, like `offline-ebooks.com` or something?\r\n\r\nA minor note is that the currently proposed v1 solution (show the publisher hostname, reveal the full URL on click) might be a significant implementation investment. Even just eliding `www` subdomain labels was a large implementation effort (as I understand it) because of edge cases with the cursor jumping around when you select, dealing with different ways to focus the omnibox, etc. So it could turn out that implementing custom UI for `package:` URLs is a simpler v1 approach anyway.",
          "createdAt": "2020-03-02T19:21:43Z",
          "updatedAt": "2020-03-02T19:21:43Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "Okay, maybe the modified proposal could be: show the distributor's URL in omnibox (ideally  making it non-editable), but internally use package: URL.  @estark37 let us know if you have further comments on this idea. Thanks!",
          "createdAt": "2020-04-06T23:48:52Z",
          "updatedAt": "2020-04-06T23:48:52Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I've updated the text here to match my understanding of @estark37's suggestion. \r\n\r\n@annevk, the authority is with the distributor of the content, since they're the ones who can modify it. The complexity is justified by wanting to allow an archive of multiple sites to be transferred together, without those sites' storage colliding.",
          "createdAt": "2020-06-10T21:49:38Z",
          "updatedAt": "2020-06-10T21:49:38Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I haven't mentioned the risk of sites adopting double-url-bars like https://web.archive.org/web/20200514010317/https://tag.w3.org/. It really doesn't seem like bundles make that any more likely.",
          "createdAt": "2020-06-10T21:51:56Z",
          "updatedAt": "2020-06-10T21:52:08Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is superseded by the [URL rendering bits](https://github.com/jyasskin/webpackage/blob/package-scheme-explainer/explainers/bundle-urls-and-origins.md#rendering-the-url-bar) in #587.",
          "createdAt": "2020-07-08T19:52:49Z",
          "updatedAt": "2020-07-08T19:52:49Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 561,
      "id": "MDExOlB1bGxSZXF1ZXN0MzgyNzAxMjI0",
      "title": "go: Simplify SXG cert's validity period check",
      "url": "https://github.com/WICG/webpackage/pull/561",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Since it has already passwed 2019-08-01, all SXG certs must\r\nhave <=90 days validity.",
      "createdAt": "2020-03-03T01:51:40Z",
      "updatedAt": "2020-03-03T03:05:47Z",
      "closedAt": "2020-03-03T03:05:31Z",
      "mergedAt": "2020-03-03T03:05:31Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzY3NjY4NDUy",
          "commit": {
            "abbreviatedOid": "f946cd8"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-03-03T02:39:32Z",
          "updatedAt": "2020-03-03T02:39:32Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2578456138c197456c4243902b4e9d81effd0639",
      "headRepository": "irori/webpackage",
      "headRefName": "validity-check",
      "headRefOid": "f946cd8c2857c9b0b8bdba5f86c35b704c7a0df6",
      "mergeCommit": {
        "oid": "0ba8f7e5891fc9e3f1f28a1832366c326603a223"
      }
    },
    {
      "number": 563,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzg3MDMyNDk2",
      "title": "gen-bundle: Skip duplicated URLs in URL list",
      "url": "https://github.com/WICG/webpackage/pull/563",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is similar to #481, but for `gen-bundle -URLList`.",
      "createdAt": "2020-03-12T04:24:09Z",
      "updatedAt": "2020-03-12T05:06:18Z",
      "closedAt": "2020-03-12T05:05:41Z",
      "mergedAt": "2020-03-12T05:05:41Z",
      "mergedBy": "irori",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzczMjgwMjE5",
          "commit": {
            "abbreviatedOid": "7174e85"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-03-12T05:03:29Z",
          "updatedAt": "2020-03-12T05:03:29Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "0ba8f7e5891fc9e3f1f28a1832366c326603a223",
      "headRepository": "irori/webpackage",
      "headRefName": "dup-url",
      "headRefOid": "7174e85190927ed09b6a910f276f6869274df72d",
      "mergeCommit": {
        "oid": "77ce83e0d8f27ee6123f1c8d615d3ffaf66b1fa0"
      }
    },
    {
      "number": 565,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkyMzcyNzA0",
      "title": "Add an explainer for subresource loading (#526)",
      "url": "https://github.com/WICG/webpackage/pull/565",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Add an explainer for subresource loading (#526).\r\n\r\ncc: @jyasskin, @kinu, @irori, @horo-t",
      "createdAt": "2020-03-23T13:05:04Z",
      "updatedAt": "2020-04-14T12:28:42Z",
      "closedAt": "2020-04-14T12:28:41Z",
      "mergedAt": "2020-04-14T12:28:41Z",
      "mergedBy": "kinu",
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "It looks ipr check said:\r\n\r\n> hayatoito is unknown, they need to link their Github account with a W3C account.\r\n\r\nOkay, I've just linked my GitHub acccount, @hayatoito, with W3C account (hito).  I guess this is sufficient to pass checks, hopefully.\r\n",
          "createdAt": "2020-03-23T13:15:14Z",
          "updatedAt": "2020-03-23T13:15:14Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Regarding https://labs.w3.org/repo-manager/pr/id/WICG/webpackage/565,\r\n\r\n> hayatoito should join the Web Platform Incubator Community Group .\r\n\r\nI've also sent a request to join WICG. \r\n",
          "createdAt": "2020-03-24T00:31:04Z",
          "updatedAt": "2020-03-24T00:31:04Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+cc: @yoavweiss",
          "createdAt": "2020-03-24T03:31:34Z",
          "updatedAt": "2020-03-24T03:31:34Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "+cc: @hiroshige-g",
          "createdAt": "2020-03-24T03:41:04Z",
          "updatedAt": "2020-03-24T03:41:04Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I guess we prefer squash merge in this repository. So I will squash the commits before merging, anyway.",
          "createdAt": "2020-03-25T05:44:07Z",
          "updatedAt": "2020-03-25T05:44:07Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've squashed the commits.",
          "createdAt": "2020-03-26T05:09:06Z",
          "updatedAt": "2020-03-26T05:09:06Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin Could you review this PR? It would be great if you could take a look.\r\n\r\nFor reviewers, please feel free to merge this. I think we can update the explainer with more details anytime later.",
          "createdAt": "2020-04-01T03:20:35Z",
          "updatedAt": "2020-04-01T03:20:35Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I've squashed the commits.\r\nReviewers, please feel free to merge the PR if you think it's ready.\r\n",
          "createdAt": "2020-04-09T03:16:32Z",
          "updatedAt": "2020-04-09T03:16:32Z"
        },
        {
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "body": "There are other ongoing discussions but I'm going to merge this (so that more discussion can be built on top of it)",
          "createdAt": "2020-04-14T12:28:32Z",
          "updatedAt": "2020-04-14T12:28:32Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwNDU4NzQ1",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-03-24T16:02:18Z",
          "updatedAt": "2020-03-24T16:02:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODA1Mzcy",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T01:30:40Z",
          "updatedAt": "2020-03-25T01:43:40Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "I don't think they need to be the same-origin, and actually the example URLs are not the same-origin.\r\nWhen I wrote [this example](https://docs.google.com/document/d/18fFrURT6xD1GnqJwCx2K3Z81Te9Iv-r2ZsCkOvDH_04/edit#heading=h.irqypigubog7), my idea was:\r\n  - If the page is controlled by a service worker, the service worker can intercept any requests from the page and can respond with arbitrary resources.\r\n  - So, it is safe (=no difference from service worker from the security point of view) even if they are not the same origin, when the page can access the web bundle in the CORS manner.\r\n",
              "createdAt": "2020-03-25T01:30:40Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODEyMTMy",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T01:54:44Z",
          "updatedAt": "2020-03-25T02:31:17Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "```suggestion\r\na format that allows multiple resources can be bundled, e.g.\r\n```",
              "createdAt": "2020-03-25T01:54:44Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 20,
              "body": "I think this is not true for parsing.\r\n\r\nChrome is already doing streaming parsing / compiling for classic scripts (probably scaling it to more than one processor is hard, though), and for module scripts each module is parsed / compiled as soon as it is downloaded, without waiting for the entire module tree.",
              "createdAt": "2020-03-25T02:09:11Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 55,
              "body": "```suggestion\r\nresources to a particular bundled resource. Something like [Fetch maps proposal](https://discourse.wicg.io/t/proposal-fetch-maps/4259)\r\n```",
              "createdAt": "2020-03-25T02:24:30Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 97,
              "body": "Could you expand this a bit? I'm not sure how this enables resource subsetting.",
              "createdAt": "2020-03-25T02:30:32Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMxNTE4",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:05:07Z",
          "updatedAt": "2020-03-25T03:05:07Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Thanks.\r\n@kinu, what do you think? I'm afraid that I misunderstood your suggestions.\r\n\r\nI'm wondering what the explainer should mention here. We have 3 URLs:\r\n\r\n1. The main document's URL\r\n2. href\r\n3. scope\r\n\r\nI thought 2 and 3 need to be the same origin, however, it is okay that 1 is in a different origin.\r\nIt's a simple mistake I forgot to update example URLs.\r\n\r\nAny suggestions? If we don't have a clear answer, I think it is okay to mention it as TBD.",
              "createdAt": "2020-03-25T03:05:07Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMyNTQy",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:08:51Z",
          "updatedAt": "2020-03-25T03:08:52Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Ah, thanks! This is typo. \"allows multiple resources *to* be bundled\" might be better, I think.\r\nI'll fix that.",
              "createdAt": "2020-03-25T03:08:52Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMzMTM0",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:10:57Z",
          "updatedAt": "2020-03-25T03:10:58Z",
          "comments": [
            {
              "originalPosition": 55,
              "body": "Thanks! Let me add a link.",
              "createdAt": "2020-03-25T03:10:58Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMzMjAz",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:11:12Z",
          "updatedAt": "2020-03-25T03:11:13Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Yeah I suggested this but I remember I discussed that cross-origin seems okay too with you. I want to think through all the implications... for example it apparently complicates CSP story. But I agree that maybe we can just drop this for now.",
              "createdAt": "2020-03-25T03:11:12Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMzMzUz",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:11:48Z",
          "updatedAt": "2020-03-25T03:11:49Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "@kinu \r\nDo you have any opinions? I guess we don't have a concrete idea yet.",
              "createdAt": "2020-03-25T03:11:48Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODMzNjcw",
          "commit": {
            "abbreviatedOid": "d268422"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:12:55Z",
          "updatedAt": "2020-03-25T03:12:56Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Would just dropping 'parsing and' make sense?",
              "createdAt": "2020-03-25T03:12:55Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODQyMjQ5",
          "commit": {
            "abbreviatedOid": "71d9e93"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T03:46:24Z",
          "updatedAt": "2020-03-25T03:46:24Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "(^^I commented before I see Hayato's response) @hayatoito I was indeed thinking about 2 and 3 indeed, but thinking about this more it's a little unclear too. (As @horo-t mentioned SW could already override it)  I think I'm fine with just dropping this sentence.",
              "createdAt": "2020-03-25T03:46:24Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODQ3MDk1",
          "commit": {
            "abbreviatedOid": "71d9e93"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T04:07:03Z",
          "updatedAt": "2020-03-25T04:07:03Z",
          "comments": [
            {
              "originalPosition": 43,
              "body": "Thanks! Okay, let's just drop this for now.\r\nOnce we have a more clear idea, let's add something back.",
              "createdAt": "2020-03-25T04:07:03Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgwODQ4NjQw",
          "commit": {
            "abbreviatedOid": "649c4c3"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-25T04:13:43Z",
          "updatedAt": "2020-03-25T04:13:44Z",
          "comments": [
            {
              "originalPosition": 20,
              "body": "Thanks. Let's drop the \"parsing and\".",
              "createdAt": "2020-03-25T04:13:44Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNjk3MDk0",
          "commit": {
            "abbreviatedOid": "649c4c3"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T04:36:17Z",
          "updatedAt": "2020-03-26T04:36:18Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Can we address this in a follow-up commit? We can adress that later, I think.",
              "createdAt": "2020-03-26T04:36:17Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNzAyMTYz",
          "commit": {
            "abbreviatedOid": "649c4c3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T04:55:33Z",
          "updatedAt": "2020-03-26T04:55:33Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "sgtm.",
              "createdAt": "2020-03-26T04:55:33Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzgxNzYxMTIz",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-03-26T07:43:18Z",
          "updatedAt": "2020-03-26T07:43:19Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "Yeah... I think I was thinking *something* like: Server can maintain versioned bundles, and client can send a request with some URL parameters that indicates the version of the bundle they already have in cache (so that the server can identify the updated resources and send them back).  This is mostly about updating-fetch for same bundle cases though, and haven't really thought about how to do for similarly looking bundle on different pages cases.",
              "createdAt": "2020-03-26T07:43:18Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MjQwMDA5",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-01T03:17:50Z",
          "updatedAt": "2020-04-01T03:17:51Z",
          "comments": [
            {
              "originalPosition": 97,
              "body": "@kinu Thanks! I appreciate that! That's helpful. I think we can update the explainer with the more details once we can explore this area. Let me close this as resolved for now.",
              "createdAt": "2020-04-01T03:17:50Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MzY5MjQx",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Given that we can do more iterations on top of it this LGTM",
          "createdAt": "2020-04-01T08:30:18Z",
          "updatedAt": "2020-04-01T08:30:18Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1NjQxMzEz",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "jkrems",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-01T14:29:17Z",
          "updatedAt": "2020-04-01T14:29:17Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Both of those option sound like exclusion-based fetching. What we've observed while working on a similar system is that there are scale boundaries where it stops working. When the number of individual items is high, it breaks the length limits for URLs (1) and a digest becomes increasingly unreliable (2).\r\n\r\nThe third solution is to have an official way to batch resources by inclusion instead. It requires an \"inclusion digest\" or \"inclusion list\" instead of an \"cached/exclusion digest\" though.",
              "createdAt": "2020-04-01T14:29:17Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg2OTIyOTk5",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T04:01:15Z",
          "updatedAt": "2020-04-03T04:01:16Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "@jkrems\r\nThanks! I agree that especially for dynamic bundling it seems to need some \"inclusion signal\" in requesting phase. I suspect it still could be benefited if it's combined with cache/exclusion approach for better cache efficiency?  A straw-idea could be:\r\n\r\n1. The bundle request should express some hash or list that indicates the set of resources it wants.  Possibly the server and client can share a logic to compute the hash / variations for the session to determine what resources are needed.\r\n2. Platform also attaches some digest that indicates exclusive-fetching information for caching.\r\n\r\nThis explainer didn't tell anything about 1. but probably it'd be better to mention it too. Does it make better sense, or I might be still missing something?",
              "createdAt": "2020-04-03T04:01:15Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg3MzIyMjQy",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "jkrems",
          "authorAssociation": "NONE",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-03T14:44:48Z",
          "updatedAt": "2020-04-03T14:44:49Z",
          "comments": [
            {
              "originalPosition": 94,
              "body": "Makes sense, I think you covered what I had in mind! And this definitely doesn't have to block this initial PR, more a comment towards future iteration.",
              "createdAt": "2020-04-03T14:44:48Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4Njc4NjE4",
          "commit": {
            "abbreviatedOid": "65ce2c8"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-06T23:06:03Z",
          "updatedAt": "2020-04-06T23:26:20Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "```suggestion\r\n  they're also incompatible with new requirements like dynamic bundling (e.g. small edit\r\n```\r\n\r\nAnd please link \"dynamic bundling\" to a description.",
              "createdAt": "2020-04-06T23:06:04Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 15,
              "body": "```suggestion\r\n- The caching story with JS bundlers (e.g. webpack) is tough. They are pretty good\r\n```\r\n\r\nOr\r\n\r\n```suggestion\r\n- The output of JS bundlers (e.g. webpack) doesn't interact well with the HTTP cache. They are pretty good\r\n```",
              "createdAt": "2020-04-06T23:06:59Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 22,
              "body": "```suggestion\r\n  parallelization, but that's not possible if all resources are bundled as one\r\n```",
              "createdAt": "2020-04-06T23:07:28Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 48,
              "body": "The primary requirement to avoid fetching the same bytes twice is that \"If a subresource under that scope is needed later in the document, that later fetch should block until at least the index of the bundle has downloaded to see if it's there.\"\r\n\r\nIt seems secondary to then say that if the subresource within that scope isn't in the bundle, its fetch should fail or otherwise notify the developer: that just prevents delays in starting the subresource fetch.",
              "createdAt": "2020-04-06T23:16:06Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            },
            {
              "originalPosition": 99,
              "body": "A patch format also seems plausible. If the server looks at the If-None-Match request header to learn what version the client already has cached, it can send down a different response type to patch the bundle instead of sending down the whole bundle. I don't know of any existing systems that do that, so we should talk to more people if that direction sounds good. Roberto Peon has argued for patches.",
              "createdAt": "2020-04-06T23:26:12Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE3NTU1",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:43:32Z",
          "updatedAt": "2020-04-08T02:43:32Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Thanks. Done.",
              "createdAt": "2020-04-08T02:43:32Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE4MTk2",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:45:48Z",
          "updatedAt": "2020-04-08T02:45:48Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Ah, I didn't add link \"dynamic bundling\". I think it's still an early idea, and we don't have a good description of that in public yet, AFAIK.",
              "createdAt": "2020-04-08T02:45:48Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE4NjI0",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:47:19Z",
          "updatedAt": "2020-04-08T02:47:20Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Thanks! The latter sounds good to me.",
              "createdAt": "2020-04-08T02:47:19Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE5MjM0",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:49:40Z",
          "updatedAt": "2020-04-08T02:49:41Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Thanks! Let me add these almost \"as-is\".  I think that would help the reader of this explainer to understand the possible behaviors we are thinking in more details.",
              "createdAt": "2020-04-08T02:49:41Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE5NTAx",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:50:39Z",
          "updatedAt": "2020-04-08T02:50:40Z",
          "comments": [
            {
              "originalPosition": 99,
              "body": "Thanks! Yes, we are currently discussing this topic actively in other places. I think we'll cover this topic in another explainer!",
              "createdAt": "2020-04-08T02:50:39Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjE5NzMw",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T02:51:32Z",
          "updatedAt": "2020-04-08T02:51:33Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "Done. Thanks!",
              "createdAt": "2020-04-08T02:51:32Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjM2NTg4",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T03:57:14Z",
          "updatedAt": "2020-04-08T03:57:14Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "This one, maybe?\r\n\r\nhttps://github.com/azukaru/progressive-fetching/blob/master/docs/dynamic-bundling/index.md",
              "createdAt": "2020-04-08T03:57:14Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NjM4MzAw",
          "commit": {
            "abbreviatedOid": "2eed11f"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T04:04:20Z",
          "updatedAt": "2020-04-08T04:04:21Z",
          "comments": [
            {
              "originalPosition": 17,
              "body": "Thanks! Let me add a link to that. I think that is okay for us.",
              "createdAt": "2020-04-08T04:04:21Z",
              "updatedAt": "2020-04-09T03:15:08Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "31f2253a5c46e7e2575e87eb318c16d0878be964",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "subresource-loading-explainer",
      "headRefOid": "1549e7985a10071872dfdd65a273e8510732f076",
      "mergeCommit": {
        "oid": "89c887e02095c55a2cafad60b04c68f70ae825cd"
      }
    },
    {
      "number": 566,
      "id": "MDExOlB1bGxSZXF1ZXN0MzkzOTQ5NjMz",
      "title": "Navigation Explainer: Add a chart illustrating the modes of loading a bundle",
      "url": "https://github.com/WICG/webpackage/pull/566",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Preview: [navigation-to-unsigned-bundles.md](https://github.com/irori/webpackage/blob/chart/explainers/navigation-to-unsigned-bundles.md)\r\nSource code of the chart: https://bit.ly/2UAJ5pX\r\n\r\nLet me know if some terms needs to be changed, and feel free to dismiss this PR if you think it doesn't add much value.",
      "createdAt": "2020-03-26T04:28:54Z",
      "updatedAt": "2020-04-06T23:34:27Z",
      "closedAt": "2020-04-06T23:34:26Z",
      "mergedAt": "2020-04-06T23:34:26Z",
      "mergedBy": "irori",
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!\r\n\r\nThe PlantUML image is also compact (in terms of pixels). Let's use this one.",
          "createdAt": "2020-04-06T23:31:34Z",
          "updatedAt": "2020-04-06T23:31:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg1MzczNzYw",
          "commit": {
            "abbreviatedOid": "ecc45c8"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "This lgtm, fwiw",
          "createdAt": "2020-04-01T08:36:24Z",
          "updatedAt": "2020-04-01T08:36:24Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg4NjY3ODY3",
          "commit": {
            "abbreviatedOid": "ecc45c8"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks for putting together this diagram! I'd like to rework the \"trusted\" bits of this navigation explainer around whether the response is \"authoritative\" per the HTTP spec (https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#establishing.authority), but we can update the diagram at the same time as we rework the text.",
          "createdAt": "2020-04-06T22:40:19Z",
          "updatedAt": "2020-04-06T22:58:07Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "We should be sure to commit the source for any graphics so they're easy to reproduce. e.g.\r\n\r\n```suggestion\r\n![graph TD\r\n  s([Navigation to an<br/>application/webbundle<br/>resource]) -->\r\n  p[Parse primary URL<br/>and control flags] -->\r\n  Signed{Signed?}\r\n  Signed -->|yes| outofscope([\"Load as a signed bundle<br/>(Out of the scope<br/>of this document)\"])\r\n  Signed -->|no| Trusted{The trusted<br/>flag is set?}\r\n  Trusted -->|yes| InScope{The primary URL is<br/>within the unsigned<br/>bundle scope?}\r\n  Trusted -->|no| untrusted([Load as an<br/>untrusted<br/>bundle])\r\n  InScope -->|yes| trust([Load as a<br/>trusted bundle])\r\n  InScope -->|no| redirect([Redirect to the<br/>primary URL])\r\n](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggVERcbiAgcyhbTmF2aWdhdGlvbiB0byBhbjxici8-YXBwbGljYXRpb24vd2ViYnVuZGxlPGJyLz5yZXNvdXJjZV0pIC0tPlxuICBwW1BhcnNlIHByaW1hcnkgVVJMPGJyLz5hbmQgY29udHJvbCBmbGFnc10gLS0-XG4gIFNpZ25lZHtTaWduZWQ_fVxuICBTaWduZWQgLS0-fHllc3wgb3V0b2ZzY29wZShbXCJMb2FkIGFzIGEgc2lnbmVkIGJ1bmRsZTxici8-KE91dCBvZiB0aGUgc2NvcGU8YnIvPm9mIHRoaXMgZG9jdW1lbnQpXCJdKVxuICBTaWduZWQgLS0-fG5vfCBUcnVzdGVke1RoZSB0cnVzdGVkPGJyLz5mbGFnIGlzIHNldD99XG4gIFRydXN0ZWQgLS0-fHllc3wgSW5TY29wZXtUaGUgcHJpbWFyeSBVUkwgaXM8YnIvPndpdGhpbiB0aGUgdW5zaWduZWQ8YnIvPmJ1bmRsZSBzY29wZT99XG4gIFRydXN0ZWQgLS0-fG5vfCB1bnRydXN0ZWQoW0xvYWQgYXMgYW48YnIvPnVudHJ1c3RlZDxici8-YnVuZGxlXSlcbiAgSW5TY29wZSAtLT58eWVzfCB0cnVzdChbTG9hZCBhcyBhPGJyLz50cnVzdGVkIGJ1bmRsZV0pXG4gIEluU2NvcGUgLS0-fG5vfCByZWRpcmVjdChbUmVkaXJlY3QgdG8gdGhlPGJyLz5wcmltYXJ5IFVSTF0pXG4iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)\r\n```\r\n\r\n![graph TD\r\n  s([Navigation to an<br/>application/webbundle<br/>resource]) -->\r\n  p[Parse primary URL<br/>and control flags] -->\r\n  Signed{Signed?}\r\n  Signed -->|yes| outofscope([\"Load as a signed bundle<br/>(Out of the scope<br/>of this document)\"])\r\n  Signed -->|no| Trusted{The trusted<br/>flag is set?}\r\n  Trusted -->|yes| InScope{The primary URL is<br/>within the unsigned<br/>bundle scope?}\r\n  Trusted -->|no| untrusted([Load as an<br/>untrusted<br/>bundle])\r\n  InScope -->|yes| trust([Load as a<br/>trusted bundle])\r\n  InScope -->|no| redirect([Redirect to the<br/>primary URL])\r\n](https://mermaid.ink/img/eyJjb2RlIjoiZ3JhcGggVERcbiAgcyhbTmF2aWdhdGlvbiB0byBhbjxici8-YXBwbGljYXRpb24vd2ViYnVuZGxlPGJyLz5yZXNvdXJjZV0pIC0tPlxuICBwW1BhcnNlIHByaW1hcnkgVVJMPGJyLz5hbmQgY29udHJvbCBmbGFnc10gLS0-XG4gIFNpZ25lZHtTaWduZWQ_fVxuICBTaWduZWQgLS0-fHllc3wgb3V0b2ZzY29wZShbXCJMb2FkIGFzIGEgc2lnbmVkIGJ1bmRsZTxici8-KE91dCBvZiB0aGUgc2NvcGU8YnIvPm9mIHRoaXMgZG9jdW1lbnQpXCJdKVxuICBTaWduZWQgLS0-fG5vfCBUcnVzdGVke1RoZSB0cnVzdGVkPGJyLz5mbGFnIGlzIHNldD99XG4gIFRydXN0ZWQgLS0-fHllc3wgSW5TY29wZXtUaGUgcHJpbWFyeSBVUkwgaXM8YnIvPndpdGhpbiB0aGUgdW5zaWduZWQ8YnIvPmJ1bmRsZSBzY29wZT99XG4gIFRydXN0ZWQgLS0-fG5vfCB1bnRydXN0ZWQoW0xvYWQgYXMgYW48YnIvPnVudHJ1c3RlZDxici8-YnVuZGxlXSlcbiAgSW5TY29wZSAtLT58eWVzfCB0cnVzdChbTG9hZCBhcyBhPGJyLz50cnVzdGVkIGJ1bmRsZV0pXG4gIEluU2NvcGUgLS0-fG5vfCByZWRpcmVjdChbUmVkaXJlY3QgdG8gdGhlPGJyLz5wcmltYXJ5IFVSTF0pXG4iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9LCJ1cGRhdGVFZGl0b3IiOmZhbHNlfQ)\r\n\r\n\r\nThe PlantUML output is 1/10 the size...\r\n\r\n```suggestion\r\n![@startuml\r\n:Navigation to an application/webbundle resource;\r\n:Parse primary URL and control flags;\r\nif (Signed?) then (yes)\r\n  :Load as a signed bundle\r\n  (Out of the scope of\r\n  this document);\r\n  stop\r\nelse (no)\r\n  if (The trusted flag is set?) then (yes)\r\n    if (The primary URL is\\nwithin the unsigned\\nbundle scope?) then (yes)\r\n      :Load as a trusted bundle;\r\n      stop\r\n    else (no)\r\n      :Redirect to the primary URL;\r\n      stop\r\n    endif\r\n  else (no)\r\n    :Load as an\r\n    untrusted bundle;\r\n    stop\r\n  endif\r\nendif\r\n@enduml](http://www.plantuml.com/plantuml/svg/POyzRWCX48LxJl7ATPNUMyG7i9B8IJet66OT97POCKCitpuOP2KRDy2Wz_FDJjHcBNCqPljYlyFPQaWCJR0CkomnkFRpTA7JgR2FX4oIIdOqcksRpK9OSfXjlkBpiAyk3vTOSugOeZtBQCA4uJsScVpp1lf5ZE5AiZ70Tf-iXnLOI1EWLnXWU2sADDtq49SMgeD17OF09rTcOjsC1X1DYw4eX87JBVHMzr5Tceie-KQ1wXBI__rtyNg584U-XDh4hRrmPpjoX-iuZr6hTUxbtJ8sGMTjpp-ytNaW7p8vXIReckVHp3vCPXMoAkSs5tvW-0tf4VqqktgNEVu0)\r\n```\r\n\r\n![@startuml\r\n:Navigation to an application/webbundle resource;\r\n:Parse primary URL and control flags;\r\nif (Signed?) then (yes)\r\n  :Load as a signed bundle\r\n  (Out of the scope of\r\n  this document);\r\n  stop\r\nelse (no)\r\n  if (The trusted flag is set?) then (yes)\r\n    if (The primary URL is\\nwithin the unsigned\\nbundle scope?) then (yes)\r\n      :Load as a trusted bundle;\r\n      stop\r\n    else (no)\r\n      :Redirect to the primary URL;\r\n      stop\r\n    endif\r\n  else (no)\r\n    :Load as an\r\n    untrusted bundle;\r\n    stop\r\n  endif\r\nendif\r\n@enduml](http://www.plantuml.com/plantuml/svg/POyzRWCX48LxJl7ATPNUMyG7i9B8IJet66OT97POCKCitpuOP2KRDy2Wz_FDJjHcBNCqPljYlyFPQaWCJR0CkomnkFRpTA7JgR2FX4oIIdOqcksRpK9OSfXjlkBpiAyk3vTOSugOeZtBQCA4uJsScVpp1lf5ZE5AiZ70Tf-iXnLOI1EWLnXWU2sADDtq49SMgeD17OF09rTcOjsC1X1DYw4eX87JBVHMzr5Tceie-KQ1wXBI__rtyNg584U-XDh4hRrmPpjoX-iuZr6hTUxbtJ8sGMTjpp-ytNaW7p8vXIReckVHp3vCPXMoAkSs5tvW-0tf4VqqktgNEVu0)",
              "createdAt": "2020-04-06T22:40:19Z",
              "updatedAt": "2020-04-06T23:29:39Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "77ce83e0d8f27ee6123f1c8d615d3ffaf66b1fa0",
      "headRepository": "irori/webpackage",
      "headRefName": "chart",
      "headRefOid": "056974155dd5690eb37e60688f0138ae78d5ea44",
      "mergeCommit": {
        "oid": "08f4344a57cb60045e7455753466660d9199b96b"
      }
    },
    {
      "number": 567,
      "id": "MDExOlB1bGxSZXF1ZXN0Mzk1MDA5NjYz",
      "title": "Update to Python 3",
      "url": "https://github.com/WICG/webpackage/pull/567",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Now that Bikeshed requires it.\r\n\r\nTesting via PR; no need to review this if it passes TravisCI.",
      "createdAt": "2020-03-27T23:32:01Z",
      "updatedAt": "2020-03-31T16:18:37Z",
      "closedAt": "2020-03-31T16:18:36Z",
      "mergedAt": "2020-03-31T16:18:36Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "77ce83e0d8f27ee6123f1c8d615d3ffaf66b1fa0",
      "headRepository": "WICG/webpackage",
      "headRefName": "jyasskin-update-bikeshed",
      "headRefOid": "0ff568698c4fc6f22c357f18d7b79641f8c6caee",
      "mergeCommit": {
        "oid": "c74169290c89e8598371509a9b4bead6bfb262bf"
      }
    },
    {
      "number": 570,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAwNTUyODE1",
      "title": "Add explicit use cases to the navigation-to-bundles explainer.",
      "url": "https://github.com/WICG/webpackage/pull/570",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "And an initial diagram.\r\n\r\nThis could probably use diagrams for the other two use cases, but let me know what you think of the use case descriptions and the first diagram.",
      "createdAt": "2020-04-07T23:35:49Z",
      "updatedAt": "2020-04-08T18:14:32Z",
      "closedAt": "2020-04-08T18:14:30Z",
      "mergedAt": "2020-04-08T18:14:30Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NzkxNDA0",
          "commit": {
            "abbreviatedOid": "d4a33a5"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T09:11:38Z",
          "updatedAt": "2020-04-08T09:11:38Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Maybe also say \"see also the alternate formats section (link) to see why we are proposing this with a new format\" or something (but up to you)",
              "createdAt": "2020-04-08T09:11:38Z",
              "updatedAt": "2020-04-08T18:10:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzg5NzkxNzkz",
          "commit": {
            "abbreviatedOid": "d4a33a5"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks, lgtm",
          "createdAt": "2020-04-08T09:12:08Z",
          "updatedAt": "2020-04-08T09:12:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkwMjEzOTk0",
          "commit": {
            "abbreviatedOid": "5c1029f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-08T18:11:40Z",
          "updatedAt": "2020-04-08T18:11:41Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Thanks, done.",
              "createdAt": "2020-04-08T18:11:40Z",
              "updatedAt": "2020-04-08T18:11:41Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7412e313f959808ed927cfd4156acffb8bbd9420",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "add-use-cases-to-unsigned-navigation-explainer",
      "headRefOid": "5c1029f6de71b87094ab25fea3a51208a27d6de1",
      "mergeCommit": {
        "oid": "31f2253a5c46e7e2575e87eb318c16d0878be964"
      }
    },
    {
      "number": 571,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyMDkzNDI1",
      "title": "The IETF WPACK WG is chartered now.",
      "url": "https://github.com/WICG/webpackage/pull/571",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-04-10T22:39:44Z",
      "updatedAt": "2020-04-15T00:49:03Z",
      "closedAt": "2020-04-15T00:49:03Z",
      "mergedAt": "2020-04-15T00:49:03Z",
      "mergedBy": "kinu",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkzMzg3ODU3",
          "commit": {
            "abbreviatedOid": "45e41df"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-04-15T00:48:08Z",
          "updatedAt": "2020-04-15T00:48:08Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "31f2253a5c46e7e2575e87eb318c16d0878be964",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "wpack-wg",
      "headRefOid": "45e41dfa49ad2ee60349637ae79167d680ddb9ea",
      "mergeCommit": {
        "oid": "f9b19a700cfc65fc1361ea276f846fb8075c78f7"
      }
    },
    {
      "number": 572,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAyNzUwOTA3",
      "title": "Switch to \"authoritative\" instead of \"trusted\" to match HTTP.",
      "url": "https://github.com/WICG/webpackage/pull/572",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#establishing.authority",
      "createdAt": "2020-04-13T17:31:59Z",
      "updatedAt": "2020-04-14T17:02:27Z",
      "closedAt": "2020-04-14T17:02:25Z",
      "mergedAt": "2020-04-14T17:02:25Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTI1ODk5",
          "commit": {
            "abbreviatedOid": "8ca6fad"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with comments",
          "createdAt": "2020-04-14T00:29:08Z",
          "updatedAt": "2020-04-14T00:50:51Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "```suggestion\r\n<details>\r\n```",
              "createdAt": "2020-04-14T00:29:08Z",
              "updatedAt": "2020-04-14T02:42:48Z"
            },
            {
              "originalPosition": 118,
              "body": "```suggestion\r\n</details>\r\n```",
              "createdAt": "2020-04-14T00:29:41Z",
              "updatedAt": "2020-04-14T02:42:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3MzkyNTY2Mjgx",
          "commit": {
            "abbreviatedOid": "054fc8c"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-14T02:42:59Z",
          "updatedAt": "2020-04-14T02:43:00Z",
          "comments": [
            {
              "originalPosition": 66,
              "body": "Oops, thanks.",
              "createdAt": "2020-04-14T02:43:00Z",
              "updatedAt": "2020-04-14T02:43:00Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "31f2253a5c46e7e2575e87eb318c16d0878be964",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "refine-trusted-terminology",
      "headRefOid": "054fc8cd5b1b18e5fb40ead77a3871bd3544d82e",
      "mergeCommit": {
        "oid": "a4947d8b7e122b4a7f5fe67158d6a84c8fc3a2fc"
      }
    },
    {
      "number": 573,
      "id": "MDExOlB1bGxSZXF1ZXN0NDAzOTM2MzY2",
      "title": "Answer #551: explore how bundles might but probably don't help anti-adblockers.",
      "url": "https://github.com/WICG/webpackage/pull/573",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@pes10k @shwetank ",
      "createdAt": "2020-04-15T19:05:52Z",
      "updatedAt": "2020-04-20T23:45:04Z",
      "closedAt": "2020-04-20T15:47:06Z",
      "mergedAt": "2020-04-20T15:47:06Z",
      "mergedBy": "jyasskin",
      "comments": [
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "I still disagree with this, as stated from the private thread you created.  Here is another example that has the same underlying properties.   Take a fingerprinting script, or some other resource (many) users don't want, and that many filter lists target.\r\n\r\nCurrently, a site could choose to include it in any of the following ways:\r\n1. Inline the code (best defense against filter lists since there is no URL to target, but expensive for the site bc can cause bad performance, can't be deferred / async'ed, etc)\r\n2. src= include the code from the original host (easiest option for filter lists to target, easiest deployment option for the site)\r\n3. move the code first party, src= it as its own resource first party (difficult but not impossible for filter lists to target, medium work for site)\r\n4. if the code allows it, include the code in a build process (rollup, etc) (basically impossible for filter lists to target, medium for the site, since this code again can't be defer'ed / asynced)\r\n\r\nIn a web bundle world, the site wishing to do (in this case) fingerprinting, doesn't have to do any of the cost / benefit trade off discussed above.  They get a new, strictly superior to all of the above, option: deferable / async able code without a URL filter lists can target.\r\n\r\nSince web bundles give sites a new way of delivering code to users, in a way thats effectively unblockable by filter lists, in a way that has zero additional marginal cost to the site, i don't think you can say this helps adblockers; i think the proposal _at best_ is neutral to adblockers, and almost certainly (very) net negative",
          "createdAt": "2020-04-15T19:23:32Z",
          "updatedAt": "2020-04-15T19:23:32Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "@pes10k Can you clarify why bundles have \"zero additional marginal cost to the site\"? It seems like a specialization of your (3), first-party delivery of the resource, but perhaps I'm missing something.\r\n\r\nFurthermore, the same randomization to avoid filtering could be achieved through 1p delivery without bundles. For instance, one could:\r\n - Set up a URL router that says \"if path starts with `/blog/` and its sha256 % N == 0, then serve JS\".\r\n - Modify the blog generator tool to try multiple variations of the slug (e.g. by adding/removing stopwords) until a non-matching sha256 is found.\r\n - Pick an N that's large enough so the expected number of variations needed to try is low, but small enough so it's not too costly to build convincing-looking fake blog URLs.\r\n\r\nIt seems like this would require a similar amount of work from the site -- the most difficulty likely being in making the HTML template dynamic (e.g. without sacrificing the utility of caching gateways).",
          "createdAt": "2020-04-15T20:21:49Z",
          "updatedAt": "2020-04-15T20:28:29Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "@twifkak\r\n\r\n> zero marginal cost\r\n\r\nI mean that since the code is already delivered / downloaded as part of the bundle, there is no additional cost to making it an async request vs inlining it.\r\n\r\n> seems like a specialization of your (3)\r\n\r\nTrackers are strictly better in web bundling than in case 3 for two reasons:\r\n\r\n - A site needing to do this w/o web bundles would need to take care to avoid name / URL collisions with other resources the were serving. These are the kinds of patterns filter lists look for. Web bundles free the tracker from even this constraint\r\n - the tracker reduces the benefit to the defender in a web bundle world, since the defender has already paid the network cost for the unwanted resource\r\n\r\n> the same randomization to avoid filtering could be achieved through 1p delivery without bundles\r\n\r\nSure, im not arguing that web bundling makes something possible thats currently impossible. Im saying it changes something thats currently moderately-difficult and costly into something easy and free (to the tracker / site / etc).",
          "createdAt": "2020-04-15T20:31:32Z",
          "updatedAt": "2020-04-15T22:04:53Z"
        },
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "@pes10k\r\n\r\n> I mean that since the code is already delivered / downloaded as part of the bundle, there is no additional cost to making it an async request vs inlining it.\r\n\r\nI see, I think... but can't the site choose not to include the 3p script in the bundle? IIUC navigation to bundles still allows `fetch`, albeit with a different `Origin` header.\r\n\r\n> A site needing to do this w/o web bundles would need to take care to avoid name / URL collisions with other resources the were serving.  These are the kinds of patterns filter lists look for.  Web bundles free the tracker from even this constraint\r\n\r\nI think a bundler would still need to avoid name collisions within a bundle, at the very least, but I agree it's easy to do that while avoiding detection. As for collisions between bundles and the unbundled web, I think it depends:\r\n 1. Could the UA choose a cached resource over a bundled one?\r\n 2. Could a SW intercept bundled requests?\r\n\r\n> Im saying it changes something thats currently moderately-difficult and costly into something easy and free (to the tracker / site / etc).\r\n\r\nI'm not convinced it's more difficult without bundles, but I could be. My example involves changes that would mostly be internal to the CMS, and hence the cost amortized across its customers. Each customer would need to upgrade its version (something it may already doing regularly), and potentially modify a bit of frontend config (depending on the CMS -- some are end-to-end).\r\n\r\nPS -- Sorry I edited your comment. I can't internet. I believe/hope I returned it to its original state.",
          "createdAt": "2020-04-15T22:06:35Z",
          "updatedAt": "2020-04-15T22:09:13Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I definitely don't mean to claim bundles make things harder for attackers. As a new option for attackers that doesn't close off any of the old options, it can't possibly make things harder; the best we can hope for is that it doesn't make things easier. I checked, and I think the text says the right thing about this.\r\n\r\nhttps://github.com/WICG/webpackage/pull/573#issuecomment-614233247 is wrong about the performance implications of inlining code or including it in an existing build process. `defer` is basically equivalent to putting the inline `<script>` at the end of its document or to wrapping the code in `window.addEventListener('DOMContentLoaded', ()=>{/* the code */});`, and there are more ways to explicitly defer work today.\r\n\r\n[rollup.js](https://rollupjs.org/)'ed scripts deliver bytes at approximately the same time a web package would and defer work just as well.\r\n\r\nI've added a paragraph talking about non-ad scripts, since my initial text here ignored that use for \"ad\" blockers. Fingerprint.js already gives step-by-step instructions for integrating it into a build process, so it's not like web packages could make the bar any lower.",
          "createdAt": "2020-04-16T22:54:59Z",
          "updatedAt": "2020-04-16T22:54:59Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "Now that this has been merged, where is the right place to continue this conversation?\r\n\r\nIn general, i'm happy to continue discussing point by point above, but lets not loose the forest for the trees.  The general claim (one that seems seconded by the content and adblocking tool libraries who \ud83d\udc4d 'ed the original issue before this was taken private) is that:\r\n\r\n1) consistent, descriptive URLs are useful for adblocking\r\n2) this proposal allows reduces the consistency and descriptiveness of URLs by changing them into arbitrary, opaque indexes into an archive.\r\n\r\nAre we disagreeing about either of the above points?\r\n\r\nSince rollup got mentioned above, its a perfect example here.  Before rollup-and-the-link world, content blocking was ideal; URLs described (both conceptually, and frequently) one resource, and the user agent could reason about each URL independently.  Post rollup-world, URLs are less useful (though not useless), since JS URLs now describe (often) many resources, about which its increasingly difficult for the UA to reason individually about.  (on going research here, etc).  URLs represent multiple interests, the user will often feel differnetly about, but which UA's are (generally) forced into an all or nothing position about.\r\n\r\nThis proposal does the same thing, _but for websites entirely_!  The UA effectively gets just one URL to reason about (the entire web package), but looses the ability to reason about sub resources.  This is very (very!) bad if we intend the web to be an open, transparent, user-first system!\r\n\r\nOkie, now, replying to individual points, but eager to not loose site of the above big picture\u2026\r\n\r\n@jyasskin \r\n> #573 (comment) is wrong about the performance implications\r\n\r\nThis is not correct.  Its _partially_ correct in v8, bc in some cases v8 will defer the parsing of function bodies, but (i) even then there are exceptions, and (ii) I have even less familiarity with how other JS engines do this.  I know that, for example, spidermonkey does not _not_ defer parsing in cases where v8 will (e.g. JS in HTML attributes, onclick=X), but I dont have enough information to say in general (and I know even less about JavaScriptCore).  But, point is\r\n\r\n1. there is in all cases some difference, because there is at lease _some_ additional parsing and executing going on\r\n2. there may be significant difference in other platforms\r\n3. caching makes all this even more different, as platforms may differ on how and when they cache inline script\r\n4. none of this difference hangs on standards defined behavior, and so is not a sound basis for this standard to rely on\r\n\r\n@twifkak \r\n> can't the site choose not to include the 3p script in the bundle\r\n\r\nSure, a site could choose this, but i'm not sure I follow the point.  My point isn't that sites _have_ to evade content blockers in the proposal, its that it gives them new options to circumvent the user's goals / aims / wishes.\r\n\r\n> As for collisions between bundles and the unbundled web\u2026\r\n\r\nAgain, im not sure I follow you here.  My point is that it'd be simple to change URLs during \"bundling\" so that they're (i) impossible for content blockers to reason about, and (ii) ensure they don't collide with real world urls.  Say, every bundled resource has its URL changed to be a random domain 256 character domain and path.\r\n\r\n> My example involves changes that would mostly be internal to the CMS, and hence the cost amortized across its customers\r\n\r\nNeeding to update the large number of existing CMS's seems like a perfect example of why this is difficult for sites!  Let alone other costs (loosing cache, in your hash guessing scheme paying an extra network request and on some platform OS thread or process, making static sites unworkable, etc etc etc). ",
          "createdAt": "2020-04-20T22:29:42Z",
          "updatedAt": "2020-04-20T22:29:42Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "The right place to continue discussion is probably #551, which I intentionally didn't close with this PR. FWIW, I disagree with (2): URLs are already arbitrary, opaque indexes into a server if the content wants them to be, and web packages don't make that worse. ",
          "createdAt": "2020-04-20T23:31:30Z",
          "updatedAt": "2020-04-20T23:31:30Z"
        },
        {
          "author": "pes10k",
          "authorAssociation": "NONE",
          "body": "okie i will move this over there.  \r\n\r\n> URLs are already arbitrary, opaque indexes into a server if the content wants them to be, and web packages don't make that worse\r\n\r\n1. Yes URLs can be opaque\r\n2. they are never the less still useful (see Google safe browsing, EasyList, disconnect, caching policies etc etc etc)\r\n3. again the claim isn't that this proposal does something to fundamentally change URLs, its that it (i) takes something expensive and possible now, and makes it free and trivial, and (ii) basically makes every resource on a site into a single yes / no decision. \r\n\r\nI'm sure im repeating myself on the above, so for everyone's sake, i'll copy it over to #551 and then stop ",
          "createdAt": "2020-04-20T23:45:04Z",
          "updatedAt": "2020-04-20T23:45:04Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk2MTIxNzQz",
          "commit": {
            "abbreviatedOid": "34908ad"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "As we are planning to request a TAG review of this proposal soonish, it would be nice to include this content.",
          "createdAt": "2020-04-20T03:44:34Z",
          "updatedAt": "2020-04-20T03:44:34Z",
          "comments": []
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f9b19a700cfc65fc1361ea276f846fb8075c78f7",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "anti-adblock",
      "headRefOid": "34908adff23bd6b7bc11ebf99bba3b13d764d21b",
      "mergeCommit": {
        "oid": "7f17cc55d627f76b03439b525acb23bb1ffbd664"
      }
    },
    {
      "number": 574,
      "id": "MDExOlB1bGxSZXF1ZXN0NDA4MzE2NjY4",
      "title": "Add more details and alternative designs to the subresource explainer.",
      "url": "https://github.com/WICG/webpackage/pull/574",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "* What makes a bundled subresource authoritative?\r\n* How else could we express scope?\r\n* Is the link type named right?\r\n\r\n@hayatoito",
      "createdAt": "2020-04-24T04:03:31Z",
      "updatedAt": "2020-04-29T23:42:11Z",
      "closedAt": "2020-04-29T23:42:09Z",
      "mergedAt": "2020-04-29T23:42:09Z",
      "mergedBy": "jyasskin",
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5ODEzMDkz",
          "commit": {
            "abbreviatedOid": "55ad096"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "This lgtm, thanks for fleshing a lot more details.",
          "createdAt": "2020-04-24T10:06:49Z",
          "updatedAt": "2020-04-24T10:14:56Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "```suggestion\r\nWeb pages will declare that some of their subresources are provided by the\r\n```",
              "createdAt": "2020-04-24T10:06:49Z",
              "updatedAt": "2020-04-27T22:57:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3Mzk5NjY1Nzk3",
          "commit": {
            "abbreviatedOid": "55ad096"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Overall looks good. A few questions/comments",
          "createdAt": "2020-04-24T06:14:40Z",
          "updatedAt": "2020-04-24T10:18:06Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "Why not?",
              "createdAt": "2020-04-24T06:14:40Z",
              "updatedAt": "2020-04-27T22:57:34Z"
            },
            {
              "originalPosition": 144,
              "body": "Since the resource list is in HTML, it doesn't have to be base64 encoded & compressed. It could be a simple list of readable URLs, which then gets compressed with the rest of the HTML document.\r\nAt the same time, pre-compressing can reduce HTML tokenization load, and can guarantee brotli compression. I added that as a TODO to the doc.",
              "createdAt": "2020-04-24T06:23:11Z",
              "updatedAt": "2020-04-27T22:57:34Z"
            },
            {
              "originalPosition": 146,
              "body": "Fair point about the measurement. I've now published the methodology: https://github.com/yoavweiss/url_compression_experiments",
              "createdAt": "2020-04-24T06:24:40Z",
              "updatedAt": "2020-04-27T22:57:34Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxMzgxODY0",
          "commit": {
            "abbreviatedOid": "3d6b71f"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-04-27T22:50:49Z",
          "updatedAt": "2020-04-27T22:57:44Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "I elaborated here. It's mostly that it's not necessary for a minimum-viable feature, but we can also learn more about the right API design by letting some sites unpack the bundle themselves.",
              "createdAt": "2020-04-27T22:50:49Z",
              "updatedAt": "2020-04-27T22:57:44Z"
            },
            {
              "originalPosition": 144,
              "body": "Good point. Leaving the URLs uncompressed may even help compress them against their other use in the same document.",
              "createdAt": "2020-04-27T22:51:44Z",
              "updatedAt": "2020-04-27T22:57:44Z"
            },
            {
              "originalPosition": 146,
              "body": "And I've linked it here. Thanks!",
              "createdAt": "2020-04-27T22:56:39Z",
              "updatedAt": "2020-04-27T22:57:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDAxNjkxOTI1",
          "commit": {
            "abbreviatedOid": "caadcd1"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2020-04-28T10:12:13Z",
          "updatedAt": "2020-04-28T10:12:49Z",
          "comments": [
            {
              "originalPosition": 46,
              "body": "OK. I'm not 100% convinced that SW should not be part of an MVP, but agree that polyfilling an API for them may worrk as a stop gap and can help inform what such an API should look like.",
              "createdAt": "2020-04-28T10:12:13Z",
              "updatedAt": "2020-04-28T10:12:49Z"
            }
          ]
        }
      ],
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7f17cc55d627f76b03439b525acb23bb1ffbd664",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "subresource-explainer",
      "headRefOid": "caadcd1d0bbc656606afa3d1d859ae08690dbbb2",
      "mergeCommit": {
        "oid": "d65b775e6c358610be52391df8faafdc09355b70"
      }
    },
    {
      "number": 578,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE1MDE4MzUw",
      "title": "js/bundle: Allow non-http(s) URLs",
      "url": "https://github.com/WICG/webpackage/pull/578",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This makes the JS WebBundle encoder be liberal about inner URL schemes.\r\n\r\nThe format spec currently does not say which URL scheme should be\r\nallowed, which is discussed in #468.",
      "createdAt": "2020-05-08T02:58:45Z",
      "updatedAt": "2020-05-08T03:49:18Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d65b775e6c358610be52391df8faafdc09355b70",
      "headRepository": "irori/webpackage",
      "headRefName": "scheme",
      "headRefOid": "b07ab5aa1d4540d484abb3fc9b58db91699ebb99",
      "closedAt": "2020-05-08T03:44:52Z",
      "mergedAt": "2020-05-08T03:44:52Z",
      "mergedBy": "irori",
      "mergeCommit": {
        "oid": "f00f792f4e89d4b10fe07ef6702c5a381df65844"
      },
      "comments": [
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks!",
          "createdAt": "2020-05-08T03:44:24Z",
          "updatedAt": "2020-05-08T03:44:24Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTY5Mzg0",
          "commit": {
            "abbreviatedOid": "b07ab5a"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "It's a bit questionable if we ever want to allow ftp://.... but either way lgtm for now",
          "createdAt": "2020-05-08T03:13:35Z",
          "updatedAt": "2020-05-08T03:13:35Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTc4NDc3",
          "commit": {
            "abbreviatedOid": "b07ab5a"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2020-05-08T03:49:18Z",
          "updatedAt": "2020-05-08T03:49:18Z",
          "comments": []
        }
      ]
    },
    {
      "number": 579,
      "id": "MDExOlB1bGxSZXF1ZXN0NDE1MDIwNjA0",
      "title": "js/bundle: Bump version to 0.0.5",
      "url": "https://github.com/WICG/webpackage/pull/579",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-05-08T03:08:40Z",
      "updatedAt": "2020-05-08T03:53:40Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "d65b775e6c358610be52391df8faafdc09355b70",
      "headRepository": "irori/webpackage",
      "headRefName": "js-version",
      "headRefOid": "764432761cbf23956f26759cd5821542b38dc206",
      "closedAt": "2020-05-08T03:53:40Z",
      "mergedAt": "2020-05-08T03:53:40Z",
      "mergedBy": "irori",
      "mergeCommit": {
        "oid": "83a83ee876ebd4d59aaf3909c3be262a9a59c1c0"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDA3OTc5MzUw",
          "commit": {
            "abbreviatedOid": "7644327"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm",
          "createdAt": "2020-05-08T03:52:48Z",
          "updatedAt": "2020-05-08T03:52:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 584,
      "id": "MDExOlB1bGxSZXF1ZXN0NDMyNzA3NDIx",
      "title": "Update the description of the package: scheme",
      "url": "https://github.com/WICG/webpackage/pull/584",
      "state": "CLOSED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Remove the \"//\", and stop escaping nested \":\"s. ",
      "createdAt": "2020-06-10T21:16:20Z",
      "updatedAt": "2020-07-08T19:53:54Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "83a83ee876ebd4d59aaf3909c3be262a9a59c1c0",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "package-url",
      "headRefOid": "a3b032afc32659253c7dccd22420eef062564f3c",
      "closedAt": "2020-07-08T19:53:49Z",
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "This is superseded by #587.",
          "createdAt": "2020-07-08T19:53:48Z",
          "updatedAt": "2020-07-08T19:53:48Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 586,
      "id": "MDExOlB1bGxSZXF1ZXN0NDM4OTI5NjY4",
      "title": "Make resources attribute DOMTokenList",
      "url": "https://github.com/WICG/webpackage/pull/586",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "Make `<link>` elements' `resources` attribute `DOMTokenList` so that the explainer matches chromium's current POC implementation.",
      "createdAt": "2020-06-24T02:59:46Z",
      "updatedAt": "2020-06-30T08:30:34Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "83a83ee876ebd4d59aaf3909c3be262a9a59c1c0",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "subresource-loading-resources",
      "headRefOid": "8e96b29163662ffd392c0801749a792d3bde2d12",
      "closedAt": "2020-06-30T08:02:25Z",
      "mergedAt": "2020-06-30T08:02:24Z",
      "mergedBy": "yoavweiss",
      "mergeCommit": {
        "oid": "e8239ae3eb4e1a5ff310e95aff29313f321a66bb"
      },
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin @yoavweiss \r\nWould you review this PR? This PR just makes `<link>` element's `resources` attribute DOMTokenList explicitly with IDL.\r\n\r\nIn follow-up PRs, I will stop mentioning \"scope=\" attribute because we are unlikely to implement that approach, in favor of `resources`.",
          "createdAt": "2020-06-24T04:03:32Z",
          "updatedAt": "2020-06-24T04:36:38Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the reviews. I dropped the IDL and rebased the PR with new commit message.\r\nWould you review again? Thanks!",
          "createdAt": "2020-06-25T02:13:49Z",
          "updatedAt": "2020-06-25T02:13:49Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks for the reviews! I committed the suggestion from @jyasskin . That sounds good to me.",
          "createdAt": "2020-06-26T01:52:21Z",
          "updatedAt": "2020-06-26T01:52:42Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "@jyasskin @yoavweiss \r\nI'd appreciate if you could merge this RP if the PR is fine to you.\r\nI don't have a merge permission.",
          "createdAt": "2020-06-30T07:25:01Z",
          "updatedAt": "2020-06-30T07:25:01Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Thanks!",
          "createdAt": "2020-06-30T08:30:34Z",
          "updatedAt": "2020-06-30T08:30:34Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM2NTQ3NTU1",
          "commit": {
            "abbreviatedOid": "60c9e13"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T11:10:54Z",
          "updatedAt": "2020-06-24T11:11:00Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "What's `value`?",
              "createdAt": "2020-06-24T11:10:54Z",
              "updatedAt": "2020-06-26T01:50:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MDUwNDg2",
          "commit": {
            "abbreviatedOid": "60c9e13"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-24T22:30:23Z",
          "updatedAt": "2020-06-24T22:30:23Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "We're not supposed to put WebIDL into explainers at all. You could show this as some sample Typescript code using the link element's object?",
              "createdAt": "2020-06-24T22:30:23Z",
              "updatedAt": "2020-06-26T01:50:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MTE5NDg1",
          "commit": {
            "abbreviatedOid": "60c9e13"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T01:57:38Z",
          "updatedAt": "2020-06-25T01:57:39Z",
          "comments": [
            {
              "originalPosition": 11,
              "body": "Ah, I didn't know that. Thanks!\r\nRegarding a TypeScript example, I am not sure we could have a good example here. So let's just drop the IDL.\r\n\r\nLet me update the commit message, and rebase it.\r\n",
              "createdAt": "2020-06-25T01:57:38Z",
              "updatedAt": "2020-06-26T01:50:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MTIwMjgy",
          "commit": {
            "abbreviatedOid": "60c9e13"
          },
          "author": "hayatoito",
          "authorAssociation": "CONTRIBUTOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-06-25T01:59:59Z",
          "updatedAt": "2020-06-25T02:00:00Z",
          "comments": [
            {
              "originalPosition": 13,
              "body": "Thanks. As @jyasskin suggested, it looks we are not supposed to put WebIDL into explainers at all. So let me remove the IDL section.",
              "createdAt": "2020-06-25T01:59:59Z",
              "updatedAt": "2020-06-26T01:50:45Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3MTg4NDIw",
          "commit": {
            "abbreviatedOid": "7c15647"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "\r\nI don't think that clarifies that it's a DOMTokenList, but maybe that's OK for an explainer. In the IDL code you pointed at some reflection. If it's something that web developers should know about, you might want to add a paragraph on that front (with an example?)",
          "createdAt": "2020-06-25T05:57:59Z",
          "updatedAt": "2020-06-25T05:57:59Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDM3Nzc0OTQ1",
          "commit": {
            "abbreviatedOid": "7c15647"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2020-06-25T18:58:31Z",
          "updatedAt": "2020-06-25T18:59:29Z",
          "comments": [
            {
              "originalPosition": 8,
              "body": "We could say something like:\r\n\r\n```suggestion\r\n\r\nThe `resources` attribute is reflected to JavaScript as a [`DOMTokenList`](https://developer.mozilla.org/en-US/docs/Web/API/DOMTokenList).\r\n\r\n```",
              "createdAt": "2020-06-25T18:58:31Z",
              "updatedAt": "2020-06-26T01:50:45Z"
            }
          ]
        }
      ]
    },
    {
      "number": 587,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ0OTg3ODY4",
      "title": "Add an explainer for the package: URL scheme",
      "url": "https://github.com/WICG/webpackage/pull/587",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "This tries to identify and describe all the places that the URL gets exposed in interesting ways to the platform, and define how they'll work. It probably misses several.\r\n\r\nYou can see this rendered at https://github.com/jyasskin/webpackage/blob/package-scheme-explainer/explainers/bundle-urls-and-origins.md.",
      "createdAt": "2020-07-06T20:34:06Z",
      "updatedAt": "2020-07-09T00:48:01Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "f38446044e22e98165063363a9516b634ccd94e6",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "package-scheme-explainer",
      "headRefOid": "8e03f145ad03e6b98cf55dad97ec88e02cbe4951",
      "closedAt": "2020-07-08T22:37:48Z",
      "mergedAt": "2020-07-08T22:37:47Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "fc9b3e75309546c805b5cdb1db74b2d58a8e0b28"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQzNTY0Mjk5",
          "commit": {
            "abbreviatedOid": "adc34b8"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-07T05:04:49Z",
          "updatedAt": "2020-07-07T05:04:50Z",
          "comments": [
            {
              "originalPosition": 361,
              "body": "Sorry, I don't understand correctly. Why the message could be intercepted by something inside the same bundle?\r\n\r\nWhen \"package:https:,,a.example.com$https:,,b.example/page.html\" sends a message to \"https://c.example/target.html\", postMessage() should be called with \"https://c.example\" `targetOrigin`.\r\nIn this case, the message can't be intercepted anything inside the same bundle.\r\nIs my understanding incorrect?\r\n",
              "createdAt": "2020-07-07T05:04:50Z",
              "updatedAt": "2020-07-08T22:29:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ0MzgyMDE0",
          "commit": {
            "abbreviatedOid": "adc34b8"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T03:07:59Z",
          "updatedAt": "2020-07-08T03:07:59Z",
          "comments": [
            {
              "originalPosition": 361,
              "body": "My understanding writing this was that if `package:https:,,a.example.com$https:,,b.example/page.html` (a.k.a. \"Packaged-B\") has a `WindowProxy` whose name it sees as `https://c.example/target.html`, that `WindowProxy` could be referring to either the \"real\" `https://c.example/target.html` (Internet-C) fetched over the internet or `package:https:,,a.example.com$https:,,c.example/target.html` (Packaged-C) retrieved from inside the same bundle. And even if Packaged-B has some reason to prefer its message be received by Internet-C, it can't use `targetOrigin` to ensure that, because the two are expressed the same inside the `targetOrigin` field.\r\n\r\nIn the design as it's written here, Packaged-B has absolutely no way to tell those two situations apart (other than knowledge baked in when the package was created). I don't see any harm from giving it a way in the platform to tell the situations apart, but it adds some complication that I haven't been able to justify with a compensating benefit.",
              "createdAt": "2020-07-08T03:07:59Z",
              "updatedAt": "2020-07-08T22:29:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MTcxODAx",
          "commit": {
            "abbreviatedOid": "8e03f14"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-08T22:29:16Z",
          "updatedAt": "2020-07-08T22:29:16Z",
          "comments": [
            {
              "originalPosition": 361,
              "body": "I've added a similar example to the wording here.",
              "createdAt": "2020-07-08T22:29:16Z",
              "updatedAt": "2020-07-08T22:29:16Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDQ1MjE5NDA0",
          "commit": {
            "abbreviatedOid": "8e03f14"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-07-09T00:48:00Z",
          "updatedAt": "2020-07-09T00:48:01Z",
          "comments": [
            {
              "originalPosition": 361,
              "body": "Thank you. Now I understand.",
              "createdAt": "2020-07-09T00:48:01Z",
              "updatedAt": "2020-07-09T00:48:01Z"
            }
          ]
        }
      ]
    },
    {
      "number": 588,
      "id": "MDExOlB1bGxSZXF1ZXN0NDQ3NjUyODg0",
      "title": "Explain how storage works after a bundle is downloaded.",
      "url": "https://github.com/WICG/webpackage/pull/588",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2020-07-10T21:32:09Z",
      "updatedAt": "2020-07-29T19:17:44Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "fc9b3e75309546c805b5cdb1db74b2d58a8e0b28",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "bundle-downloading",
      "headRefOid": "e73da0033d27a28afc4af40eeb8e018cfde9f707",
      "closedAt": "2020-07-29T19:17:36Z",
      "mergedAt": "2020-07-29T19:17:36Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "f6a6b39f4c06ad9c029b2590d7c88a427058bd30"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 591,
      "id": "MDExOlB1bGxSZXF1ZXN0NDY2NTAxNjE0",
      "title": "Update loading spec to support subresource substitution",
      "url": "https://github.com/WICG/webpackage/pull/591",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "I'd like to update the \"Loading Signed Exchanges\" spec to support Signed Exchange subresource substitution.\nThe logic is copied from \"Algorithm sketch\" section of the explainer of [Signed Exchange subresource substitution](https://github.com/WICG/webpackage/blob/master/explainers/signed-exchange-subresource-subtitution-explainer.md#algorithm-sketch).\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/591.html\" title=\"Last updated on Sep 4, 2020, 12:29 AM UTC (8466393)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/591/7d82584...horo-t:8466393.html\" title=\"Last updated on Sep 4, 2020, 12:29 AM UTC (8466393)\">Diff</a>",
      "createdAt": "2020-08-12T04:35:36Z",
      "updatedAt": "2020-09-07T07:13:55Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "7d82584113dc44de97d13866cd083fa55c69076c",
      "headRepository": "horo-t/webpackage",
      "headRefName": "subresource-sxg-loading",
      "headRefOid": "84663936b5da33000dd1679b70a74926e1517bba",
      "closedAt": "2020-09-04T00:32:19Z",
      "mergedAt": "2020-09-04T00:32:18Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "bfd16402098add7dd5b39e99f7baac1d15407f73"
      },
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin @kinu \r\nCold you please review the latest PR?\r\nhttps://github.com/WICG/webpackage/pull/591/commits/99de0b338b9ae715160bf03217d92558a3ac1945",
          "createdAt": "2020-08-17T23:23:47Z",
          "updatedAt": "2020-08-17T23:23:47Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I think 1304768f307ba220c8714a35a892c1c62a310a54 is ready for review.\r\n@jyasskin Could you please review this again?\r\nThank you.",
          "createdAt": "2020-08-24T09:42:56Z",
          "updatedAt": "2020-08-24T09:42:56Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I changed this PR to monkeypatch `Link type \"prefetch\"` for recursive prefetching of alternate signed exchange subresources, and monkeypatch `Page load processing model for HTML files` for Link rel=preload HTTP headers processing.\r\n\r\n@jyasskin @yoavweiss \r\nCould you please review the latest patch?",
          "createdAt": "2020-08-26T08:26:11Z",
          "updatedAt": "2020-08-26T08:26:11Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2MjMwNDc2",
          "commit": {
            "abbreviatedOid": "552b4ff"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "This is going to be more complicated than just copying and pasting the algorithm sketch from the explainer. You need to go through the adjacent specifications and describe what's happening in their terms. Where the adjacent specs don't exist yet, like `prenavigate`, you can be a bit more handwavey, but try to be as precise as you can.",
          "createdAt": "2020-08-12T20:00:43Z",
          "updatedAt": "2020-08-12T21:01:09Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "We don't generally link back to the explainer from the specification. Instead, this paragraph should summarize the behavior the section is trying to achieve.",
              "createdAt": "2020-08-12T20:00:43Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            },
            {
              "originalPosition": 15,
              "body": "\"the alternate subresources signed exchanges\" needs to link to its definition. I don't see one anywhere in this patch.\r\n\r\nThat probably belongs as the first subsection of this new section, and I think it's the `<link rel=\"alternate\" type=\"application/signed-exchange\" anchor=\"https://prenavigated.example/subresource.css\" href=\"https://distributor.example/subresource.css.sxg\">`? https://w3c.github.io/resource-hints/#dfn-resource-hint-link has a similar definition of a term to refer to semantics defined elsewhere. The new section here should also explain how the attributes on that `<link>` combine to the meaning we want.",
              "createdAt": "2020-08-12T20:02:34Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            },
            {
              "originalPosition": 19,
              "body": "Nothing defines \"allowed-alt-sxg\" yet. This document should have a section to define that link relation, similar to the sections under https://w3c.github.io/resource-hints/#resource-hints. Probably put that above the monkeypatches since it's more about the overall semantics and so more useful for general developers.",
              "createdAt": "2020-08-12T20:13:09Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            },
            {
              "originalPosition": 18,
              "body": "The only defined resource hint that tells the UA to process the inner response at all is [prerender](https://w3c.github.io/resource-hints/#prerender), which is fairly deprecated. We need to specify that this happens inside of `prenavigate`, which doesn't have a spec yet... @yoavweiss, what's the status there?\r\n\r\nI think this block needs to be a monkeypatch to either the `prenavigate` definition, or the [fetch and process the linked resource algorithm](https://html.spec.whatwg.org/multipage/semantics.html#fetch-and-process-the-linked-resource) that `preload` uses. Probably both: `prenavigate` to set some flag about which origins are ok to connect to, and \"fetch and process the linked resource\" to notice that and use the `rel=alternate` link instead.",
              "createdAt": "2020-08-12T20:34:27Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            },
            {
              "originalPosition": 39,
              "body": "```suggestion\r\n\r\nNote: As browsers move toward partitioned HTTP caches, the source\r\n```",
              "createdAt": "2020-08-12T20:35:47Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            },
            {
              "originalPosition": 54,
              "body": "@domfarolino, I'm having trouble finding where `<link rel=preload>` applies the `imagesrcset` and `imagesizes` attributes to control what it fetches. https://www.w3.org/TR/preload/#processing appears to use the default https://html.spec.whatwg.org/multipage/semantics.html#fetch-and-process-the-linked-resource algorithm, which doesn't consult those attributes. Since you wrote https://github.com/whatwg/html/pull/4048, can you point us in the right direction?\r\n\r\nWe should find or define a way for this algorithm to just ask the new document what it preloaded. We'll also have to pick the moment at which we check this set, since documents can add and remove `<link rel=\"allowed-alt-sxg\">` and `<link rel=\"preload\">` elements at any time.",
              "createdAt": "2020-08-12T20:47:24Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            },
            {
              "originalPosition": 36,
              "body": "Monkeypatches need to specify where any new steps are added.",
              "createdAt": "2020-08-12T20:57:27Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            },
            {
              "originalPosition": 38,
              "body": "I think \"the one that serves the navigation itself\" is just naturally excluded from the set of SXGs that went through the \"attach it to the top-level prefetch\" step above. You do need to take those attached SXGs and attach them to the new document.",
              "createdAt": "2020-08-12T20:59:32Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY2ODI1MTA4",
          "commit": {
            "abbreviatedOid": "552b4ff"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T14:36:46Z",
          "updatedAt": "2020-08-13T14:36:46Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "`prenavigate` is indeed not currently defined. All we have is a few [past discussions](https://github.com/w3c/resource-hints/issues/82#issuecomment-532072736) :/\r\n\r\n",
              "createdAt": "2020-08-13T14:36:46Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MTk1NzA0",
          "commit": {
            "abbreviatedOid": "552b4ff"
          },
          "author": "kinu",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-13T23:29:44Z",
          "updatedAt": "2020-08-13T23:29:44Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "(As we also chatted elsewhere) I don't think this part specifically relies on `prenavigate` (while this one itself needs to have spec too), but rather depending on the unclarified behavior processing link headers won't be considered preprocessing the content (https://github.com/w3c/resource-hints/issues/77#issuecomment-360743041).  But yes this part also needs to be reflected in the spec text.",
              "createdAt": "2020-08-13T23:29:44Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3MzUwMTAy",
          "commit": {
            "abbreviatedOid": "552b4ff"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T07:03:39Z",
          "updatedAt": "2020-08-14T07:03:39Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "While runnning [default fetch and process the linked resource](https://html.spec.whatwg.org/multipage/semantics.html#default-fetch-and-process-the-linked-resource), the [linked resource fetch setup steps for preload](https://html.spec.whatwg.org/multipage/links.html#link-type-preload:linked-resource-fetch-setup-steps) is called from step 10.\r\n>  10. Run the linked resource fetch setup steps, given el and request. If the result is false, then return.\r\n\r\nThe [linked resource fetch setup steps for preload](https://html.spec.whatwg.org/multipage/links.html#link-type-preload:linked-resource-fetch-setup-steps) calls [select an image source](https://html.spec.whatwg.org/multipage/images.html#select-an-image-source) which calls [update the source set](https://html.spec.whatwg.org/multipage/images.html#update-the-source-set) to update `source set` using the imagesrcset and imagesizes attributes and returns `selected source` from the `source set`. And\r\n> 4. Set request's url to url.\r\n\r\nSo I think we need the monkypatch after `4. If as is \"image\", then:` of [the linked resource fetch setup steps for preload](https://html.spec.whatwg.org/multipage/links.html#link-type-preload:linked-resource-fetch-setup-steps).\r\n",
              "createdAt": "2020-08-14T07:03:39Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTIxODQx",
          "commit": {
            "abbreviatedOid": "99de0b3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:04:28Z",
          "updatedAt": "2020-08-14T12:04:28Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Updated this section and introduced new terms **allowed-alt-sxg link**, **alternate signed exchange link** and **header integrity value**.",
              "createdAt": "2020-08-14T12:04:28Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTIyNDkw",
          "commit": {
            "abbreviatedOid": "99de0b3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:05:42Z",
          "updatedAt": "2020-08-14T12:05:42Z",
          "comments": [
            {
              "originalPosition": 15,
              "body": "Introduced new term **alternate signed exchange link**.",
              "createdAt": "2020-08-14T12:05:42Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTIyNjkz",
          "commit": {
            "abbreviatedOid": "99de0b3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:06:05Z",
          "updatedAt": "2020-08-14T12:06:05Z",
          "comments": [
            {
              "originalPosition": 19,
              "body": "Introduced the terms **allowed-alt-sxg link**.",
              "createdAt": "2020-08-14T12:06:05Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTIyODg1",
          "commit": {
            "abbreviatedOid": "99de0b3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:06:32Z",
          "updatedAt": "2020-08-14T12:06:32Z",
          "comments": [
            {
              "originalPosition": 39,
              "body": "Done.",
              "createdAt": "2020-08-14T12:06:32Z",
              "updatedAt": "2020-09-04T00:28:52Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTIzMzU4",
          "commit": {
            "abbreviatedOid": "99de0b3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:07:25Z",
          "updatedAt": "2020-08-14T12:07:26Z",
          "comments": [
            {
              "originalPosition": 54,
              "body": "Changed this PR to monkeypatch [linked resource fetch setup steps for preload type of linked resource](https://html.spec.whatwg.org/multipage/links.html#link-type-preload:linked-resource-fetch-setup-steps).",
              "createdAt": "2020-08-14T12:07:26Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTIzNTU1",
          "commit": {
            "abbreviatedOid": "99de0b3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:07:48Z",
          "updatedAt": "2020-08-14T12:07:48Z",
          "comments": [
            {
              "originalPosition": 36,
              "body": "Done",
              "createdAt": "2020-08-14T12:07:48Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTI1MDk0",
          "commit": {
            "abbreviatedOid": "99de0b3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:10:46Z",
          "updatedAt": "2020-08-14T12:10:46Z",
          "comments": [
            {
              "originalPosition": 38,
              "body": "Introduced **prefetched subresource singed exchanges** and **allowed alternate subresource signed exchange links** in [navigation param struct](https://html.spec.whatwg.org/multipage/browsing-the-web.html#navigation-params), and **prefetched singed exchanges for navigation**, **prefetched subresource singed exchanges**, **transferred subresource singed exchanges** and **allowed alternate\r\nsubresource signed exchange links** in [document  object](https://html.spec.whatwg.org/multipage/dom.html#the-document-object)",
              "createdAt": "2020-08-14T12:10:46Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY3NTMxMjMz",
          "commit": {
            "abbreviatedOid": "552b4ff"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-14T12:21:59Z",
          "updatedAt": "2020-08-14T12:22:07Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "I think this monkeypatch does describes the behavior of processing the preload header in the inner response of the prefetched signed exchange.\r\n",
              "createdAt": "2020-08-14T12:21:59Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDY5ODQ5MjEw",
          "commit": {
            "abbreviatedOid": "c2b292d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "CHANGES_REQUESTED",
          "body": "Sorry, I didn't get through the whole thing. I'll do more tomorrow.",
          "createdAt": "2020-08-18T21:38:47Z",
          "updatedAt": "2020-08-18T22:39:19Z",
          "comments": [
            {
              "originalPosition": 22,
              "body": "```suggestion\r\nWhen prenavigating to a page held in a signed exchange, it can be useful to\r\nalso prefetch subresources of that page as signed exchanges from the same\r\nserver. To identify those transitive prefetchable resources, this section introduces\r\nan extension to the HTTP Link header.\r\n```",
              "createdAt": "2020-08-18T21:38:48Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 24,
              "body": "```suggestion\r\n* An <dfn dfn-type=dfn>allowed-alt-sxg link</dfn> is a relationship that is used\r\n```",
              "createdAt": "2020-08-18T21:39:02Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 47,
              "body": "This is |headerBytes| in https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/591.html#parsing-a-signed-exchange, and we need to return it from that algorithm in order to let this one use it. It's probably reasonable to stick the sha256 into https://pr-preview.s3.amazonaws.com/horo-t/webpackage/pull/591.html#exchange.",
              "createdAt": "2020-08-18T21:55:17Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 24,
              "body": "Imitate the language used in https://html.spec.whatwg.org/multipage/links.html#link-type-prefetch when defining this new link type. It probably makes sense to describe this as a monkeypatch to HTML so we don't end up with duplication like https://www.w3.org/TR/resource-hints/#prefetch.",
              "createdAt": "2020-08-18T22:07:49Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 33,
              "body": "This is not actually a link relationship since it's not a keyword. Imitating https://www.w3.org/TR/resource-hints/#dfn-resource-hint-link, how about:\r\n\r\n```suggestion\r\n* An <dfn>alternate signed exchange link</dfn> is a `` `Link` `` header sent with a signed exchange |S|, with the [=alternate=] link type, the `type` parameter set to `application/signed-exchange`, and a [=Link Context=]. The [=Link Context=] MUST be the [=Link Target=] of a [=preload=] `` `Link` `` header inside the signed content of |S|, and the [=alternate signed exchange link=] means that this resource can also be found inside the signed exchange at the [=Link Target=] of the [=alternate signed exchange link=].\r\n\r\n    <div class=\"example\" id=\"example-alternate-signed-exchange-link\">\r\n    ```http\r\n    Link: <...>; ...\r\n    ```\r\n  </div>\r\n```\r\n\r\nAdd the Link Target (https://tools.ietf.org/html/rfc8288#section-3.1) and Link Context (https://tools.ietf.org/html/rfc8288#section-3.2) definitions to the `<pre class='anchors'>` so they appear correctly in the References section.\r\n\r\nYou may have to fiddle with the bikeshed markdown to get it to link to https://html.spec.whatwg.org/multipage/links.html#rel-alternate and look right. See https://tabatkins.github.io/bikeshed/#autolinking.\r\n\r\nThis would probably make more sense with a diagram showing where in the inner and outer signed exchanges the headers appear. Try to make one with https://plantuml.com/component-diagram#58bb821cf05c48a2?",
              "createdAt": "2020-08-18T22:35:02Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 66,
              "body": "```suggestion\r\nThe {{Document}} has a set of <dfn for=\"Document\" dfn-type=dfn>prefetched singed exchanges\r\n```",
              "createdAt": "2020-08-18T22:36:35Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 69,
              "body": "```suggestion\r\nThe {{Document}} has a set of <dfn for=\"Document\" dfn-type=dfn>prefetched\r\n```\r\n\r\nAnd similarly for the rest.",
              "createdAt": "2020-08-18T22:37:39Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMjI1NjMz",
          "commit": {
            "abbreviatedOid": "c2b292d"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T08:14:32Z",
          "updatedAt": "2020-08-19T08:14:33Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "> You may have to fiddle with the bikeshed markdown to get it to link to https://html.spec.whatwg.org/multipage/links.html#rel-alternate and look right. See https://tabatkins.github.io/bikeshed/#autolinking.\r\n\r\nSorry I may not understand well how bikeshed works.\r\nI created a PR to the HTML spec to export `rel` and `alternate`. https://github.com/whatwg/html/pull/5843\r\nDo I need to wait for the PR to be merged?",
              "createdAt": "2020-08-19T08:14:32Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcwMjYzNTE4",
          "commit": {
            "abbreviatedOid": "c2b292d"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T09:03:05Z",
          "updatedAt": "2020-08-19T09:40:07Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Done",
              "createdAt": "2020-08-19T09:03:05Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 66,
              "body": "Done",
              "createdAt": "2020-08-19T09:03:10Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 69,
              "body": "Done",
              "createdAt": "2020-08-19T09:03:14Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 24,
              "body": "done",
              "createdAt": "2020-08-19T09:03:59Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 22,
              "body": "Done",
              "createdAt": "2020-08-19T09:04:06Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDM0NjA3",
          "commit": {
            "abbreviatedOid": "060b561"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-19T23:39:42Z",
          "updatedAt": "2020-08-20T00:10:27Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "Based on discussion in https://github.com/whatwg/html/pull/5843, let's use a better `dfn-type`:\r\n\r\n```suggestion\r\n* Link type \"<dfn dfn-type=\"attr-value\" dfn-for=\"link/rel\">allowed-alt-sxg</dfn>\"\r\n```",
              "createdAt": "2020-08-19T23:39:43Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 28,
              "body": "Silly English nits:\r\n\r\n```suggestion\r\n    in the HTTP <a http-header>Link</a> header of the inner HTTP response of the main\r\n```",
              "createdAt": "2020-08-19T23:40:35Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 30,
              "body": "I think you can \r\n\r\n```suggestion\r\n    resource signed exchange to indicate that the subresource of the\r\n```\r\n\r\nand just use `<{link/rel/allowed-alt-sxg}> link` to refer to these.",
              "createdAt": "2020-08-19T23:43:23Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 33,
              "body": "```suggestion\r\n    The <dfn element-attr for=\"link\">header-integrity</dfn> parameter holds the value of the\r\n    [=exchange/header integrity value=] of the [=alternate signed exchange=], encoded as a [[CSP]] <a grammar>hash-source</a>.\r\n```",
              "createdAt": "2020-08-19T23:57:09Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 31,
              "body": "This reads like the Link Target has a subresource that can be replaced, but it's actually that the Link Target is a subresource of the current page, and it can be replaced. So maybe:\r\n\r\n```suggestion\r\n    that the content of the\r\n    [=Link Target=] is also available as a particular signed exchange identified by the <{link/header-integrity}> parameter.\r\n```",
              "createdAt": "2020-08-19T23:59:45Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 41,
              "body": "```suggestion\r\n            header-integrity=\"sha256-XXXXXX\"\r\n```",
              "createdAt": "2020-08-20T00:08:26Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 71,
              "body": "```suggestion\r\nThe {{Document}} has a set of <dfn dfn-for=\"Document\" dfn-type=dfn>prefetched\r\n```\r\n\r\nand similarly for the sets below.",
              "createdAt": "2020-08-20T00:09:58Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDcxMDY1NDIx",
          "commit": {
            "abbreviatedOid": "060b561"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-20T01:21:24Z",
          "updatedAt": "2020-08-20T02:04:31Z",
          "comments": [
            {
              "originalPosition": 25,
              "body": "done",
              "createdAt": "2020-08-20T01:21:24Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 28,
              "body": "done",
              "createdAt": "2020-08-20T01:48:16Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 30,
              "body": "done",
              "createdAt": "2020-08-20T01:48:25Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 31,
              "body": "done",
              "createdAt": "2020-08-20T01:48:54Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 33,
              "body": "done",
              "createdAt": "2020-08-20T01:49:14Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 41,
              "body": "done",
              "createdAt": "2020-08-20T01:49:20Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 71,
              "body": "done",
              "createdAt": "2020-08-20T01:49:25Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDczODY3Mjc1",
          "commit": {
            "abbreviatedOid": "1304768"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-24T21:24:27Z",
          "updatedAt": "2020-08-24T23:16:44Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "Dunno why these wound up indented; I think they should just be normal paragraph lines.\r\n\r\n```suggestion\r\nvalue</dfn>, either null or, for responses that [=response/came from a\r\nsigned exchange=], a [=byte sequence=] holding the [=SHA-256=] hash that\r\nverified the [=exchange/response=]'s [=response/header list=].\r\n\r\nNote: The [=response/header integrity value=] doesn\u2019t change even if the\r\npublisher signs the content again or changes the signing key, but it does\r\nchange if any of the headers or body change. (It catches changes to the body\r\nbecause a valid signed exchange's headers have to include a `Digest` value\r\nthat covers the body.)\r\n```",
              "createdAt": "2020-08-24T21:24:28Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 117,
              "body": "I think you mean to be defining new parameters ([\"Target Attributes\"](https://tools.ietf.org/html/rfc8288#section-3.4)) on the `<a http-header>Link</a>` _header_, not the element.  If you mean the element, they're usually lower-case, and they take \"attributes\" instead of \"parameters\".",
              "createdAt": "2020-08-24T21:26:35Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 119,
              "body": "You need to define its format. I think you mean that it's an instance of https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#variants ... which is tricky because that's a full sh-dict, which doesn't really fit as a field inside another header. What's the implementation doing?",
              "createdAt": "2020-08-24T21:48:07Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 121,
              "body": "Similarly here, with https://httpwg.org/http-extensions/draft-ietf-httpbis-variants.html#variant-key.",
              "createdAt": "2020-08-24T21:48:39Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 150,
              "body": "I know I wrote the original version of this, so sorry for leading the PR astray, but we actually should spell out variables, so `|signedResponse|` instead of `|R|`, `|allowedSxgLinks|` instead of `|L|`, etc.",
              "createdAt": "2020-08-24T22:34:54Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 158,
              "body": "Should this be `<{link/rel/preload}>`?",
              "createdAt": "2020-08-24T22:36:20Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 161,
              "body": "We need to define \"semantically-equivalent link element\" in order to use it here.",
              "createdAt": "2020-08-24T22:36:41Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 165,
              "body": "```suggestion\r\n        <{link/href}> attribute's value, with a base URL of |R|'s [=response/URL=].\r\n```",
              "createdAt": "2020-08-24T22:43:38Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 164,
              "body": "Optionally:\r\n\r\n```suggestion\r\n    1. Let |url| be the result of [=URL parser|parsing=] |el|'s\r\n```",
              "createdAt": "2020-08-24T22:44:26Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 160,
              "body": "I would probably use this line to explain why we create link elements and requests that seem unused.\r\n\r\n```suggestion\r\n1. For each |preload link| in |preload links|, use the following steps to resolve the link's actual target, incorporating attributes like {<link/imagesrcset>} and <{link/imagesizes}>}:\r\n```",
              "createdAt": "2020-08-24T23:01:54Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 330,
              "body": "I've run out of time to review today, so this comment is just a general direction rather than actually what needs to be fixed, but:\r\n\r\nWe're going to have to reconcile that the HTML spec pretends that it's dealing with `<link>` elements, but we're doing `Link` headers, and that HTML is trying to handle things incrementally, but we're putting a restriction on the overall set of `Link` headers. It might work to define a predicate on the response that runs over the full set of response headers to say whether to do the resource substitution at all, and then maybe you can avoid checking whether each element came from a header...",
              "createdAt": "2020-08-24T23:16:40Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MDEwMzEy",
          "commit": {
            "abbreviatedOid": "1304768"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T00:16:19Z",
          "updatedAt": "2020-08-25T03:42:12Z",
          "comments": [
            {
              "originalPosition": 62,
              "body": "done",
              "createdAt": "2020-08-25T00:16:19Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 117,
              "body": "done.",
              "createdAt": "2020-08-25T00:29:48Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 121,
              "body": "Added the explanation.",
              "createdAt": "2020-08-25T01:05:10Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 119,
              "body": "Added the explanation.\r\nSorry, I don't understand why sh-dict doesn't fit as a field inside another header. \r\n\r\nCurrently Chrome is supporting the format defined in [draft-ietf-httpbis-variants-04](https://tools.ietf.org/html/draft-ietf-httpbis-variants-04).",
              "createdAt": "2020-08-25T01:19:10Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 150,
              "body": "Done",
              "createdAt": "2020-08-25T01:25:31Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 158,
              "body": "Done.",
              "createdAt": "2020-08-25T01:26:49Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 160,
              "body": "done.",
              "createdAt": "2020-08-25T01:29:11Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 161,
              "body": "Done. Linked to https://tools.ietf.org/html/rfc5988##page-5:~:text=semantically%20equivalent",
              "createdAt": "2020-08-25T01:50:19Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 164,
              "body": "done",
              "createdAt": "2020-08-25T01:50:24Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 165,
              "body": "done",
              "createdAt": "2020-08-25T01:51:52Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 330,
              "body": "Added note about the Issue(whatwg/html#4224).",
              "createdAt": "2020-08-25T03:39:43Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc0MjI1NDQy",
          "commit": {
            "abbreviatedOid": "ca33fd9"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-25T07:56:23Z",
          "updatedAt": "2020-08-25T08:30:49Z",
          "comments": [
            {
              "originalPosition": 32,
              "body": "I don't think this is the right link",
              "createdAt": "2020-08-25T07:56:23Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 158,
              "body": "This is not an \"appropriate times\" algorithm, (e.g. like [this one](https://html.spec.whatwg.org/#link-type-modulepreload)), but more of a \"should we preload this resource?\" one.",
              "createdAt": "2020-08-25T07:57:28Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 209,
              "body": "This simply extends the Document object. I don't think I'd categorize it as \"mokeypatch\".",
              "createdAt": "2020-08-25T07:58:40Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 236,
              "body": "Similarly to above, extending an object is not necessarily \"monkeypatching\"",
              "createdAt": "2020-08-25T07:59:12Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 255,
              "body": "I think this should mokeypatch Fetch or HTML (if this is only meant for prenavigates) directly.\r\nSo when either processes a response, they need to call an algorithm defined here that would:\r\n* Check if the response is a prefetch one (e.g. by checking its request's initiator) and otherwise bail\r\n* Check if the response came from an SXG. Otherwise bail\r\n* Create an exchange...",
              "createdAt": "2020-08-25T08:06:02Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 158,
              "body": "As such, it should be called from somewhere.",
              "createdAt": "2020-08-25T08:09:25Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 275,
              "body": "\"has a matching exchange\" is a bit handwavy. Might be better to define \"prefetched signed exchanged for navigation\" as a [map](https://infra.spec.whatwg.org/#maps)",
              "createdAt": "2020-08-25T08:21:49Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 330,
              "body": "Also \"is for the main resource\" is not really precise, and it's be better to have some boolean that indicates what you mean here.",
              "createdAt": "2020-08-25T08:28:05Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTE0ODg2",
          "commit": {
            "abbreviatedOid": "c02be81"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "I haven't read every line here, but it's looking good. Go through the comments here (and try to generalize them), and then I expect to be able to fix up anything else tomorrow and merge the PR.",
          "createdAt": "2020-08-27T22:02:02Z",
          "updatedAt": "2020-08-27T22:57:13Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "You don't have to repeat `type: dfn` for subsequent definitions.\r\n\r\n```suggestion\r\n    type: dfn\r\n        text: Link Target; url: section-3.1\r\n        text: Link Context; url: section-3.2\r\n        text: Relation Type; url: section-3.3\r\n        text: Target Attributes; url: section-3.4\r\n        text: Parsing a Link Field Value; url: appendix-B.2\r\n```",
              "createdAt": "2020-08-27T22:02:02Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 242,
              "body": "I would probably define a small algorithm for this bit to make it more readable, since it's used so many times. E.g.\r\n\r\n> `A link header value |link|'s <dfn noexport>Target Attribute named</dfn> |name| is the second item of the first tuple of |link|'s [=Target Attributes list|Target Attributes=] whose first item matches the string |name|, or the empty string (\"\") if no such tuple is present.`\r\n\r\nAnd then use it like\r\n```\r\nLet |outerLinkVariants| be |outerLink|'s [=Target Attribute named=] `\"variants\"`.\r\n```",
              "createdAt": "2020-08-27T22:36:02Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 285,
              "body": "```suggestion\r\n        1. Create a <{link}> element |linkElement| whose <{link/href}> attribute\r\n            is |linkTarget|, <{link/imagesrcset}> attribute is\r\n            |imagesrcset|, and <{link/imagesizes}> attribute is |imagesizes|.\r\n```",
              "createdAt": "2020-08-27T22:37:01Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 293,
              "body": "```suggestion\r\n        1. If |allowedSxgLink|'s linkTarget isn't the same as |linkTarget|, then continue.\r\n```\r\n\r\nIt might be good to explicitly define the Allowed SXG Link struct so that you could link to its fields in the above line.",
              "createdAt": "2020-08-27T22:39:55Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 307,
              "body": "We can probably refactor [=matches the stored exchange=] so this algorithm doesn't need to create a placeholder exchange, but no need to do that in this change.",
              "createdAt": "2020-08-27T22:44:41Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 443,
              "body": "Similarly down here, because [tuples are structs](https://infra.spec.whatwg.org/#tuple), all the items have names, which need to be implied or stated when the tuple is created. Here, the variable names that created the tuple work well as names, so you can just use `|allowedSxgLink|'s innerLinkVariants` or similar wherever it's used, instead of needing steps to pull them out into local variables.",
              "createdAt": "2020-08-27T22:49:33Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 471,
              "body": "It wasn't obvious why it was ok for |headerIntegrity| to be an empty string here. I think it's that when it's empty, there was no allowed signed exchange, and so we don't need it to have been prefetched ... in which case maybe it'll be clearer to put the \"If |headerIntegrity| is not an empty string\" condition around both the for loop and what's left of this step?",
              "createdAt": "2020-08-27T22:55:28Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3MTc5ODU3",
          "commit": {
            "abbreviatedOid": "c02be81"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T01:11:40Z",
          "updatedAt": "2020-08-28T06:47:24Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "done",
              "createdAt": "2020-08-28T01:11:40Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 242,
              "body": "done",
              "createdAt": "2020-08-28T02:17:03Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 285,
              "body": "done",
              "createdAt": "2020-08-28T02:22:50Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 293,
              "body": "Done",
              "createdAt": "2020-08-28T05:00:45Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 443,
              "body": "Done",
              "createdAt": "2020-08-28T05:01:31Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 471,
              "body": "I introduced `getting allowed signed exchange link info` algorithm which doesn't allow `allowed signed exchange link info`'s `header integrity` to be null. And I added a Note about the intension. Does this answer your question?",
              "createdAt": "2020-08-28T05:49:47Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NDg5NDg0",
          "commit": {
            "abbreviatedOid": "523beff"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T08:18:52Z",
          "updatedAt": "2020-08-28T08:28:03Z",
          "comments": [
            {
              "originalPosition": 344,
              "body": "I don't think that's what you want to do here. You want to wait until the viewport is \"known\" (in practice, by scanning HTML tokens). Otherwise, IIUC, the viewport is initialized by the parser, which creation you're blocking here...\r\nMight be worthwhile to add a note/TODO saying that this needs to be better defined if/when we'll define the preloadScanner",
              "createdAt": "2020-08-28T08:18:52Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 247,
              "body": "This is an O(n^2) algorithm. Is this how we're implementing this?\r\nNot a blocker, but might be better to redefine this using a map, as a followup. ",
              "createdAt": "2020-08-28T08:21:23Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 378,
              "body": "Same O(n^2) comment as above",
              "createdAt": "2020-08-28T08:22:04Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 443,
              "body": "I'm not sure I get this. It seems that the resource is loaded even if `canLoadAlternateSxg` is false.\r\nIf that's intentional, a better name could clarify that",
              "createdAt": "2020-08-28T08:27:43Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NTMwMDYx",
          "commit": {
            "abbreviatedOid": "523beff"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T08:40:06Z",
          "updatedAt": "2020-08-28T08:40:37Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "As the algorithms are rather lengthy, I think it would help readability to add a note here outlining (at a high level) what they are doing and why",
              "createdAt": "2020-08-28T08:40:07Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 342,
              "body": "Same comment here - a note would be helpful",
              "createdAt": "2020-08-28T08:40:33Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NTU3ODA4",
          "commit": {
            "abbreviatedOid": "523beff"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-08-28T08:54:57Z",
          "updatedAt": "2020-08-28T09:43:07Z",
          "comments": [
            {
              "originalPosition": 199,
              "body": "done",
              "createdAt": "2020-08-28T08:54:57Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 342,
              "body": "done",
              "createdAt": "2020-08-28T09:08:43Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 344,
              "body": "Added Note.",
              "createdAt": "2020-08-28T09:09:32Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 443,
              "body": "Added Note.",
              "createdAt": "2020-08-28T09:22:09Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 378,
              "body": "I will use a map as a followup.",
              "createdAt": "2020-08-28T09:38:36Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 247,
              "body": "Blink is using a map AlternateSignedExchangeResourceInfo.EntryMap.\r\n\r\nI will do so as a followup.",
              "createdAt": "2020-08-28T09:38:42Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc3NjI2NDEy",
          "commit": {
            "abbreviatedOid": "5fd8b75"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM % not-really-blocking comments\r\n\r\nI still want @jyasskin to take a look before landing",
          "createdAt": "2020-08-28T10:40:06Z",
          "updatedAt": "2020-08-28T10:58:17Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "\"Set an entry\" would make this clearer without clicking the link",
              "createdAt": "2020-08-28T10:40:06Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 202,
              "body": "It would be good to make the note more descriptive, outlining that this is getting all the alternateLinks from the outer response, see if they're allowed by the inner response, matches preloads to allowed, etc.",
              "createdAt": "2020-08-28T10:52:54Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 343,
              "body": "Same as above, would be good to outline what the algorithm is doing",
              "createdAt": "2020-08-28T10:54:54Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 465,
              "body": "Thanks! That makes things clearer! :)",
              "createdAt": "2020-08-28T10:55:14Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 373,
              "body": "Non blocking note: Might be worthwhile to coalesce the common parts of the 2 large fetching algorithms into a single one, called from both places. As is, there's a lot of repetition.",
              "createdAt": "2020-08-28T10:57:21Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDc4MjgzODM1",
          "commit": {
            "abbreviatedOid": "5fd8b75"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Thank you!",
          "createdAt": "2020-08-31T03:17:58Z",
          "updatedAt": "2020-08-31T04:02:24Z",
          "comments": [
            {
              "originalPosition": 221,
              "body": "Done.",
              "createdAt": "2020-08-31T03:17:58Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 202,
              "body": "Done.",
              "createdAt": "2020-08-31T03:41:07Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 343,
              "body": "Done.",
              "createdAt": "2020-08-31T03:52:13Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 373,
              "body": "I will do so when I will use a map as a followup.",
              "createdAt": "2020-08-31T03:58:46Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxMTUwNTc4",
          "commit": {
            "abbreviatedOid": "c6c10d0"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-02T18:19:11Z",
          "updatedAt": "2020-09-03T00:30:15Z",
          "comments": [
            {
              "originalPosition": 302,
              "body": "I think \"matches\" here means [\"is identical to\"](https://infra.spec.whatwg.org/#string-is)? Or did you implement something more flexible?",
              "createdAt": "2020-09-02T18:19:12Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 306,
              "body": "Is this string equality or [URL equivalence](https://url.spec.whatwg.org/#concept-url-equals)? Because the [Link Context is a URL](https://tools.ietf.org/html/rfc8288#section-3.2), I'm going to assume it's parsed and then checked for URL equivalence, but we need to be sure to be precise about this to avoid security problems when one of the links is unnecessarily more percent-encoded than the other.",
              "createdAt": "2020-09-02T18:20:56Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgxNDEzOTE5",
          "commit": {
            "abbreviatedOid": "c6c10d0"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-03T01:01:43Z",
          "updatedAt": "2020-09-03T01:06:55Z",
          "comments": [
            {
              "originalPosition": 302,
              "body": "Yes. The implementation is checking the equality of strings in  alternate_signed_exchange_resource_info.cc",
              "createdAt": "2020-09-03T01:01:43Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            },
            {
              "originalPosition": 306,
              "body": "Yes. The implementation is checking the equality of URL in alternate_signed_exchange_resource_info.cc.\r\nSorry I'm not sure what kind of security problems exist here.",
              "createdAt": "2020-09-03T01:06:24Z",
              "updatedAt": "2020-09-04T00:28:53Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgyMjU5MjI1",
          "commit": {
            "abbreviatedOid": "4ce3ca5"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "I finally got through the whole thing. Thanks for bearing with me. I'll merge it now, and we can fix up any mistakes I made in another PR.",
          "createdAt": "2020-09-03T23:08:43Z",
          "updatedAt": "2020-09-04T00:29:33Z",
          "comments": [
            {
              "originalPosition": 314,
              "body": "Same question about this destination.",
              "createdAt": "2020-09-03T23:08:43Z",
              "updatedAt": "2020-09-04T00:29:33Z"
            },
            {
              "originalPosition": 296,
              "body": "This sets the destination to the empty string, but it looks like we have an `as` value above. We should use that, right?",
              "createdAt": "2020-09-03T23:21:17Z",
              "updatedAt": "2020-09-04T00:29:33Z"
            },
            {
              "originalPosition": 448,
              "body": "This looks like it'll use the `header-integrity` of the last matching `allowed-alt-sxg` link if multiple such links match. Does that match your implementation?",
              "createdAt": "2020-09-04T00:09:43Z",
              "updatedAt": "2020-09-04T00:29:33Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDgzMjU4OTMx",
          "commit": {
            "abbreviatedOid": "4ce3ca5"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-09-07T05:58:02Z",
          "updatedAt": "2020-09-07T07:13:55Z",
          "comments": [
            {
              "originalPosition": 296,
              "body": "Yes. Correct, thank you for fixing.",
              "createdAt": "2020-09-07T05:58:03Z",
              "updatedAt": "2020-09-07T07:13:55Z"
            },
            {
              "originalPosition": 314,
              "body": "Yes. Correct.",
              "createdAt": "2020-09-07T05:58:33Z",
              "updatedAt": "2020-09-07T07:13:55Z"
            },
            {
              "originalPosition": 448,
              "body": "No. Chrome is using the first allowed-alt-sxg link entry.h.\r\n\r\nI will update the spec to make it closer to the Chrome's implementation.\r\n(But it may take a few months because of my paternity leave.)\r\n",
              "createdAt": "2020-09-07T07:13:26Z",
              "updatedAt": "2020-09-07T07:13:55Z"
            }
          ]
        }
      ]
    },
    {
      "number": 592,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxODgzOTQy",
      "title": "Record Martin Thomson's suggestion of simplifying the URLs by inferring https: or file:.",
      "url": "https://github.com/WICG/webpackage/pull/592",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@martinthomson suggested this in a somewhat different context, but I think it's equally plausible here.",
      "createdAt": "2020-08-21T22:42:09Z",
      "updatedAt": "2020-08-26T17:30:35Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2ab2cca9b8e211c6dff98ef3ebc4c694d7927446",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "infer-scheme",
      "headRefOid": "83741b1ec357cb273ba13dd988e1867d74f11809",
      "closedAt": "2020-08-26T17:30:26Z",
      "mergedAt": "2020-08-26T17:30:26Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "e83c554a38a7bca4ca36016abb96f8620d05d36b"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 593,
      "id": "MDExOlB1bGxSZXF1ZXN0NDcxODg1OTU3",
      "title": "Prefer percent-encoding all special characters.",
      "url": "https://github.com/WICG/webpackage/pull/593",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "The IETF meeting attendees seemed to prefer this. [Minutes](https://datatracker.ietf.org/doc/minutes-108-wpack/), [Video](https://youtu.be/Hezs0oifBbc?t=298)",
      "createdAt": "2020-08-21T22:50:40Z",
      "updatedAt": "2020-08-26T17:30:52Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2ab2cca9b8e211c6dff98ef3ebc4c694d7927446",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "percent-escape-urls",
      "headRefOid": "dfcd0c746a2688c504e1f8304759bcc1da77b702",
      "closedAt": "2020-08-26T17:30:48Z",
      "mergedAt": "2020-08-26T17:30:48Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "73b551236f4e7a62476b54a155d2fc270777c852"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 598,
      "id": "MDExOlB1bGxSZXF1ZXN0NDg0MjA0MDQy",
      "title": "Use the header-integrity of the first matching allowed-alt-sxg link.",
      "url": "https://github.com/WICG/webpackage/pull/598",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Instead of the last.\n\nBased on https://github.com/WICG/webpackage/pull/591#discussion_r484225955, I believe this more accurately describes the implemented behavior.\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/598.html\" title=\"Last updated on Sep 10, 2020, 6:44 PM UTC (12ea1bd)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/598/bfd1640...jyasskin:12ea1bd.html\" title=\"Last updated on Sep 10, 2020, 6:44 PM UTC (12ea1bd)\">Diff</a>",
      "createdAt": "2020-09-10T18:43:54Z",
      "updatedAt": "2020-09-11T17:47:11Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "bfd16402098add7dd5b39e99f7baac1d15407f73",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "fix-multiple-allowed-alt-sxg",
      "headRefOid": "12ea1bd89915cb1303b395bed4bd47007856a2eb",
      "closedAt": "2020-09-11T17:47:08Z",
      "mergedAt": "2020-09-11T17:47:08Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "ec0871e80e7822434841df8a3c048fe9e8af999b"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NDg2MzkyODk0",
          "commit": {
            "abbreviatedOid": "12ea1bd"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\nThank you!",
          "createdAt": "2020-09-11T00:15:57Z",
          "updatedAt": "2020-09-11T00:15:57Z",
          "comments": []
        }
      ]
    },
    {
      "number": 601,
      "id": "MDExOlB1bGxSZXF1ZXN0NDk1OTEyOTU5",
      "title": "Prefer \"resources\"-based approach",
      "url": "https://github.com/WICG/webpackage/pull/601",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update the subresource loading explainer. The two major functional\r\nchanges are:\r\n\r\n- Prefer a \"resources\"-based approach to a \"scope\"-based approach.\r\n  A \"scope\"-based approach is now under the alternative design\r\n  section.\r\n- Subresources are only loaded from the bundle if either:\r\n  - a subresource's origin is the same origin as the bundle's origin, or\r\n  - a subresource's URL is urn:uuid URL.\r\n\r\nAlso update the other parts accordingly, such as updating examples.",
      "createdAt": "2020-10-01T02:55:41Z",
      "updatedAt": "2020-10-06T00:07:22Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "ec0871e80e7822434841df8a3c048fe9e8af999b",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "prefer-resources",
      "headRefOid": "0dac16659a06af065ea7f35a53202ac7575b3d35",
      "closedAt": "2020-10-06T00:06:05Z",
      "mergedAt": "2020-10-06T00:06:05Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "44c3437db2d89af300b655f0d3efca52410a2ff3"
      },
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin @yoavweiss \r\nCould you review the PR?\r\nI've updated the explainer, as a preparation for an origin trial.",
          "createdAt": "2020-10-01T03:04:05Z",
          "updatedAt": "2020-10-01T03:04:05Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin  Thanks for the review!\r\n\r\nI've applied the suggestions, and updated the PR.\r\nRegarding a security consideration section, let me try to make another PR.",
          "createdAt": "2020-10-02T03:55:13Z",
          "updatedAt": "2020-10-02T03:55:51Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin \r\nCould you merge the PR if it is okay?\r\n",
          "createdAt": "2020-10-05T23:49:05Z",
          "updatedAt": "2020-10-05T23:49:05Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "I became a member of this repository, so let me merge this! Thanks!",
          "createdAt": "2020-10-06T00:05:47Z",
          "updatedAt": "2020-10-06T00:05:47Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Yep, I hadn't realized you didn't yet have write access.",
          "createdAt": "2020-10-06T00:07:22Z",
          "updatedAt": "2020-10-06T00:07:22Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwNTQ1NTky",
          "commit": {
            "abbreviatedOid": "4b8db57"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Looks good after several changes below. Thanks!",
          "createdAt": "2020-10-01T16:58:37Z",
          "updatedAt": "2020-10-01T17:26:35Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "Indent these so they appear inside step 4, since they're commentary on that step.",
              "createdAt": "2020-10-01T16:58:37Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            },
            {
              "originalPosition": 68,
              "body": "```suggestion\r\n   - a subresource's origin is the [same origin](https://html.spec.whatwg.org/#same-origin)\r\n     as the bundle's origin and its [path](https://url.spec.whatwg.org/#concept-url-path) contains the bundle's path as a prefix, or\r\n```",
              "createdAt": "2020-10-01T17:11:40Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            },
            {
              "originalPosition": 69,
              "body": "We should say something about whether the the bundle subresources are entered into the HTTP cache. I think it's moderately important that we not put the `urn:uuid` resources into the cache, to prevent it from being a problem if a site re-uses those UUIDs. The origin+path restriction makes it fairly safe to cache the `https:` subresources, but we also don't want to be causing extra IPCs to fetch those from the cache. This interacts with the \"Subsequent loading and Caching\" section and might belong there.\r\n\r\nA note about this would also make a good start for a security considerations section.",
              "createdAt": "2020-10-01T17:13:58Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            },
            {
              "originalPosition": 126,
              "body": "We wouldn't write `\\`s in the HTML source:\r\n```suggestion\r\n  resources=\"https://example.com/dir/a.js\r\n             https://example.com/dir/b.js\r\n             https://example.com/dir/c.png\r\n```",
              "createdAt": "2020-10-01T17:16:55Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            },
            {
              "originalPosition": 69,
              "body": "```suggestion\r\n   - a subresource's URL is a [`urn:uuid:`](https://tools.ietf.org/html/rfc4122) URL.\r\n```",
              "createdAt": "2020-10-01T17:24:21Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            },
            {
              "originalPosition": 187,
              "body": "```suggestion\r\n### Summarizing the contents of the bundle\r\n\r\nSeveral other mechanisms are available to give the bundler more flexibility or to compress the resource list.\r\n```\r\n\r\nAnd then keep the subsections about this nested with `####`.",
              "createdAt": "2020-10-01T17:24:47Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODQ1NjAy",
          "commit": {
            "abbreviatedOid": "4b8db57"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T03:44:14Z",
          "updatedAt": "2020-10-02T03:44:15Z",
          "comments": [
            {
              "originalPosition": 101,
              "body": "Thanks. Done.",
              "createdAt": "2020-10-02T03:44:15Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODQ1NzEz",
          "commit": {
            "abbreviatedOid": "4b8db57"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T03:44:44Z",
          "updatedAt": "2020-10-02T03:44:44Z",
          "comments": [
            {
              "originalPosition": 68,
              "body": "Thanks. Merged the change to the PR.",
              "createdAt": "2020-10-02T03:44:44Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODQ2MzU0",
          "commit": {
            "abbreviatedOid": "4b8db57"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T03:47:46Z",
          "updatedAt": "2020-10-02T03:47:46Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Thanks! Yes, it is a good idea to have a security consideration section in this explainer.\r\nLet me try to add a security consideration section as another PR.",
              "createdAt": "2020-10-02T03:47:46Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODQ2Mzk1",
          "commit": {
            "abbreviatedOid": "4b8db57"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T03:48:00Z",
          "updatedAt": "2020-10-02T03:48:00Z",
          "comments": [
            {
              "originalPosition": 126,
              "body": "Done.",
              "createdAt": "2020-10-02T03:48:00Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODQ2NDM1",
          "commit": {
            "abbreviatedOid": "4b8db57"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T03:48:13Z",
          "updatedAt": "2020-10-02T03:48:13Z",
          "comments": [
            {
              "originalPosition": 69,
              "body": "Done.",
              "createdAt": "2020-10-02T03:48:13Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTAwODQ2NjI2",
          "commit": {
            "abbreviatedOid": "4b8db57"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2020-10-02T03:49:06Z",
          "updatedAt": "2020-10-02T03:49:07Z",
          "comments": [
            {
              "originalPosition": 187,
              "body": "Done! Thanks!",
              "createdAt": "2020-10-02T03:49:07Z",
              "updatedAt": "2020-10-02T03:53:02Z"
            }
          ]
        }
      ]
    },
    {
      "number": 604,
      "id": "MDExOlB1bGxSZXF1ZXN0NTE1NjExNTE5",
      "title": "Update the bundle specification to be declarative instead of algorithmic",
      "url": "https://github.com/WICG/webpackage/pull/604",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "Also refine the semantic model to center on HTTP representations,\r\nupdate to the latest Variants spec, and\r\nremove the signatures section.\r\n\r\nI hope this makes it easier for the WPACK WG to think about the format and consider adopting the draft.\r\n\r\n[Preview](https://jyasskin.github.io/webpackage/update-bundle-spec/draft-yasskin-wpack-bundled-exchanges.html), [text diff](https://tools.ietf.org/rfcdiff?url1=https://jyasskin.github.io/webpackage/draft-yasskin-wpack-bundled-exchanges.txt&url2=https://jyasskin.github.io/webpackage/update-bundle-spec/draft-yasskin-wpack-bundled-exchanges.txt)",
      "createdAt": "2020-11-04T20:05:47Z",
      "updatedAt": "2020-11-25T23:55:59Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "2fa8c54b048f8f45aa65f95c1d07cef4462374d1",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-bundle-spec",
      "headRefOid": "143222c4db014474ecee72b95839da588815dc36",
      "closedAt": "2020-11-25T23:55:53Z",
      "mergedAt": "2020-11-25T23:55:53Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "826cadfa986bdb403bca2e149016459172f98144"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 607,
      "id": "MDExOlB1bGxSZXF1ZXN0NTMyMjUxODA5",
      "title": "go/signedexchange/README: Remove reference to allow-sxg-certs-without-extension flag",
      "url": "https://github.com/WICG/webpackage/pull/607",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "`chrome://flags/#allow-sxg-certs-without-extension` flag is [removed](https://crbug.com/862003) in Chrome M89.",
      "createdAt": "2020-12-04T03:07:25Z",
      "updatedAt": "2020-12-04T05:17:35Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "826cadfa986bdb403bca2e149016459172f98144",
      "headRepository": "irori/webpackage",
      "headRefName": "readme",
      "headRefOid": "b32f0de1d88a00c9cab5af03f3053fe5a43effdb",
      "closedAt": "2020-12-04T05:17:24Z",
      "mergedAt": "2020-12-04T05:17:24Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "a29dd77f79b1a837cbe2831852a6249d722fef98"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTQ0NjYzMDQw",
          "commit": {
            "abbreviatedOid": "b32f0de"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2020-12-04T05:17:02Z",
          "updatedAt": "2020-12-04T05:17:02Z",
          "comments": []
        }
      ]
    },
    {
      "number": 608,
      "id": "MDExOlB1bGxSZXF1ZXN0NTUzMjA5Mjk5",
      "title": "Introduce scopes attribute for subresource Web Bundles link.",
      "url": "https://github.com/WICG/webpackage/pull/608",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Currently the explainer of \"subresource loading with Web Bundles\" is\r\nusing a new \"scope\" attribute of the link element. However the new\r\nattribute should be \"scopes\" that accept multiple scopes, giving web\r\ndevelopers more flexibility. For example, in this case, some dynamic\r\ncontents can be under \"https://example.com/dir/api/\".\r\n\r\nSo this PR changes the explainer to use \"scopes\".",
      "createdAt": "2021-01-12T05:57:31Z",
      "updatedAt": "2021-02-09T23:55:47Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "a29dd77f79b1a837cbe2831852a6249d722fef98",
      "headRepository": "horo-t/webpackage",
      "headRefName": "linkscopes",
      "headRefOid": "5d40e1bbd1cfcca286d0a36fe882e9a09573f025",
      "closedAt": "2021-01-12T06:07:35Z",
      "mergedAt": "2021-01-12T06:07:35Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "4c8ee9a5db881490cd1108a04570ec00e524f89b"
      },
      "comments": [
        {
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Do you have any more context on the use cases for `scopes`?",
          "createdAt": "2021-02-09T15:47:07Z",
          "updatedAt": "2021-02-09T15:47:07Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "`scopes` attribute is useful when the writer of HTML don't know the all dependent subresources (eg: `import` of JS, @import of CSS, images referred by CSS).",
          "createdAt": "2021-02-09T23:55:47Z",
          "updatedAt": "2021-02-09T23:55:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTY1OTYxNjQz",
          "commit": {
            "abbreviatedOid": "5d40e1b"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks! I think `scopes` would be an improvement.",
          "createdAt": "2021-01-12T06:07:16Z",
          "updatedAt": "2021-01-12T06:07:16Z",
          "comments": []
        }
      ]
    },
    {
      "number": 610,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYyMDA2NjQ3",
      "title": "Write an index to the explainers.",
      "url": "https://github.com/WICG/webpackage/pull/610",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "@philipwalton @khempenius, do you think this makes it easy enough to find the explainers?",
      "createdAt": "2021-01-26T19:29:53Z",
      "updatedAt": "2021-02-02T20:16:02Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "e4a3f1ccd86aaac7aa6298a7163822b8810a0ddf",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "update-explainer",
      "headRefOid": "4150974417d9b9afdb62ba0362df1fc5d6ff150f",
      "closedAt": "2021-02-02T20:15:58Z",
      "mergedAt": "2021-02-02T20:15:58Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "6a24231dd13ad3b38a14f7372daba43f6e57268e"
      },
      "comments": [
        {
          "author": "philipwalton",
          "authorAssociation": "NONE",
          "body": "Thanks, this is definitely helpful. One question: what are your thoughts on putting all the content of the explainers.md page (since it's not a lot) into the main README? That might make it even easier to find for folks just driving by.",
          "createdAt": "2021-01-29T22:35:16Z",
          "updatedAt": "2021-01-29T22:35:16Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "@philipwalton Good idea; how's this?",
          "createdAt": "2021-02-01T22:50:27Z",
          "updatedAt": "2021-02-01T22:50:27Z"
        },
        {
          "author": "philipwalton",
          "authorAssociation": "NONE",
          "body": "Looks great, thanks!",
          "createdAt": "2021-02-02T19:50:47Z",
          "updatedAt": "2021-02-02T19:50:47Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3MzI0MzU1",
          "commit": {
            "abbreviatedOid": "c1c6f71"
          },
          "author": "yoavweiss",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM",
          "createdAt": "2021-01-27T13:18:24Z",
          "updatedAt": "2021-01-27T13:18:24Z",
          "comments": []
        }
      ]
    },
    {
      "number": 611,
      "id": "MDExOlB1bGxSZXF1ZXN0NTYyMTk2MzM0",
      "title": "dump-signedexchange: add -headerIntegrity flag",
      "url": "https://github.com/WICG/webpackage/pull/611",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "When specified, only prints the header-integrity value for the given signed\r\nexchange, as needed for subresource substitution.",
      "createdAt": "2021-01-27T03:19:08Z",
      "updatedAt": "2021-01-27T18:13:21Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "4c8ee9a5db881490cd1108a04570ec00e524f89b",
      "headRepository": "twifkak/webpackage",
      "headRefName": "header_integrity",
      "headRefOid": "0ae512b062a047634ece56160728685560129576",
      "closedAt": "2021-01-27T18:13:15Z",
      "mergedAt": "2021-01-27T18:13:15Z",
      "mergedBy": "twifkak",
      "mergeCommit": {
        "oid": "e4a3f1ccd86aaac7aa6298a7163822b8810a0ddf"
      },
      "comments": [
        {
          "author": "twifkak",
          "authorAssociation": "COLLABORATOR",
          "body": "@horo-t Can you mark this PR as non-normative (per the ipr check), or do you know who can?",
          "createdAt": "2021-01-27T03:21:03Z",
          "updatedAt": "2021-01-27T03:21:03Z"
        },
        {
          "author": "w3cbot",
          "authorAssociation": "NONE",
          "body": "[horo-t](https://github.com/horo-t) marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2021-01-27T12:44:57Z",
          "updatedAt": "2021-01-27T12:44:57Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTc3Mjk3ODI2",
          "commit": {
            "abbreviatedOid": "0ae512b"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\nThank you.",
          "createdAt": "2021-01-27T12:46:23Z",
          "updatedAt": "2021-01-27T12:46:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 615,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY3NzM2OTIy",
      "title": "Fix links to explainers",
      "url": "https://github.com/WICG/webpackage/pull/615",
      "state": "MERGED",
      "author": "littledan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-04T16:00:45Z",
      "updatedAt": "2021-02-04T18:05:27Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "master",
      "baseRefOid": "6a24231dd13ad3b38a14f7372daba43f6e57268e",
      "headRepository": "littledan/webpackage",
      "headRefName": "patch-1",
      "headRefOid": "9848bcab767c16a15706b2b4cc2bb8ecb6fe8ce3",
      "closedAt": "2021-02-04T18:05:27Z",
      "mergedAt": "2021-02-04T18:05:26Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "84bb2d27ff8e67243230e4f487dfe300bf1b6dae"
      },
      "comments": [
        {
          "author": "w3cbot",
          "authorAssociation": "NONE",
          "body": "[jyasskin](https://github.com/jyasskin) marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2021-02-04T18:04:21Z",
          "updatedAt": "2021-02-04T18:04:21Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTgzNjcxNDUx",
          "commit": {
            "abbreviatedOid": "9848bca"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Whoops, thanks!",
          "createdAt": "2021-02-04T18:03:07Z",
          "updatedAt": "2021-02-04T18:03:07Z",
          "comments": []
        }
      ]
    },
    {
      "number": 617,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY5NzU0NTYy",
      "title": "Separating the primary URL into a section",
      "url": "https://github.com/WICG/webpackage/pull/617",
      "state": "OPEN",
      "author": "littledan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "Closes #616",
      "createdAt": "2021-02-08T20:15:11Z",
      "updatedAt": "2021-02-17T00:19:09Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "littledan/webpackage",
      "headRefName": "patch-2",
      "headRefOid": "1f8f113dedbe5367b6b41baf76c3e51dd5af9aa4",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "This is just an idea to open for discussion. The idea here is to make the primary URL more thoroughly optional by moving it into a separate section. The main semantic difference here is that the primary URL can no longer server as a fallback (e.g., in case the magic number is wrong)--it's a bit questionable how/when this fallback would be useful, and the identification of this fallback is a bit out of step with other changes to this document which made it less operationally defined.",
          "createdAt": "2021-02-08T20:23:39Z",
          "updatedAt": "2021-02-08T20:23:39Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 618,
      "id": "MDExOlB1bGxSZXF1ZXN0NTY5Nzc0NzAx",
      "title": "Remove content negotiation",
      "url": "https://github.com/WICG/webpackage/pull/618",
      "state": "OPEN",
      "author": "littledan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "As proposed in #612\r\n\r\nThis is just to be a concrete reference point for discussion.",
      "createdAt": "2021-02-08T20:32:25Z",
      "updatedAt": "2021-02-17T00:19:10Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "littledan/webpackage",
      "headRefName": "patch-3",
      "headRefOid": "0faa6a35a194eb4dd0f6447c05e47faa525e6eec",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [],
      "reviews": []
    },
    {
      "number": 619,
      "id": "MDExOlB1bGxSZXF1ZXN0NTcwNjQwMDAy",
      "title": "Remove the manifest and critical sections",
      "url": "https://github.com/WICG/webpackage/pull/619",
      "state": "OPEN",
      "author": "littledan",
      "authorAssociation": "CONTRIBUTOR",
      "assignees": [],
      "labels": [
        "discuss"
      ],
      "body": "The idea of this PR is that the \"core\" Web Bundles specification does not include the manifest or critical sections, but that these sections can be defined in other documents. The motivation is to factor the Web Bundles specification to include just the minimal amount needed to support cases like subresource loading. Subresource loading does not need a manifest. For the critical section, if it is missing, the behavior is likely to be to not require any sections, so it can also be defined and interpreted just where it is needed for more detailed bundle types.",
      "createdAt": "2021-02-09T21:49:02Z",
      "updatedAt": "2021-02-17T00:19:10Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "littledan/webpackage",
      "headRefName": "patch-4",
      "headRefOid": "f9894c33f4d8f746e9db8b3f844bcf7c8c9e1b6a",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "I'm friendly to the idea of pulling `\"manifest\"` out to an extension document, like we're doing for `\"signatures\"`.\r\n\r\nI feel like `\"critical\"` needs to be in the core spec in order to be worth having at all, since its purpose is to be able to get all implementations to reject a bundle with a section they don't understand. It's possible we could replace the `\"critical\"` section entirely with your idea around defining an HTTP header to negotiate it, but we should make sure that's likely to work before deciding to get rid of the `\"critical\"` section.",
          "createdAt": "2021-02-09T22:41:08Z",
          "updatedAt": "2021-02-09T22:41:08Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "Yeah, maybe this should've been two separate PRs. I don't fully understand the full story around the \"critical\" section, and don't feel strongly that it needs to be removed; \"discuss\" seems like an appropriate label.",
          "createdAt": "2021-02-09T22:49:35Z",
          "updatedAt": "2021-02-09T22:49:35Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 622,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc0MDAwOTg2",
      "title": "Clarify how request's mode and credentials mode are set (#609)",
      "url": "https://github.com/WICG/webpackage/pull/622",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Add a section which explains how request's mode and credentials mode\r\nare set with `<link>`-based API.",
      "createdAt": "2021-02-16T07:53:56Z",
      "updatedAt": "2021-02-19T00:34:13Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "cors",
      "headRefOid": "05f3214ee9e8279d340839cdf61ea41f2f033401",
      "closedAt": "2021-02-19T00:34:13Z",
      "mergedAt": "2021-02-19T00:34:13Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "653918ffd185515ca08c243715ba28c8c459cacc"
      },
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the review!",
          "createdAt": "2021-02-19T00:34:06Z",
          "updatedAt": "2021-02-19T00:34:06Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkxNzQyMzMz",
          "commit": {
            "abbreviatedOid": "b3643ee"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-17T00:38:51Z",
          "updatedAt": "2021-02-17T00:51:01Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\nWith the `<link>`-based API, a\r\n[request](https://fetch.spec.whatwg.org/#concept-request) for a bundle\r\nwill have its [mode][request mode] set to \"`no-cors`\" and its\r\n[credentials mode][credentials mode] set to \"`include`\" unless a\r\n[crossorigin][crossorigin attribute] attribute is specified.\r\n```",
              "createdAt": "2021-02-17T00:38:51Z",
              "updatedAt": "2021-02-18T05:50:21Z"
            },
            {
              "originalPosition": 21,
              "body": "```suggestion\r\nthe request's [mode][request mode] and [credentials mode][credentials mode]\r\n```",
              "createdAt": "2021-02-17T00:45:47Z",
              "updatedAt": "2021-02-18T05:50:21Z"
            },
            {
              "originalPosition": 29,
              "body": "Can we follow the [\"For more modern features\"](https://html.spec.whatwg.org/multipage/urls-and-fetching.html#cors-settings-attributes:~:text=For%20more%20modern%20features) policy, and always use CORS for bundle fetching?",
              "createdAt": "2021-02-17T00:50:46Z",
              "updatedAt": "2021-02-18T05:50:21Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyODcxMzI3",
          "commit": {
            "abbreviatedOid": "05f3214"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T05:51:50Z",
          "updatedAt": "2021-02-18T05:51:50Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "Done. Thanks!",
              "createdAt": "2021-02-18T05:51:50Z",
              "updatedAt": "2021-02-18T05:51:50Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyODcxNTcz",
          "commit": {
            "abbreviatedOid": "05f3214"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T05:52:31Z",
          "updatedAt": "2021-02-18T05:52:31Z",
          "comments": [
            {
              "originalPosition": 21,
              "body": "Done. Thanks!",
              "createdAt": "2021-02-18T05:52:31Z",
              "updatedAt": "2021-02-18T05:52:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkyODczNDk0",
          "commit": {
            "abbreviatedOid": "05f3214"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-02-18T05:57:30Z",
          "updatedAt": "2021-02-18T05:57:30Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "As per the separate discussion, we've decided to follow \"For more modern features\" policy.\r\n\r\nNow we use \"cors\" always, and use \"same-origin\" for a credentials mode if `crossorigin`attribute is not given.",
              "createdAt": "2021-02-18T05:57:30Z",
              "updatedAt": "2021-02-18T05:57:30Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTkzNzIwMDc0",
          "commit": {
            "abbreviatedOid": "b3643ee"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-18T22:53:40Z",
          "updatedAt": "2021-02-18T22:53:46Z",
          "comments": [
            {
              "originalPosition": 29,
              "body": "Thanks! And sorry for forgetting why we had `no-cors` in the first place. ",
              "createdAt": "2021-02-18T22:53:40Z",
              "updatedAt": "2021-02-18T22:53:46Z"
            }
          ]
        }
      ]
    },
    {
      "number": 625,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc0NTU3ODYw",
      "title": "Rename references to master branch",
      "url": "https://github.com/WICG/webpackage/pull/625",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "It's been renamed to \"main\".",
      "createdAt": "2021-02-17T00:25:41Z",
      "updatedAt": "2021-02-17T23:57:44Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "81751e89e521667efc4da0cd0f0249efe20d737e",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "rename-master-to-main",
      "headRefOid": "6cc837fb6c55ff37135b985f2ffedcb51e0256b5",
      "closedAt": "2021-02-17T23:57:41Z",
      "mergedAt": "2021-02-17T23:57:41Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "eb2e40273364ccbf54035f8a1af66df993c5ba86"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 626,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc2MTc3OTM5",
      "title": "Set a request's destination to \"webbundle\"",
      "url": "https://github.com/WICG/webpackage/pull/626",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a sort of a monky patch until the upstream issue,\r\nhttps://github.com/whatwg/fetch/issues/1120, is resolved.",
      "createdAt": "2021-02-19T04:57:42Z",
      "updatedAt": "2021-02-24T03:24:55Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "653918ffd185515ca08c243715ba28c8c459cacc",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "destination",
      "headRefOid": "c43dc8a6291f1e289f7cd4fe447035f32e2702bb",
      "closedAt": "2021-02-24T03:24:55Z",
      "mergedAt": "2021-02-24T03:24:55Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "2ca2c33626503f20448faad59d372d3bc6bc9e35"
      },
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "WPT is here. https://chromium-review.googlesource.com/c/chromium/src/+/2706327",
          "createdAt": "2021-02-22T03:06:16Z",
          "updatedAt": "2021-02-22T03:06:16Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk0NTE2MDEx",
          "commit": {
            "abbreviatedOid": "c43dc8a"
          },
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Making a new destination seems like a good idea to me, e.g., so that all of the content negotiation headers are sent.",
          "createdAt": "2021-02-19T19:53:12Z",
          "updatedAt": "2021-02-19T19:53:12Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk2MDA1Mzcz",
          "commit": {
            "abbreviatedOid": "c43dc8a"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-02-23T05:27:48Z",
          "updatedAt": "2021-02-23T05:27:48Z",
          "comments": []
        }
      ]
    },
    {
      "number": 627,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc3MjQxMDU2",
      "title": "Limit Subresource Web Bundles only in secure contexts",
      "url": "https://github.com/WICG/webpackage/pull/627",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-22T01:37:15Z",
      "updatedAt": "2021-02-25T01:33:28Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "653918ffd185515ca08c243715ba28c8c459cacc",
      "headRepository": "horo-t/webpackage",
      "headRefName": "require_secure_context",
      "headRefOid": "f3ae154164767ec7edaf07cce240c6d3becc56e7",
      "closedAt": "2021-02-25T01:33:28Z",
      "mergedAt": "2021-02-25T01:33:28Z",
      "mergedBy": "horo-t",
      "mergeCommit": {
        "oid": "aa2368a289dcbac514a0f948a0e067d39303794e"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1MjgzMjcz",
          "commit": {
            "abbreviatedOid": "f3ae154"
          },
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-02-22T12:09:01Z",
          "updatedAt": "2021-02-22T12:09:01Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk1ODUzNjYw",
          "commit": {
            "abbreviatedOid": "f3ae154"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "The canonical definition of \"secure context\" has moved to HTML (https://html.spec.whatwg.org/multipage/webappapis.html#secure-context), but the CR is still the explainer-level explanation, so no need to change this PR..",
          "createdAt": "2021-02-22T22:43:21Z",
          "updatedAt": "2021-02-22T22:43:21Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk4MDc5MTE1",
          "commit": {
            "abbreviatedOid": "f3ae154"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM.",
          "createdAt": "2021-02-25T01:23:23Z",
          "updatedAt": "2021-02-25T01:23:23Z",
          "comments": []
        }
      ]
    },
    {
      "number": 628,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc4ODQ3Njk3",
      "title": "Remove use of Request's synchronous flag.",
      "url": "https://github.com/WICG/webpackage/pull/628",
      "state": "MERGED",
      "author": "jyasskin",
      "authorAssociation": "MEMBER",
      "assignees": [],
      "labels": [],
      "body": "whatwg/fetch#1165 removed the flag.\n\nSince this algorithm runs the requests in parallel anyway, I think we never needed to set the synchronous flag?\n\n\n<!--\n    This comment and the below content is programatically generated.\n    You may add a comma-separated list of anchors you'd like a\n    direct link to below (e.g. #idl-serializers, #idl-sequence):\n\n    Don't remove this comment or modify anything below this line.\n    If you don't want a preview generated for this pull request,\n    just replace the whole of this comment's content by \"no preview\"\n    and remove what's below.\n-->\n***\n<a href=\"https://pr-preview.s3.amazonaws.com/jyasskin/webpackage/pull/628.html\" title=\"Last updated on Feb 24, 2021, 12:04 AM UTC (d9e967c)\">Preview</a> | <a href=\"https://pr-preview.s3.amazonaws.com/WICG/webpackage/628/d3e87eb...jyasskin:d9e967c.html\" title=\"Last updated on Feb 24, 2021, 12:04 AM UTC (d9e967c)\">Diff</a>",
      "createdAt": "2021-02-24T00:04:14Z",
      "updatedAt": "2021-02-25T01:27:28Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "d3e87eb16cc9cafb7fb4c5da4ac7f2df1296e4ad",
      "headRepository": "jyasskin/webpackage",
      "headRefName": "remove-synchronous-flag-use",
      "headRefOid": "d9e967c1f1d211e94727636a0ff1d69cbcb6dd09",
      "closedAt": "2021-02-25T01:27:28Z",
      "mergedAt": "2021-02-25T01:27:28Z",
      "mergedBy": "horo-t",
      "mergeCommit": {
        "oid": "dcc4e2773fd1bf2635bf181bfe333a26152b8f80"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NTk3MDM1NTAw",
          "commit": {
            "abbreviatedOid": "d9e967c"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm.\r\n\r\n(I don't remember why I set this flag...)",
          "createdAt": "2021-02-24T03:30:37Z",
          "updatedAt": "2021-02-24T03:30:37Z",
          "comments": []
        }
      ]
    },
    {
      "number": 629,
      "id": "MDExOlB1bGxSZXF1ZXN0NTc5Nzg0NDM4",
      "title": "Mentions about custom scheme handler",
      "url": "https://github.com/WICG/webpackage/pull/629",
      "state": "MERGED",
      "author": "horo-t",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-02-25T03:54:24Z",
      "updatedAt": "2021-03-17T01:38:25Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "aa2368a289dcbac514a0f948a0e067d39303794e",
      "headRepository": "horo-t/webpackage",
      "headRefName": "protocolHandler",
      "headRefOid": "18bc500069b7b09d4bc8076250dc061de5ca60f4",
      "closedAt": "2021-03-17T01:38:25Z",
      "mergedAt": "2021-03-17T01:38:25Z",
      "mergedBy": "horo-t",
      "mergeCommit": {
        "oid": "5d5b5dd7fab38940df920569642c7164d48228a8"
      },
      "comments": [
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin\r\nCould you please review this PR?",
          "createdAt": "2021-02-25T03:54:44Z",
          "updatedAt": "2021-02-25T03:54:44Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "I understand your concerns. We may need to introduce a new scheme, at least before shipping this feature, so as not to violate the existing scheme. However, since the browser changes its behavior only when the `<link rel = webbundle>` element is inserted, I think it's okay to start the Origin Trial with the current behavior. What do you think? @jyasskin @hayatoito  ",
          "createdAt": "2021-03-04T03:13:22Z",
          "updatedAt": "2021-03-04T03:13:22Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Hmm. Let me confirm an expected behavior at first, if UA doesn't ignore a custom handler, so that I can understand the problem correctly.\r\n\r\nIf the user had visited a site at https://example.com/ that made the following call:\r\n\r\n```\r\nnavigator.registerProtocolHandler('urn', 'soup?url=%s')\r\n```\r\n\r\n...and then, much later, visit https://www.example.net/, which has a ```<link rel=webundle href=\"..bundle\" ..>``` element, and\r\nthe bundle has `urn:uuid:aaaaa` content, and the page also has `<iframe src=\"urn:uuid:aaaaa\"></iframe>`\r\n\r\n, then the UA might make iframe navigate to the following URL:\r\n\r\nhttps://example.com/soup?url=urn:uuid:aaaaa\r\n\r\nas if the page, https://www.example.net/, had `<iframe src=\"https://example.com/soup?url=urn:uuid:aaaaa\"></iframe>`.\r\n\r\nIs this an expected behavior, according to the current spec?\r\n",
          "createdAt": "2021-03-04T03:38:57Z",
          "updatedAt": "2021-03-04T03:40:33Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Yes. But it was unclear whether the browser should load the \"https://example.com/soup?url=urn:uuid:aaaaa\" from the web bundle or from the server.\r\n\r\nChrome before https://crrev.com/c/2717122 failed to load the \"https://example.com/soup?url=urn:uuid:aaaaa\" from the web bundle, and failed because the web bundle does not have such content.\r\nAfter https://crrev.com/c/2717122, Chrome loads \"urn:uuid:aaaaa\" from the web bundle.",
          "createdAt": "2021-03-04T03:57:54Z",
          "updatedAt": "2021-03-04T03:57:54Z"
        },
        {
          "author": "domenic",
          "authorAssociation": "NONE",
          "body": "I'm still a little lost.\r\n\r\n> Is this an expected behavior, according to the current spec?\r\n\r\nYes.\r\n\r\n> Yes. But it was unclear whether the browser should load the \"https://example.com/soup?url=urn:uuid:aaaaa\" from the web bundle or from the server.\r\n\r\nLoading it from the web bundle seems reasonable, as long as the web bundle contains a mapping for `https://example.com/soup?url=urn:uuid:aaaaa`.\r\n\r\nHowever, I'm not sure I understand the need for the patch. The patch, with or without Jeffrey's suggestion, seems to imply that registered protocol handlers get bypassed in some way. Why would we bypass them?\r\n\r\nTo implement loading `https://example.com/soup?url=urn:uuid:aaaaa` from the web bundle, I'd assume that the same fetch interception which makes any navigation to `https://example.com/soup?url=urn:uuid:aaaaa` go through a web bundle, would also work after the registerProtocolHandler. Note how [the spec](https://html.spec.whatwg.org/#dom-navigator-registerprotocolhandler) does the URL translation before ever calling navigate (and I assume it's navigate, or perhaps fetch which is called by navigate, which starts loading things from web bundles.)",
          "createdAt": "2021-03-04T19:12:26Z",
          "updatedAt": "2021-03-04T19:12:26Z"
        },
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "Re https://github.com/WICG/webpackage/pull/629#issuecomment-790254524, I think it's ok to start the origin trial using `urn:uuid:` and then change it to be more specific later. We're trying to get developer feedback on the whole thing, and that piece being wrong isn't likely to invalidate any of the feedback or break guarantees.\r\n\r\nRe @domenic's https://github.com/WICG/webpackage/pull/629#issuecomment-790860454, since it seems like everyone's happy with moving away from `urn:uuid:` to a scheme that isn't [safelisted](https://html.spec.whatwg.org/#safelisted-scheme), we don't really need this PR. I think the PR is acceptable because the call sites for [process a navigate URL scheme](https://html.spec.whatwg.org/multipage/browsing-the-web.html#process-a-navigate-url-scheme) always prioritize fetchable URLs over registerProtocolHander-registered handlers, so prioritizing something we know how to fetch (because it's in a bundle) seems reasonable even if it has a registerable scheme. But on the other hand, the data flow look like it'll become weird, so if we don't *need* to do it, we probably shouldn't.",
          "createdAt": "2021-03-05T00:47:20Z",
          "updatedAt": "2021-03-05T00:47:20Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "It seems complex than I expected. I'm not 100% confident how to interpret the current spec. However, this is an explainer, so maybe we don't need a normative one at this point.\r\n\r\nMy suggestions are:\r\n1. Merge a PR so that we can clarify that UA must load a resource from a bundle, bypassing any custom registered protocol handler.\r\n2. And, file a new issue to discuss moving away from \"urn:uuid:\".\r\n\r\nWDYT?\r\n",
          "createdAt": "2021-03-05T03:25:19Z",
          "updatedAt": "2021-03-05T03:25:19Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyNTA0Mjc0",
          "commit": {
            "abbreviatedOid": "d7d6af6"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "LGTM with a nit.",
          "createdAt": "2021-03-03T04:43:47Z",
          "updatedAt": "2021-03-03T04:45:21Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Nit; Could we replace \"should\" with \"must\"?\r\n(This is an explainer, so this is not an issue, however, \"must\" may be better for this case, IMO)",
              "createdAt": "2021-03-03T04:43:47Z",
              "updatedAt": "2021-03-05T07:35:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAyNTM3MjY1",
          "commit": {
            "abbreviatedOid": "4edd960"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-03T06:00:11Z",
          "updatedAt": "2021-03-03T06:00:11Z",
          "comments": [
            {
              "originalPosition": 6,
              "body": "Done",
              "createdAt": "2021-03-03T06:00:11Z",
              "updatedAt": "2021-03-05T07:35:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzMzA2MDY2",
          "commit": {
            "abbreviatedOid": "4edd960"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "This makes me really nervous. `urn:` is treated as a scheme on the web platform layer, but it actually accepts a whole universe of subschemes, each of which needs to be treated differently. IIRC we hit the same thing in CORS handling, where we'd like to define how to treat `urn:uuid:`, but we had to define a uniform behavior across all `urn:`s.\r\n\r\nI checked in with @domenic who suggested we define a new top-level scheme for this, e.g. `packageuuid:` or `uuid-in-package:`.",
          "createdAt": "2021-03-03T20:15:15Z",
          "updatedAt": "2021-03-03T20:15:15Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNjg2MjA4",
          "commit": {
            "abbreviatedOid": "4edd960"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-04T04:05:53Z",
          "updatedAt": "2021-03-04T04:06:00Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "How about not mentioning \"urn\" scheme here? I think it is redundant.\r\nCan we simply say, for example, \"The browser must ignore any custom registered protocol handler in loading a resource from a bundle\"?",
              "createdAt": "2021-03-04T04:05:53Z",
              "updatedAt": "2021-03-05T07:35:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNjg4NDgx",
          "commit": {
            "abbreviatedOid": "4edd960"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-04T04:13:26Z",
          "updatedAt": "2021-03-04T04:13:26Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "I'm not sure whether it is a good idea or not to ignore a custom registered protocol handler in loading a subresource from a bundle. That needs a discussion, however, it seems much *safer* to ignore any custom registered protocol handler until we have a consensus.",
              "createdAt": "2021-03-04T04:13:26Z",
              "updatedAt": "2021-03-05T07:35:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjAzNjg4OTU5",
          "commit": {
            "abbreviatedOid": "4edd960"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-04T04:14:59Z",
          "updatedAt": "2021-03-04T04:14:59Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Done",
              "createdAt": "2021-03-04T04:14:59Z",
              "updatedAt": "2021-03-05T07:35:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA0NDI2MDcy",
          "commit": {
            "abbreviatedOid": "6dbce16"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-04T18:34:45Z",
          "updatedAt": "2021-03-04T18:37:20Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "This is much more comfortable; thanks @hayatoito. Custom protocol handlers are always used from https://html.spec.whatwg.org/multipage/browsing-the-web.html#process-a-navigate-url-scheme, which looks like it's only called after filtering out \"fetch schemes\" (like `https:`). Since a URL in a bundle is fetchable, it makes sense to avoid checking custom protocol handlers. So ...\r\n\r\n```suggestion\r\nIf a URL is available from an attached bundle, the browser must retrieve it from the bundle, instead of using any [registered custom protocol handler](https://html.spec.whatwg.org/multipage/system-state.html#dom-navigator-registerprotocolhandler) for its scheme.\r\n```",
              "createdAt": "2021-03-04T18:34:45Z",
              "updatedAt": "2021-03-05T07:35:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA0NzA4Njgw",
          "commit": {
            "abbreviatedOid": "c46241d"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T00:58:59Z",
          "updatedAt": "2021-03-05T00:58:59Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done",
              "createdAt": "2021-03-05T00:58:59Z",
              "updatedAt": "2021-03-05T07:35:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA0ODM1MTc2",
          "commit": {
            "abbreviatedOid": "c46241d"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "That sounds right to me.",
          "createdAt": "2021-03-05T06:18:51Z",
          "updatedAt": "2021-03-05T06:19:01Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "```suggestion\r\nthe bundle, instead of using any [registered custom protocol handler](https://html.spec.whatwg.org/multipage/system-state.html#dom-navigator-registerprotocolhandler)\r\n```",
              "createdAt": "2021-03-05T06:18:51Z",
              "updatedAt": "2021-03-05T07:35:48Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA0ODcxMjc5",
          "commit": {
            "abbreviatedOid": "18bc500"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-05T07:36:04Z",
          "updatedAt": "2021-03-05T07:36:04Z",
          "comments": [
            {
              "originalPosition": 5,
              "body": "Done.\r\nThank you.",
              "createdAt": "2021-03-05T07:36:04Z",
              "updatedAt": "2021-03-05T07:36:04Z"
            }
          ]
        }
      ]
    },
    {
      "number": 631,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg1MjI5NDA1",
      "title": "Extract function to read exchange prologue only.",
      "url": "https://github.com/WICG/webpackage/pull/631",
      "state": "MERGED",
      "author": "twifkak",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Can be helpful for computing header-integrity, which doesn't rely on reading\r\nthe payload (because of Digest).",
      "createdAt": "2021-03-05T00:46:42Z",
      "updatedAt": "2021-03-05T01:39:08Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "aa2368a289dcbac514a0f948a0e067d39303794e",
      "headRepository": "twifkak/webpackage",
      "headRefName": "prologue",
      "headRefOid": "42515966786a02bd04b62b9716726ffc9461cd67",
      "closedAt": "2021-03-05T01:00:37Z",
      "mergedAt": "2021-03-05T01:00:37Z",
      "mergedBy": "irori",
      "mergeCommit": {
        "oid": "f96d8cb03c2b74f92ca2bfdcb040d2e5c5de9e0b"
      },
      "comments": [
        {
          "author": "w3cbot",
          "authorAssociation": "NONE",
          "body": "[irori](https://github.com/irori) marked as non substantive for IPR from ash-nazg.",
          "createdAt": "2021-03-05T00:59:38Z",
          "updatedAt": "2021-03-05T00:59:38Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA0NzA5MjEx",
          "commit": {
            "abbreviatedOid": "4251596"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-03-05T01:00:12Z",
          "updatedAt": "2021-03-05T01:00:12Z",
          "comments": []
        }
      ]
    },
    {
      "number": 633,
      "id": "MDExOlB1bGxSZXF1ZXN0NTg5MzIzMjYw",
      "title": "Mention the relationship to Resource Bundles (issue #630)",
      "url": "https://github.com/WICG/webpackage/pull/633",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "It'd be better to mention how this proposal and Resource Bundles are\r\nrelated briefly.\r\n\r\nWe'll add more details and update alternative designs with some of ideas\r\nfrom resource-bundles and others.",
      "createdAt": "2021-03-10T09:20:31Z",
      "updatedAt": "2021-03-15T06:42:15Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "f96d8cb03c2b74f92ca2bfdcb040d2e5c5de9e0b",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "resource-bundle",
      "headRefOid": "86f1c32fed0aac801d17fc17e81f5ca3f1b953d3",
      "closedAt": "2021-03-15T06:42:15Z",
      "mergedAt": "2021-03-15T06:42:15Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "d6afcefffcf7ebeadbe4372d6d5532bf90e0a050"
      },
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin Could you please review this?",
          "createdAt": "2021-03-12T05:31:27Z",
          "updatedAt": "2021-03-12T05:31:27Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA4NTAxOTc3",
          "commit": {
            "abbreviatedOid": "eec2baa"
          },
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "state": "APPROVED",
          "body": "Thanks!",
          "createdAt": "2021-03-10T09:32:28Z",
          "updatedAt": "2021-03-10T09:32:28Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEwOTc0MjE0",
          "commit": {
            "abbreviatedOid": "eec2baa"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-12T16:50:46Z",
          "updatedAt": "2021-03-12T16:51:30Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "Remember to update the table of contents. I use https://marketplace.visualstudio.com/items?itemName=AlanWalk.markdown-toc to do that automatically.",
              "createdAt": "2021-03-12T16:50:46Z",
              "updatedAt": "2021-03-15T06:38:54Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExODYzODk3",
          "commit": {
            "abbreviatedOid": "86f1c32"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-15T06:41:39Z",
          "updatedAt": "2021-03-15T06:41:40Z",
          "comments": [
            {
              "originalPosition": 4,
              "body": "A good point. I forgot it. Let me update the TOC, then merge this PR. Thanks!",
              "createdAt": "2021-03-15T06:41:39Z",
              "updatedAt": "2021-03-15T06:41:40Z"
            }
          ]
        }
      ]
    },
    {
      "number": 634,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkwNDE5MTM0",
      "title": "Document how CSP works for bundled resources",
      "url": "https://github.com/WICG/webpackage/pull/634",
      "state": "MERGED",
      "author": "irori",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "",
      "createdAt": "2021-03-11T02:48:59Z",
      "updatedAt": "2021-03-15T01:19:16Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "f96d8cb03c2b74f92ca2bfdcb040d2e5c5de9e0b",
      "headRepository": "irori/webpackage",
      "headRefName": "csp",
      "headRefOid": "8064231a579234f64ffacec186b11b38f8615813",
      "closedAt": "2021-03-15T01:19:09Z",
      "mergedAt": "2021-03-15T01:19:09Z",
      "mergedBy": "irori",
      "mergeCommit": {
        "oid": "c848d49cc0035ad21d0aace865549567503272dc"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5MzU0OTg2",
          "commit": {
            "abbreviatedOid": "656b675"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Looks good to me. I am not familiar with CSP, however, this explanation is clear to me, and I got it.",
          "createdAt": "2021-03-11T02:54:08Z",
          "updatedAt": "2021-03-11T02:54:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjA5NzA4NjA0",
          "commit": {
            "abbreviatedOid": "656b675"
          },
          "author": "jeffkaufman",
          "authorAssociation": "NONE",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-11T12:31:17Z",
          "updatedAt": "2021-03-11T12:31:22Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Give an example of how a `urn:uuid:` script is blocked?",
              "createdAt": "2021-03-11T12:31:17Z",
              "updatedAt": "2021-03-12T00:57:42Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEwMzY4Mjgw",
          "commit": {
            "abbreviatedOid": "8064231"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-12T01:00:07Z",
          "updatedAt": "2021-03-12T01:00:07Z",
          "comments": [
            {
              "originalPosition": 33,
              "body": "Updated the example to show that `*` does not allow a `urn:uuid:` resource.",
              "createdAt": "2021-03-12T01:00:07Z",
              "updatedAt": "2021-03-12T01:00:07Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEwODIzMDE4",
          "commit": {
            "abbreviatedOid": "8064231"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-12T14:14:50Z",
          "updatedAt": "2021-03-12T14:14:50Z",
          "comments": []
        }
      ]
    },
    {
      "number": 635,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkxMzY3NTMz",
      "title": "Add a strawperson proposal: Content Addressable Bundles",
      "url": "https://github.com/WICG/webpackage/pull/635",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This is a strawperson proposal at very early stage, aiming to load\r\nmultiple resources efficiently, using a Content-Addressable Bundle,\r\nwhich can link to other bundles.\r\n",
      "createdAt": "2021-03-12T04:45:37Z",
      "updatedAt": "2021-03-15T03:35:08Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "f96d8cb03c2b74f92ca2bfdcb040d2e5c5de9e0b",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "content-addressable-bundles",
      "headRefOid": "2cdc0e33e2e8fdf985b77cb3bc1a46c071a23a2f",
      "closedAt": "2021-03-12T06:08:54Z",
      "mergedAt": "2021-03-12T06:08:54Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "f5c59e252380098bd7590eb3eb7eaee2cb91a8d8"
      },
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "@jyasskin @irori @littledan \r\nAs I promised, I've written a strawperson proposal. Could you please quick check it?\r\nThis is just a starting point. So we don't need to discuss much in this PR, I guess.\r\nWe can discuss using our issue trackers or other places, after we merge this.\r\n\r\nI'll continue to update, refine, add more details! This is very early draft!",
          "createdAt": "2021-03-12T04:50:30Z",
          "updatedAt": "2021-03-12T04:50:30Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks! Let me merge this. Let me continue to update the proposal there.\r\nEarly feedback is always welcome!",
          "createdAt": "2021-03-12T06:08:43Z",
          "updatedAt": "2021-03-12T06:08:43Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "> Sorry, it is not clear for me what is the benefit of this proposal.\r\n> What is the difference between your proposal and just using two <link rel=webbundle>s?\r\n\r\nGood questions! This can be a good candidate for FAQ. I'll add FAQ.\r\n\r\nThis proposal strongly suggests that a bundle should be **self-contained** as much as possible; Every external dependencies, including their hash values, should be explicitly declared in the bundle for reproducibility.\r\n\r\nIn the example, `https://example.com/app/index.js.abcd.wbn` depends on the specific version of `date-util.js`, which is inside of  `https://cdn.example.com/date-util.js.f1f2.wbn`. Such a dependency, including its *hash*, should be explicitly declared in the bundle itself.\r\n\r\nIf the `index.js.abcd.wbn` doesn't declare the dependency to the specific version of `date-util.js`, there is no guarantee that  `index.js` can run without any version incompatible issues. That can beak anytime.\r\n\r\nOf course, `index.js` can hard-code the specific version of `data-util.js` such as `https://cdn.example.com/date-util.js@4.12` or something in its source file,:\r\n\r\n```\r\nimport * as date from \"https://cdn.example.com/date-util.js@4.12\";\r\n```\r\n\r\nHowever, this proposal suggests that this kind of hard-coding should be avoided, and such a dependency information should be specified outside of source code.\r\n\r\nI think this is an established pattern, and there are many similar pattern in other package management system or convention, such as node (package.json), Rust (Cargo.toml), deno (deps.ts).\r\n\r\nThis proposal also implies that only direct depencencies should be declared in a bundle (or in a page which uses `<link>`-based API). Indirect dependencies don't have to be declared.\r\n\r\nIn the example case, the main page doesn't depends on `date-util.js` directly, so the page doesn't have to declare it. \r\n\r\n",
          "createdAt": "2021-03-15T02:36:58Z",
          "updatedAt": "2021-03-15T02:36:58Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "Sorry I don\u2019t understand well.\r\n\r\n> In the example case, the main page doesn't depends on date-util.js directly, so the page doesn't have to declare it.\r\n\r\nSo, the https://cdn.example.com/date-util.js.f1f2.wbn can be removed from the example\u2019s link element\u2019s resources attribute?\r\nIf we do so, how can the browser know that the date-util.js can be loaded from the date-util.js.f1f2.wbn?\r\n",
          "createdAt": "2021-03-15T03:04:13Z",
          "updatedAt": "2021-03-15T03:04:13Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "> So, the https://cdn.example.com/date-util.js.f1f2.wbn can be removed from the example\u2019s link element\u2019s resources attribute?\r\n\r\nThat makes sense.  The page can declare only `index.js` in resources in the example case.\r\n\r\ne.g.\r\n```html\r\n<link rel=webbundle\r\n      href=https://example.com/app/index.js.abcd.wbn\r\n      resources=\"index.js\" >\r\n```\r\n\r\nLet me fix this. Thanks!",
          "createdAt": "2021-03-15T03:09:09Z",
          "updatedAt": "2021-03-15T03:09:09Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "> If we do so, how can the browser know that the date-util.js can be loaded from the date-util.js.f1f2.wbn?\r\n\r\nThe browser should do a similar step to 6, \"*parse the index section of the bundle and record a list of resource URLs*\", for `index.js.abcd.wbn` somewhere after 2 and before 4 (in *How to Load* section). Let me fix that!\r\n\r\n",
          "createdAt": "2021-03-15T03:14:39Z",
          "updatedAt": "2021-03-15T03:21:27Z"
        },
        {
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "body": "If my understanding is correct, the browser must defer all subresource requests after starting the web bundle fetch until the browser finishes parsing the web bundle.  Is my understanding correct?",
          "createdAt": "2021-03-15T03:24:25Z",
          "updatedAt": "2021-03-15T03:24:25Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "> If my understanding is correct, the browser must defer all subresource requests after starting the web bundle fetch until the browser finishes parsing the web bundle. Is my understanding correct?\r\n\r\nA good question. This proposal doesn't have an intention to defer all subresource requests. The browser must defer only subresources requests for resources which are explicitly specified in `resources` attribute (or resources listed in the index section of a bundle).\r\n\r\nFor example,  if the top page uses `foo.js` directly, without any forward declaration, such as:\r\n\r\n`<script type=\"module\" src=\"foo.js\" />`.\r\n\r\nThat should be probably considered as a configuration error. There is no guarantee from where `foo.js` is loaded because of race condition, as of now. The proposal doesn't define any formal semantics in this case yet. \r\n",
          "createdAt": "2021-03-15T03:34:43Z",
          "updatedAt": "2021-03-15T03:35:08Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEwNDczMjU1",
          "commit": {
            "abbreviatedOid": "2cdc0e3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "Merging this as-is and discuss on issue tracker sounds good to me.",
          "createdAt": "2021-03-12T06:04:34Z",
          "updatedAt": "2021-03-12T06:04:34Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNzc1NjM5",
          "commit": {
            "abbreviatedOid": "2cdc0e3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "Sorry, it is not clear for me what is the benefit of this proposal.\r\nWhat is the difference between your proposal and just using two `<link rel=webbundle>`s?\r\nExample: \r\n```html\r\n<link rel=webbundle\r\n      href=https://example.com/app/index.js.abcd.wbn\r\n      resources=\"index.js foo.js bar.js\" >\r\n<link rel=webbundle\r\n      href=https://cdn.example.com/date-util.js.f1f2.wbn\r\n      resources=\"https://cdn.example.com/date-util.js\" >\r\n```",
          "createdAt": "2021-03-15T01:52:34Z",
          "updatedAt": "2021-03-15T02:05:08Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "date-util.js.f1f2.wbn",
              "createdAt": "2021-03-15T01:52:34Z",
              "updatedAt": "2021-03-15T02:05:08Z"
            },
            {
              "originalPosition": 48,
              "body": "https://github.com/azukaru/progressive-fetching/blob/master/docs/dynamic-bundling/index.md",
              "createdAt": "2021-03-15T02:01:31Z",
              "updatedAt": "2021-03-15T02:05:08Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNzg3Njk2",
          "commit": {
            "abbreviatedOid": "2cdc0e3"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-15T02:37:36Z",
          "updatedAt": "2021-03-15T02:37:36Z",
          "comments": [
            {
              "originalPosition": 48,
              "body": "Thanks. Let me fix in another PR!",
              "createdAt": "2021-03-15T02:37:36Z",
              "updatedAt": "2021-03-15T02:37:36Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjExNzg3Nzgz",
          "commit": {
            "abbreviatedOid": "2cdc0e3"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-15T02:37:57Z",
          "updatedAt": "2021-03-15T02:37:57Z",
          "comments": [
            {
              "originalPosition": 238,
              "body": "Ops. Thanks! Let me fix it in another PR.",
              "createdAt": "2021-03-15T02:37:57Z",
              "updatedAt": "2021-03-15T02:37:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 636,
      "id": "MDExOlB1bGxSZXF1ZXN0NTkzNjE4OTQ4",
      "title": "Update content-addressable-bundles.md",
      "url": "https://github.com/WICG/webpackage/pull/636",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Address the comments of PR #625, fixing editorial errors\r\n- Introduce terminorogies: mutable bundles and immutable bundles\r\n- Add some FAQs",
      "createdAt": "2021-03-16T06:37:38Z",
      "updatedAt": "2021-03-17T07:29:26Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "d6afcefffcf7ebeadbe4372d6d5532bf90e0a050",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "content-addressable-bundles",
      "headRefOid": "6a8d4186b80e17cafc5f85e82a7169073c845dfb",
      "closedAt": "2021-03-16T06:56:13Z",
      "mergedAt": "2021-03-16T06:56:13Z",
      "mergedBy": "irori",
      "mergeCommit": {
        "oid": "80af68a43b9755a6f185cfc4be9a422ee4704891"
      },
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "@irori I've updated the explainer a bit. Could you please do quick check and merge this?\r\n\r\ncc: @littledan @jyasskin \r\n\r\nLet me work on updating this explainer this week. There are still many TODO items.",
          "createdAt": "2021-03-16T06:40:33Z",
          "updatedAt": "2021-03-16T06:40:33Z"
        },
        {
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "body": "Merged.",
          "createdAt": "2021-03-16T07:03:13Z",
          "updatedAt": "2021-03-16T07:03:13Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I'm a bit concerned that this protocol has too many round-trips in it. The nested bundles are discovered one by one, down the tree. I think it's important to load all bundle chunks ASAP, without multiple round trips, to avoid being a regression vs current loading techniques. We could do this by making a manifest of the bundle chunk tree structure available inline in the HTML on initial load, so the browser can immediately calculate what should be fetched. I previously wrote up a somewhat different version of this idea at https://gist.github.com/littledan/18a1bd6e14e4f0ddb305a2a051ced01e (this gist preserves the idea that the integrity hash and chunk ID are separated, but they could be unified as in your document).",
          "createdAt": "2021-03-16T21:51:31Z",
          "updatedAt": "2021-03-16T21:51:31Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the comment!\r\n\r\nA good question! A possible workaround as a user-land solution would be to declare indirect dependent bundles as well as direct dependencies.\r\n\r\nIn the example case, top page may declare:\r\n\r\n```html\r\n<link rel=webbundle\r\n      href=https://example.com/app/index.js.abcd.wbn\r\n      resources=\"index.js\" >\r\n<link rel=webundle href=https://cdn.example.com/date-util.js.f1f2.wbn>\r\n<link rel=webundle href=https://cdn.example.com/common-util.js.3b3b.wbn>\r\n```\r\nThen, this should guarantee that a browser prefetch every bundles in parallel, instead of on demand.\r\n\r\nThe 2nd and 3rd link elements are optional. They are declared to avoid a round trip.\r\n\r\nI'm about to add this to FAQ. Let me reflect this. Thanks!\r\n",
          "createdAt": "2021-03-17T03:10:51Z",
          "updatedAt": "2021-03-17T03:10:51Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "> https://gist.github.com/littledan/18a1bd6e14e4f0ddb305a2a051ced01e\r\n\r\nThanks for the link! I am afraid I didn't read this.  Let me read!\r\nYes, Merkle tree inspired me, and this link also mentioned Merkle tree. It looks I can learn many things from there.\r\n",
          "createdAt": "2021-03-17T03:39:17Z",
          "updatedAt": "2021-03-17T03:39:17Z"
        },
        {
          "author": "littledan",
          "authorAssociation": "CONTRIBUTOR",
          "body": "I like the idea of making the bundle itself self-contained and having these redundant inline elements as optional to avoid extra round-trips. There are some more fundamental reasons why dynamic bundling could be a win (which Yoav and Shubhie have written about before) but this is a pretty tricky topic and I am working on consolidating that information in one place to be easier to understand.",
          "createdAt": "2021-03-17T07:29:26Z",
          "updatedAt": "2021-03-17T07:29:26Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEyOTAxMDAz",
          "commit": {
            "abbreviatedOid": "6a8d418"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-16T06:55:44Z",
          "updatedAt": "2021-03-16T06:55:44Z",
          "comments": []
        }
      ]
    },
    {
      "number": 637,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk0MzkwNjI1",
      "title": "Update content-addressable-bundles.md",
      "url": "https://github.com/WICG/webpackage/pull/637",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Update Introduction, Goals, and Non-Goals section\r\n- Add FAQ: How to avoid round-trips\r\n- Minor editorial fixes",
      "createdAt": "2021-03-17T04:22:20Z",
      "updatedAt": "2021-03-17T04:36:34Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "5d5b5dd7fab38940df920569642c7164d48228a8",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "content-addressable-bundles",
      "headRefOid": "3f47169c1fdd1096b23d2cb4a243c8bdfb316f82",
      "closedAt": "2021-03-17T04:36:34Z",
      "mergedAt": "2021-03-17T04:36:34Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "3eec7b6a3d75c136f6c06dad8cf8c7720032236f"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEzOTEyMjMy",
          "commit": {
            "abbreviatedOid": "794a4b5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-03-17T04:30:15Z",
          "updatedAt": "2021-03-17T04:30:40Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "s/browwer/browser/",
              "createdAt": "2021-03-17T04:30:15Z",
              "updatedAt": "2021-03-17T04:34:13Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjEzOTEyODg2",
          "commit": {
            "abbreviatedOid": "794a4b5"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-17T04:32:16Z",
          "updatedAt": "2021-03-17T04:32:16Z",
          "comments": [
            {
              "originalPosition": 144,
              "body": "Ah, sorry for that. Thanks!\r\nLet me fix typo, and merge with a fix.",
              "createdAt": "2021-03-17T04:32:16Z",
              "updatedAt": "2021-03-17T04:34:13Z"
            }
          ]
        }
      ]
    },
    {
      "number": 639,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk0NTcyNTIx",
      "title": "Update content-addressable-bundles.md",
      "url": "https://github.com/WICG/webpackage/pull/639",
      "state": "OPEN",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "- Add a link to issue #638\r\n- Add \"URL integrity\" to Goal\r\n- Add \"Resource Batch Preloading\" to references",
      "createdAt": "2021-03-17T10:05:17Z",
      "updatedAt": "2021-03-23T05:16:57Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "3eec7b6a3d75c136f6c06dad8cf8c7720032236f",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "content-addressable-bundles",
      "headRefOid": "d6612876fac3f19e7335397b9201f6c5b7dd48ee",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "I've added a link to issue #638 so that a reader can know the position of this proposal, and find easily where they can give feedback.",
          "createdAt": "2021-03-17T10:06:39Z",
          "updatedAt": "2021-03-17T10:06:39Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "There are several commits in this PR. I'll do \"squash and merge\" so that this can be one commit.",
          "createdAt": "2021-03-18T09:41:03Z",
          "updatedAt": "2021-03-18T09:41:03Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE1MjM5MzE4",
          "commit": {
            "abbreviatedOid": "e21c434"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-18T11:06:21Z",
          "updatedAt": "2021-03-18T11:06:22Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "My understanding is:\r\n - Web developers should write multiple webbundle link elements in the HTML to fetch the webbundles in parallel if the loading performance is important.\r\n - This nested webbundle format should be used when lazy-loading is important, and the loading performance is not important.\r\n \r\nIs my understanding correct?\r\n\r\nIf so, I don't understand the motivation of browser developers of introducing a new cache mechanism to keep the dependency information. Could you please explain this?",
              "createdAt": "2021-03-18T11:06:21Z",
              "updatedAt": "2021-03-23T05:16:57Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjE2MDI3Nzc4",
          "commit": {
            "abbreviatedOid": "e21c434"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-03-19T03:04:54Z",
          "updatedAt": "2021-03-19T03:04:54Z",
          "comments": [
            {
              "originalPosition": 111,
              "body": "A good question!\r\n\r\nIt's fine for a browser to prefetch nested bundles even if a user doesn't request it explicitly.\r\n\r\n- If a user requests prefetch via `<link>` elements explicitly,  browser *should* prefetch it.\r\n- If a user doesn't request it via `<link>` elements, a browser doesn't have to prefetch it, but *may* prefetch it, enabling the content to load instantly if and when the user requests it.\r\n",
              "createdAt": "2021-03-19T03:04:54Z",
              "updatedAt": "2021-03-23T05:16:57Z"
            }
          ]
        }
      ]
    },
    {
      "number": 640,
      "id": "MDExOlB1bGxSZXF1ZXN0NTk4NTYyMzY2",
      "title": "Update subresource-loading.md #630",
      "url": "https://github.com/WICG/webpackage/pull/640",
      "state": "OPEN",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Clean up the Alternate designs section:\r\n\r\n- Remove Approximate Membership Query datastructure, which is\r\n  a bit obsolete. Resource Bundles would be a successor.\r\n- Some editorial fixes.",
      "createdAt": "2021-03-23T05:44:43Z",
      "updatedAt": "2021-03-23T21:48:58Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "3eec7b6a3d75c136f6c06dad8cf8c7720032236f",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "alternative",
      "headRefOid": "6d125a13d21681378e5802ca936f01863d82219e",
      "closedAt": null,
      "mergedAt": null,
      "mergedBy": null,
      "mergeCommit": null,
      "comments": [
        {
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "body": "We should keep the list of alternate designs in the explainer, as shown in https://w3ctag.github.io/explainers#considered-alternatives. When we decide to definitely not pursue a particular design, we should add the reason, rather than removing the design, so that future readers know whether to reopen that discussion.",
          "createdAt": "2021-03-23T21:48:58Z",
          "updatedAt": "2021-03-23T21:48:58Z"
        }
      ],
      "reviews": []
    },
    {
      "number": 643,
      "id": "MDExOlB1bGxSZXF1ZXN0NjAwNDE4NjUz",
      "title": "Add links to Web Bundles tools",
      "url": "https://github.com/WICG/webpackage/pull/643",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update README.md to mention several tools for Web Bundles.",
      "createdAt": "2021-03-25T04:34:10Z",
      "updatedAt": "2021-03-25T05:43:25Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "3eec7b6a3d75c136f6c06dad8cf8c7720032236f",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "tools",
      "headRefOid": "4f6449d86d0e49dd99f501a70409dc463b0d5131",
      "closedAt": "2021-03-25T05:43:25Z",
      "mergedAt": "2021-03-25T05:43:25Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "de6545e3c0c5d18183c01f627b9be0aaf9378e56"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwNzA0Mjg4",
          "commit": {
            "abbreviatedOid": "a3ff5f3"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\nThank you!",
          "createdAt": "2021-03-25T05:09:46Z",
          "updatedAt": "2021-03-25T05:09:46Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjIwNjk5OTA3",
          "commit": {
            "abbreviatedOid": "a3ff5f3"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm with one suggestion",
          "createdAt": "2021-03-25T05:07:02Z",
          "updatedAt": "2021-03-25T05:10:11Z",
          "comments": [
            {
              "originalPosition": 18,
              "body": "```suggestion\r\n- Plugin for bundlers (Experimental)\r\n```",
              "createdAt": "2021-03-25T05:07:02Z",
              "updatedAt": "2021-03-25T05:21:06Z"
            }
          ]
        }
      ]
    },
    {
      "number": 645,
      "id": "MDExOlB1bGxSZXF1ZXN0NjA3ODQ0MTEw",
      "title": "Split the subresource-loading explainer into the core part and the ex\u2026",
      "url": "https://github.com/WICG/webpackage/pull/645",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "\u2026tension part (#623 #641)\r\n\r\nThis is the almost mechanical *refactoring*, splitting the\r\nsubresource-loading explainer into the core part and the extension\r\npart. The related issues are #624 and #641.\r\n\r\nIn a follow-up PR, we might want to refine the core part so that we\r\ncan write extension parts more easily, such as having well-defined\r\nterminologies and hook points.",
      "createdAt": "2021-04-02T06:27:04Z",
      "updatedAt": "2021-04-07T06:12:41Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "de6545e3c0c5d18183c01f627b9be0aaf9378e56",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "split",
      "headRefOid": "674ffa5ff194c6de27b518b0eb03e19317d2948d",
      "closedAt": "2021-04-07T03:33:27Z",
      "mergedAt": "2021-04-07T03:33:27Z",
      "mergedBy": "hayatoito",
      "mergeCommit": {
        "oid": "4ec4d7d8c72deef2132e1bb51ddcff274e7b97ff"
      },
      "comments": [
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks for the reviews. I'll merge the PR in a day.\r\n\r\n@jyasskin If you have a chance to take a look, feel free to review this!",
          "createdAt": "2021-04-06T05:35:52Z",
          "updatedAt": "2021-04-06T05:35:52Z"
        },
        {
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "body": "cc: @littledan @jyasskin \r\nI've merged this PR, aiming to address #623 #641.\r\nThis is just a starting point!",
          "createdAt": "2021-04-07T06:12:41Z",
          "updatedAt": "2021-04-07T06:12:41Z"
        }
      ],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2ODUwMTM0",
          "commit": {
            "abbreviatedOid": "4334f0d"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-02T08:07:34Z",
          "updatedAt": "2021-04-02T08:16:44Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "```suggestion\r\n<link\r\n```",
              "createdAt": "2021-04-02T08:07:35Z",
              "updatedAt": "2021-04-02T09:18:31Z"
            },
            {
              "originalPosition": 65,
              "body": "> `scope` attribute can not be used to specify `urn:uuid` resources.\r\n\r\n- `scope` -> `scopes`\r\n- This does not match the behavior of current Chromium implementation where `scopes=\"urn:\"` allows all `urn:` resources.",
              "createdAt": "2021-04-02T08:14:34Z",
              "updatedAt": "2021-04-02T09:18:31Z"
            },
            {
              "originalPosition": 63,
              "body": "```suggestion\r\n- `urn:uuid:` resource must be explicitly specified in `resources` attribute in\r\n```",
              "createdAt": "2021-04-02T08:15:24Z",
              "updatedAt": "2021-04-02T09:18:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2ODgwNDc3",
          "commit": {
            "abbreviatedOid": "4334f0d"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-02T09:13:06Z",
          "updatedAt": "2021-04-02T09:13:06Z",
          "comments": [
            {
              "originalPosition": 47,
              "body": "Thanks. Done.",
              "createdAt": "2021-04-02T09:13:06Z",
              "updatedAt": "2021-04-02T09:18:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2ODgxNDgy",
          "commit": {
            "abbreviatedOid": "4334f0d"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-02T09:15:22Z",
          "updatedAt": "2021-04-02T09:15:22Z",
          "comments": [
            {
              "originalPosition": 65,
              "body": "Thanks! I've updated the PR so that it matches the Chromium implementation.",
              "createdAt": "2021-04-02T09:15:22Z",
              "updatedAt": "2021-04-02T09:18:31Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI2ODgzMDA2",
          "commit": {
            "abbreviatedOid": "674ffa5"
          },
          "author": "hayatoito",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2021-04-02T09:18:44Z",
          "updatedAt": "2021-04-02T09:18:44Z",
          "comments": [
            {
              "originalPosition": 63,
              "body": "Thanks! Fixed.",
              "createdAt": "2021-04-02T09:18:44Z",
              "updatedAt": "2021-04-02T09:18:44Z"
            }
          ]
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NTc5Nzc3",
          "commit": {
            "abbreviatedOid": "674ffa5"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "lgtm\r\n\r\nThank you.",
          "createdAt": "2021-04-04T23:25:08Z",
          "updatedAt": "2021-04-04T23:25:08Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI3NTg3ODMx",
          "commit": {
            "abbreviatedOid": "674ffa5"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-05T01:06:19Z",
          "updatedAt": "2021-04-05T01:06:19Z",
          "comments": []
        }
      ]
    },
    {
      "number": 646,
      "id": "MDExOlB1bGxSZXF1ZXN0NjEwMzg3MTUx",
      "title": "[subresource-loading] Update the TOC and fix a link",
      "url": "https://github.com/WICG/webpackage/pull/646",
      "state": "MERGED",
      "author": "hayatoito",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Update the TOC and fix a link to the extension doc.",
      "createdAt": "2021-04-07T06:53:13Z",
      "updatedAt": "2021-04-08T00:18:49Z",
      "baseRepository": "WICG/webpackage",
      "baseRefName": "main",
      "baseRefOid": "4ec4d7d8c72deef2132e1bb51ddcff274e7b97ff",
      "headRepository": "hayatoito/webpackage",
      "headRefName": "update-toc",
      "headRefOid": "6c6fc89985ecab8ef6aa2db7c60c11127ffb67ae",
      "closedAt": "2021-04-07T17:26:44Z",
      "mergedAt": "2021-04-07T17:26:44Z",
      "mergedBy": "jyasskin",
      "mergeCommit": {
        "oid": "f60efe9bbbb5a9f0543e890ef642d5cef57fc5c9"
      },
      "comments": [],
      "reviews": [
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjI5NjU3Mzcz",
          "commit": {
            "abbreviatedOid": "6c6fc89"
          },
          "author": "irori",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-07T07:04:14Z",
          "updatedAt": "2021-04-07T07:04:14Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwMjc1OTIy",
          "commit": {
            "abbreviatedOid": "6c6fc89"
          },
          "author": "jyasskin",
          "authorAssociation": "MEMBER",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2021-04-07T17:26:27Z",
          "updatedAt": "2021-04-07T17:26:27Z",
          "comments": []
        },
        {
          "id": "MDE3OlB1bGxSZXF1ZXN0UmV2aWV3NjMwODgxMzIx",
          "commit": {
            "abbreviatedOid": "6c6fc89"
          },
          "author": "horo-t",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "lgtm",
          "createdAt": "2021-04-08T00:18:49Z",
          "updatedAt": "2021-04-08T00:18:49Z",
          "comments": []
        }
      ]
    }
  ]
}