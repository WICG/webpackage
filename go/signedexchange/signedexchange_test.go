package signedexchange_test

import (
	"bytes"
	"encoding/pem"
	"io"
	"io/ioutil"
	"log"
	"net/http"
	"net/url"
	"os"
	"strings"
	"testing"
	"time"

	. "github.com/WICG/webpackage/go/signedexchange"
	"github.com/WICG/webpackage/go/signedexchange/certurl"
	"github.com/WICG/webpackage/go/signedexchange/internal/bigendian"
	"github.com/WICG/webpackage/go/signedexchange/internal/testhelper"
	"github.com/WICG/webpackage/go/signedexchange/version"
)

const (
	payload  = `Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`
	pemCerts = `-----BEGIN CERTIFICATE-----
MIIBhjCCAS2gAwIBAgIJAOhR3xtYd5QsMAoGCCqGSM49BAMCMDIxFDASBgNVBAMM
C2V4YW1wbGUub3JnMQ0wCwYDVQQKDARUZXN0MQswCQYDVQQGEwJVUzAeFw0xODEx
MDUwOTA5MjJaFw0xOTEwMzEwOTA5MjJaMDIxFDASBgNVBAMMC2V4YW1wbGUub3Jn
MQ0wCwYDVQQKDARUZXN0MQswCQYDVQQGEwJVUzBZMBMGByqGSM49AgEGCCqGSM49
AwEHA0IABH1E6odXRm3+r7dMYmkJRmftx5IYHAsqgA7zjsFfCvPqL/fM4Uvi8EFu
JVQM/oKEZw3foCZ1KBjo/6Tenkoj/wCjLDAqMBAGCisGAQQB1nkCARYEAgUAMBYG
A1UdEQQPMA2CC2V4YW1wbGUub3JnMAoGCCqGSM49BAMCA0cAMEQCIEbxRKhlQYlw
Ja+O9h7misjLil82Q82nhOtl4j96awZgAiB6xrvRZIlMtWYKdi41BTb5fX22gL9M
L/twWg8eWpYeJA==
-----END CERTIFICATE-----
`
	// Generated by `openssl ecparam -out priv.key -name prime256v1 -genkey`
	pemPrivateKey = `-----BEGIN EC PRIVATE KEY-----
MHcCAQEEIEMac81NMjwO4pQ2IGKZ3UdymYtnFAXEjKdvAdEx4DQwoAoGCCqGSM49
AwEHoUQDQgAEfUTqh1dGbf6vt0xiaQlGZ+3HkhgcCyqADvOOwV8K8+ov98zhS+Lw
QW4lVAz+goRnDd+gJnUoGOj/pN6eSiP/AA==
-----END EC PRIVATE KEY-----`
	expectedSignatureHeader = "label; sig=*MEYCIQCbay5VbkR9mi4pnwDAJamuf7Fj1CWnEnJt6Uxm7YeqiwIhAL8JISyzF5sDhtUaEbNCE6vgv2NIKCkONzLgwL23UL6P*; validity-url=\"https://example.com/resource.validity\"; integrity=\"mi-draft2\"; cert-url=\"https://example.com/cert.msg\"; cert-sha256=*eLWHusI0YcDcHSG5nkYbyZddE2sidVyhx6iSYoJ+SFc=*; date=1517418800; expires=1517422400"
)

// signatureDate corresponds to the expectedSignatureHeader's date value.
var signatureDate = time.Date(2018, 1, 31, 17, 13, 20, 0, time.UTC)

type zeroReader struct{}

func (zeroReader) Read(b []byte) (int, error) {
	for i := range b {
		b[i] = 0
	}
	return len(b), nil
}

func mustReadFile(path string) []byte {
	b, err := ioutil.ReadFile(path)
	if err != nil {
		panic(err)
	}
	return b
}

func TestSignedExchange(t *testing.T) {
	u, _ := url.Parse("https://example.com/")
	reqHeader := http.Header{}
	reqHeader.Add("Accept", "*/*")
	respHeader := http.Header{}
	respHeader.Add("Content-Type", "text/html; charset=utf-8")

	// Multiple values for the same header
	respHeader.Add("Foo", "Bar")
	respHeader.Add("Foo", "Baz")

	const ver = version.Version1b1
	e, err := NewExchange(ver, u, http.MethodGet, reqHeader, 200, respHeader, []byte(payload))
	if err != nil {
		t.Fatal(err)
	}
	if err := e.MiEncodePayload(16); err != nil {
		t.Fatal(err)
	}

	certs, err := ParseCertificates([]byte(pemCerts))
	if err != nil {
		t.Fatal(err)
	}

	derPrivateKey, _ := pem.Decode([]byte(pemPrivateKey))
	privKey, err := ParsePrivateKey(derPrivateKey.Bytes)
	if err != nil {
		t.Fatal(err)
	}
	certUrl, _ := url.Parse("https://example.com/cert.msg")
	validityUrl, _ := url.Parse("https://example.com/resource.validity")
	s := &Signer{
		Date:        signatureDate,
		Expires:     signatureDate.Add(1 * time.Hour),
		Certs:       certs,
		CertUrl:     certUrl,
		ValidityUrl: validityUrl,
		PrivKey:     privKey,
		Rand:        zeroReader{},
	}
	if err := e.AddSignatureHeader(s); err != nil {
		t.Fatal(err)
	}

	var buf bytes.Buffer
	if err := e.Write(&buf); err != nil {
		t.Fatal(err)
	}

	magic, err := buf.ReadBytes(0x00)
	if err != nil {
		t.Fatal(err)
	}
	if !bytes.Equal(magic, HeaderMagicBytes(ver)) {
		t.Errorf("unexpected magic: %q", magic)
	}

	encodedSigLength := [3]byte{}
	if _, err := io.ReadFull(&buf, encodedSigLength[:]); err != nil {
		t.Fatal(err)
	}
	sigLength := bigendian.Decode3BytesUint(encodedSigLength)

	if sigLength != len(expectedSignatureHeader) {
		t.Errorf("Unexpected sigLength: %d", sigLength)
	}

	encodedHeaderLength := [3]byte{}
	if _, err := io.ReadFull(&buf, encodedHeaderLength[:]); err != nil {
		t.Fatal(err)
	}
	headerLength := bigendian.Decode3BytesUint(encodedHeaderLength)

	signatureHeaderBytes := make([]byte, sigLength)
	if _, err := io.ReadFull(&buf, signatureHeaderBytes); err != nil {
		t.Fatal(err)
	}

	if !bytes.Equal(signatureHeaderBytes, []byte(expectedSignatureHeader)) {
		t.Errorf("Unexpected signature header: %q", signatureHeaderBytes)
	}

	encodedHeader := make([]byte, headerLength)
	if _, err := io.ReadFull(&buf, encodedHeader); err != nil {
		t.Fatal(err)
	}

	got, err := testhelper.CborBinaryToReadableString(encodedHeader)
	if err != nil {
		t.Fatal(err)
	}
	want := strings.TrimSpace(string(mustReadFile("test-signedexchange-expected.txt")))

	if got != want {
		t.Errorf("WriteExchangeFile:\ngot: %v\nwant: %v", got, want)
	}

	gotPayload := buf.Bytes()
	wantPayload := mustReadFile("test-signedexchange-expected-payload-mi.bin")
	if !bytes.Equal(gotPayload, wantPayload) {
		t.Errorf("payload mismatch")
	}
}

func TestSignedExchangeStatefulHeader(t *testing.T) {
	u, _ := url.Parse("https://example.com/")
	header := http.Header{}
	header.Add("Content-Type", "text/html; charset=utf-8")
	// Set-Cookie is a stateful header and not available.
	header.Add("Set-Cookie", "wow, such cookie")

	const ver = version.Version1b1
	if _, err := NewExchange(ver, u, http.MethodGet, nil, 200, header, []byte(payload)); err == nil {
		t.Errorf("stateful header unexpectedly allowed in an exchange")
	}

	// Header names are case-insensitive.
	u, _ = url.Parse("https://example.com/")
	header = http.Header{}
	header.Add("cOnTent-TyPe", "text/html; charset=utf-8")
	header.Add("setProfile", "profile X")

	if _, err := NewExchange(ver, u, http.MethodGet, nil, 200, header, []byte(payload)); err == nil {
		t.Errorf("stateful header unexpectedly allowed in an exchange")
	}
}

func TestSignedExchangeNonHttps(t *testing.T) {
	u, _ := url.Parse("http://example.com/")
	const ver = version.Version1b1
	if _, err := NewExchange(ver, u, http.MethodGet, nil, 200, http.Header{}, []byte(payload)); err == nil {
		t.Errorf("non-https resource URI unexpectedly allowed in an exchange")
	}
}

func TestSignedExchangeBannedCertUrlScheme(t *testing.T) {
	u, _ := url.Parse("https://example.com/")
	const ver = version.Version1b1
	e, err := NewExchange(ver, u, http.MethodGet, nil, 200, http.Header{}, []byte(payload))
	if err != nil {
		t.Fatal(err)
	}
	if err := e.MiEncodePayload(16); err != nil {
		t.Fatal(err)
	}

	certs, _ := ParseCertificates([]byte(pemCerts))
	certUrl, _ := url.Parse("http://example.com/cert.msg")
	validityUrl, _ := url.Parse("https://example.com/resource.validity")
	derPrivateKey, _ := pem.Decode([]byte(pemPrivateKey))
	privKey, _ := ParsePrivateKey(derPrivateKey.Bytes)
	s := &Signer{
		Date:        signatureDate,
		Expires:     signatureDate.Add(1 * time.Hour),
		Certs:       certs,
		CertUrl:     certUrl,
		ValidityUrl: validityUrl,
		PrivKey:     privKey,
		Rand:        zeroReader{},
	}
	if err := e.AddSignatureHeader(s); err == nil {
		t.Errorf("non-{https,data} cert-url unexpectedly allowed in an exchange")
	}
}

func createTestExchange(t *testing.T) (e *Exchange, s *Signer, certBytes []byte) {
	u, _ := url.Parse("https://example.com/")
	header := http.Header{}
	header.Add("Content-Type", "text/html; charset=utf-8")

	const ver = version.Version1b2
	e, err := NewExchange(ver, u, http.MethodGet, nil, 200, header, []byte(payload))
	if err != nil {
		t.Fatal(err)
	}
	if err := e.MiEncodePayload(16); err != nil {
		t.Fatal(err)
	}

	certs, err := ParseCertificates([]byte(pemCerts))
	if err != nil {
		t.Fatal(err)
	}

	derPrivateKey, _ := pem.Decode([]byte(pemPrivateKey))
	privKey, err := ParsePrivateKey(derPrivateKey.Bytes)
	if err != nil {
		t.Fatal(err)
	}
	certUrl, _ := url.Parse("https://example.com/cert.msg")
	validityUrl, _ := url.Parse("https://example.com/resource.validity")
	s = &Signer{
		Date:        signatureDate,
		Expires:     signatureDate.Add(1 * time.Hour),
		Certs:       certs,
		CertUrl:     certUrl,
		ValidityUrl: validityUrl,
		PrivKey:     privKey,
		Rand:        zeroReader{},
	}

	certChain := certurl.CertChain{}
	for _, cert := range certs {
		certChain = append(certChain, &certurl.CertChainItem{Cert: cert})
	}
	certChain[0].OCSPResponse = []byte("dummy")
	var certCBOR bytes.Buffer
	if err := certChain.Write(&certCBOR); err != nil {
		t.Fatal(err)
	}
	certBytes = certCBOR.Bytes()
	return
}

func TestVerify(t *testing.T) {
	e, s, c := createTestExchange(t)
	if err := e.AddSignatureHeader(s); err != nil {
		t.Fatal(err)
	}
	certFetcher := func(_ string) ([]byte, error) { return c, nil }

	verificationTime := signatureDate
	if !e.Verify(verificationTime, certFetcher, log.New(os.Stdout, "ERROR: ", 0)) {
		t.Errorf("Verification failed")
	}
}

func TestVerifyNotYetValidExchange(t *testing.T) {
	e, s, c := createTestExchange(t)
	if err := e.AddSignatureHeader(s); err != nil {
		t.Fatal(err)
	}
	certFetcher := func(_ string) ([]byte, error) { return c, nil }

	verificationTime := signatureDate.Add(-1 * time.Second)
	if e.Verify(verificationTime, certFetcher, log.New(ioutil.Discard, "", 0)) {
		t.Errorf("Verification should fail")
	}
}

func TestVerifyExpiredExchange(t *testing.T) {
	e, s, c := createTestExchange(t)
	if err := e.AddSignatureHeader(s); err != nil {
		t.Fatal(err)
	}
	certFetcher := func(_ string) ([]byte, error) { return c, nil }

	verificationTime := signatureDate.Add(1 * time.Hour).Add(1 * time.Second)
	if e.Verify(verificationTime, certFetcher, log.New(ioutil.Discard, "", 0)) {
		t.Errorf("Verification should fail")
	}
}

func TestVerifyBadValidityUrl(t *testing.T) {
	e, s, c := createTestExchange(t)
	s.ValidityUrl, _ = url.Parse("https://subdomain.example.com/resource.validity")
	if err := e.AddSignatureHeader(s); err != nil {
		t.Fatal(err)
	}
	certFetcher := func(_ string) ([]byte, error) { return c, nil }

	verificationTime := signatureDate
	if e.Verify(verificationTime, certFetcher, log.New(ioutil.Discard, "", 0)) {
		t.Errorf("Verification should fail")
	}
}

func TestVerifyBadMethod(t *testing.T) {
	e, s, c := createTestExchange(t)
	e.RequestMethod = "POST"
	if err := e.AddSignatureHeader(s); err != nil {
		t.Fatal(err)
	}
	certFetcher := func(_ string) ([]byte, error) { return c, nil }

	verificationTime := signatureDate
	if e.Verify(verificationTime, certFetcher, log.New(ioutil.Discard, "", 0)) {
		t.Errorf("Verification should fail")
	}
}

func TestVerifyStatefulRequestHeader(t *testing.T) {
	e, s, c := createTestExchange(t)
	if e.RequestHeaders == nil {
		e.RequestHeaders = http.Header{}
	}
	e.RequestHeaders.Set("Authorization", "Basic Zm9vOmJhcg==")
	if err := e.AddSignatureHeader(s); err != nil {
		t.Fatal(err)
	}
	certFetcher := func(_ string) ([]byte, error) { return c, nil }

	verificationTime := signatureDate
	if e.Verify(verificationTime, certFetcher, log.New(ioutil.Discard, "", 0)) {
		t.Errorf("Verification should fail")
	}
}

func TestVerifyStatefulResponseHeader(t *testing.T) {
	e, s, c := createTestExchange(t)
	e.ResponseHeaders.Set("Set-Cookie", "foo=bar")
	if err := e.AddSignatureHeader(s); err != nil {
		t.Fatal(err)
	}
	certFetcher := func(_ string) ([]byte, error) { return c, nil }

	verificationTime := signatureDate
	if e.Verify(verificationTime, certFetcher, log.New(ioutil.Discard, "", 0)) {
		t.Errorf("Verification should fail")
	}
}

func TestVerifyBadSignature(t *testing.T) {
	e, s, c := createTestExchange(t)
	if err := e.AddSignatureHeader(s); err != nil {
		t.Fatal(err)
	}
	certFetcher := func(_ string) ([]byte, error) { return c, nil }

	e.ResponseHeaders.Add("Etag", "0123")

	verificationTime := signatureDate
	if e.Verify(verificationTime, certFetcher, log.New(ioutil.Discard, "", 0)) {
		t.Errorf("Verification should fail")
	}
}
